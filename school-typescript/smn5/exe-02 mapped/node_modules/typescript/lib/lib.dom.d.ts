e.kind === 206 /* SyntaxKind.PropertyAccessExpression */ && isDottedName(node.expression)
            || node.kind === 212 /* SyntaxKind.ParenthesizedExpression */ && isDottedName(node.expression);
    }
    ts.isDottedName = isDottedName;
    function isPropertyAccessEntityNameExpression(node) {
        return ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) && isEntityNameExpression(node.expression);
    }
    ts.isPropertyAccessEntityNameExpression = isPropertyAccessEntityNameExpression;
    function tryGetPropertyAccessOrIdentifierToString(expr) {
        if (ts.isPropertyAccessExpression(expr)) {
            var baseStr = tryGetPropertyAccessOrIdentifierToString(expr.expression);
            if (baseStr !== undefined) {
                return baseStr + "." + entityNameToString(expr.name);
            }
        }
        else if (ts.isElementAccessExpression(expr)) {
            var baseStr = tryGetPropertyAccessOrIdentifierToString(expr.expression);
            if (baseStr !== undefined && ts.isPropertyName(expr.argumentExpression)) {
                return baseStr + "." + getPropertyNameForPropertyNameNode(expr.argumentExpression);
            }
        }
        else if (ts.isIdentifier(expr)) {
            return ts.unescapeLeadingUnderscores(expr.escapedText);
        }
        return undefined;
    }
    ts.tryGetPropertyAccessOrIdentifierToString = tryGetPropertyAccessOrIdentifierToString;
    function isPrototypeAccess(node) {
        return isBindableStaticAccessExpression(node) && getElementOrPropertyAccessName(node) === "prototype";
    }
    ts.isPrototypeAccess = isPrototypeAccess;
    function isRightSideOfQualifiedNameOrPropertyAccess(node) {
        return (node.parent.kind === 161 /* SyntaxKind.QualifiedName */ && node.parent.right === node) ||
            (node.parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */ && node.parent.name === node);
    }
    ts.isRightSideOfQualifiedNameOrPropertyAccess = isRightSideOfQualifiedNameOrPropertyAccess;
    function isRightSideOfAccessExpression(node) {
        return ts.isPropertyAccessExpression(node.parent) && node.parent.name === node
            || ts.isElementAccessExpression(node.parent) && node.parent.argumentExpression === node;
    }
    ts.isRightSideOfAccessExpression = isRightSideOfAccessExpression;
    function isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(node) {
        return ts.isQualifiedName(node.parent) && node.parent.right === node
            || ts.isPropertyAccessExpression(node.parent) && node.parent.name === node
            || ts.isJSDocMemberName(node.parent) && node.parent.right === node;
    }
    ts.isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName = isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName;
    function isEmptyObjectLiteral(expression) {
        return expression.kind === 205 /* SyntaxKind.ObjectLiteralExpression */ &&
            expression.properties.length === 0;
    }
    ts.isEmptyObjectLiteral = isEmptyObjectLiteral;
    function isEmptyArrayLiteral(expression) {
        return expression.kind === 204 /* SyntaxKind.ArrayLiteralExpression */ &&
            expression.elements.length === 0;
    }
    ts.isEmptyArrayLiteral = isEmptyArrayLiteral;
    function getLocalSymbolForExportDefault(symbol) {
        if (!isExportDefaultSymbol(symbol) || !symbol.declarations)
            return undefined;
        for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
            var decl = _a[_i];
            if (decl.localSymbol)
                return decl.localSymbol;
        }
        return undefined;
    }
    ts.getLocalSymbolForExportDefault = getLocalSymbolForExportDefault;
    function isExportDefaultSymbol(symbol) {
        return symbol && ts.length(symbol.declarations) > 0 && hasSyntacticModifier(symbol.declarations[0], 512 /* ModifierFlags.Default */);
    }
    /** Return ".ts", ".d.ts", or ".tsx", if that is the extension. */
    function tryExtractTSExtension(fileName) {
        return ts.find(supportedTSExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.tryExtractTSExtension = tryExtractTSExtension;
    /**
     * Replace each instance of non-ascii characters by one, two, three, or four escape sequences
     * representing the UTF-8 encoding of the character, and return the expanded char code list.
     */
    function getExpandedCharCodes(input) {
        var output = [];
        var length = input.length;
        for (var i = 0; i < length; i++) {
            var charCode = input.charCodeAt(i);
            // handle utf8
            if (charCode < 0x80) {
                output.push(charCode);
            }
            else if (charCode < 0x800) {
                output.push((charCode >> 6) | 192);
                output.push((charCode & 63) | 128);
            }
            else if (charCode < 0x10000) {
                output.push((charCode >> 12) | 224);
                output.push(((charCode >> 6) & 63) | 128);
                output.push((charCode & 63) | 128);
            }
            else if (charCode < 0x20000) {
                output.push((charCode >> 18) | 240);
                output.push(((charCode >> 12) & 63) | 128);
                output.push(((charCode >> 6) & 63) | 128);
                output.push((charCode & 63) | 128);
            }
            else {
                ts.Debug.assert(false, "Unexpected code point");
            }
        }
        return output;
    }
    var base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    /**
     * Converts a string to a base-64 encoded ASCII string.
     */
    function convertToBase64(input) {
        var result = "";
        var charCodes = getExpandedCharCodes(input);
        var i = 0;
        var length = charCodes.length;
        var byte1, byte2, byte3, byte4;
        while (i < length) {
            // Convert every 6-bits in the input 3 character points
            // into a base64 digit
            byte1 = charCodes[i] >> 2;
            byte2 = (charCodes[i] & 3) << 4 | charCodes[i + 1] >> 4;
            byte3 = (charCodes[i + 1] & 15) << 2 | charCodes[i + 2] >> 6;
            byte4 = charCodes[i + 2] & 63;
            // We are out of characters in the input, set the extra
            // digits to 64 (padding character).
            if (i + 1 >= length) {
                byte3 = byte4 = 64;
            }
            else if (i + 2 >= length) {
                byte4 = 64;
            }
            // Write to the output
            result += base64Digits.charAt(byte1) + base64Digits.charAt(byte2) + base64Digits.charAt(byte3) + base64Digits.charAt(byte4);
            i += 3;
        }
        return result;
    }
    ts.convertToBase64 = convertToBase64;
    function getStringFromExpandedCharCodes(codes) {
        var output = "";
        var i = 0;
        var length = codes.length;
        while (i < length) {
            var charCode = codes[i];
            if (charCode < 0x80) {
                output += String.fromCharCode(charCode);
                i++;
            }
            else if ((charCode & 192) === 192) {
                var value = charCode & 63;
                i++;
                var nextCode = codes[i];
                while ((nextCode & 192) === 128) {
                    value = (value << 6) | (nextCode & 63);
                    i++;
                    nextCode = codes[i];
                }
                // `value` may be greater than 10FFFF (the maximum unicode codepoint) - JS will just make this into an invalid character for us
                output += String.fromCharCode(value);
            }
            else {
                // We don't want to kill the process when decoding fails (due to a following char byte not
                // following a leading char), so we just print the (bad) value
                output += String.fromCharCode(charCode);
                i++;
            }
        }
        return output;
    }
    function base64encode(host, input) {
        if (host && host.base64encode) {
            return host.base64encode(input);
        }
        return convertToBase64(input);
    }
    ts.base64encode = base64encode;
    function base64decode(host, input) {
        if (host && host.base64decode) {
            return host.base64decode(input);
        }
        var length = input.length;
        var expandedCharCodes = [];
        var i = 0;
        while (i < length) {
            // Stop decoding once padding characters are present
            if (input.charCodeAt(i) === base64Digits.charCodeAt(64)) {
                break;
            }
            // convert 4 input digits into three characters, ignoring padding characters at the end
            var ch1 = base64Digits.indexOf(input[i]);
            var ch2 = base64Digits.indexOf(input[i + 1]);
            var ch3 = base64Digits.indexOf(input[i + 2]);
            var ch4 = base64Digits.indexOf(input[i + 3]);
            var code1 = ((ch1 & 63) << 2) | ((ch2 >> 4) & 3);
            var code2 = ((ch2 & 15) << 4) | ((ch3 >> 2) & 15);
            var code3 = ((ch3 & 3) << 6) | (ch4 & 63);
            if (code2 === 0 && ch3 !== 0) { // code2 decoded to zero, but ch3 was padding - elide code2 and code3
                expandedCharCodes.push(code1);
            }
            else if (code3 === 0 && ch4 !== 0) { // code3 decoded to zero, but ch4 was padding, elide code3
                expandedCharCodes.push(code1, code2);
            }
            else {
                expandedCharCodes.push(code1, code2, code3);
            }
            i += 4;
        }
        return getStringFromExpandedCharCodes(expandedCharCodes);
    }
    ts.base64decode = base64decode;
    function readJson(path, host) {
        try {
            var jsonText = host.readFile(path);
            if (!jsonText)
                return {};
            var result = ts.parseConfigFileTextToJson(path, jsonText);
            if (result.error) {
                return {};
            }
            return result.config;
        }
        catch (e) {
            // gracefully handle if readFile fails or returns not JSON
            return {};
        }
    }
    ts.readJson = readJson;
    function directoryProbablyExists(directoryName, host) {
        // if host does not support 'directoryExists' assume that directory will exist
        return !host.directoryExists || host.directoryExists(directoryName);
    }
    ts.directoryProbablyExists = directoryProbablyExists;
    var carriageReturnLineFeed = "\r\n";
    var lineFeed = "\n";
    function getNewLineCharacter(options, getNewLine) {
        switch (options.newLine) {
            case 0 /* NewLineKind.CarriageReturnLineFeed */:
                return carriageReturnLineFeed;
            case 1 /* NewLineKind.LineFeed */:
                return lineFeed;
        }
        return getNewLine ? getNewLine() : ts.sys ? ts.sys.newLine : carriageReturnLineFeed;
    }
    ts.getNewLineCharacter = getNewLineCharacter;
    /**
     * Creates a new TextRange from the provided pos and end.
     *
     * @param pos The start position.
     * @param end The end position.
     */
    function createRange(pos, end) {
        if (end === void 0) { end = pos; }
        ts.Debug.assert(end >= pos || end === -1);
        return { pos: pos, end: end };
    }
    ts.createRange = createRange;
    /**
     * Creates a new TextRange from a provided range with a new end position.
     *
     * @param range A TextRange.
     * @param end The new end position.
     */
    function moveRangeEnd(range, end) {
        return createRange(range.pos, end);
    }
    ts.moveRangeEnd = moveRangeEnd;
    /**
     * Creates a new TextRange from a provided range with a new start position.
     *
     * @param range A TextRange.
     * @param pos The new Start position.
     */
    function moveRangePos(range, pos) {
        return createRange(pos, range.end);
    }
    ts.moveRangePos = moveRangePos;
    /**
     * Moves the start position of a range past any decorators.
     */
    function moveRangePastDecorators(node) {
        return node.decorators && node.decorators.length > 0
            ? moveRangePos(node, node.decorators.end)
            : node;
    }
    ts.moveRangePastDecorators = moveRangePastDecorators;
    /**
     * Moves the start position of a range past any decorators or modifiers.
     */
    function moveRangePastModifiers(node) {
        return node.modifiers && node.modifiers.length > 0
            ? moveRangePos(node, node.modifiers.end)
            : moveRangePastDecorators(node);
    }
    ts.moveRangePastModifiers = moveRangePastModifiers;
    /**
     * Determines whether a TextRange has the same start and end positions.
     *
     * @param range A TextRange.
     */
    function isCollapsedRange(range) {
        return range.pos === range.end;
    }
    ts.isCollapsedRange = isCollapsedRange;
    /**
     * Creates a new TextRange for a token at the provides start position.
     *
     * @param pos The start position.
     * @param token The token.
     */
    function createTokenRange(pos, token) {
        return createRange(pos, pos + ts.tokenToString(token).length);
    }
    ts.createTokenRange = createTokenRange;
    function rangeIsOnSingleLine(range, sourceFile) {
        return rangeStartIsOnSameLineAsRangeEnd(range, range, sourceFile);
    }
    ts.rangeIsOnSingleLine = rangeIsOnSingleLine;
    function rangeStartPositionsAreOnSameLine(range1, range2, sourceFile) {
        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile, /*includeComments*/ false), getStartPositionOfRange(range2, sourceFile, /*includeComments*/ false), sourceFile);
    }
    ts.rangeStartPositionsAreOnSameLine = rangeStartPositionsAreOnSameLine;
    function rangeEndPositionsAreOnSameLine(range1, range2, sourceFile) {
        return positionsAreOnSameLine(range1.end, range2.end, sourceFile);
    }
    ts.rangeEndPositionsAreOnSameLine = rangeEndPositionsAreOnSameLine;
    function rangeStartIsOnSameLineAsRangeEnd(range1, range2, sourceFile) {
        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile, /*includeComments*/ false), range2.end, sourceFile);
    }
    ts.rangeStartIsOnSameLineAsRangeEnd = rangeStartIsOnSameLineAsRangeEnd;
    function rangeEndIsOnSameLineAsRangeStart(range1, range2, sourceFile) {
        return positionsAreOnSameLine(range1.end, getStartPositionOfRange(range2, sourceFile, /*includeComments*/ false), sourceFile);
    }
    ts.rangeEndIsOnSameLineAsRangeStart = rangeEndIsOnSameLineAsRangeStart;
    function getLinesBetweenRangeEndAndRangeStart(range1, range2, sourceFile, includeSecondRangeComments) {
        var range2Start = getStartPositionOfRange(range2, sourceFile, includeSecondRangeComments);
        return ts.getLinesBetweenPositions(sourceFile, range1.end, range2Start);
    }
    ts.getLinesBetweenRangeEndAndRangeStart = getLinesBetweenRangeEndAndRangeStart;
    function getLinesBetweenRangeEndPositions(range1, range2, sourceFile) {
        return ts.getLinesBetweenPositions(sourceFile, range1.end, range2.end);
    }
    ts.getLinesBetweenRangeEndPositions = getLinesBetweenRangeEndPositions;
    function isNodeArrayMultiLine(list, sourceFile) {
        return !positionsAreOnSameLine(list.pos, list.end, sourceFile);
    }
    ts.isNodeArrayMultiLine = isNodeArrayMultiLine;
    function positionsAreOnSameLine(pos1, pos2, sourceFile) {
        return ts.getLinesBetweenPositions(sourceFile, pos1, pos2) === 0;
    }
    ts.positionsAreOnSameLine = positionsAreOnSameLine;
    function getStartPositionOfRange(range, sourceFile, includeComments) {
        return positionIsSynthesized(range.pos) ? -1 : ts.skipTrivia(sourceFile.text, range.pos, /*stopAfterLineBreak*/ false, includeComments);
    }
    ts.getStartPositionOfRange = getStartPositionOfRange;
    function getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(pos, stopPos, sourceFile, includeComments) {
        var startPos = ts.skipTrivia(sourceFile.text, pos, /*stopAfterLineBreak*/ false, includeComments);
        var prevPos = getPreviousNonWhitespacePosition(startPos, stopPos, sourceFile);
        return ts.getLinesBetweenPositions(sourceFile, prevPos !== null && prevPos !== void 0 ? prevPos : stopPos, startPos);
    }
    ts.getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter = getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter;
    function getLinesBetweenPositionAndNextNonWhitespaceCharacter(pos, stopPos, sourceFile, includeComments) {
        var nextPos = ts.skipTrivia(sourceFile.text, pos, /*stopAfterLineBreak*/ false, includeComments);
        return ts.getLinesBetweenPositions(sourceFile, pos, Math.min(stopPos, nextPos));
    }
    ts.getLinesBetweenPositionAndNextNonWhitespaceCharacter = getLinesBetweenPositionAndNextNonWhitespaceCharacter;
    function getPreviousNonWhitespacePosition(pos, stopPos, sourceFile) {
        if (stopPos === void 0) { stopPos = 0; }
        while (pos-- > stopPos) {
            if (!ts.isWhiteSpaceLike(sourceFile.text.charCodeAt(pos))) {
                return pos;
            }
        }
    }
    /**
     * Determines whether a name was originally the declaration name of an enum or namespace
     * declaration.
     */
    function isDeclarationNameOfEnumOrNamespace(node) {
        var parseNode = ts.getParseTreeNode(node);
        if (parseNode) {
            switch (parseNode.parent.kind) {
                case 260 /* SyntaxKind.EnumDeclaration */:
                case 261 /* SyntaxKind.ModuleDeclaration */:
                    return parseNode === parseNode.parent.name;
            }
        }
        return false;
    }
    ts.isDeclarationNameOfEnumOrNamespace = isDeclarationNameOfEnumOrNamespace;
    function getInitializedVariables(node) {
        return ts.filter(node.declarations, isInitializedVariable);
    }
    ts.getInitializedVariables = getInitializedVariables;
    function isInitializedVariable(node) {
        return node.initializer !== undefined;
    }
    function isWatchSet(options) {
        // Firefox has Object.prototype.watch
        return options.watch && options.hasOwnProperty("watch");
    }
    ts.isWatchSet = isWatchSet;
    function closeFileWatcher(watcher) {
        watcher.close();
    }
    ts.closeFileWatcher = closeFileWatcher;
    function getCheckFlags(symbol) {
        return symbol.flags & 33554432 /* SymbolFlags.Transient */ ? symbol.checkFlags : 0;
    }
    ts.getCheckFlags = getCheckFlags;
    function getDeclarationModifierFlagsFromSymbol(s, isWrite) {
        if (isWrite === void 0) { isWrite = false; }
        if (s.valueDeclaration) {
            var declaration = (isWrite && s.declarations && ts.find(s.declarations, function (d) { return d.kind === 173 /* SyntaxKind.SetAccessor */; })) || s.valueDeclaration;
            var flags = ts.getCombinedModifierFlags(declaration);
            return s.parent && s.parent.flags & 32 /* SymbolFlags.Class */ ? flags : flags & ~28 /* ModifierFlags.AccessibilityModifier */;
        }
        if (getCheckFlags(s) & 6 /* CheckFlags.Synthetic */) {
            var checkFlags = s.checkFlags;
            var accessModifier = checkFlags & 1024 /* CheckFlags.ContainsPrivate */ ? 8 /* ModifierFlags.Private */ :
                checkFlags & 256 /* CheckFlags.ContainsPublic */ ? 4 /* ModifierFlags.Public */ :
                    16 /* ModifierFlags.Protected */;
            var staticModifier = checkFlags & 2048 /* CheckFlags.ContainsStatic */ ? 32 /* ModifierFlags.Static */ : 0;
            return accessModifier | staticModifier;
        }
        if (s.flags & 4194304 /* SymbolFlags.Prototype */) {
            return 4 /* ModifierFlags.Public */ | 32 /* ModifierFlags.Static */;
        }
        return 0;
    }
    ts.getDeclarationModifierFlagsFromSymbol = getDeclarationModifierFlagsFromSymbol;
    function skipAlias(symbol, checker) {
        return symbol.flags & 2097152 /* SymbolFlags.Alias */ ? checker.getAliasedSymbol(symbol) : symbol;
    }
    ts.skipAlias = skipAlias;
    /** See comment on `declareModuleMember` in `binder.ts`. */
    function getCombinedLocalAndExportSymbolFlags(symbol) {
        return symbol.exportSymbol ? symbol.exportSymbol.flags | symbol.flags : symbol.flags;
    }
    ts.getCombinedLocalAndExportSymbolFlags = getCombinedLocalAndExportSymbolFlags;
    function isWriteOnlyAccess(node) {
        return accessKind(node) === 1 /* AccessKind.Write */;
    }
    ts.isWriteOnlyAccess = isWriteOnlyAccess;
    function isWriteAccess(node) {
        return accessKind(node) !== 0 /* AccessKind.Read */;
    }
    ts.isWriteAccess = isWriteAccess;
    var AccessKind;
    (function (AccessKind) {
        /** Only reads from a variable. */
        AccessKind[AccessKind["Read"] = 0] = "Read";
        /** Only writes to a variable without using the result. E.g.: `x++;`. */
        AccessKind[AccessKind["Write"] = 1] = "Write";
        /** Writes to a variable and uses the result as an expression. E.g.: `f(x++);`. */
        AccessKind[AccessKind["ReadWrite"] = 2] = "ReadWrite";
    })(AccessKind || (AccessKind = {}));
    function accessKind(node) {
        var parent = node.parent;
        if (!parent)
            return 0 /* AccessKind.Read */;
        switch (parent.kind) {
            case 212 /* SyntaxKind.ParenthesizedExpression */:
                return accessKind(parent);
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
                var operator = parent.operator;
                return operator === 45 /* SyntaxKind.PlusPlusToken */ || operator === 46 /* SyntaxKind.MinusMinusToken */ ? writeOrReadWrite() : 0 /* AccessKind.Read */;
            case 221 /* SyntaxKind.BinaryExpression */:
                var _a = parent, left = _a.left, operatorToken = _a.operatorToken;
                return left === node && isAssignmentOperator(operatorToken.kind) ?
                    operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ ? 1 /* AccessKind.Write */ : writeOrReadWrite()
                    : 0 /* AccessKind.Read */;
            case 206 /* SyntaxKind.PropertyAccessExpression */:
                return parent.name !== node ? 0 /* AccessKind.Read */ : accessKind(parent);
            case 296 /* SyntaxKind.PropertyAssignment */: {
                var parentAccess = accessKind(parent.parent);
                // In `({ x: varname }) = { x: 1 }`, the left `x` is a read, the right `x` is a write.
                return node === parent.name ? reverseAccessKind(parentAccess) : parentAccess;
            }
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                // Assume it's the local variable being accessed, since we don't check public properties for --noUnusedLocals.
                return node === parent.objectAssignmentInitializer ? 0 /* AccessKind.Read */ : accessKind(parent.parent);
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                return accessKind(parent);
            default:
                return 0 /* AccessKind.Read */;
        }
        function writeOrReadWrite() {
            // If grandparent is not an ExpressionStatement, this is used as an expression in addition to having a side effect.
            return parent.parent && walkUpParenthesizedExpressions(parent.parent).kind === 238 /* SyntaxKind.ExpressionStatement */ ? 1 /* AccessKind.Write */ : 2 /* AccessKind.ReadWrite */;
        }
    }
    function reverseAccessKind(a) {
        switch (a) {
            case 0 /* AccessKind.Read */:
                return 1 /* AccessKind.Write */;
            case 1 /* AccessKind.Write */:
                return 0 /* AccessKind.Read */;
            case 2 /* AccessKind.ReadWrite */:
                return 2 /* AccessKind.ReadWrite */;
            default:
                return ts.Debug.assertNever(a);
        }
    }
    function compareDataObjects(dst, src) {
        if (!dst || !src || Object.keys(dst).length !== Object.keys(src).length) {
            return false;
        }
        for (var e in dst) {
            if (typeof dst[e] === "object") {
                if (!compareDataObjects(dst[e], src[e])) {
                    return false;
                }
            }
            else if (typeof dst[e] !== "function") {
                if (dst[e] !== src[e]) {
                    return false;
                }
            }
        }
        return true;
    }
    ts.compareDataObjects = compareDataObjects;
    /**
     * clears already present map by calling onDeleteExistingValue callback before deleting that key/value
     */
    function clearMap(map, onDeleteValue) {
        // Remove all
        map.forEach(onDeleteValue);
        map.clear();
    }
    ts.clearMap = clearMap;
    /**
     * Mutates the map with newMap such that keys in map will be same as newMap.
     */
    function mutateMapSkippingNewValues(map, newMap, options) {
        var onDeleteValue = options.onDeleteValue, onExistingValue = options.onExistingValue;
        // Needs update
        map.forEach(function (existingValue, key) {
            var valueInNewMap = newMap.get(key);
            // Not present any more in new map, remove it
            if (valueInNewMap === undefined) {
                map.delete(key);
                onDeleteValue(existingValue, key);
            }
            // If present notify about existing values
            else if (onExistingValue) {
                onExistingValue(existingValue, valueInNewMap, key);
            }
        });
    }
    ts.mutateMapSkippingNewValues = mutateMapSkippingNewValues;
    /**
     * Mutates the map with newMap such that keys in map will be same as newMap.
     */
    function mutateMap(map, newMap, options) {
        // Needs update
        mutateMapSkippingNewValues(map, newMap, options);
        var createNewValue = options.createNewValue;
        // Add new values that are not already present
        newMap.forEach(function (valueInNewMap, key) {
            if (!map.has(key)) {
                // New values
                map.set(key, createNewValue(key, valueInNewMap));
            }
        });
    }
    ts.mutateMap = mutateMap;
    function isAbstractConstructorSymbol(symbol) {
        if (symbol.flags & 32 /* SymbolFlags.Class */) {
            var declaration = getClassLikeDeclarationOfSymbol(symbol);
            return !!declaration && hasSyntacticModifier(declaration, 128 /* ModifierFlags.Abstract */);
        }
        return false;
    }
    ts.isAbstractConstructorSymbol = isAbstractConstructorSymbol;
    function getClassLikeDeclarationOfSymbol(symbol) {
        var _a;
        return (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isClassLike);
    }
    ts.getClassLikeDeclarationOfSymbol = getClassLikeDeclarationOfSymbol;
    function getObjectFlags(type) {
        return type.flags & 3899393 /* TypeFlags.ObjectFlagsType */ ? type.objectFlags : 0;
    }
    ts.getObjectFlags = getObjectFlags;
    function typeHasCallOrConstructSignatures(type, checker) {
        return checker.getSignaturesOfType(type, 0 /* SignatureKind.Call */).length !== 0 || checker.getSignaturesOfType(type, 1 /* SignatureKind.Construct */).length !== 0;
    }
    ts.typeHasCallOrConstructSignatures = typeHasCallOrConstructSignatures;
    function forSomeAncestorDirectory(directory, callback) {
        return !!ts.forEachAncestorDirectory(directory, function (d) { return callback(d) ? true : undefined; });
    }
    ts.forSomeAncestorDirectory = forSomeAncestorDirectory;
    function isUMDExportSymbol(symbol) {
        return !!symbol && !!symbol.declarations && !!symbol.declarations[0] && ts.isNamespaceExportDeclaration(symbol.declarations[0]);
    }
    ts.isUMDExportSymbol = isUMDExportSymbol;
    function showModuleSpecifier(_a) {
        var moduleSpecifier = _a.moduleSpecifier;
        return ts.isStringLiteral(moduleSpecifier) ? moduleSpecifier.text : getTextOfNode(moduleSpecifier);
    }
    ts.showModuleSpecifier = showModuleSpecifier;
    function getLastChild(node) {
        var lastChild;
        ts.forEachChild(node, function (child) {
            if (nodeIsPresent(child))
                lastChild = child;
        }, function (children) {
            // As an optimization, jump straight to the end of the list.
            for (var i = children.length - 1; i >= 0; i--) {
                if (nodeIsPresent(children[i])) {
                    lastChild = children[i];
                    break;
                }
            }
        });
        return lastChild;
    }
    ts.getLastChild = getLastChild;
    function addToSeen(seen, key, value) {
        if (value === void 0) { value = true; }
        if (seen.has(key)) {
            return false;
        }
        seen.set(key, value);
        return true;
    }
    ts.addToSeen = addToSeen;
    function isObjectTypeDeclaration(node) {
        return ts.isClassLike(node) || ts.isInterfaceDeclaration(node) || ts.isTypeLiteralNode(node);
    }
    ts.isObjectTypeDeclaration = isObjectTypeDeclaration;
    function isTypeNodeKind(kind) {
        return (kind >= 177 /* SyntaxKind.FirstTypeNode */ && kind <= 200 /* SyntaxKind.LastTypeNode */)
            || kind === 130 /* SyntaxKind.AnyKeyword */
            || kind === 155 /* SyntaxKind.UnknownKeyword */
            || kind === 147 /* SyntaxKind.NumberKeyword */
            || kind === 158 /* SyntaxKind.BigIntKeyword */
            || kind === 148 /* SyntaxKind.ObjectKeyword */
            || kind === 133 /* SyntaxKind.BooleanKeyword */
            || kind === 150 /* SyntaxKind.StringKeyword */
            || kind === 151 /* SyntaxKind.SymbolKeyword */
            || kind === 114 /* SyntaxKind.VoidKeyword */
            || kind === 153 /* SyntaxKind.UndefinedKeyword */
            || kind === 143 /* SyntaxKind.NeverKeyword */
            || kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */
            || kind === 312 /* SyntaxKind.JSDocAllType */
            || kind === 313 /* SyntaxKind.JSDocUnknownType */
            || kind === 314 /* SyntaxKind.JSDocNullableType */
            || kind === 315 /* SyntaxKind.JSDocNonNullableType */
            || kind === 316 /* SyntaxKind.JSDocOptionalType */
            || kind === 317 /* SyntaxKind.JSDocFunctionType */
            || kind === 318 /* SyntaxKind.JSDocVariadicType */;
    }
    ts.isTypeNodeKind = isTypeNodeKind;
    function isAccessExpression(node) {
        return node.kind === 206 /* SyntaxKind.PropertyAccessExpression */ || node.kind === 207 /* SyntaxKind.ElementAccessExpression */;
    }
    ts.isAccessExpression = isAccessExpression;
    function getNameOfAccessExpression(node) {
        if (node.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
            return node.name;
        }
        ts.Debug.assert(node.kind === 207 /* SyntaxKind.ElementAccessExpression */);
        return node.argumentExpression;
    }
    ts.getNameOfAccessExpression = getNameOfAccessExpression;
    function isBundleFileTextLike(section) {
        switch (section.kind) {
            case "text" /* BundleFileSectionKind.Text */:
            case "internal" /* BundleFileSectionKind.Internal */:
                return true;
            default:
                return false;
        }
    }
    ts.isBundleFileTextLike = isBundleFileTextLike;
    function isNamedImportsOrExports(node) {
        return node.kind === 269 /* SyntaxKind.NamedImports */ || node.kind === 273 /* SyntaxKind.NamedExports */;
    }
    ts.isNamedImportsOrExports = isNamedImportsOrExports;
    function getLeftmostAccessExpression(expr) {
        while (isAccessExpression(expr)) {
            expr = expr.expression;
        }
        return expr;
    }
    ts.getLeftmostAccessExpression = getLeftmostAccessExpression;
    function forEachNameInAccessChainWalkingLeft(name, action) {
        if (isAccessExpression(name.parent) && isRightSideOfAccessExpression(name)) {
            return walkAccessExpression(name.parent);
        }
        function walkAccessExpression(access) {
            if (access.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
                var res = action(access.name);
                if (res !== undefined) {
                    return res;
                }
            }
            else if (access.kind === 207 /* SyntaxKind.ElementAccessExpression */) {
                if (ts.isIdentifier(access.argumentExpression) || ts.isStringLiteralLike(access.argumentExpression)) {
                    var res = action(access.argumentExpression);
                    if (res !== undefined) {
                        return res;
                    }
                }
                else {
                    // Chain interrupted by non-static-name access 'x[expr()].y.z'
                    return undefined;
                }
            }
            if (isAccessExpression(access.expression)) {
                return walkAccessExpression(access.expression);
            }
            if (ts.isIdentifier(access.expression)) {
                // End of chain at Identifier 'x.y.z'
                return action(access.expression);
            }
            // End of chain at non-Identifier 'x().y.z'
            return undefined;
        }
    }
    ts.forEachNameInAccessChainWalkingLeft = forEachNameInAccessChainWalkingLeft;
    function getLeftmostExpression(node, stopAtCallExpressions) {
        while (true) {
            switch (node.kind) {
                case 220 /* SyntaxKind.PostfixUnaryExpression */:
                    node = node.operand;
                    continue;
                case 221 /* SyntaxKind.BinaryExpression */:
                    node = node.left;
                    continue;
                case 222 /* SyntaxKind.ConditionalExpression */:
                    node = node.condition;
                    continue;
                case 210 /* SyntaxKind.TaggedTemplateExpression */:
                    node = node.tag;
                    continue;
                case 208 /* SyntaxKind.CallExpression */:
                    if (stopAtCallExpressions) {
                        return node;
                    }
                // falls through
                case 229 /* SyntaxKind.AsExpression */:
                case 207 /* SyntaxKind.ElementAccessExpression */:
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 230 /* SyntaxKind.NonNullExpression */:
                case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                    node = node.expression;
                    continue;
            }
            return node;
        }
    }
    ts.getLeftmostExpression = getLeftmostExpression;
    function Symbol(flags, name) {
        this.flags = flags;
        this.escapedName = name;
        this.declarations = undefined;
        this.valueDeclaration = undefined;
        this.id = undefined;
        this.mergeId = undefined;
        this.parent = undefined;
    }
    function Type(checker, flags) {
        this.flags = flags;
        if (ts.Debug.isDebugging || ts.tracing) {
            this.checker = checker;
        }
    }
    function Signature(checker, flags) {
        this.flags = flags;
        if (ts.Debug.isDebugging) {
            this.checker = checker;
        }
    }
    function Node(kind, pos, end) {
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.id = 0;
        this.flags = 0 /* NodeFlags.None */;
        this.modifierFlagsCache = 0 /* ModifierFlags.None */;
        this.transformFlags = 0 /* TransformFlags.None */;
        this.parent = undefined;
        this.original = undefined;
    }
    function Token(kind, pos, end) {
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.id = 0;
        this.flags = 0 /* NodeFlags.None */;
        this.transformFlags = 0 /* TransformFlags.None */;
        this.parent = undefined;
    }
    function Identifier(kind, pos, end) {
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.id = 0;
        this.flags = 0 /* NodeFlags.None */;
        this.transformFlags = 0 /* TransformFlags.None */;
        this.parent = undefined;
        this.original = undefined;
        this.flowNode = undefined;
    }
    function SourceMapSource(fileName, text, skipTrivia) {
        this.fileName = fileName;
        this.text = text;
        this.skipTrivia = skipTrivia || (function (pos) { return pos; });
    }
    // eslint-disable-next-line prefer-const
    ts.objectAllocator = {
        getNodeConstructor: function () { return Node; },
        getTokenConstructor: function () { return Token; },
        getIdentifierConstructor: function () { return Identifier; },
        getPrivateIdentifierConstructor: function () { return Node; },
        getSourceFileConstructor: function () { return Node; },
        getSymbolConstructor: function () { return Symbol; },
        getTypeConstructor: function () { return Type; },
        getSignatureConstructor: function () { return Signature; },
        getSourceMapSourceConstructor: function () { return SourceMapSource; },
    };
    function setObjectAllocator(alloc) {
        Object.assign(ts.objectAllocator, alloc);
    }
    ts.setObjectAllocator = setObjectAllocator;
    function formatStringFromArgs(text, args, baseIndex) {
        if (baseIndex === void 0) { baseIndex = 0; }
        return text.replace(/{(\d+)}/g, function (_match, index) { return "" + ts.Debug.checkDefined(args[+index + baseIndex]); });
    }
    ts.formatStringFromArgs = formatStringFromArgs;
    var localizedDiagnosticMessages;
    /* @internal */
    function setLocalizedDiagnosticMessages(messages) {
        localizedDiagnosticMessages = messages;
    }
    ts.setLocalizedDiagnosticMessages = setLocalizedDiagnosticMessages;
    /* @internal */
    // If the localized messages json is unset, and if given function use it to set the json
    function maybeSetLocalizedDiagnosticMessages(getMessages) {
        if (!localizedDiagnosticMessages && getMessages) {
            localizedDiagnosticMessages = getMessages();
        }
    }
    ts.maybeSetLocalizedDiagnosticMessages = maybeSetLocalizedDiagnosticMessages;
    function getLocaleSpecificMessage(message) {
        return localizedDiagnosticMessages && localizedDiagnosticMessages[message.key] || message.message;
    }
    ts.getLocaleSpecificMessage = getLocaleSpecificMessage;
    function createDetachedDiagnostic(fileName, start, length, message) {
        assertDiagnosticLocation(/*file*/ undefined, start, length);
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: undefined,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            fileName: fileName,
        };
    }
    ts.createDetachedDiagnostic = createDetachedDiagnostic;
    function isDiagnosticWithDetachedLocation(diagnostic) {
        return diagnostic.file === undefined
            && diagnostic.start !== undefined
            && diagnostic.length !== undefined
            && typeof diagnostic.fileName === "string";
    }
    function attachFileToDiagnostic(diagnostic, file) {
        var fileName = file.fileName || "";
        var length = file.text.length;
        ts.Debug.assertEqual(diagnostic.fileName, fileName);
        ts.Debug.assertLessThanOrEqual(diagnostic.start, length);
        ts.Debug.assertLessThanOrEqual(diagnostic.start + diagnostic.length, length);
        var diagnosticWithLocation = {
            file: file,
            start: diagnostic.start,
            length: diagnostic.length,
            messageText: diagnostic.messageText,
            category: diagnostic.category,
            code: diagnostic.code,
            reportsUnnecessary: diagnostic.reportsUnnecessary
        };
        if (diagnostic.relatedInformation) {
            diagnosticWithLocation.relatedInformation = [];
            for (var _i = 0, _a = diagnostic.relatedInformation; _i < _a.length; _i++) {
                var related = _a[_i];
                if (isDiagnosticWithDetachedLocation(related) && related.fileName === fileName) {
                    ts.Debug.assertLessThanOrEqual(related.start, length);
                    ts.Debug.assertLessThanOrEqual(related.start + related.length, length);
                    diagnosticWithLocation.relatedInformation.push(attachFileToDiagnostic(related, file));
                }
                else {
                    diagnosticWithLocation.relatedInformation.push(related);
                }
            }
        }
        return diagnosticWithLocation;
    }
    function attachFileToDiagnostics(diagnostics, file) {
        var diagnosticsWithLocation = [];
        for (var _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {
            var diagnostic = diagnostics_1[_i];
            diagnosticsWithLocation.push(attachFileToDiagnostic(diagnostic, file));
        }
        return diagnosticsWithLocation;
    }
    ts.attachFileToDiagnostics = attachFileToDiagnostics;
    function createFileDiagnostic(file, start, length, message) {
        assertDiagnosticLocation(file, start, length);
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: file,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            reportsDeprecated: message.reportsDeprecated
        };
    }
    ts.createFileDiagnostic = createFileDiagnostic;
    function formatMessage(_dummy, message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return text;
    }
    ts.formatMessage = formatMessage;
    function createCompilerDiagnostic(message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 1) {
            text = formatStringFromArgs(text, arguments, 1);
        }
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            reportsDeprecated: message.reportsDeprecated
        };
    }
    ts.createCompilerDiagnostic = createCompilerDiagnostic;
    function createCompilerDiagnosticFromMessageChain(chain, relatedInformation) {
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            code: chain.code,
            category: chain.category,
            messageText: chain.next ? chain : chain.messageText,
            relatedInformation: relatedInformation
        };
    }
    ts.createCompilerDiagnosticFromMessageChain = createCompilerDiagnosticFromMessageChain;
    function chainDiagnosticMessages(details, message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return {
            messageText: text,
            category: message.category,
            code: message.code,
            next: details === undefined || Array.isArray(details) ? details : [details]
        };
    }
    ts.chainDiagnosticMessages = chainDiagnosticMessages;
    function concatenateDiagnosticMessageChains(headChain, tailChain) {
        var lastChain = headChain;
        while (lastChain.next) {
            lastChain = lastChain.next[0];
        }
        lastChain.next = [tailChain];
    }
    ts.concatenateDiagnosticMessageChains = concatenateDiagnosticMessageChains;
    function getDiagnosticFilePath(diagnostic) {
        return diagnostic.file ? diagnostic.file.path : undefined;
    }
    function compareDiagnostics(d1, d2) {
        return compareDiagnosticsSkipRelatedInformation(d1, d2) ||
            compareRelatedInformation(d1, d2) ||
            0 /* Comparison.EqualTo */;
    }
    ts.compareDiagnostics = compareDiagnostics;
    function compareDiagnosticsSkipRelatedInformation(d1, d2) {
        return ts.compareStringsCaseSensitive(getDiagnosticFilePath(d1), getDiagnosticFilePath(d2)) ||
            ts.compareValues(d1.start, d2.start) ||
            ts.compareValues(d1.length, d2.length) ||
            ts.compareValues(d1.code, d2.code) ||
            compareMessageText(d1.messageText, d2.messageText) ||
            0 /* Comparison.EqualTo */;
    }
    ts.compareDiagnosticsSkipRelatedInformation = compareDiagnosticsSkipRelatedInformation;
    function compareRelatedInformation(d1, d2) {
        if (!d1.relatedInformation && !d2.relatedInformation) {
            return 0 /* Comparison.EqualTo */;
        }
        if (d1.relatedInformation && d2.relatedInformation) {
            return ts.compareValues(d1.relatedInformation.length, d2.relatedInformation.length) || ts.forEach(d1.relatedInformation, function (d1i, index) {
                var d2i = d2.relatedInformation[index];
                return compareDiagnostics(d1i, d2i); // EqualTo is 0, so falsy, and will cause the next item to be compared
            }) || 0 /* Comparison.EqualTo */;
        }
        return d1.relatedInformation ? -1 /* Comparison.LessThan */ : 1 /* Comparison.GreaterThan */;
    }
    function compareMessageText(t1, t2) {
        if (typeof t1 === "string" && typeof t2 === "string") {
            return ts.compareStringsCaseSensitive(t1, t2);
        }
        else if (typeof t1 === "string") {
            return -1 /* Comparison.LessThan */;
        }
        else if (typeof t2 === "string") {
            return 1 /* Comparison.GreaterThan */;
        }
        var res = ts.compareStringsCaseSensitive(t1.messageText, t2.messageText);
        if (res) {
            return res;
        }
        if (!t1.next && !t2.next) {
            return 0 /* Comparison.EqualTo */;
        }
        if (!t1.next) {
            return -1 /* Comparison.LessThan */;
        }
        if (!t2.next) {
            return 1 /* Comparison.GreaterThan */;
        }
        var len = Math.min(t1.next.length, t2.next.length);
        for (var i = 0; i < len; i++) {
            res = compareMessageText(t1.next[i], t2.next[i]);
            if (res) {
                return res;
            }
        }
        if (t1.next.length < t2.next.length) {
            return -1 /* Comparison.LessThan */;
        }
        else if (t1.next.length > t2.next.length) {
            return 1 /* Comparison.GreaterThan */;
        }
        return 0 /* Comparison.EqualTo */;
    }
    function getLanguageVariant(scriptKind) {
        // .tsx and .jsx files are treated as jsx language variant.
        return scriptKind === 4 /* ScriptKind.TSX */ || scriptKind === 2 /* ScriptKind.JSX */ || scriptKind === 1 /* ScriptKind.JS */ || scriptKind === 6 /* ScriptKind.JSON */ ? 1 /* LanguageVariant.JSX */ : 0 /* LanguageVariant.Standard */;
    }
    ts.getLanguageVariant = getLanguageVariant;
    /**
     * This is a somewhat unavoidable full tree walk to locate a JSX tag - `import.meta` requires the same,
     * but we avoid that walk (or parts of it) if at all possible using the `PossiblyContainsImportMeta` node flag.
     * Unfortunately, there's no `NodeFlag` space to do the same for JSX.
     */
    function walkTreeForJSXTags(node) {
        if (!(node.transformFlags & 2 /* TransformFlags.ContainsJsx */))
            return undefined;
        return ts.isJsxOpeningLikeElement(node) || ts.isJsxFragment(node) ? node : ts.forEachChild(node, walkTreeForJSXTags);
    }
    function isFileModuleFromUsingJSXTag(file) {
        // Excludes declaration files - they still require an explicit `export {}` or the like
        // for back compat purposes. (not that declaration files should contain JSX tags!)
        return !file.isDeclarationFile ? walkTreeForJSXTags(file) : undefined;
    }
    /**
     * Note that this requires file.impliedNodeFormat be set already; meaning it must be set very early on
     * in SourceFile construction.
     */
    function isFileForcedToBeModuleByFormat(file) {
        // Excludes declaration files - they still require an explicit `export {}` or the like
        // for back compat purposes. The only non-declaration files _not_ forced to be a module are `.js` files
        // that aren't esm-mode (meaning not in a `type: module` scope).
        return (file.impliedNodeFormat === ts.ModuleKind.ESNext || (ts.fileExtensionIsOneOf(file.fileName, [".cjs" /* Extension.Cjs */, ".cts" /* Extension.Cts */]))) && !file.isDeclarationFile ? true : undefined;
    }
    function getSetExternalModuleIndicator(options) {
        // TODO: Should this callback be cached?
        switch (getEmitModuleDetectionKind(options)) {
            case ts.ModuleDetectionKind.Force:
                // All non-declaration files are modules, declaration files still do the usual isFileProbablyExternalModule
                return function (file) {
                    file.externalModuleIndicator = ts.isFileProbablyExternalModule(file) || !file.isDeclarationFile || undefined;
                };
            case ts.ModuleDetectionKind.Legacy:
                // Files are modules if they have imports, exports, or import.meta
                return function (file) {
                    file.externalModuleIndicator = ts.isFileProbablyExternalModule(file);
                };
            case ts.ModuleDetectionKind.Auto:
                // If module is nodenext or node16, all esm format files are modules
                // If jsx is react-jsx or react-jsxdev then jsx tags force module-ness
                // otherwise, the presence of import or export statments (or import.meta) implies module-ness
                var checks = [ts.isFileProbablyExternalModule];
                if (options.jsx === 4 /* JsxEmit.ReactJSX */ || options.jsx === 5 /* JsxEmit.ReactJSXDev */) {
                    checks.push(isFileModuleFromUsingJSXTag);
                }
                var moduleKind = getEmitModuleKind(options);
                if (moduleKind === ts.ModuleKind.Node16 || moduleKind === ts.ModuleKind.NodeNext) {
                    checks.push(isFileForcedToBeModuleByFormat);
                }
                var combined_1 = ts.or.apply(void 0, checks);
                var callback = function (file) { return void (file.externalModuleIndicator = combined_1(file)); };
                return callback;
        }
    }
    ts.getSetExternalModuleIndicator = getSetExternalModuleIndicator;
    function getEmitScriptTarget(compilerOptions) {
        return compilerOptions.target ||
            (compilerOptions.module === ts.ModuleKind.Node16 && 9 /* ScriptTarget.ES2022 */) ||
            (compilerOptions.module === ts.ModuleKind.NodeNext && 99 /* ScriptTarget.ESNext */) ||
            0 /* ScriptTarget.ES3 */;
    }
    ts.getEmitScriptTarget = getEmitScriptTarget;
    function getEmitModuleKind(compilerOptions) {
        return typeof compilerOptions.module === "number" ?
            compilerOptions.module :
            getEmitScriptTarget(compilerOptions) >= 2 /* ScriptTarget.ES2015 */ ? ts.ModuleKind.ES2015 : ts.ModuleKind.CommonJS;
    }
    ts.getEmitModuleKind = getEmitModuleKind;
    function getEmitModuleResolutionKind(compilerOptions) {
        var moduleResolution = compilerOptions.moduleResolution;
        if (moduleResolution === undefined) {
            switch (getEmitModuleKind(compilerOptions)) {
                case ts.ModuleKind.CommonJS:
                    moduleResolution = ts.ModuleResolutionKind.NodeJs;
                    break;
                case ts.ModuleKind.Node16:
                    moduleResolution = ts.ModuleResolutionKind.Node16;
                    break;
                case ts.ModuleKind.NodeNext:
                    moduleResolution = ts.ModuleResolutionKind.NodeNext;
                    break;
                default:
                    moduleResolution = ts.ModuleResolutionKind.Classic;
                    break;
            }
        }
        return moduleResolution;
    }
    ts.getEmitModuleResolutionKind = getEmitModuleResolutionKind;
    function getEmitModuleDetectionKind(options) {
        return options.moduleDetection ||
            (getEmitModuleKind(options) === ts.ModuleKind.Node16 || getEmitModuleKind(options) === ts.ModuleKind.NodeNext ? ts.ModuleDetectionKind.Force : ts.ModuleDetectionKind.Auto);
    }
    ts.getEmitModuleDetectionKind = getEmitModuleDetectionKind;
    function hasJsonModuleEmitEnabled(options) {
        switch (getEmitModuleKind(options)) {
            case ts.ModuleKind.CommonJS:
            case ts.ModuleKind.AMD:
            case ts.ModuleKind.ES2015:
            case ts.ModuleKind.ES2020:
            case ts.ModuleKind.ES2022:
            case ts.ModuleKind.ESNext:
            case ts.ModuleKind.Node16:
            case ts.ModuleKind.NodeNext:
                return true;
            default:
                return false;
        }
    }
    ts.hasJsonModuleEmitEnabled = hasJsonModuleEmitEnabled;
    function unreachableCodeIsError(options) {
        return options.allowUnreachableCode === false;
    }
    ts.unreachableCodeIsError = unreachableCodeIsError;
    function unusedLabelIsError(options) {
        return options.allowUnusedLabels === false;
    }
    ts.unusedLabelIsError = unusedLabelIsError;
    function getAreDeclarationMapsEnabled(options) {
        return !!(getEmitDeclarations(options) && options.declarationMap);
    }
    ts.getAreDeclarationMapsEnabled = getAreDeclarationMapsEnabled;
    function getESModuleInterop(compilerOptions) {
        if (compilerOptions.esModuleInterop !== undefined) {
            return compilerOptions.esModuleInterop;
        }
        switch (getEmitModuleKind(compilerOptions)) {
            case ts.ModuleKind.Node16:
            case ts.ModuleKind.NodeNext:
                return true;
        }
        return undefined;
    }
    ts.getESModuleInterop = getESModuleInterop;
    function getAllowSyntheticDefaultImports(compilerOptions) {
        var moduleKind = getEmitModuleKind(compilerOptions);
        return compilerOptions.allowSyntheticDefaultImports !== undefined
            ? compilerOptions.allowSyntheticDefaultImports
            : getESModuleInterop(compilerOptions) ||
                moduleKind === ts.ModuleKind.System;
    }
    ts.getAllowSyntheticDefaultImports = getAllowSyntheticDefaultImports;
    function getEmitDeclarations(compilerOptions) {
        return !!(compilerOptions.declaration || compilerOptions.composite);
    }
    ts.getEmitDeclarations = getEmitDeclarations;
    function shouldPreserveConstEnums(compilerOptions) {
        return !!(compilerOptions.preserveConstEnums || compilerOptions.isolatedModules);
    }
    ts.shouldPreserveConstEnums = shouldPreserveConstEnums;
    function isIncrementalCompilation(options) {
        return !!(options.incremental || options.composite);
    }
    ts.isIncrementalCompilation = isIncrementalCompilation;
    function getStrictOptionValue(compilerOptions, flag) {
        return compilerOptions[flag] === undefined ? !!compilerOptions.strict : !!compilerOptions[flag];
    }
    ts.getStrictOptionValue = getStrictOptionValue;
    function getAllowJSCompilerOption(compilerOptions) {
        return compilerOptions.allowJs === undefined ? !!compilerOptions.checkJs : compilerOptions.allowJs;
    }
    ts.getAllowJSCompilerOption = getAllowJSCompilerOption;
    function getUseDefineForClassFields(compilerOptions) {
        return compilerOptions.useDefineForClassFields === undefined ? getEmitScriptTarget(compilerOptions) >= 9 /* ScriptTarget.ES2022 */ : compilerOptions.useDefineForClassFields;
    }
    ts.getUseDefineForClassFields = getUseDefineForClassFields;
    function compilerOptionsAffectSemanticDiagnostics(newOptions, oldOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.semanticDiagnosticsOptionDeclarations);
    }
    ts.compilerOptionsAffectSemanticDiagnostics = compilerOptionsAffectSemanticDiagnostics;
    function compilerOptionsAffectEmit(newOptions, oldOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.affectsEmitOptionDeclarations);
    }
    ts.compilerOptionsAffectEmit = compilerOptionsAffectEmit;
    function getCompilerOptionValue(options, option) {
        return option.strictFlag ? getStrictOptionValue(options, option.name) : options[option.name];
    }
    ts.getCompilerOptionValue = getCompilerOptionValue;
    function getJSXTransformEnabled(options) {
        var jsx = options.jsx;
        return jsx === 2 /* JsxEmit.React */ || jsx === 4 /* JsxEmit.ReactJSX */ || jsx === 5 /* JsxEmit.ReactJSXDev */;
    }
    ts.getJSXTransformEnabled = getJSXTransformEnabled;
    function getJSXImplicitImportBase(compilerOptions, file) {
        var jsxImportSourcePragmas = file === null || file === void 0 ? void 0 : file.pragmas.get("jsximportsource");
        var jsxImportSourcePragma = ts.isArray(jsxImportSourcePragmas) ? jsxImportSourcePragmas[jsxImportSourcePragmas.length - 1] : jsxImportSourcePragmas;
        return compilerOptions.jsx === 4 /* JsxEmit.ReactJSX */ ||
            compilerOptions.jsx === 5 /* JsxEmit.ReactJSXDev */ ||
            compilerOptions.jsxImportSource ||
            jsxImportSourcePragma ?
            (jsxImportSourcePragma === null || jsxImportSourcePragma === void 0 ? void 0 : jsxImportSourcePragma.arguments.factory) || compilerOptions.jsxImportSource || "react" :
            undefined;
    }
    ts.getJSXImplicitImportBase = getJSXImplicitImportBase;
    function getJSXRuntimeImport(base, options) {
        return base ? "".concat(base, "/").concat(options.jsx === 5 /* JsxEmit.ReactJSXDev */ ? "jsx-dev-runtime" : "jsx-runtime") : undefined;
    }
    ts.getJSXRuntimeImport = getJSXRuntimeImport;
    function hasZeroOrOneAsteriskCharacter(str) {
        var seenAsterisk = false;
        for (var i = 0; i < str.length; i++) {
            if (str.charCodeAt(i) === 42 /* CharacterCodes.asterisk */) {
                if (!seenAsterisk) {
                    seenAsterisk = true;
                }
                else {
                    // have already seen asterisk
                    return false;
                }
            }
        }
        return true;
    }
    ts.hasZeroOrOneAsteriskCharacter = hasZeroOrOneAsteriskCharacter;
    function createSymlinkCache(cwd, getCanonicalFileName) {
        var symlinkedDirectories;
        var symlinkedDirectoriesByRealpath;
        var symlinkedFiles;
        var hasProcessedResolutions = false;
        return {
            getSymlinkedFiles: function () { return symlinkedFiles; },
            getSymlinkedDirectories: function () { return symlinkedDirectories; },
            getSymlinkedDirectoriesByRealpath: function () { return symlinkedDirectoriesByRealpath; },
            setSymlinkedFile: function (path, real) { return (symlinkedFiles || (symlinkedFiles = new ts.Map())).set(path, real); },
            setSymlinkedDirectory: function (symlink, real) {
                // Large, interconnected dependency graphs in pnpm will have a huge number of symlinks
                // where both the realpath and the symlink path are inside node_modules/.pnpm. Since
                // this path is never a candidate for a module specifier, we can ignore it entirely.
                var symlinkPath = ts.toPath(symlink, cwd, getCanonicalFileName);
                if (!containsIgnoredPath(symlinkPath)) {
                    symlinkPath = ts.ensureTrailingDirectorySeparator(symlinkPath);
                    if (real !== false && !(symlinkedDirectories === null || symlinkedDirectories === void 0 ? void 0 : symlinkedDirectories.has(symlinkPath))) {
                        (symlinkedDirectoriesByRealpath || (symlinkedDirectoriesByRealpath = ts.createMultiMap())).add(ts.ensureTrailingDirectorySeparator(real.realPath), symlink);
                    }
                    (symlinkedDirectories || (symlinkedDirectories = new ts.Map())).set(symlinkPath, real);
                }
            },
            setSymlinksFromResolutions: function (files, typeReferenceDirectives) {
                var _this = this;
                var _a;
                ts.Debug.assert(!hasProcessedResolutions);
                hasProcessedResolutions = true;
                for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                    var file = files_1[_i];
                    (_a = file.resolvedModules) === null || _a === void 0 ? void 0 : _a.forEach(function (resolution) { return processResolution(_this, resolution); });
                }
                typeReferenceDirectives === null || typeReferenceDirectives === void 0 ? void 0 : typeReferenceDirectives.forEach(function (resolution) { return processResolution(_this, resolution); });
            },
            hasProcessedResolutions: function () { return hasProcessedResolutions; },
        };
        function processResolution(cache, resolution) {
            if (!resolution || !resolution.originalPath || !resolution.resolvedFileName)
                return;
            var resolvedFileName = resolution.resolvedFileName, originalPath = resolution.originalPath;
            cache.setSymlinkedFile(ts.toPath(originalPath, cwd, getCanonicalFileName), resolvedFileName);
            var _a = guessDirectorySymlink(resolvedFileName, originalPath, cwd, getCanonicalFileName) || ts.emptyArray, commonResolved = _a[0], commonOriginal = _a[1];
            if (commonResolved && commonOriginal) {
                cache.setSymlinkedDirectory(commonOriginal, { real: commonResolved, realPath: ts.toPath(commonResolved, cwd, getCanonicalFileName) });
            }
        }
    }
    ts.createSymlinkCache = createSymlinkCache;
    function guessDirectorySymlink(a, b, cwd, getCanonicalFileName) {
        var aParts = ts.getPathComponents(ts.getNormalizedAbsolutePath(a, cwd));
        var bParts = ts.getPathComponents(ts.getNormalizedAbsolutePath(b, cwd));
        var isDirectory = false;
        while (aParts.length >= 2 && bParts.length >= 2 &&
            !isNodeModulesOrScopedPackageDirectory(aParts[aParts.length - 2], getCanonicalFileName) &&
            !isNodeModulesOrScopedPackageDirectory(bParts[bParts.length - 2], getCanonicalFileName) &&
            getCanonicalFileName(aParts[aParts.length - 1]) === getCanonicalFileName(bParts[bParts.length - 1])) {
            aParts.pop();
            bParts.pop();
            isDirectory = true;
        }
        return isDirectory ? [ts.getPathFromPathComponents(aParts), ts.getPathFromPathComponents(bParts)] : undefined;
    }
    // KLUDGE: Don't assume one 'node_modules' links to another. More likely a single directory inside the node_modules is the symlink.
    // ALso, don't assume that an `@foo` directory is linked. More likely the contents of that are linked.
    function isNodeModulesOrScopedPackageDirectory(s, getCanonicalFileName) {
        return s !== undefined && (getCanonicalFileName(s) === "node_modules" || ts.startsWith(s, "@"));
    }
    function stripLeadingDirectorySeparator(s) {
        return ts.isAnyDirectorySeparator(s.charCodeAt(0)) ? s.slice(1) : undefined;
    }
    function tryRemoveDirectoryPrefix(path, dirPath, getCanonicalFileName) {
        var withoutPrefix = ts.tryRemovePrefix(path, dirPath, getCanonicalFileName);
        return withoutPrefix === undefined ? undefined : stripLeadingDirectorySeparator(withoutPrefix);
    }
    ts.tryRemoveDirectoryPrefix = tryRemoveDirectoryPrefix;
    // Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.
    // It may be inefficient (we could just match (/[-[\]{}()*+?.,\\^$|#\s]/g), but this is future
    // proof.
    var reservedCharacterPattern = /[^\w\s\/]/g;
    function regExpEscape(text) {
        return text.replace(reservedCharacterPattern, escapeRegExpCharacter);
    }
    ts.regExpEscape = regExpEscape;
    function escapeRegExpCharacter(match) {
        return "\\" + match;
    }
    var wildcardCharCodes = [42 /* CharacterCodes.asterisk */, 63 /* CharacterCodes.question */];
    ts.commonPackageFolders = ["node_modules", "bower_components", "jspm_packages"];
    var implicitExcludePathRegexPattern = "(?!(".concat(ts.commonPackageFolders.join("|"), ")(/|$))");
    var filesMatcher = {
        /**
         * Matches any single directory segment unless it is the last segment and a .min.js file
         * Breakdown:
         *  [^./]                   # matches everything up to the first . character (excluding directory separators)
         *  (\\.(?!min\\.js$))?     # matches . characters but not if they are part of the .min.js file extension
         */
        singleAsteriskRegexFragment: "([^./]|(\\.(?!min\\.js$))?)*",
        /**
         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
         * files or directories, does not match subdirectories that start with a . character
         */
        doubleAsteriskRegexFragment: "(/".concat(implicitExcludePathRegexPattern, "[^/.][^/]*)*?"),
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment); }
    };
    var directoriesMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        /**
         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
         * files or directories, does not match subdirectories that start with a . character
         */
        doubleAsteriskRegexFragment: "(/".concat(implicitExcludePathRegexPattern, "[^/.][^/]*)*?"),
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment); }
    };
    var excludeMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        doubleAsteriskRegexFragment: "(/.+?)?",
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment); }
    };
    var wildcardMatchers = {
        files: filesMatcher,
        directories: directoriesMatcher,
        exclude: excludeMatcher
    };
    function getRegularExpressionForWildcard(specs, basePath, usage) {
        var patterns = getRegularExpressionsForWildcards(specs, basePath, usage);
        if (!patterns || !patterns.length) {
            return undefined;
        }
        var pattern = patterns.map(function (pattern) { return "(".concat(pattern, ")"); }).join("|");
        // If excluding, match "foo/bar/baz...", but if including, only allow "foo".
        var terminator = usage === "exclude" ? "($|/)" : "$";
        return "^(".concat(pattern, ")").concat(terminator);
    }
    ts.getRegularExpressionForWildcard = getRegularExpressionForWildcard;
    function getRegularExpressionsForWildcards(specs, basePath, usage) {
        if (specs === undefined || specs.length === 0) {
            return undefined;
        }
        return ts.flatMap(specs, function (spec) {
            return spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]);
        });
    }
    ts.getRegularExpressionsForWildcards = getRegularExpressionsForWildcards;
    /**
     * An "includes" path "foo" is implicitly a glob "foo/** /*" (without the space) if its last component has no extension,
     * and does not contain any glob characters itself.
     */
    function isImplicitGlob(lastPathComponent) {
        return !/[.*?]/.test(lastPathComponent);
    }
    ts.isImplicitGlob = isImplicitGlob;
    function getPatternFromSpec(spec, basePath, usage) {
        var pattern = spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]);
        return pattern && "^(".concat(pattern, ")").concat(usage === "exclude" ? "($|/)" : "$");
    }
    ts.getPatternFromSpec = getPatternFromSpec;
    function getSubPatternFromSpec(spec, basePath, usage, _a) {
        var singleAsteriskRegexFragment = _a.singleAsteriskRegexFragment, doubleAsteriskRegexFragment = _a.doubleAsteriskRegexFragment, replaceWildcardCharacter = _a.replaceWildcardCharacter;
        var subpattern = "";
        var hasWrittenComponent = false;
        var components = ts.getNormalizedPathComponents(spec, basePath);
        var lastComponent = ts.last(components);
        if (usage !== "exclude" && lastComponent === "**") {
            return undefined;
        }
        // getNormalizedPathComponents includes the separator for the root component.
        // We need to remove to create our regex correctly.
        components[0] = ts.removeTrailingDirectorySeparator(components[0]);
        if (isImplicitGlob(lastComponent)) {
            components.push("**", "*");
        }
        var optionalCount = 0;
        for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
            var component = components_1[_i];
            if (component === "**") {
                subpattern += doubleAsteriskRegexFragment;
            }
            else {
                if (usage === "directories") {
                    subpattern += "(";
                    optionalCount++;
                }
                if (hasWrittenComponent) {
                    subpattern += ts.directorySeparator;
                }
                if (usage !== "exclude") {
                    var componentPattern = "";
                    // The * and ? wildcards should not match directories or files that start with . if they
                    // appear first in a component. Dotted directories and files can be included explicitly
                    // like so: **/.*/.*
                    if (component.charCodeAt(0) === 42 /* CharacterCodes.asterisk */) {
                        componentPattern += "([^./]" + singleAsteriskRegexFragment + ")?";
                        component = component.substr(1);
                    }
                    else if (component.charCodeAt(0) === 63 /* CharacterCodes.question */) {
                        componentPattern += "[^./]";
                        component = component.substr(1);
                    }
                    componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
                    // Patterns should not include subfolders like node_modules unless they are
                    // explicitly included as part of the path.
                    //
                    // As an optimization, if the component pattern is the same as the component,
                    // then there definitely were no wildcard characters and we do not need to
                    // add the exclusion pattern.
                    if (componentPattern !== component) {
                        subpattern += implicitExcludePathRegexPattern;
                    }
                    subpattern += componentPattern;
                }
                else {
                    subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
                }
            }
            hasWrittenComponent = true;
        }
        while (optionalCount > 0) {
            subpattern += ")?";
            optionalCount--;
        }
        return subpattern;
    }
    function replaceWildcardCharacter(match, singleAsteriskRegexFragment) {
        return match === "*" ? singleAsteriskRegexFragment : match === "?" ? "[^/]" : "\\" + match;
    }
    /** @param path directory of the tsconfig.json */
    function getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {
        path = ts.normalizePath(path);
        currentDirectory = ts.normalizePath(currentDirectory);
        var absolutePath = ts.combinePaths(currentDirectory, path);
        return {
            includeFilePatterns: ts.map(getRegularExpressionsForWildcards(includes, absolutePath, "files"), function (pattern) { return "^".concat(pattern, "$"); }),
            includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, "files"),
            includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, "directories"),
            excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, "exclude"),
            basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames)
        };
    }
    ts.getFileMatcherPatterns = getFileMatcherPatterns;
    function getRegexFromPattern(pattern, useCaseSensitiveFileNames) {
        return new RegExp(pattern, useCaseSensitiveFileNames ? "" : "i");
    }
    ts.getRegexFromPattern = getRegexFromPattern;
    /** @param path directory of the tsconfig.json */
    function matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getFileSystemEntries, realpath) {
        path = ts.normalizePath(path);
        currentDirectory = ts.normalizePath(currentDirectory);
        var patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);
        var includeFileRegexes = patterns.includeFilePatterns && patterns.includeFilePatterns.map(function (pattern) { return getRegexFromPattern(pattern, useCaseSensitiveFileNames); });
        var includeDirectoryRegex = patterns.includeDirectoryPattern && getRegexFromPattern(patterns.includeDirectoryPattern, useCaseSensitiveFileNames);
        var excludeRegex = patterns.excludePattern && getRegexFromPattern(patterns.excludePattern, useCaseSensitiveFileNames);
        // Associate an array of results with each include regex. This keeps results in order of the "include" order.
        // If there are no "includes", then just put everything in results[0].
        var results = includeFileRegexes ? includeFileRegexes.map(function () { return []; }) : [[]];
        var visited = new ts.Map();
        var toCanonical = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        for (var _i = 0, _a = patterns.basePaths; _i < _a.length; _i++) {
            var basePath = _a[_i];
            visitDirectory(basePath, ts.combinePaths(currentDirectory, basePath), depth);
        }
        return ts.flatten(results);
        function visitDirectory(path, absolutePath, depth) {
            var canonicalPath = toCanonical(realpath(absolutePath));
            if (visited.has(canonicalPath))
                return;
            visited.set(canonicalPath, true);
            var _a = getFileSystemEntries(path), files = _a.files, directories = _a.directories;
            var _loop_1 = function (current) {
                var name = ts.combinePaths(path, current);
                var absoluteName = ts.combinePaths(absolutePath, current);
                if (extensions && !ts.fileExtensionIsOneOf(name, extensions))
                    return "continue";
                if (excludeRegex && excludeRegex.test(absoluteName))
                    return "continue";
                if (!includeFileRegexes) {
                    results[0].push(name);
                }
                else {
                    var includeIndex = ts.findIndex(includeFileRegexes, function (re) { return re.test(absoluteName); });
                    if (includeIndex !== -1) {
                        results[includeIndex].push(name);
                    }
                }
            };
            for (var _i = 0, _b = ts.sort(files, ts.compareStringsCaseSensitive); _i < _b.length; _i++) {
                var current = _b[_i];
                _loop_1(current);
            }
            if (depth !== undefined) {
                depth--;
                if (depth === 0) {
                    return;
                }
            }
            for (var _c = 0, _d = ts.sort(directories, ts.compareStringsCaseSensitive); _c < _d.length; _c++) {
                var current = _d[_c];
                var name = ts.combinePaths(path, current);
                var absoluteName = ts.combinePaths(absolutePath, current);
                if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) &&
                    (!excludeRegex || !excludeRegex.test(absoluteName))) {
                    visitDirectory(name, absoluteName, depth);
                }
            }
        }
    }
    ts.matchFiles = matchFiles;
    /**
     * Computes the unique non-wildcard base paths amongst the provided include patterns.
     */
    function getBasePaths(path, includes, useCaseSensitiveFileNames) {
        // Storage for our results in the form of literal paths (e.g. the paths as written by the user).
        var basePaths = [path];
        if (includes) {
            // Storage for literal base paths amongst the include patterns.
            var includeBasePaths = [];
            for (var _i = 0, includes_1 = includes; _i < includes_1.length; _i++) {
                var include = includes_1[_i];
                // We also need to check the relative paths by converting them to absolute and normalizing
                // in case they escape the base path (e.g "..\somedirectory")
                var absolute = ts.isRootedDiskPath(include) ? include : ts.normalizePath(ts.combinePaths(path, include));
                // Append the literal and canonical candidate base paths.
                includeBasePaths.push(getIncludeBasePath(absolute));
            }
            // Sort the offsets array using either the literal or canonical path representations.
            includeBasePaths.sort(ts.getStringComparer(!useCaseSensitiveFileNames));
            var _loop_2 = function (includeBasePath) {
                if (ts.every(basePaths, function (basePath) { return !ts.containsPath(basePath, includeBasePath, path, !useCaseSensitiveFileNames); })) {
                    basePaths.push(includeBasePath);
                }
            };
            // Iterate over each include base path and include unique base paths that are not a
            // subpath of an existing base path
            for (var _a = 0, includeBasePaths_1 = includeBasePaths; _a < includeBasePaths_1.length; _a++) {
                var includeBasePath = includeBasePaths_1[_a];
                _loop_2(includeBasePath);
            }
        }
        return basePaths;
    }
    function getIncludeBasePath(absolute) {
        var wildcardOffset = ts.indexOfAnyCharCode(absolute, wildcardCharCodes);
        if (wildcardOffset < 0) {
            // No "*" or "?" in the path
            return !ts.hasExtension(absolute)
                ? absolute
                : ts.removeTrailingDirectorySeparator(ts.getDirectoryPath(absolute));
        }
        return absolute.substring(0, absolute.lastIndexOf(ts.directorySeparator, wildcardOffset));
    }
    function ensureScriptKind(fileName, scriptKind) {
        // Using scriptKind as a condition handles both:
        // - 'scriptKind' is unspecified and thus it is `undefined`
        // - 'scriptKind' is set and it is `Unknown` (0)
        // If the 'scriptKind' is 'undefined' or 'Unknown' then we attempt
        // to get the ScriptKind from the file name. If it cannot be resolved
        // from the file name then the default 'TS' script kind is returned.
        return scriptKind || getScriptKindFromFileName(fileName) || 3 /* ScriptKind.TS */;
    }
    ts.ensureScriptKind = ensureScriptKind;
    function getScriptKindFromFileName(fileName) {
        var ext = fileName.substr(fileName.lastIndexOf("."));
        switch (ext.toLowerCase()) {
            case ".js" /* Extension.Js */:
            case ".cjs" /* Extension.Cjs */:
            case ".mjs" /* Extension.Mjs */:
                return 1 /* ScriptKind.JS */;
            case ".jsx" /* Extension.Jsx */:
                return 2 /* ScriptKind.JSX */;
            case ".ts" /* Extension.Ts */:
            case ".cts" /* Extension.Cts */:
            case ".mts" /* Extension.Mts */:
                return 3 /* ScriptKind.TS */;
            case ".tsx" /* Extension.Tsx */:
                return 4 /* ScriptKind.TSX */;
            case ".json" /* Extension.Json */:
                return 6 /* ScriptKind.JSON */;
            default:
                return 0 /* ScriptKind.Unknown */;
        }
    }
    ts.getScriptKindFromFileName = getScriptKindFromFileName;
    /**
     *  Groups of supported extensions in order of file resolution precedence. (eg, TS > TSX > DTS and seperately, CTS > DCTS)
     */
    ts.supportedTSExtensions = [[".ts" /* Extension.Ts */, ".tsx" /* Extension.Tsx */, ".d.ts" /* Extension.Dts */], [".cts" /* Extension.Cts */, ".d.cts" /* Extension.Dcts */], [".mts" /* Extension.Mts */, ".d.mts" /* Extension.Dmts */]];
    ts.supportedTSExtensionsFlat = ts.flatten(ts.supportedTSExtensions);
    var supportedTSExtensionsWithJson = __spreadArray(__spreadArray([], ts.supportedTSExtensions, true), [[".json" /* Extension.Json */]], false);
    /** Must have ".d.ts" first because if ".ts" goes first, that will be detected as the extension instead of ".d.ts". */
    var supportedTSExtensionsForExtractExtension = [".d.ts" /* Extension.Dts */, ".d.cts" /* Extension.Dcts */, ".d.mts" /* Extension.Dmts */, ".cts" /* Extension.Cts */, ".mts" /* Extension.Mts */, ".ts" /* Extension.Ts */, ".tsx" /* Extension.Tsx */, ".cts" /* Extension.Cts */, ".mts" /* Extension.Mts */];
    ts.supportedJSExtensions = [[".js" /* Extension.Js */, ".jsx" /* Extension.Jsx */], [".mjs" /* Extension.Mjs */], [".cjs" /* Extension.Cjs */]];
    ts.supportedJSExtensionsFlat = ts.flatten(ts.supportedJSExtensions);
    var allSupportedExtensions = [[".ts" /* Extension.Ts */, ".tsx" /* Extension.Tsx */, ".d.ts" /* Extension.Dts */, ".js" /* Extension.Js */, ".jsx" /* Extension.Jsx */], [".cts" /* Extension.Cts */, ".d.cts" /* Extension.Dcts */, ".cjs" /* Extension.Cjs */], [".mts" /* Extension.Mts */, ".d.mts" /* Extension.Dmts */, ".mjs" /* Extension.Mjs */]];
    var allSupportedExtensionsWithJson = __spreadArray(__spreadArray([], allSupportedExtensions, true), [[".json" /* Extension.Json */]], false);
    ts.supportedDeclarationExtensions = [".d.ts" /* Extension.Dts */, ".d.cts" /* Extension.Dcts */, ".d.mts" /* Extension.Dmts */];
    function getSupportedExtensions(options, extraFileExtensions) {
        var needJsExtensions = options && getAllowJSCompilerOption(options);
        if (!extraFileExtensions || extraFileExtensions.length === 0) {
            return needJsExtensions ? allSupportedExtensions : ts.supportedTSExtensions;
        }
        var builtins = needJsExtensions ? allSupportedExtensions : ts.supportedTSExtensions;
        var flatBuiltins = ts.flatten(builtins);
        var extensions = __spreadArray(__spreadArray([], builtins, true), ts.mapDefined(extraFileExtensions, function (x) { return x.scriptKind === 7 /* ScriptKind.Deferred */ || needJsExtensions && isJSLike(x.scriptKind) && flatBuiltins.indexOf(x.extension) === -1 ? [x.extension] : undefined; }), true);
        return extensions;
    }
    ts.getSupportedExtensions = getSupportedExtensions;
    function getSupportedExtensionsWithJsonIfResolveJsonModule(options, supportedExtensions) {
        if (!options || !options.resolveJsonModule)
            return supportedExtensions;
        if (supportedExtensions === allSupportedExtensions)
            return allSupportedExtensionsWithJson;
        if (supportedExtensions === ts.supportedTSExtensions)
            return supportedTSExtensionsWithJson;
        return __spreadArray(__spreadArray([], supportedExtensions, true), [[".json" /* Extension.Json */]], false);
    }
    ts.getSupportedExtensionsWithJsonIfResolveJsonModule = getSupportedExtensionsWithJsonIfResolveJsonModule;
    function isJSLike(scriptKind) {
        return scriptKind === 1 /* ScriptKind.JS */ || scriptKind === 2 /* ScriptKind.JSX */;
    }
    function hasJSFileExtension(fileName) {
        return ts.some(ts.supportedJSExtensionsFlat, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.hasJSFileExtension = hasJSFileExtension;
    function hasTSFileExtension(fileName) {
        return ts.some(ts.supportedTSExtensionsFlat, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.hasTSFileExtension = hasTSFileExtension;
    function isSupportedSourceFileName(fileName, compilerOptions, extraFileExtensions) {
        if (!fileName)
            return false;
        var supportedExtensions = getSupportedExtensions(compilerOptions, extraFileExtensions);
        for (var _i = 0, _a = ts.flatten(getSupportedExtensionsWithJsonIfResolveJsonModule(compilerOptions, supportedExtensions)); _i < _a.length; _i++) {
            var extension = _a[_i];
            if (ts.fileExtensionIs(fileName, extension)) {
                return true;
            }
        }
        return false;
    }
    ts.isSupportedSourceFileName = isSupportedSourceFileName;
    function numberOfDirectorySeparators(str) {
        var match = str.match(/\//g);
        return match ? match.length : 0;
    }
    function compareNumberOfDirectorySeparators(path1, path2) {
        return ts.compareValues(numberOfDirectorySeparators(path1), numberOfDirectorySeparators(path2));
    }
    ts.compareNumberOfDirectorySeparators = compareNumberOfDirectorySeparators;
    var extensionsToRemove = [".d.ts" /* Extension.Dts */, ".d.mts" /* Extension.Dmts */, ".d.cts" /* Extension.Dcts */, ".mjs" /* Extension.Mjs */, ".mts" /* Extension.Mts */, ".cjs" /* Extension.Cjs */, ".cts" /* Extension.Cts */, ".ts" /* Extension.Ts */, ".js" /* Extension.Js */, ".tsx" /* Extension.Tsx */, ".jsx" /* Extension.Jsx */, ".json" /* Extension.Json */];
    function removeFileExtension(path) {
        for (var _i = 0, extensionsToRemove_1 = extensionsToRemove; _i < extensionsToRemove_1.length; _i++) {
            var ext = extensionsToRemove_1[_i];
            var extensionless = tryRemoveExtension(path, ext);
            if (extensionless !== undefined) {
                return extensionless;
            }
        }
        return path;
    }
    ts.removeFileExtension = removeFileExtension;
    function tryRemoveExtension(path, extension) {
        return ts.fileExtensionIs(path, extension) ? removeExtension(path, extension) : undefined;
    }
    ts.tryRemoveExtension = tryRemoveExtension;
    function removeExtension(path, extension) {
        return path.substring(0, path.length - extension.length);
    }
    ts.removeExtension = removeExtension;
    function changeExtension(path, newExtension) {
        return ts.changeAnyExtension(path, newExtension, extensionsToRemove, /*ignoreCase*/ false);
    }
    ts.changeExtension = changeExtension;
    /**
     * Returns the input if there are no stars, a pattern if there is exactly one,
     * and undefined if there are more.
     */
    function tryParsePattern(pattern) {
        var indexOfStar = pattern.indexOf("*");
        if (indexOfStar === -1) {
            return pattern;
        }
        return pattern.indexOf("*", indexOfStar + 1) !== -1
            ? undefined
            : {
                prefix: pattern.substr(0, indexOfStar),
                suffix: pattern.substr(indexOfStar + 1)
            };
    }
    ts.tryParsePattern = tryParsePattern;
    function tryParsePatterns(paths) {
        return ts.mapDefined(ts.getOwnKeys(paths), function (path) { return tryParsePattern(path); });
    }
    ts.tryParsePatterns = tryParsePatterns;
    function positionIsSynthesized(pos) {
        // This is a fast way of testing the following conditions:
        //  pos === undefined || pos === null || isNaN(pos) || pos < 0;
        return !(pos >= 0);
    }
    ts.positionIsSynthesized = positionIsSynthesized;
    /** True if an extension is one of the supported TypeScript extensions. */
    function extensionIsTS(ext) {
        return ext === ".ts" /* Extension.Ts */ || ext === ".tsx" /* Extension.Tsx */ || ext === ".d.ts" /* Extension.Dts */ || ext === ".cts" /* Extension.Cts */ || ext === ".mts" /* Extension.Mts */ || ext === ".d.mts" /* Extension.Dmts */ || ext === ".d.cts" /* Extension.Dcts */;
    }
    ts.extensionIsTS = extensionIsTS;
    function resolutionExtensionIsTSOrJson(ext) {
        return extensionIsTS(ext) || ext === ".json" /* Extension.Json */;
    }
    ts.resolutionExtensionIsTSOrJson = resolutionExtensionIsTSOrJson;
    /**
     * Gets the extension from a path.
     * Path must have a valid extension.
     */
    function extensionFromPath(path) {
        var ext = tryGetExtensionFromPath(path);
        return ext !== undefined ? ext : ts.Debug.fail("File ".concat(path, " has unknown extension."));
    }
    ts.extensionFromPath = extensionFromPath;
    function isAnySupportedFileExtension(path) {
        return tryGetExtensionFromPath(path) !== undefined;
    }
    ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
    function tryGetExtensionFromPath(path) {
        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
    }
    ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
    function isCheckJsEnabledForFile(sourceFile, compilerOptions) {
        return sourceFile.checkJsDirective ? sourceFile.checkJsDirective.enabled : compilerOptions.checkJs;
    }
    ts.isCheckJsEnabledForFile = isCheckJsEnabledForFile;
    ts.emptyFileSystemEntries = {
        files: ts.emptyArray,
        directories: ts.emptyArray
    };
    /**
     * patternOrStrings contains both patterns (containing "*") and regular strings.
     * Return an exact match if possible, or a pattern match, or undefined.
     * (These are verified by verifyCompilerOptions to have 0 or 1 "*" characters.)
     */
    function matchPatternOrExact(patternOrStrings, candidate) {
        var patterns = [];
        for (var _i = 0, patternOrStrings_1 = patternOrStrings; _i < patternOrStrings_1.length; _i++) {
            var patternOrString = patternOrStrings_1[_i];
            if (patternOrString === candidate) {
                return candidate;
            }
            if (!ts.isString(patternOrString)) {
                patterns.push(patternOrString);
            }
        }
        return ts.findBestPatternMatch(patterns, function (_) { return _; }, candidate);
    }
    ts.matchPatternOrExact = matchPatternOrExact;
    function sliceAfter(arr, value) {
        var index = arr.indexOf(value);
        ts.Debug.assert(index !== -1);
        return arr.slice(index);
    }
    ts.sliceAfter = sliceAfter;
    function addRelatedInfo(diagnostic) {
        var _a;
        var relatedInformation = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            relatedInformation[_i - 1] = arguments[_i];
        }
        if (!relatedInformation.length) {
            return diagnostic;
        }
        if (!diagnostic.relatedInformation) {
            diagnostic.relatedInformation = [];
        }
        ts.Debug.assert(diagnostic.relatedInformation !== ts.emptyArray, "Diagnostic had empty array singleton for related info, but is still being constructed!");
        (_a = diagnostic.relatedInformation).push.apply(_a, relatedInformation);
        return diagnostic;
    }
    ts.addRelatedInfo = addRelatedInfo;
    function minAndMax(arr, getValue) {
        ts.Debug.assert(arr.length !== 0);
        var min = getValue(arr[0]);
        var max = min;
        for (var i = 1; i < arr.length; i++) {
            var value = getValue(arr[i]);
            if (value < min) {
                min = value;
            }
            else if (value > max) {
                max = value;
            }
        }
        return { min: min, max: max };
    }
    ts.minAndMax = minAndMax;
    function rangeOfNode(node) {
        return { pos: getTokenPosOfNode(node), end: node.end };
    }
    ts.rangeOfNode = rangeOfNode;
    function rangeOfTypeParameters(sourceFile, typeParameters) {
        // Include the `<>`
        var pos = typeParameters.pos - 1;
        var end = ts.skipTrivia(sourceFile.text, typeParameters.end) + 1;
        return { pos: pos, end: end };
    }
    ts.rangeOfTypeParameters = rangeOfTypeParameters;
    function skipTypeChecking(sourceFile, options, host) {
        // If skipLibCheck is enabled, skip reporting errors if file is a declaration file.
        // If skipDefaultLibCheck is enabled, skip reporting errors if file contains a
        // '/// <reference no-default-lib="true"/>' directive.
        return (options.skipLibCheck && sourceFile.isDeclarationFile ||
            options.skipDefaultLibCheck && sourceFile.hasNoDefaultLib) ||
            host.isSourceOfProjectReferenceRedirect(sourceFile.fileName);
    }
    ts.skipTypeChecking = skipTypeChecking;
    function isJsonEqual(a, b) {
        // eslint-disable-next-line no-null/no-null
        return a === b || typeof a === "object" && a !== null && typeof b === "object" && b !== null && ts.equalOwnProperties(a, b, isJsonEqual);
    }
    ts.isJsonEqual = isJsonEqual;
    /**
     * Converts a bigint literal string, e.g. `0x1234n`,
     * to its decimal string representation, e.g. `4660`.
     */
    function parsePseudoBigInt(stringValue) {
        var log2Base;
        switch (stringValue.charCodeAt(1)) { // "x" in "0x123"
            case 98 /* CharacterCodes.b */:
            case 66 /* CharacterCodes.B */: // 0b or 0B
                log2Base = 1;
                break;
            case 111 /* CharacterCodes.o */:
            case 79 /* CharacterCodes.O */: // 0o or 0O
                log2Base = 3;
                break;
            case 120 /* CharacterCodes.x */:
            case 88 /* CharacterCodes.X */: // 0x or 0X
                log2Base = 4;
                break;
            default: // already in decimal; omit trailing "n"
                var nIndex = stringValue.length - 1;
                // Skip leading 0s
                var nonZeroStart = 0;
                while (stringValue.charCodeAt(nonZeroStart) === 48 /* CharacterCodes._0 */) {
                    nonZeroStart++;
                }
                return stringValue.slice(nonZeroStart, nIndex) || "0";
        }
        // Omit leading "0b", "0o", or "0x", and trailing "n"
        var startIndex = 2, endIndex = stringValue.length - 1;
        var bitsNeeded = (endIndex - startIndex) * log2Base;
        // Stores the value specified by the string as a LE array of 16-bit integers
        // using Uint16 instead of Uint32 so combining steps can use bitwise operators
        var segments = new Uint16Array((bitsNeeded >>> 4) + (bitsNeeded & 15 ? 1 : 0));
        // Add the digits, one at a time
        for (var i = endIndex - 1, bitOffset = 0; i >= startIndex; i--, bitOffset += log2Base) {
            var segment = bitOffset >>> 4;
            var digitChar = stringValue.charCodeAt(i);
            // Find character range: 0-9 < A-F < a-f
            var digit = digitChar <= 57 /* CharacterCodes._9 */
                ? digitChar - 48 /* CharacterCodes._0 */
                : 10 + digitChar -
                    (digitChar <= 70 /* CharacterCodes.F */ ? 65 /* CharacterCodes.A */ : 97 /* CharacterCodes.a */);
            var shiftedDigit = digit << (bitOffset & 15);
            segments[segment] |= shiftedDigit;
            var residual = shiftedDigit >>> 16;
            if (residual)
                segments[segment + 1] |= residual; // overflows segment
        }
        // Repeatedly divide segments by 10 and add remainder to base10Value
        var base10Value = "";
        var firstNonzeroSegment = segments.length - 1;
        var segmentsRemaining = true;
        while (segmentsRemaining) {
            var mod10 = 0;
            segmentsRemaining = false;
            for (var segment = firstNonzeroSegment; segment >= 0; segment--) {
                var newSegment = mod10 << 16 | segments[segment];
                var segmentValue = (newSegment / 10) | 0;
                segments[segment] = segmentValue;
                mod10 = newSegment - segmentValue * 10;
                if (segmentValue && !segmentsRemaining) {
                    firstNonzeroSegment = segment;
                    segmentsRemaining = true;
                }
            }
            base10Value = mod10 + base10Value;
        }
        return base10Value;
    }
    ts.parsePseudoBigInt = parsePseudoBigInt;
    function pseudoBigIntToString(_a) {
        var negative = _a.negative, base10Value = _a.base10Value;
        return (negative && base10Value !== "0" ? "-" : "") + base10Value;
    }
    ts.pseudoBigIntToString = pseudoBigIntToString;
    function isValidTypeOnlyAliasUseSite(useSite) {
        return !!(useSite.flags & 16777216 /* NodeFlags.Ambient */)
            || isPartOfTypeQuery(useSite)
            || isIdentifierInNonEmittingHeritageClause(useSite)
            || isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(useSite)
            || !(isExpressionNode(useSite) || isShorthandPropertyNameUseSite(useSite));
    }
    ts.isValidTypeOnlyAliasUseSite = isValidTypeOnlyAliasUseSite;
    function isShorthandPropertyNameUseSite(useSite) {
        return ts.isIdentifier(useSite) && ts.isShorthandPropertyAssignment(useSite.parent) && useSite.parent.name === useSite;
    }
    function isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(node) {
        while (node.kind === 79 /* SyntaxKind.Identifier */ || node.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
            node = node.parent;
        }
        if (node.kind !== 162 /* SyntaxKind.ComputedPropertyName */) {
            return false;
        }
        if (hasSyntacticModifier(node.parent, 128 /* ModifierFlags.Abstract */)) {
            return true;
        }
        var containerKind = node.parent.parent.kind;
        return containerKind === 258 /* SyntaxKind.InterfaceDeclaration */ || containerKind === 182 /* SyntaxKind.TypeLiteral */;
    }
    /** Returns true for an identifier in 1) an `implements` clause, and 2) an `extends` clause of an interface. */
    function isIdentifierInNonEmittingHeritageClause(node) {
        if (node.kind !== 79 /* SyntaxKind.Identifier */)
            return false;
        var heritageClause = ts.findAncestor(node.parent, function (parent) {
            switch (parent.kind) {
                case 291 /* SyntaxKind.HeritageClause */:
                    return true;
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                    return false;
                default:
                    return "quit";
            }
        });
        return (heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.token) === 117 /* SyntaxKind.ImplementsKeyword */ || (heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.parent.kind) === 258 /* SyntaxKind.InterfaceDeclaration */;
    }
    function isIdentifierTypeReference(node) {
        return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName);
    }
    ts.isIdentifierTypeReference = isIdentifierTypeReference;
    function arrayIsHomogeneous(array, comparer) {
        if (comparer === void 0) { comparer = ts.equateValues; }
        if (array.length < 2)
            return true;
        var first = array[0];
        for (var i = 1, length_1 = array.length; i < length_1; i++) {
            var target = array[i];
            if (!comparer(first, target))
                return false;
        }
        return true;
    }
    ts.arrayIsHomogeneous = arrayIsHomogeneous;
    /**
     * Bypasses immutability and directly sets the `pos` property of a `TextRange` or `Node`.
     */
    /* @internal */
    function setTextRangePos(range, pos) {
        range.pos = pos;
        return range;
    }
    ts.setTextRangePos = setTextRangePos;
    /**
     * Bypasses immutability and directly sets the `end` property of a `TextRange` or `Node`.
     */
    /* @internal */
    function setTextRangeEnd(range, end) {
        range.end = end;
        return range;
    }
    ts.setTextRangeEnd = setTextRangeEnd;
    /**
     * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node`.
     */
    /* @internal */
    function setTextRangePosEnd(range, pos, end) {
        return setTextRangeEnd(setTextRangePos(range, pos), end);
    }
    ts.setTextRangePosEnd = setTextRangePosEnd;
    /**
     * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node` from the
     * provided position and width.
     */
    /* @internal */
    function setTextRangePosWidth(range, pos, width) {
        return setTextRangePosEnd(range, pos, pos + width);
    }
    ts.setTextRangePosWidth = setTextRangePosWidth;
    function setNodeFlags(node, newFlags) {
        if (node) {
            node.flags = newFlags;
        }
        return node;
    }
    ts.setNodeFlags = setNodeFlags;
    function setParent(child, parent) {
        if (child && parent) {
            child.parent = parent;
        }
        return child;
    }
    ts.setParent = setParent;
    function setEachParent(children, parent) {
        if (children) {
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var child = children_1[_i];
                setParent(child, parent);
            }
        }
        return children;
    }
    ts.setEachParent = setEachParent;
    function setParentRecursive(rootNode, incremental) {
        if (!rootNode)
            return rootNode;
        ts.forEachChildRecursively(rootNode, ts.isJSDocNode(rootNode) ? bindParentToChildIgnoringJSDoc : bindParentToChild);
        return rootNode;
        function bindParentToChildIgnoringJSDoc(child, parent) {
            if (incremental && child.parent === parent) {
                return "skip";
            }
            setParent(child, parent);
        }
        function bindJSDoc(child) {
            if (ts.hasJSDocNodes(child)) {
                for (var _i = 0, _a = child.jsDoc; _i < _a.length; _i++) {
                    var doc = _a[_i];
                    bindParentToChildIgnoringJSDoc(doc, child);
                    ts.forEachChildRecursively(doc, bindParentToChildIgnoringJSDoc);
                }
            }
        }
        function bindParentToChild(child, parent) {
            return bindParentToChildIgnoringJSDoc(child, parent) || bindJSDoc(child);
        }
    }
    ts.setParentRecursive = setParentRecursive;
    function isPackedElement(node) {
        return !ts.isOmittedExpression(node);
    }
    /**
     * Determines whether the provided node is an ArrayLiteralExpression that contains no missing elements.
     */
    function isPackedArrayLiteral(node) {
        return ts.isArrayLiteralExpression(node) && ts.every(node.elements, isPackedElement);
    }
    ts.isPackedArrayLiteral = isPackedArrayLiteral;
    /**
     * Indicates whether the result of an `Expression` will be unused.
     *
     * NOTE: This requires a node with a valid `parent` pointer.
     */
    function expressionResultIsUnused(node) {
        ts.Debug.assertIsDefined(node.parent);
        while (true) {
            var parent = node.parent;
            // walk up parenthesized expressions, but keep a pointer to the top-most parenthesized expression
            if (ts.isParenthesizedExpression(parent)) {
                node = parent;
                continue;
            }
            // result is unused in an expression statement, `void` expression, or the initializer or incrementer of a `for` loop
            if (ts.isExpressionStatement(parent) ||
                ts.isVoidExpression(parent) ||
                ts.isForStatement(parent) && (parent.initializer === node || parent.incrementor === node)) {
                return true;
            }
            if (ts.isCommaListExpression(parent)) {
                // left side of comma is always unused
                if (node !== ts.last(parent.elements))
                    return true;
                // right side of comma is unused if parent is unused
                node = parent;
                continue;
            }
            if (ts.isBinaryExpression(parent) && parent.operatorToken.kind === 27 /* SyntaxKind.CommaToken */) {
                // left side of comma is always unused
                if (node === parent.left)
                    return true;
                // right side of comma is unused if parent is unused
                node = parent;
                continue;
            }
            return false;
        }
    }
    ts.expressionResultIsUnused = expressionResultIsUnused;
    function containsIgnoredPath(path) {
        return ts.some(ts.ignoredPaths, function (p) { return ts.stringContains(path, p); });
    }
    ts.containsIgnoredPath = containsIgnoredPath;
    function getContainingNodeArray(node) {
        if (!node.parent)
            return undefined;
        switch (node.kind) {
            case 163 /* SyntaxKind.TypeParameter */:
                var parent_1 = node.parent;
                return parent_1.kind === 190 /* SyntaxKind.InferType */ ? undefined : parent_1.typeParameters;
            case 164 /* SyntaxKind.Parameter */:
                return node.parent.parameters;
            case 199 /* SyntaxKind.TemplateLiteralTypeSpan */:
                return node.parent.templateSpans;
            case 233 /* SyntaxKind.TemplateSpan */:
                return node.parent.templateSpans;
            case 165 /* SyntaxKind.Decorator */:
                return node.parent.decorators;
            case 291 /* SyntaxKind.HeritageClause */:
                return node.parent.heritageClauses;
        }
        var parent = node.parent;
        if (ts.isJSDocTag(node)) {
            return ts.isJSDocTypeLiteral(node.parent) ? undefined : node.parent.tags;
        }
        switch (parent.kind) {
            case 182 /* SyntaxKind.TypeLiteral */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
                return ts.isTypeElement(node) ? parent.members : undefined;
            case 187 /* SyntaxKind.UnionType */:
            case 188 /* SyntaxKind.IntersectionType */:
                return parent.types;
            case 184 /* SyntaxKind.TupleType */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
            case 351 /* SyntaxKind.CommaListExpression */:
            case 269 /* SyntaxKind.NamedImports */:
            case 273 /* SyntaxKind.NamedExports */:
                return parent.elements;
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
            case 286 /* SyntaxKind.JsxAttributes */:
                return parent.properties;
            case 208 /* SyntaxKind.CallExpression */:
            case 209 /* SyntaxKind.NewExpression */:
                return ts.isTypeNode(node) ? parent.typeArguments :
                    parent.expression === node ? undefined :
                        parent.arguments;
            case 278 /* SyntaxKind.JsxElement */:
            case 282 /* SyntaxKind.JsxFragment */:
                return ts.isJsxChild(node) ? parent.children : undefined;
            case 280 /* SyntaxKind.JsxOpeningElement */:
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
                return ts.isTypeNode(node) ? parent.typeArguments : undefined;
            case 235 /* SyntaxKind.Block */:
            case 289 /* SyntaxKind.CaseClause */:
            case 290 /* SyntaxKind.DefaultClause */:
            case 262 /* SyntaxKind.ModuleBlock */:
                return parent.statements;
            case 263 /* SyntaxKind.CaseBlock */:
                return parent.clauses;
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
                return ts.isClassElement(node) ? parent.members : undefined;
            case 260 /* SyntaxKind.EnumDeclaration */:
                return ts.isEnumMember(node) ? parent.members : undefined;
            case 305 /* SyntaxKind.SourceFile */:
                return parent.statements;
        }
    }
    ts.getContainingNodeArray = getContainingNodeArray;
    function hasContextSensitiveParameters(node) {
        // Functions with type parameters are not context sensitive.
        if (!node.typeParameters) {
            // Functions with any parameters that lack type annotations are context sensitive.
            if (ts.some(node.parameters, function (p) { return !getEffectiveTypeAnnotationNode(p); })) {
                return true;
            }
            if (node.kind !== 214 /* SyntaxKind.ArrowFunction */) {
                // If the first parameter is not an explicit 'this' parameter, then the function has
                // an implicit 'this' parameter which is subject to contextual typing.
                var parameter = ts.firstOrUndefined(node.parameters);
                if (!(parameter && parameterIsThisKeyword(parameter))) {
                    return true;
                }
            }
        }
        return false;
    }
    ts.hasContextSensitiveParameters = hasContextSensitiveParameters;
    /* @internal */
    function isInfinityOrNaNString(name) {
        return name === "Infinity" || name === "-Infinity" || name === "NaN";
    }
    ts.isInfinityOrNaNString = isInfinityOrNaNString;
    function isCatchClauseVariableDeclaration(node) {
        return node.kind === 254 /* SyntaxKind.VariableDeclaration */ && node.parent.kind === 292 /* SyntaxKind.CatchClause */;
    }
    ts.isCatchClauseVariableDeclaration = isCatchClauseVariableDeclaration;
    function isParameterOrCatchClauseVariable(symbol) {
        var declaration = symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration);
        return !!declaration && (ts.isParameter(declaration) || isCatchClauseVariableDeclaration(declaration));
    }
    ts.isParameterOrCatchClauseVariable = isParameterOrCatchClauseVariable;
    function isFunctionExpressionOrArrowFunction(node) {
        return node.kind === 213 /* SyntaxKind.FunctionExpression */ || node.kind === 214 /* SyntaxKind.ArrowFunction */;
    }
    ts.isFunctionExpressionOrArrowFunction = isFunctionExpressionOrArrowFunction;
    function escapeSnippetText(text) {
        return text.replace(/\$/gm, function () { return "\\$"; });
    }
    ts.escapeSnippetText = escapeSnippetText;
    function isNumericLiteralName(name) {
        // The intent of numeric names is that
        //     - they are names with text in a numeric form, and that
        //     - setting properties/indexing with them is always equivalent to doing so with the numeric literal 'numLit',
        //         acquired by applying the abstract 'ToNumber' operation on the name's text.
        //
        // The subtlety is in the latter portion, as we cannot reliably say that anything that looks like a numeric literal is a numeric name.
        // In fact, it is the case that the text of the name must be equal to 'ToString(numLit)' for this to hold.
        //
        // Consider the property name '"0xF00D"'. When one indexes with '0xF00D', they are actually indexing with the value of 'ToString(0xF00D)'
        // according to the ECMAScript specification, so it is actually as if the user indexed with the string '"61453"'.
        // Thus, the text of all numeric literals equivalent to '61543' such as '0xF00D', '0xf00D', '0170015', etc. are not valid numeric names
        // because their 'ToString' representation is not equal to their original text.
        // This is motivated by ECMA-262 sections 9.3.1, 9.8.1, 11.1.5, and 11.2.1.
        //
        // Here, we test whether 'ToString(ToNumber(name))' is exactly equal to 'name'.
        // The '+' prefix operator is equivalent here to applying the abstract ToNumber operation.
        // Applying the 'toString()' method on a number gives us the abstract ToString operation on a number.
        //
        // Note that this accepts the values 'Infinity', '-Infinity', and 'NaN', and that this is intentional.
        // This is desired behavior, because when indexing with them as numeric entities, you are indexing
        // with the strings '"Infinity"', '"-Infinity"', and '"NaN"' respectively.
        return (+name).toString() === name;
    }
    ts.isNumericLiteralName = isNumericLiteralName;
    function createPropertyNameNodeForIdentifierOrLiteral(name, target, singleQuote, stringNamed) {
        return ts.isIdentifierText(name, target) ? ts.factory.createIdentifier(name) :
            !stringNamed && isNumericLiteralName(name) && +name >= 0 ? ts.factory.createNumericLiteral(+name) :
                ts.factory.createStringLiteral(name, !!singleQuote);
    }
    ts.createPropertyNameNodeForIdentifierOrLiteral = createPropertyNameNodeForIdentifierOrLiteral;
    function isThisTypeParameter(type) {
        return !!(type.flags & 262144 /* TypeFlags.TypeParameter */ && type.isThisType);
    }
    ts.isThisTypeParameter = isThisTypeParameter;
    function getNodeModulePathParts(fullPath) {
        // If fullPath can't be valid module file within node_modules, returns undefined.
        // Example of expected pattern: /base/path/node_modules/[@scope/otherpackage/@otherscope/node_modules/]package/[subdirectory/]file.js
        // Returns indices:                       ^            ^                                                      ^             ^
        var topLevelNodeModulesIndex = 0;
        var topLevelPackageNameIndex = 0;
        var packageRootIndex = 0;
        var fileNameIndex = 0;
        var States;
        (function (States) {
            States[States["BeforeNodeModules"] = 0] = "BeforeNodeModules";
            States[States["NodeModules"] = 1] = "NodeModules";
            States[States["Scope"] = 2] = "Scope";
            States[States["PackageContent"] = 3] = "PackageContent";
        })(States || (States = {}));
        var partStart = 0;
        var partEnd = 0;
        var state = 0 /* States.BeforeNodeModules */;
        while (partEnd >= 0) {
            partStart = partEnd;
            partEnd = fullPath.indexOf("/", partStart + 1);
            switch (state) {
                case 0 /* States.BeforeNodeModules */:
                    if (fullPath.indexOf(ts.nodeModulesPathPart, partStart) === partStart) {
                        topLevelNodeModulesIndex = partStart;
                        topLevelPackageNameIndex = partEnd;
                        state = 1 /* States.NodeModules */;
                    }
                    break;
                case 1 /* States.NodeModules */:
                case 2 /* States.Scope */:
                    if (state === 1 /* States.NodeModules */ && fullPath.charAt(partStart + 1) === "@") {
                        state = 2 /* States.Scope */;
                    }
                    else {
                        packageRootIndex = partEnd;
                        state = 3 /* States.PackageContent */;
                    }
                    break;
                case 3 /* States.PackageContent */:
                    if (fullPath.indexOf(ts.nodeModulesPathPart, partStart) === partStart) {
                        state = 1 /* States.NodeModules */;
                    }
                    else {
                        state = 3 /* States.PackageContent */;
                    }
                    break;
            }
        }
        fileNameIndex = partStart;
        return state > 1 /* States.NodeModules */ ? { topLevelNodeModulesIndex: topLevelNodeModulesIndex, topLevelPackageNameIndex: topLevelPackageNameIndex, packageRootIndex: packageRootIndex, fileNameIndex: fileNameIndex } : undefined;
    }
    ts.getNodeModulePathParts = getNodeModulePathParts;
    function getParameterTypeNode(parameter) {
        var _a;
        return parameter.kind === 340 /* SyntaxKind.JSDocParameterTag */ ? (_a = parameter.typeExpression) === null || _a === void 0 ? void 0 : _a.type : parameter.type;
    }
    ts.getParameterTypeNode = getParameterTypeNode;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    /**
     * Creates a `BaseNodeFactory` which can be used to create `Node` instances from the constructors provided by the object allocator.
     */
    function createBaseNodeFactory() {
        // tslint:disable variable-name
        var NodeConstructor;
        var TokenConstructor;
        var IdentifierConstructor;
        var PrivateIdentifierConstructor;
        var SourceFileConstructor;
        // tslint:enable variable-name
        return {
            createBaseSourceFileNode: createBaseSourceFileNode,
            createBaseIdentifierNode: createBaseIdentifierNode,
            createBasePrivateIdentifierNode: createBasePrivateIdentifierNode,
            createBaseTokenNode: createBaseTokenNode,
            createBaseNode: createBaseNode
        };
        function createBaseSourceFileNode(kind) {
            return new (SourceFileConstructor || (SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
        function createBaseIdentifierNode(kind) {
            return new (IdentifierConstructor || (IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
        function createBasePrivateIdentifierNode(kind) {
            return new (PrivateIdentifierConstructor || (PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
        function createBaseTokenNode(kind) {
            return new (TokenConstructor || (TokenConstructor = ts.objectAllocator.getTokenConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
        function createBaseNode(kind) {
            return new (NodeConstructor || (NodeConstructor = ts.objectAllocator.getNodeConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
    }
    ts.createBaseNodeFactory = createBaseNodeFactory;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createParenthesizerRules(factory) {
        var binaryLeftOperandParenthesizerCache;
        var binaryRightOperandParenthesizerCache;
        return {
            getParenthesizeLeftSideOfBinaryForOperator: getParenthesizeLeftSideOfBinaryForOperator,
            getParenthesizeRightSideOfBinaryForOperator: getParenthesizeRightSideOfBinaryForOperator,
            parenthesizeLeftSideOfBinary: parenthesizeLeftSideOfBinary,
            parenthesizeRightSideOfBinary: parenthesizeRightSideOfBinary,
            parenthesizeExpressionOfComputedPropertyName: parenthesizeExpressionOfComputedPropertyName,
            parenthesizeConditionOfConditionalExpression: parenthesizeConditionOfConditionalExpression,
            parenthesizeBranchOfConditionalExpression: parenthesizeBranchOfConditionalExpression,
            parenthesizeExpressionOfExportDefault: parenthesizeExpressionOfExportDefault,
            parenthesizeExpressionOfNew: parenthesizeExpressionOfNew,
            parenthesizeLeftSideOfAccess: parenthesizeLeftSideOfAccess,
            parenthesizeOperandOfPostfixUnary: parenthesizeOperandOfPostfixUnary,
            parenthesizeOperandOfPrefixUnary: parenthesizeOperandOfPrefixUnary,
            parenthesizeExpressionsOfCommaDelimitedList: parenthesizeExpressionsOfCommaDelimitedList,
            parenthesizeExpressionForDisallowedComma: parenthesizeExpressionForDisallowedComma,
            parenthesizeExpressionOfExpressionStatement: parenthesizeExpressionOfExpressionStatement,
            parenthesizeConciseBodyOfArrowFunction: parenthesizeConciseBodyOfArrowFunction,
            parenthesizeCheckTypeOfConditionalType: parenthesizeCheckTypeOfConditionalType,
            parenthesizeExtendsTypeOfConditionalType: parenthesizeExtendsTypeOfConditionalType,
            parenthesizeConstituentTypesOfUnionType: parenthesizeConstituentTypesOfUnionType,
            parenthesizeConstituentTypeOfUnionType: parenthesizeConstituentTypeOfUnionType,
            parenthesizeConstituentTypesOfIntersectionType: parenthesizeConstituentTypesOfIntersectionType,
            parenthesizeConstituentTypeOfIntersectionType: parenthesizeConstituentTypeOfIntersectionType,
            parenthesizeOperandOfTypeOperator: parenthesizeOperandOfTypeOperator,
            parenthesizeOperandOfReadonlyTypeOperator: parenthesizeOperandOfReadonlyTypeOperator,
            parenthesizeNonArrayTypeOfPostfixType: parenthesizeNonArrayTypeOfPostfixType,
            parenthesizeElementTypesOfTupleType: parenthesizeElementTypesOfTupleType,
            parenthesizeElementTypeOfTupleType: parenthesizeElementTypeOfTupleType,
            parenthesizeTypeOfOptionalType: parenthesizeTypeOfOptionalType,
            parenthesizeTypeArguments: parenthesizeTypeArguments,
            parenthesizeLeadingTypeArgument: parenthesizeLeadingTypeArgument,
        };
        function getParenthesizeLeftSideOfBinaryForOperator(operatorKind) {
            binaryLeftOperandParenthesizerCache || (binaryLeftOperandParenthesizerCache = new ts.Map());
            var parenthesizerRule = binaryLeftOperandParenthesizerCache.get(operatorKind);
            if (!parenthesizerRule) {
                parenthesizerRule = function (node) { return parenthesizeLeftSideOfBinary(operatorKind, node); };
                binaryLeftOperandParenthesizerCache.set(operatorKind, parenthesizerRule);
            }
            return parenthesizerRule;
        }
        function getParenthesizeRightSideOfBinaryForOperator(operatorKind) {
            binaryRightOperandParenthesizerCache || (binaryRightOperandParenthesizerCache = new ts.Map());
            var parenthesizerRule = binaryRightOperandParenthesizerCache.get(operatorKind);
            if (!parenthesizerRule) {
                parenthesizerRule = function (node) { return parenthesizeRightSideOfBinary(operatorKind, /*leftSide*/ undefined, node); };
                binaryRightOperandParenthesizerCache.set(operatorKind, parenthesizerRule);
            }
            return parenthesizerRule;
        }
        /**
         * Determines whether the operand to a BinaryExpression needs to be parenthesized.
         *
         * @param binaryOperator The operator for the BinaryExpression.
         * @param operand The operand for the BinaryExpression.
         * @param isLeftSideOfBinary A value indicating whether the operand is the left side of the
         *                           BinaryExpression.
         */
        function binaryOperandNeedsParentheses(binaryOperator, operand, isLeftSideOfBinary, leftOperand) {
            // If the operand has lower precedence, then it needs to be parenthesized to preserve the
            // intent of the expression. For example, if the operand is `a + b` and the operator is
            // `*`, then we need to parenthesize the operand to preserve the intended order of
            // operations: `(a + b) * x`.
            //
            // If the operand has higher precedence, then it does not need to be parenthesized. For
            // example, if the operand is `a * b` and the operator is `+`, then we do not need to
            // parenthesize to preserve the intended order of operations: `a * b + x`.
            //
            // If the operand has the same precedence, then we need to check the associativity of
            // the operator based on whether this is the left or right operand of the expression.
            //
            // For example, if `a / d` is on the right of operator `*`, we need to parenthesize
            // to preserve the intended order of operations: `x * (a / d)`
            //
            // If `a ** d` is on the left of operator `**`, we need to parenthesize to preserve
            // the intended order of operations: `(a ** b) ** c`
            var binaryOperatorPrecedence = ts.getOperatorPrecedence(221 /* SyntaxKind.BinaryExpression */, binaryOperator);
            var binaryOperatorAssociativity = ts.getOperatorAssociativity(221 /* SyntaxKind.BinaryExpression */, binaryOperator);
            var emittedOperand = ts.skipPartiallyEmittedExpressions(operand);
            if (!isLeftSideOfBinary && operand.kind === 214 /* SyntaxKind.ArrowFunction */ && binaryOperatorPrecedence > 3 /* OperatorPrecedence.Assignment */) {
                // We need to parenthesize arrow functions on the right side to avoid it being
                // parsed as parenthesized expression: `a && (() => {})`
                return true;
            }
            var operandPrecedence = ts.getExpressionPrecedence(emittedOperand);
            switch (ts.compareValues(operandPrecedence, binaryOperatorPrecedence)) {
                case -1 /* Comparison.LessThan */:
                    // If the operand is the right side of a right-associative binary operation
                    // and is a yield expression, then we do not need parentheses.
                    if (!isLeftSideOfBinary
                        && binaryOperatorAssociativity === 1 /* Associativity.Right */
                        && operand.kind === 224 /* SyntaxKind.YieldExpression */) {
                        return false;
                    }
                    return true;
                case 1 /* Comparison.GreaterThan */:
                    return false;
                case 0 /* Comparison.EqualTo */:
                    if (isLeftSideOfBinary) {
                        // No need to parenthesize the left operand when the binary operator is
                        // left associative:
                        //  (a*b)/x    -> a*b/x
                        //  (a**b)/x   -> a**b/x
                        //
                        // Parentheses are needed for the left operand when the binary operator is
                        // right associative:
                        //  (a/b)**x   -> (a/b)**x
                        //  (a**b)**x  -> (a**b)**x
                        return binaryOperatorAssociativity === 1 /* Associativity.Right */;
                    }
                    else {
                        if (ts.isBinaryExpression(emittedOperand)
                            && emittedOperand.operatorToken.kind === binaryOperator) {
                            // No need to parenthesize the right operand when the binary operator and
                            // operand are the same and one of the following:
                            //  x*(a*b)     => x*a*b
                            //  x|(a|b)     => x|a|b
                            //  x&(a&b)     => x&a&b
                            //  x^(a^b)     => x^a^b
                            if (operatorHasAssociativeProperty(binaryOperator)) {
                                return false;
                            }
                            // No need to parenthesize the right operand when the binary operator
                            // is plus (+) if both the left and right operands consist solely of either
                            // literals of the same kind or binary plus (+) expressions for literals of
                            // the same kind (recursively).
                            //  "a"+(1+2)       => "a"+(1+2)
                            //  "a"+("b"+"c")   => "a"+"b"+"c"
                            if (binaryOperator === 39 /* SyntaxKind.PlusToken */) {
                                var leftKind = leftOperand ? getLiteralKindOfBinaryPlusOperand(leftOperand) : 0 /* SyntaxKind.Unknown */;
                                if (ts.isLiteralKind(leftKind) && leftKind === getLiteralKindOfBinaryPlusOperand(emittedOperand)) {
                                    return false;
                                }
                            }
                        }
                        // No need to parenthesize the right operand when the operand is right
                        // associative:
                        //  x/(a**b)    -> x/a**b
                        //  x**(a**b)   -> x**a**b
                        //
                        // Parentheses are needed for the right operand when the operand is left
                        // associative:
                        //  x/(a*b)     -> x/(a*b)
                        //  x**(a/b)    -> x**(a/b)
                        var operandAssociativity = ts.getExpressionAssociativity(emittedOperand);
                        return operandAssociativity === 0 /* Associativity.Left */;
                    }
            }
        }
        /**
         * Determines whether a binary operator is mathematically associative.
         *
         * @param binaryOperator The binary operator.
         */
        function operatorHasAssociativeProperty(binaryOperator) {
            // The following operators are associative in JavaScript:
            //  (a*b)*c     -> a*(b*c)  -> a*b*c
            //  (a|b)|c     -> a|(b|c)  -> a|b|c
            //  (a&b)&c     -> a&(b&c)  -> a&b&c
            //  (a^b)^c     -> a^(b^c)  -> a^b^c
            //
            // While addition is associative in mathematics, JavaScript's `+` is not
            // guaranteed to be associative as it is overloaded with string concatenation.
            return binaryOperator === 41 /* SyntaxKind.AsteriskToken */
                || binaryOperator === 51 /* SyntaxKind.BarToken */
                || binaryOperator === 50 /* SyntaxKind.AmpersandToken */
                || binaryOperator === 52 /* SyntaxKind.CaretToken */;
        }
        /**
         * This function determines whether an expression consists of a homogeneous set of
         * literal expressions or binary plus expressions that all share the same literal kind.
         * It is used to determine whether the right-hand operand of a binary plus expression can be
         * emitted without parentheses.
         */
        function getLiteralKindOfBinaryPlusOperand(node) {
            node = ts.skipPartiallyEmittedExpressions(node);
            if (ts.isLiteralKind(node.kind)) {
                return node.kind;
            }
            if (node.kind === 221 /* SyntaxKind.BinaryExpression */ && node.operatorToken.kind === 39 /* SyntaxKind.PlusToken */) {
                if (node.cachedLiteralKind !== undefined) {
                    return node.cachedLiteralKind;
                }
                var leftKind = getLiteralKindOfBinaryPlusOperand(node.left);
                var literalKind = ts.isLiteralKind(leftKind)
                    && leftKind === getLiteralKindOfBinaryPlusOperand(node.right)
                    ? leftKind
                    : 0 /* SyntaxKind.Unknown */;
                node.cachedLiteralKind = literalKind;
                return literalKind;
            }
            return 0 /* SyntaxKind.Unknown */;
        }
        /**
         * Wraps the operand to a BinaryExpression in parentheses if they are needed to preserve the intended
         * order of operations.
         *
         * @param binaryOperator The operator for the BinaryExpression.
         * @param operand The operand for the BinaryExpression.
         * @param isLeftSideOfBinary A value indicating whether the operand is the left side of the
         *                           BinaryExpression.
         */
        function parenthesizeBinaryOperand(binaryOperator, operand, isLeftSideOfBinary, leftOperand) {
            var skipped = ts.skipPartiallyEmittedExpressions(operand);
            // If the resulting expression is already parenthesized, we do not need to do any further processing.
            if (skipped.kind === 212 /* SyntaxKind.ParenthesizedExpression */) {
                return operand;
            }
            return binaryOperandNeedsParentheses(binaryOperator, operand, isLeftSideOfBinary, leftOperand)
                ? factory.createParenthesizedExpression(operand)
                : operand;
        }
        function parenthesizeLeftSideOfBinary(binaryOperator, leftSide) {
            return parenthesizeBinaryOperand(binaryOperator, leftSide, /*isLeftSideOfBinary*/ true);
        }
        function parenthesizeRightSideOfBinary(binaryOperator, leftSide, rightSide) {
            return parenthesizeBinaryOperand(binaryOperator, rightSide, /*isLeftSideOfBinary*/ false, leftSide);
        }
        function parenthesizeExpressionOfComputedPropertyName(expression) {
            return ts.isCommaSequence(expression) ? factory.createParenthesizedExpression(expression) : expression;
        }
        function parenthesizeConditionOfConditionalExpression(condition) {
            var conditionalPrecedence = ts.getOperatorPrecedence(222 /* SyntaxKind.ConditionalExpression */, 57 /* SyntaxKind.QuestionToken */);
            var emittedCondition = ts.skipPartiallyEmittedExpressions(condition);
            var conditionPrecedence = ts.getExpressionPrecedence(emittedCondition);
            if (ts.compareValues(conditionPrecedence, conditionalPrecedence) !== 1 /* Comparison.GreaterThan */) {
                return factory.createParenthesizedExpression(condition);
            }
            return condition;
        }
        function parenthesizeBranchOfConditionalExpression(branch) {
            // per ES grammar both 'whenTrue' and 'whenFalse' parts of conditional expression are assignment expressions
            // so in case when comma expression is introduced as a part of previous transformations
            // if should be wrapped in parens since comma operator has the lowest precedence
            var emittedExpression = ts.skipPartiallyEmittedExpressions(branch);
            return ts.isCommaSequence(emittedExpression)
                ? factory.createParenthesizedExpression(branch)
                : branch;
        }
        /**
         *  [Per the spec](https://tc39.github.io/ecma262/#prod-ExportDeclaration), `export default` accepts _AssigmentExpression_ but
         *  has a lookahead restriction for `function`, `async function`, and `class`.
         *
         * Basically, that means we need to parenthesize in the following cases:
         *
         * - BinaryExpression of CommaToken
         * - CommaList (synthetic list of multiple comma expressions)
         * - FunctionExpression
         * - ClassExpression
         */
        function parenthesizeExpressionOfExportDefault(expression) {
            var check = ts.skipPartiallyEmittedExpressions(expression);
            var needsParens = ts.isCommaSequence(check);
            if (!needsParens) {
                switch (ts.getLeftmostExpression(check, /*stopAtCallExpression*/ false).kind) {
                    case 226 /* SyntaxKind.ClassExpression */:
                    case 213 /* SyntaxKind.FunctionExpression */:
                        needsParens = true;
                }
            }
            return needsParens ? factory.createParenthesizedExpression(expression) : expression;
        }
        /**
         * Wraps an expression in parentheses if it is needed in order to use the expression
         * as the expression of a `NewExpression` node.
         */
        function parenthesizeExpressionOfNew(expression) {
            var leftmostExpr = ts.getLeftmostExpression(expression, /*stopAtCallExpressions*/ true);
            switch (leftmostExpr.kind) {
                case 208 /* SyntaxKind.CallExpression */:
                    return factory.createParenthesizedExpression(expression);
                case 209 /* SyntaxKind.NewExpression */:
                    return !leftmostExpr.arguments
                        ? factory.createParenthesizedExpression(expression)
                        : expression; // TODO(rbuckton): Verify this assertion holds
            }
            return parenthesizeLeftSideOfAccess(expression);
        }
        /**
         * Wraps an expression in parentheses if it is needed in order to use the expression for
         * property or element access.
         */
        function parenthesizeLeftSideOfAccess(expression) {
            // isLeftHandSideExpression is almost the correct criterion for when it is not necessary
            // to parenthesize the expression before a dot. The known exception is:
            //
            //    NewExpression:
            //       new C.x        -> not the same as (new C).x
            //
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isLeftHandSideExpression(emittedExpression)
                && (emittedExpression.kind !== 209 /* SyntaxKind.NewExpression */ || emittedExpression.arguments)) {
                // TODO(rbuckton): Verify whether this assertion holds.
                return expression;
            }
            // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
            return ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
        }
        function parenthesizeOperandOfPostfixUnary(operand) {
            // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
            return ts.isLeftHandSideExpression(operand) ? operand : ts.setTextRange(factory.createParenthesizedExpression(operand), operand);
        }
        function parenthesizeOperandOfPrefixUnary(operand) {
            // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
            return ts.isUnaryExpression(operand) ? operand : ts.setTextRange(factory.createParenthesizedExpression(operand), operand);
        }
        function parenthesizeExpressionsOfCommaDelimitedList(elements) {
            var result = ts.sameMap(elements, parenthesizeExpressionForDisallowedComma);
            return ts.setTextRange(factory.createNodeArray(result, elements.hasTrailingComma), elements);
        }
        function parenthesizeExpressionForDisallowedComma(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            var expressionPrecedence = ts.getExpressionPrecedence(emittedExpression);
            var commaPrecedence = ts.getOperatorPrecedence(221 /* SyntaxKind.BinaryExpression */, 27 /* SyntaxKind.CommaToken */);
            // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
            return expressionPrecedence > commaPrecedence ? expression : ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
        }
        function parenthesizeExpressionOfExpressionStatement(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isCallExpression(emittedExpression)) {
                var callee = emittedExpression.expression;
                var kind = ts.skipPartiallyEmittedExpressions(callee).kind;
                if (kind === 213 /* SyntaxKind.FunctionExpression */ || kind === 214 /* SyntaxKind.ArrowFunction */) {
                    // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
                    var updated = factory.updateCallExpression(emittedExpression, ts.setTextRange(factory.createParenthesizedExpression(callee), callee), emittedExpression.typeArguments, emittedExpression.arguments);
                    return factory.restoreOuterExpressions(expression, updated, 8 /* OuterExpressionKinds.PartiallyEmittedExpressions */);
                }
            }
            var leftmostExpressionKind = ts.getLeftmostExpression(emittedExpression, /*stopAtCallExpressions*/ false).kind;
            if (leftmostExpressionKind === 205 /* SyntaxKind.ObjectLiteralExpression */ || leftmostExpressionKind === 213 /* SyntaxKind.FunctionExpression */) {
                // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
                return ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
            }
            return expression;
        }
        function parenthesizeConciseBodyOfArrowFunction(body) {
            if (!ts.isBlock(body) && (ts.isCommaSequence(body) || ts.getLeftmostExpression(body, /*stopAtCallExpressions*/ false).kind === 205 /* SyntaxKind.ObjectLiteralExpression */)) {
                // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
                return ts.setTextRange(factory.createParenthesizedExpression(body), body);
            }
            return body;
        }
        // Type[Extends] :
        //     FunctionOrConstructorType
        //     ConditionalType[?Extends]
        // ConditionalType[Extends] :
        //     UnionType[?Extends]
        //     [~Extends] UnionType[~Extends] `extends` Type[+Extends] `?` Type[~Extends] `:` Type[~Extends]
        //
        // - The check type (the `UnionType`, above) does not allow function, constructor, or conditional types (they must be parenthesized)
        // - The extends type (the first `Type`, above) does not allow conditional types (they must be parenthesized). Function and constructor types are fine.
        // - The true and false branch types (the second and third `Type` non-terminals, above) allow any type
        function parenthesizeCheckTypeOfConditionalType(checkType) {
            switch (checkType.kind) {
                case 179 /* SyntaxKind.FunctionType */:
                case 180 /* SyntaxKind.ConstructorType */:
                case 189 /* SyntaxKind.ConditionalType */:
                    return factory.createParenthesizedType(checkType);
            }
            return checkType;
        }
        function parenthesizeExtendsTypeOfConditionalType(extendsType) {
            switch (extendsType.kind) {
                case 189 /* SyntaxKind.ConditionalType */:
                    return factory.createParenthesizedType(extendsType);
            }
            return extendsType;
        }
        // UnionType[Extends] :
        //     `|`? IntersectionType[?Extends]
        //     UnionType[?Extends] `|` IntersectionType[?Extends]
        //
        // - A union type constituent has the same precedence as the check type of a conditional type
        function parenthesizeConstituentTypeOfUnionType(type) {
            switch (type.kind) {
                case 187 /* SyntaxKind.UnionType */: // Not strictly necessary, but a union containing a union should have been flattened
                case 188 /* SyntaxKind.IntersectionType */: // Not strictly necessary, but makes generated output more readable and avoids breaks in DT tests
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeCheckTypeOfConditionalType(type);
        }
        function parenthesizeConstituentTypesOfUnionType(members) {
            return factory.createNodeArray(ts.sameMap(members, parenthesizeConstituentTypeOfUnionType));
        }
        // IntersectionType[Extends] :
        //     `&`? TypeOperator[?Extends]
        //     IntersectionType[?Extends] `&` TypeOperator[?Extends]
        //
        // - An intersection type constituent does not allow function, constructor, conditional, or union types (they must be parenthesized)
        function parenthesizeConstituentTypeOfIntersectionType(type) {
            switch (type.kind) {
                case 187 /* SyntaxKind.UnionType */:
                case 188 /* SyntaxKind.IntersectionType */: // Not strictly necessary, but an intersection containing an intersection should have been flattened
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeConstituentTypeOfUnionType(type);
        }
        function parenthesizeConstituentTypesOfIntersectionType(members) {
            return factory.createNodeArray(ts.sameMap(members, parenthesizeConstituentTypeOfIntersectionType));
        }
        // TypeOperator[Extends] :
        //     PostfixType
        //     InferType[?Extends]
        //     `keyof` TypeOperator[?Extends]
        //     `unique` TypeOperator[?Extends]
        //     `readonly` TypeOperator[?Extends]
        //
        function parenthesizeOperandOfTypeOperator(type) {
            switch (type.kind) {
                case 188 /* SyntaxKind.IntersectionType */:
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeConstituentTypeOfIntersectionType(type);
        }
        function parenthesizeOperandOfReadonlyTypeOperator(type) {
            switch (type.kind) {
                case 193 /* SyntaxKind.TypeOperator */:
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeOperandOfTypeOperator(type);
        }
        // PostfixType :
        //     NonArrayType
        //     NonArrayType [no LineTerminator here] `!` // JSDoc
        //     NonArrayType [no LineTerminator here] `?` // JSDoc
        //     IndexedAccessType
        //     ArrayType
        //
        // IndexedAccessType :
        //     NonArrayType `[` Type[~Extends] `]`
        //
        // ArrayType :
        //     NonArrayType `[` `]`
        //
        function parenthesizeNonArrayTypeOfPostfixType(type) {
            switch (type.kind) {
                case 190 /* SyntaxKind.InferType */:
                case 193 /* SyntaxKind.TypeOperator */:
                case 181 /* SyntaxKind.TypeQuery */: // Not strictly necessary, but makes generated output more readable and avoids breaks in DT tests
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeOperandOfTypeOperator(type);
        }
        // TupleType :
        //     `[` Elision? `]`
        //     `[` NamedTupleElementTypes `]`
        //     `[` NamedTupleElementTypes `,` Elision? `]`
        //     `[` TupleElementTypes `]`
        //     `[` TupleElementTypes `,` Elision? `]`
        //
        // NamedTupleElementTypes :
        //     Elision? NamedTupleMember
        //     NamedTupleElementTypes `,` Elision? NamedTupleMember
        //
        // NamedTupleMember :
        //     Identifier `?`? `:` Type[~Extends]
        //     `...` Identifier `:` Type[~Extends]
        //
        // TupleElementTypes :
        //     Elision? TupleElementType
        //     TupleElementTypes `,` Elision? TupleElementType
        //
        // TupleElementType :
        //     Type[~Extends] // NOTE: Needs cover grammar to disallow JSDoc postfix-optional
        //     OptionalType
        //     RestType
        //
        // OptionalType :
        //     Type[~Extends] `?` // NOTE: Needs cover grammar to disallow JSDoc postfix-optional
        //
        // RestType :
        //     `...` Type[~Extends]
        //
        function parenthesizeElementTypesOfTupleType(types) {
            return factory.createNodeArray(ts.sameMap(types, parenthesizeElementTypeOfTupleType));
        }
        function parenthesizeElementTypeOfTupleType(type) {
            if (hasJSDocPostfixQuestion(type))
                return factory.createParenthesizedType(type);
            return type;
        }
        function hasJSDocPostfixQuestion(type) {
            if (ts.isJSDocNullableType(type))
                return type.postfix;
            if (ts.isNamedTupleMember(type))
                return hasJSDocPostfixQuestion(type.type);
            if (ts.isFunctionTypeNode(type) || ts.isConstructorTypeNode(type) || ts.isTypeOperatorNode(type))
                return hasJSDocPostfixQuestion(type.type);
            if (ts.isConditionalTypeNode(type))
                return hasJSDocPostfixQuestion(type.falseType);
            if (ts.isUnionTypeNode(type))
                return hasJSDocPostfixQuestion(ts.last(type.types));
            if (ts.isIntersectionTypeNode(type))
                return hasJSDocPostfixQuestion(ts.last(type.types));
            if (ts.isInferTypeNode(type))
                return !!type.typeParameter.constraint && hasJSDocPostfixQuestion(type.typeParameter.constraint);
            return false;
        }
        function parenthesizeTypeOfOptionalType(type) {
            if (hasJSDocPostfixQuestion(type))
                return factory.createParenthesizedType(type);
            return parenthesizeNonArrayTypeOfPostfixType(type);
        }
        // function parenthesizeMemberOfElementType(member: TypeNode): TypeNode {
        //     switch (member.kind) {
        //         case SyntaxKind.UnionType:
        //         case SyntaxKind.IntersectionType:
        //         case SyntaxKind.FunctionType:
        //         case SyntaxKind.ConstructorType:
        //             return factory.createParenthesizedType(member);
        //     }
        //     return parenthesizeMemberOfConditionalType(member);
        // }
        // function parenthesizeElementTypeOfArrayType(member: TypeNode): TypeNode {
        //     switch (member.kind) {
        //         case SyntaxKind.TypeQuery:
        //         case SyntaxKind.TypeOperator:
        //         case SyntaxKind.InferType:
        //             return factory.createParenthesizedType(member);
        //     }
        //     return parenthesizeMemberOfElementType(member);
        // }
        function parenthesizeLeadingTypeArgument(node) {
            return ts.isFunctionOrConstructorTypeNode(node) && node.typeParameters ? factory.createParenthesizedType(node) : node;
        }
        function parenthesizeOrdinalTypeArgument(node, i) {
            return i === 0 ? parenthesizeLeadingTypeArgument(node) : node;
        }
        function parenthesizeTypeArguments(typeArguments) {
            if (ts.some(typeArguments)) {
                return factory.createNodeArray(ts.sameMap(typeArguments, parenthesizeOrdinalTypeArgument));
            }
        }
    }
    ts.createParenthesizerRules = createParenthesizerRules;
    ts.nullParenthesizerRules = {
        getParenthesizeLeftSideOfBinaryForOperator: function (_) { return ts.identity; },
        getParenthesizeRightSideOfBinaryForOperator: function (_) { return ts.identity; },
        parenthesizeLeftSideOfBinary: function (_binaryOperator, leftSide) { return leftSide; },
        parenthesizeRightSideOfBinary: function (_binaryOperator, _leftSide, rightSide) { return rightSide; },
        parenthesizeExpressionOfComputedPropertyName: ts.identity,
        parenthesizeConditionOfConditionalExpression: ts.identity,
        parenthesizeBranchOfConditionalExpression: ts.identity,
        parenthesizeExpressionOfExportDefault: ts.identity,
        parenthesizeExpressionOfNew: function (expression) { return ts.cast(expression, ts.isLeftHandSideExpression); },
        parenthesizeLeftSideOfAccess: function (expression) { return ts.cast(expression, ts.isLeftHandSideExpression); },
        parenthesizeOperandOfPostfixUnary: function (operand) { return ts.cast(operand, ts.isLeftHandSideExpression); },
        parenthesizeOperandOfPrefixUnary: function (operand) { return ts.cast(operand, ts.isUnaryExpression); },
        parenthesizeExpressionsOfCommaDelimitedList: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeExpressionForDisallowedComma: ts.identity,
        parenthesizeExpressionOfExpressionStatement: ts.identity,
        parenthesizeConciseBodyOfArrowFunction: ts.identity,
        parenthesizeCheckTypeOfConditionalType: ts.identity,
        parenthesizeExtendsTypeOfConditionalType: ts.identity,
        parenthesizeConstituentTypesOfUnionType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeConstituentTypeOfUnionType: ts.identity,
        parenthesizeConstituentTypesOfIntersectionType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeConstituentTypeOfIntersectionType: ts.identity,
        parenthesizeOperandOfTypeOperator: ts.identity,
        parenthesizeOperandOfReadonlyTypeOperator: ts.identity,
        parenthesizeNonArrayTypeOfPostfixType: ts.identity,
        parenthesizeElementTypesOfTupleType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeElementTypeOfTupleType: ts.identity,
        parenthesizeTypeOfOptionalType: ts.identity,
        parenthesizeTypeArguments: function (nodes) { return nodes && ts.cast(nodes, ts.isNodeArray); },
        parenthesizeLeadingTypeArgument: ts.identity,
    };
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createNodeConverters(factory) {
        return {
            convertToFunctionBlock: convertToFunctionBlock,
            convertToFunctionExpression: convertToFunctionExpression,
            convertToArrayAssignmentElement: convertToArrayAssignmentElement,
            convertToObjectAssignmentElement: convertToObjectAssignmentElement,
            convertToAssignmentPattern: convertToAssignmentPattern,
            convertToObjectAssignmentPattern: convertToObjectAssignmentPattern,
            convertToArrayAssignmentPattern: convertToArrayAssignmentPattern,
            convertToAssignmentElementTarget: convertToAssignmentElementTarget,
        };
        function convertToFunctionBlock(node, multiLine) {
            if (ts.isBlock(node))
                return node;
            var returnStatement = factory.createReturnStatement(node);
            ts.setTextRange(returnStatement, node);
            var body = factory.createBlock([returnStatement], multiLine);
            ts.setTextRange(body, node);
            return body;
        }
        function convertToFunctionExpression(node) {
            if (!node.body)
                return ts.Debug.fail("Cannot convert a FunctionDeclaration without a body");
            var updated = factory.createFunctionExpression(node.modifiers, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body);
            ts.setOriginalNode(updated, node);
            ts.setTextRange(updated, node);
            if (ts.getStartsOnNewLine(node)) {
                ts.setStartsOnNewLine(updated, /*newLine*/ true);
            }
            return updated;
        }
        function convertToArrayAssignmentElement(element) {
            if (ts.isBindingElement(element)) {
                if (element.dotDotDotToken) {
                    ts.Debug.assertNode(element.name, ts.isIdentifier);
                    return ts.setOriginalNode(ts.setTextRange(factory.createSpreadElement(element.name), element), element);
                }
                var expression = convertToAssignmentElementTarget(element.name);
                return element.initializer
                    ? ts.setOriginalNode(ts.setTextRange(factory.createAssignment(expression, element.initializer), element), element)
                    : expression;
            }
            return ts.cast(element, ts.isExpression);
        }
        function convertToObjectAssignmentElement(element) {
            if (ts.isBindingElement(element)) {
                if (element.dotDotDotToken) {
                    ts.Debug.assertNode(element.name, ts.isIdentifier);
                    return ts.setOriginalNode(ts.setTextRange(factory.createSpreadAssignment(element.name), element), element);
                }
                if (element.propertyName) {
                    var expression = convertToAssignmentElementTarget(element.name);
                    return ts.setOriginalNode(ts.setTextRange(factory.createPropertyAssignment(element.propertyName, element.initializer ? factory.createAssignment(expression, element.initializer) : expression), element), element);
                }
                ts.Debug.assertNode(element.name, ts.isIdentifier);
                return ts.setOriginalNode(ts.setTextRange(factory.createShorthandPropertyAssignment(element.name, element.initializer), element), element);
            }
            return ts.cast(element, ts.isObjectLiteralElementLike);
        }
        function convertToAssignmentPattern(node) {
            switch (node.kind) {
                case 202 /* SyntaxKind.ArrayBindingPattern */:
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    return convertToArrayAssignmentPattern(node);
                case 201 /* SyntaxKind.ObjectBindingPattern */:
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    return convertToObjectAssignmentPattern(node);
            }
        }
        function convertToObjectAssignmentPattern(node) {
            if (ts.isObjectBindingPattern(node)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createObjectLiteralExpression(ts.map(node.elements, convertToObjectAssignmentElement)), node), node);
            }
            return ts.cast(node, ts.isObjectLiteralExpression);
        }
        function convertToArrayAssignmentPattern(node) {
            if (ts.isArrayBindingPattern(node)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createArrayLiteralExpression(ts.map(node.elements, convertToArrayAssignmentElement)), node), node);
            }
            return ts.cast(node, ts.isArrayLiteralExpression);
        }
        function convertToAssignmentElementTarget(node) {
            if (ts.isBindingPattern(node)) {
                return convertToAssignmentPattern(node);
            }
            return ts.cast(node, ts.isExpression);
        }
    }
    ts.createNodeConverters = createNodeConverters;
    ts.nullNodeConverters = {
        convertToFunctionBlock: ts.notImplemented,
        convertToFunctionExpression: ts.notImplemented,
        convertToArrayAssignmentElement: ts.notImplemented,
        convertToObjectAssignmentElement: ts.notImplemented,
        convertToAssignmentPattern: ts.notImplemented,
        convertToObjectAssignmentPattern: ts.notImplemented,
        convertToArrayAssignmentPattern: ts.notImplemented,
        convertToAssignmentElementTarget: ts.notImplemented,
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var nextAutoGenerateId = 0;
    /* @internal */
    var NodeFactoryFlags;
    (function (NodeFactoryFlags) {
        NodeFactoryFlags[NodeFactoryFlags["None"] = 0] = "None";
        // Disables the parenthesizer rules for the factory.
        NodeFactoryFlags[NodeFactoryFlags["NoParenthesizerRules"] = 1] = "NoParenthesizerRules";
        // Disables the node converters for the factory.
        NodeFactoryFlags[NodeFactoryFlags["NoNodeConverters"] = 2] = "NoNodeConverters";
        // Ensures new `PropertyAccessExpression` nodes are created with the `NoIndentation` emit flag set.
        NodeFactoryFlags[NodeFactoryFlags["NoIndentationOnFreshPropertyAccess"] = 4] = "NoIndentationOnFreshPropertyAccess";
        // Do not set an `original` pointer when updating a node.
        NodeFactoryFlags[NodeFactoryFlags["NoOriginalNode"] = 8] = "NoOriginalNode";
    })(NodeFactoryFlags = ts.NodeFactoryFlags || (ts.NodeFactoryFlags = {}));
    /**
     * Creates a `NodeFactory` that can be used to create and update a syntax tree.
     * @param flags Flags that control factory behavior.
     * @param baseFactory A `BaseNodeFactory` used to create the base `Node` objects.
     */
    /* @internal */
    function createNodeFactory(flags, baseFactory) {
        var update = flags & 8 /* NodeFactoryFlags.NoOriginalNode */ ? updateWithoutOriginal : updateWithOriginal;
        // Lazily load the parenthesizer, node converters, and some factory methods until they are used.
        var parenthesizerRules = ts.memoize(function () { return flags & 1 /* NodeFactoryFlags.NoParenthesizerRules */ ? ts.nullParenthesizerRules : ts.createParenthesizerRules(factory); });
        var converters = ts.memoize(function () { return flags & 2 /* NodeFactoryFlags.NoNodeConverters */ ? ts.nullNodeConverters : ts.createNodeConverters(factory); });
        // lazy initializaton of common operator factories
        var getBinaryCreateFunction = ts.memoizeOne(function (operator) { return function (left, right) { return createBinaryExpression(left, operator, right); }; });
        var getPrefixUnaryCreateFunction = ts.memoizeOne(function (operator) { return function (operand) { return createPrefixUnaryExpression(operator, operand); }; });
        var getPostfixUnaryCreateFunction = ts.memoizeOne(function (operator) { return function (operand) { return createPostfixUnaryExpression(operand, operator); }; });
        var getJSDocPrimaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function () { return createJSDocPrimaryTypeWorker(kind); }; });
        var getJSDocUnaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function (type) { return createJSDocUnaryTypeWorker(kind, type); }; });
        var getJSDocUnaryTypeUpdateFunction = ts.memoizeOne(function (kind) { return function (node, type) { return updateJSDocUnaryTypeWorker(kind, node, type); }; });
        var getJSDocPrePostfixUnaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function (type, postfix) { return createJSDocPrePostfixUnaryTypeWorker(kind, type, postfix); }; });
        var getJSDocPrePostfixUnaryTypeUpdateFunction = ts.memoizeOne(function (kind) { return function (node, type) { return updateJSDocPrePostfixUnaryTypeWorker(kind, node, type); }; });
        var getJSDocSimpleTagCreateFunction = ts.memoizeOne(function (kind) { return function (tagName, comment) { return createJSDocSimpleTagWorker(kind, tagName, comment); }; });
        var getJSDocSimpleTagUpdateFunction = ts.memoizeOne(function (kind) { return function (node, tagName, comment) { return updateJSDocSimpleTagWorker(kind, node, tagName, comment); }; });
        var getJSDocTypeLikeTagCreateFunction = ts.memoizeOne(function (kind) { return function (tagName, typeExpression, comment) { return createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment); }; });
        var getJSDocTypeLikeTagUpdateFunction = ts.memoizeOne(function (kind) { return function (node, tagName, typeExpression, comment) { return updateJSDocTypeLikeTagWorker(kind, node, tagName, typeExpression, comment); }; });
        var factory = {
            get parenthesizer() { return parenthesizerRules(); },
            get converters() { return converters(); },
            baseFactory: baseFactory,
            flags: flags,
            createNodeArray: createNodeArray,
            createNumericLiteral: createNumericLiteral,
            createBigIntLiteral: createBigIntLiteral,
            createStringLiteral: createStringLiteral,
            createStringLiteralFromNode: createStringLiteralFromNode,
            createRegularExpressionLiteral: createRegularExpressionLiteral,
            createLiteralLikeNode: createLiteralLikeNode,
            createIdentifier: createIdentifier,
            updateIdentifier: updateIdentifier,
            createTempVariable: createTempVariable,
            createLoopVariable: createLoopVariable,
            createUniqueName: createUniqueName,
            getGeneratedNameForNode: getGeneratedNameForNode,
            createPrivateIdentifier: createPrivateIdentifier,
            createToken: createToken,
            createSuper: createSuper,
            createThis: createThis,
            createNull: createNull,
            createTrue: createTrue,
            createFalse: createFalse,
            createModifier: createModifier,
            createModifiersFromModifierFlags: createModifiersFromModifierFlags,
            createQualifiedName: createQualifiedName,
            updateQualifiedName: updateQualifiedName,
            createComputedPropertyName: createComputedPropertyName,
            updateComputedPropertyName: updateComputedPropertyName,
            createTypeParameterDeclaration: createTypeParameterDeclaration,
            updateTypeParameterDeclaration: updateTypeParameterDeclaration,
            createParameterDeclaration: createParameterDeclaration,
            updateParameterDeclaration: updateParameterDeclaration,
            createDecorator: createDecorator,
            updateDecorator: updateDecorator,
            createPropertySignature: createPropertySignature,
            updatePropertySignature: updatePropertySignature,
            createPropertyDeclaration: createPropertyDeclaration,
            updatePropertyDeclaration: updatePropertyDeclaration,
            createMethodSignature: createMethodSignature,
            updateMethodSignature: updateMethodSignature,
            createMethodDeclaration: createMethodDeclaration,
            updateMethodDeclaration: updateMethodDeclaration,
            createConstructorDeclaration: createConstructorDeclaration,
            updateConstructorDeclaration: updateConstructorDeclaration,
            createGetAccessorDeclaration: createGetAccessorDeclaration,
            updateGetAccessorDeclaration: updateGetAccessorDeclaration,
            createSetAccessorDeclaration: createSetAccessorDeclaration,
            updateSetAccessorDeclaration: updateSetAccessorDeclaration,
            createCallSignature: createCallSignature,
            updateCallSignature: updateCallSignature,
            createConstructSignature: createConstructSignature,
            updateConstructSignature: updateConstructSignature,
            createIndexSignature: createIndexSignature,
            updateIndexSignature: updateIndexSignature,
            createClassStaticBlockDeclaration: createClassStaticBlockDeclaration,
            updateClassStaticBlockDeclaration: updateClassStaticBlockDeclaration,
            createTemplateLiteralTypeSpan: createTemplateLiteralTypeSpan,
            updateTemplateLiteralTypeSpan: updateTemplateLiteralTypeSpan,
            createKeywordTypeNode: createKeywordTypeNode,
            createTypePredicateNode: createTypePredicateNode,
            updateTypePredicateNode: updateTypePredicateNode,
            createTypeReferenceNode: createTypeReferenceNode,
            updateTypeReferenceNode: updateTypeReferenceNode,
            createFunctionTypeNode: createFunctionTypeNode,
            updateFunctionTypeNode: updateFunctionTypeNode,
            createConstructorTypeNode: createConstructorTypeNode,
            updateConstructorTypeNode: updateConstructorTypeNode,
            createTypeQueryNode: createTypeQueryNode,
            updateTypeQueryNode: updateTypeQueryNode,
            createTypeLiteralNode: createTypeLiteralNode,
            updateTypeLiteralNode: updateTypeLiteralNode,
            createArrayTypeNode: createArrayTypeNode,
            updateArrayTypeNode: updateArrayTypeNode,
            createTupleTypeNode: createTupleTypeNode,
            updateTupleTypeNode: updateTupleTypeNode,
            createNamedTupleMember: createNamedTupleMember,
            updateNamedTupleMember: updateNamedTupleMember,
            createOptionalTypeNode: createOptionalTypeNode,
            updateOptionalTypeNode: updateOptionalTypeNode,
            createRestTypeNode: createRestTypeNode,
            updateRestTypeNode: updateRestTypeNode,
            createUnionTypeNode: createUnionTypeNode,
            updateUnionTypeNode: updateUnionTypeNode,
            createIntersectionTypeNode: createIntersectionTypeNode,
            updateIntersectionTypeNode: updateIntersectionTypeNode,
            createConditionalTypeNode: createConditionalTypeNode,
            updateConditionalTypeNode: updateConditionalTypeNode,
            createInferTypeNode: createInferTypeNode,
            updateInferTypeNode: updateInferTypeNode,
            createImportTypeNode: createImportTypeNode,
            updateImportTypeNode: updateImportTypeNode,
            createParenthesizedType: createParenthesizedType,
            updateParenthesizedType: updateParenthesizedType,
            createThisTypeNode: createThisTypeNode,
            createTypeOperatorNode: createTypeOperatorNode,
            updateTypeOperatorNode: updateTypeOperatorNode,
            createIndexedAccessTypeNode: createIndexedAccessTypeNode,
            updateIndexedAccessTypeNode: updateIndexedAccessTypeNode,
            createMappedTypeNode: createMappedTypeNode,
            updateMappedTypeNode: updateMappedTypeNode,
            createLiteralTypeNode: createLiteralTypeNode,
            updateLiteralTypeNode: updateLiteralTypeNode,
            createTemplateLiteralType: createTemplateLiteralType,
            updateTemplateLiteralType: updateTemplateLiteralType,
            createObjectBindingPattern: createObjectBindingPattern,
            updateObjectBindingPattern: updateObjectBindingPattern,
            createArrayBindingPattern: createArrayBindingPattern,
            updateArrayBindingPattern: updateArrayBindingPattern,
            createBindingElement: createBindingElement,
            updateBindingElement: updateBindingElement,
            createArrayLiteralExpression: createArrayLiteralExpression,
            updateArrayLiteralExpression: updateArrayLiteralExpression,
            createObjectLiteralExpression: createObjectLiteralExpression,
            updateObjectLiteralExpression: updateObjectLiteralExpression,
            createPropertyAccessExpression: flags & 4 /* NodeFactoryFlags.NoIndentationOnFreshPropertyAccess */ ?
                function (expression, name) { return ts.setEmitFlags(createPropertyAccessExpression(expression, name), 131072 /* EmitFlags.NoIndentation */); } :
                createPropertyAccessExpression,
            updatePropertyAccessExpression: updatePropertyAccessExpression,
            createPropertyAccessChain: flags & 4 /* NodeFactoryFlags.NoIndentationOnFreshPropertyAccess */ ?
                function (expression, questionDotToken, name) { return ts.setEmitFlags(createPropertyAccessChain(expression, questionDotToken, name), 131072 /* EmitFlags.NoIndentation */); } :
                createPropertyAccessChain,
            updatePropertyAccessChain: updatePropertyAccessChain,
            createElementAccessExpression: createElementAccessExpression,
            updateElementAccessExpression: updateElementAccessExpression,
            createElementAccessChain: createElementAccessChain,
            updateElementAccessChain: updateElementAccessChain,
            createCallExpression: createCallExpression,
            updateCallExpression: updateCallExpression,
            createCallChain: createCallChain,
            updateCallChain: updateCallChain,
            createNewExpression: createNewExpression,
            updateNewExpression: updateNewExpression,
            createTaggedTemplateExpression: createTaggedTemplateExpression,
            updateTaggedTemplateExpression: updateTaggedTemplateExpression,
            createTypeAssertion: createTypeAssertion,
            updateTypeAssertion: updateTypeAssertion,
            createParenthesizedExpression: createParenthesizedExpression,
            updateParenthesizedExpression: updateParenthesizedExpression,
            createFunctionExpression: createFunctionExpression,
            updateFunctionExpression: updateFunctionExpression,
            createArrowFunction: createArrowFunction,
            updateArrowFunction: updateArrowFunction,
            createDeleteExpression: createDeleteExpression,
            updateDeleteExpression: updateDeleteExpression,
            createTypeOfExpression: createTypeOfExpression,
            updateTypeOfExpression: updateTypeOfExpression,
            createVoidExpression: createVoidExpression,
            updateVoidExpression: updateVoidExpression,
            createAwaitExpression: createAwaitExpression,
            updateAwaitExpression: updateAwaitExpression,
            createPrefixUnaryExpression: createPrefixUnaryExpression,
            updatePrefixUnaryExpression: updatePrefixUnaryExpression,
            createPostfixUnaryExpression: createPostfixUnaryExpression,
            updatePostfixUnaryExpression: updatePostfixUnaryExpression,
            createBinaryExpression: createBinaryExpression,
            updateBinaryExpression: updateBinaryExpression,
            createConditionalExpression: createConditionalExpression,
            updateConditionalExpression: updateConditionalExpression,
            createTemplateExpression: createTemplateExpression,
            updateTemplateExpression: updateTemplateExpression,
            createTemplateHead: createTemplateHead,
            createTemplateMiddle: createTemplateMiddle,
            createTemplateTail: createTemplateTail,
            createNoSubstitutionTemplateLiteral: createNoSubstitutionTemplateLiteral,
            createTemplateLiteralLikeNode: createTemplateLiteralLikeNode,
            createYieldExpression: createYieldExpression,
            updateYieldExpression: updateYieldExpression,
            createSpreadElement: createSpreadElement,
            updateSpreadElement: updateSpreadElement,
            createClassExpression: createClassExpression,
            updateClassExpression: updateClassExpression,
            createOmittedExpression: createOmittedExpression,
            createExpressionWithTypeArguments: createExpressionWithTypeArguments,
            updateExpressionWithTypeArguments: updateExpressionWithTypeArguments,
            createAsExpression: createAsExpression,
            updateAsExpression: updateAsExpression,
            createNonNullExpression: createNonNullExpression,
            updateNonNullExpression: updateNonNullExpression,
            createNonNullChain: createNonNullChain,
            updateNonNullChain: updateNonNullChain,
            createMetaProperty: createMetaProperty,
            updateMetaProperty: updateMetaProperty,
            createTemplateSpan: createTemplateSpan,
            updateTemplateSpan: updateTemplateSpan,
            createSemicolonClassElement: createSemicolonClassElement,
            createBlock: createBlock,
            updateBlock: updateBlock,
            createVariableStatement: createVariableStatement,
            updateVariableStatement: updateVariableStatement,
            createEmptyStatement: createEmptyStatement,
            createExpressionStatement: createExpressionStatement,
            updateExpressionStatement: updateExpressionStatement,
            createIfStatement: createIfStatement,
            updateIfStatement: updateIfStatement,
            createDoStatement: createDoStatement,
            updateDoStatement: updateDoStatement,
            createWhileStatement: createWhileStatement,
            updateWhileStatement: updateWhileStatement,
            createForStatement: createForStatement,
            updateForStatement: updateForStatement,
            createForInStatement: createForInStatement,
            updateForInStatement: updateForInStatement,
            createForOfStatement: createForOfStatement,
            updateForOfStatement: updateForOfStatement,
            createContinueStatement: createContinueStatement,
            updateContinueStatement: updateContinueStatement,
            createBreakStatement: createBreakStatement,
            updateBreakStatement: updateBreakStatement,
            createReturnStatement: createReturnStatement,
            updateReturnStatement: updateReturnStatement,
            createWithStatement: createWithStatement,
            updateWithStatement: updateWithStatement,
            createSwitchStatement: createSwitchStatement,
            updateSwitchStatement: updateSwitchStatement,
            createLabeledStatement: createLabeledStatement,
            updateLabeledStatement: updateLabeledStatement,
            createThrowStatement: createThrowStatement,
            updateThrowStatement: updateThrowStatement,
            createTryStatement: createTryStatement,
            updateTryStatement: updateTryStatement,
            createDebuggerStatement: createDebuggerStatement,
            createVariableDeclaration: createVariableDeclaration,
            updateVariableDeclaration: updateVariableDeclaration,
            createVariableDeclarationList: createVariableDeclarationList,
            updateVariableDeclarationList: updateVariableDeclarationList,
            createFunctionDeclaration: createFunctionDeclaration,
            updateFunctionDeclaration: updateFunctionDeclaration,
            createClassDeclaration: createClassDeclaration,
            updateClassDeclaration: updateClassDeclaration,
            createInterfaceDeclaration: createInterfaceDeclaration,
            updateInterfaceDeclaration: updateInterfaceDeclaration,
            createTypeAliasDeclaration: createTypeAliasDeclaration,
            updateTypeAliasDeclaration: updateTypeAliasDeclaration,
            createEnumDeclaration: createEnumDeclaration,
            updateEnumDeclaration: updateEnumDeclaration,
            createModuleDeclaration: createModuleDeclaration,
            updateModuleDeclaration: updateModuleDeclaration,
            createModuleBlock: createModuleBlock,
            updateModuleBlock: updateModuleBlock,
            createCaseBlock: createCaseBlock,
            updateCaseBlock: updateCaseBlock,
            createNamespaceExportDeclaration: createNamespaceExportDeclaration,
            updateNamespaceExportDeclaration: updateNamespaceExportDeclaration,
            createImportEqualsDeclaration: createImportEqualsDeclaration,
            updateImportEqualsDeclaration: updateImportEqualsDeclaration,
            createImportDeclaration: createImportDeclaration,
            updateImportDeclaration: updateImportDeclaration,
            createImportClause: createImportClause,
            updateImportClause: updateImportClause,
            createAssertClause: createAssertClause,
            updateAssertClause: updateAssertClause,
            createAssertEntry: createAssertEntry,
            updateAssertEntry: updateAssertEntry,
            createImportTypeAssertionContainer: createImportTypeAssertionContainer,
            updateImportTypeAssertionContainer: updateImportTypeAssertionContainer,
            createNamespaceImport: createNamespaceImport,
            updateNamespaceImport: updateNamespaceImport,
            createNamespaceExport: createNamespaceExport,
            updateNamespaceExport: updateNamespaceExport,
            createNamedImports: createNamedImports,
            updateNamedImports: updateNamedImports,
            createImportSpecifier: createImportSpecifier,
            updateImportSpecifier: updateImportSpecifier,
            createExportAssignment: createExportAssignment,
            updateExportAssignment: updateExportAssignment,
            createExportDeclaration: createExportDeclaration,
            updateExportDeclaration: updateExportDeclaration,
            createNamedExports: createNamedExports,
            updateNamedExports: updateNamedExports,
            createExportSpecifier: createExportSpecifier,
            updateExportSpecifier: updateExportSpecifier,
            createMissingDeclaration: createMissingDeclaration,
            createExternalModuleReference: createExternalModuleReference,
            updateExternalModuleReference: updateExternalModuleReference,
            // lazily load factory members for JSDoc types with similar structure
            get createJSDocAllType() { return getJSDocPrimaryTypeCreateFunction(312 /* SyntaxKind.JSDocAllType */); },
            get createJSDocUnknownType() { return getJSDocPrimaryTypeCreateFunction(313 /* SyntaxKind.JSDocUnknownType */); },
            get createJSDocNonNullableType() { return getJSDocPrePostfixUnaryTypeCreateFunction(315 /* SyntaxKind.JSDocNonNullableType */); },
            get updateJSDocNonNullableType() { return getJSDocPrePostfixUnaryTypeUpdateFunction(315 /* SyntaxKind.JSDocNonNullableType */); },
            get createJSDocNullableType() { return getJSDocPrePostfixUnaryTypeCreateFunction(314 /* SyntaxKind.JSDocNullableType */); },
            get updateJSDocNullableType() { return getJSDocPrePostfixUnaryTypeUpdateFunction(314 /* SyntaxKind.JSDocNullableType */); },
            get createJSDocOptionalType() { return getJSDocUnaryTypeCreateFunction(316 /* SyntaxKind.JSDocOptionalType */); },
            get updateJSDocOptionalType() { return getJSDocUnaryTypeUpdateFunction(316 /* SyntaxKind.JSDocOptionalType */); },
            get createJSDocVariadicType() { return getJSDocUnaryTypeCreateFunction(318 /* SyntaxKind.JSDocVariadicType */); },
            get updateJSDocVariadicType() { return getJSDocUnaryTypeUpdateFunction(318 /* SyntaxKind.JSDocVariadicType */); },
            get createJSDocNamepathType() { return getJSDocUnaryTypeCreateFunction(319 /* SyntaxKind.JSDocNamepathType */); },
            get updateJSDocNamepathType() { return getJSDocUnaryTypeUpdateFunction(319 /* SyntaxKind.JSDocNamepathType */); },
            createJSDocFunctionType: createJSDocFunctionType,
            updateJSDocFunctionType: updateJSDocFunctionType,
            createJSDocTypeLiteral: createJSDocTypeLiteral,
            updateJSDocTypeLiteral: updateJSDocTypeLiteral,
            createJSDocTypeExpression: createJSDocTypeExpression,
            updateJSDocTypeExpression: updateJSDocTypeExpression,
            createJSDocSignature: createJSDocSignature,
            updateJSDocSignature: updateJSDocSignature,
            createJSDocTemplateTag: createJSDocTemplateTag,
            updateJSDocTemplateTag: updateJSDocTemplateTag,
            createJSDocTypedefTag: createJSDocTypedefTag,
            updateJSDocTypedefTag: updateJSDocTypedefTag,
            createJSDocParameterTag: createJSDocParameterTag,
            updateJSDocParameterTag: updateJSDocParameterTag,
            createJSDocPropertyTag: createJSDocPropertyTag,
            updateJSDocPropertyTag: updateJSDocPropertyTag,
            createJSDocCallbackTag: createJSDocCallbackTag,
            updateJSDocCallbackTag: updateJSDocCallbackTag,
            createJSDocAugmentsTag: createJSDocAugmentsTag,
            updateJSDocAugmentsTag: updateJSDocAugmentsTag,
            createJSDocImplementsTag: createJSDocImplementsTag,
            updateJSDocImplementsTag: updateJSDocImplementsTag,
            createJSDocSeeTag: createJSDocSeeTag,
            updateJSDocSeeTag: updateJSDocSeeTag,
            createJSDocNameReference: createJSDocNameReference,
            updateJSDocNameReference: updateJSDocNameReference,
            createJSDocMemberName: createJSDocMemberName,
            updateJSDocMemberName: updateJSDocMemberName,
            createJSDocLink: createJSDocLink,
            updateJSDocLink: updateJSDocLink,
            createJSDocLinkCode: createJSDocLinkCode,
            updateJSDocLinkCode: updateJSDocLinkCode,
            createJSDocLinkPlain: createJSDocLinkPlain,
            updateJSDocLinkPlain: updateJSDocLinkPlain,
            // lazily load factory members for JSDoc tags with similar structure
            get createJSDocTypeTag() { return getJSDocTypeLikeTagCreateFunction(343 /* SyntaxKind.JSDocTypeTag */); },
            get updateJSDocTypeTag() { return getJSDocTypeLikeTagUpdateFunction(343 /* SyntaxKind.JSDocTypeTag */); },
            get createJSDocReturnTag() { return getJSDocTypeLikeTagCreateFunction(341 /* SyntaxKind.JSDocReturnTag */); },
            get updateJSDocReturnTag() { return getJSDocTypeLikeTagUpdateFunction(341 /* SyntaxKind.JSDocReturnTag */); },
            get createJSDocThisTag() { return getJSDocTypeLikeTagCreateFunction(342 /* SyntaxKind.JSDocThisTag */); },
            get updateJSDocThisTag() { return getJSDocTypeLikeTagUpdateFunction(342 /* SyntaxKind.JSDocThisTag */); },
            get createJSDocEnumTag() { return getJSDocTypeLikeTagCreateFunction(339 /* SyntaxKind.JSDocEnumTag */); },
            get updateJSDocEnumTag() { return getJSDocTypeLikeTagUpdateFunction(339 /* SyntaxKind.JSDocEnumTag */); },
            get createJSDocAuthorTag() { return getJSDocSimpleTagCreateFunction(330 /* SyntaxKind.JSDocAuthorTag */); },
            get updateJSDocAuthorTag() { return getJSDocSimpleTagUpdateFunction(330 /* SyntaxKind.JSDocAuthorTag */); },
            get createJSDocClassTag() { return getJSDocSimpleTagCreateFunction(332 /* SyntaxKind.JSDocClassTag */); },
            get updateJSDocClassTag() { return getJSDocSimpleTagUpdateFunction(332 /* SyntaxKind.JSDocClassTag */); },
            get createJSDocPublicTag() { return getJSDocSimpleTagCreateFunction(333 /* SyntaxKind.JSDocPublicTag */); },
            get updateJSDocPublicTag() { return getJSDocSimpleTagUpdateFunction(333 /* SyntaxKind.JSDocPublicTag */); },
            get createJSDocPrivateTag() { return getJSDocSimpleTagCreateFunction(334 /* SyntaxKind.JSDocPrivateTag */); },
            get updateJSDocPrivateTag() { return getJSDocSimpleTagUpdateFunction(334 /* SyntaxKind.JSDocPrivateTag */); },
            get createJSDocProtectedTag() { return getJSDocSimpleTagCreateFunction(335 /* SyntaxKind.JSDocProtectedTag */); },
            get updateJSDocProtectedTag() { return getJSDocSimpleTagUpdateFunction(335 /* SyntaxKind.JSDocProtectedTag */); },
            get createJSDocReadonlyTag() { return getJSDocSimpleTagCreateFunction(336 /* SyntaxKind.JSDocReadonlyTag */); },
            get updateJSDocReadonlyTag() { return getJSDocSimpleTagUpdateFunction(336 /* SyntaxKind.JSDocReadonlyTag */); },
            get createJSDocOverrideTag() { return getJSDocSimpleTagCreateFunction(337 /* SyntaxKind.JSDocOverrideTag */); },
            get updateJSDocOverrideTag() { return getJSDocSimpleTagUpdateFunction(337 /* SyntaxKind.JSDocOverrideTag */); },
            get createJSDocDeprecatedTag() { return getJSDocSimpleTagCreateFunction(331 /* SyntaxKind.JSDocDeprecatedTag */); },
            get updateJSDocDeprecatedTag() { return getJSDocSimpleTagUpdateFunction(331 /* SyntaxKind.JSDocDeprecatedTag */); },
            createJSDocUnknownTag: createJSDocUnknownTag,
            updateJSDocUnknownTag: updateJSDocUnknownTag,
            createJSDocText: createJSDocText,
            updateJSDocText: updateJSDocText,
            createJSDocComment: createJSDocComment,
            updateJSDocComment: updateJSDocComment,
            createJsxElement: createJsxElement,
            updateJsxElement: updateJsxElement,
            createJsxSelfClosingElement: createJsxSelfClosingElement,
            updateJsxSelfClosingElement: updateJsxSelfClosingElement,
            createJsxOpeningElement: createJsxOpeningElement,
            updateJsxOpeningElement: updateJsxOpeningElement,
            createJsxClosingElement: createJsxClosingElement,
            updateJsxClosingElement: updateJsxClosingElement,
            createJsxFragment: createJsxFragment,
            createJsxText: createJsxText,
            updateJsxText: updateJsxText,
            createJsxOpeningFragment: createJsxOpeningFragment,
            createJsxJsxClosingFragment: createJsxJsxClosingFragment,
            updateJsxFragment: updateJsxFragment,
            createJsxAttribute: createJsxAttribute,
            updateJsxAttribute: updateJsxAttribute,
            createJsxAttributes: createJsxAttributes,
            updateJsxAttributes: updateJsxAttributes,
            createJsxSpreadAttribute: createJsxSpreadAttribute,
            updateJsxSpreadAttribute: updateJsxSpreadAttribute,
            createJsxExpression: createJsxExpression,
            updateJsxExpression: updateJsxExpression,
            createCaseClause: createCaseClause,
            updateCaseClause: updateCaseClause,
            createDefaultClause: createDefaultClause,
            updateDefaultClause: updateDefaultClause,
            createHeritageClause: createHeritageClause,
            updateHeritageClause: updateHeritageClause,
            createCatchClause: createCatchClause,
            updateCatchClause: updateCatchClause,
            createPropertyAssignment: createPropertyAssignment,
            updatePropertyAssignment: updatePropertyAssignment,
            createShorthandPropertyAssignment: createShorthandPropertyAssignment,
            updateShorthandPropertyAssignment: updateShorthandPropertyAssignment,
            createSpreadAssignment: createSpreadAssignment,
            updateSpreadAssignment: updateSpreadAssignment,
            createEnumMember: createEnumMember,
            updateEnumMember: updateEnumMember,
            createSourceFile: createSourceFile,
            updateSourceFile: updateSourceFile,
            createBundle: createBundle,
            updateBundle: updateBundle,
            createUnparsedSource: createUnparsedSource,
            createUnparsedPrologue: createUnparsedPrologue,
            createUnparsedPrepend: createUnparsedPrepend,
            createUnparsedTextLike: createUnparsedTextLike,
            createUnparsedSyntheticReference: createUnparsedSyntheticReference,
            createInputFiles: createInputFiles,
            createSyntheticExpression: createSyntheticExpression,
            createSyntaxList: createSyntaxList,
            createNotEmittedStatement: createNotEmittedStatement,
            createPartiallyEmittedExpression: createPartiallyEmittedExpression,
            updatePartiallyEmittedExpression: updatePartiallyEmittedExpression,
            createCommaListExpression: createCommaListExpression,
            updateCommaListExpression: updateCommaListExpression,
            createEndOfDeclarationMarker: createEndOfDeclarationMarker,
            createMergeDeclarationMarker: createMergeDeclarationMarker,
            createSyntheticReferenceExpression: createSyntheticReferenceExpression,
            updateSyntheticReferenceExpression: updateSyntheticReferenceExpression,
            cloneNode: cloneNode,
            // Lazily load factory methods for common operator factories and utilities
            get createComma() { return getBinaryCreateFunction(27 /* SyntaxKind.CommaToken */); },
            get createAssignment() { return getBinaryCreateFunction(63 /* SyntaxKind.EqualsToken */); },
            get createLogicalOr() { return getBinaryCreateFunction(56 /* SyntaxKind.BarBarToken */); },
            get createLogicalAnd() { return getBinaryCreateFunction(55 /* SyntaxKind.AmpersandAmpersandToken */); },
            get createBitwiseOr() { return getBinaryCreateFunction(51 /* SyntaxKind.BarToken */); },
            get createBitwiseXor() { return getBinaryCreateFunction(52 /* SyntaxKind.CaretToken */); },
            get createBitwiseAnd() { return getBinaryCreateFunction(50 /* SyntaxKind.AmpersandToken */); },
            get createStrictEquality() { return getBinaryCreateFunction(36 /* SyntaxKind.EqualsEqualsEqualsToken */); },
            get createStrictInequality() { return getBinaryCreateFunction(37 /* SyntaxKind.ExclamationEqualsEqualsToken */); },
            get createEquality() { return getBinaryCreateFunction(34 /* SyntaxKind.EqualsEqualsToken */); },
            get createInequality() { return getBinaryCreateFunction(35 /* SyntaxKind.ExclamationEqualsToken */); },
            get createLessThan() { return getBinaryCreateFunction(29 /* SyntaxKind.LessThanToken */); },
            get createLessThanEquals() { return getBinaryCreateFunction(32 /* SyntaxKind.LessThanEqualsToken */); },
            get createGreaterThan() { return getBinaryCreateFunction(31 /* SyntaxKind.GreaterThanToken */); },
            get createGreaterThanEquals() { return getBinaryCreateFunction(33 /* SyntaxKind.GreaterThanEqualsToken */); },
            get createLeftShift() { return getBinaryCreateFunction(47 /* SyntaxKind.LessThanLessThanToken */); },
            get createRightShift() { return getBinaryCreateFunction(48 /* SyntaxKind.GreaterThanGreaterThanToken */); },
            get createUnsignedRightShift() { return getBinaryCreateFunction(49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */); },
            get createAdd() { return getBinaryCreateFunction(39 /* SyntaxKind.PlusToken */); },
            get createSubtract() { return getBinaryCreateFunction(40 /* SyntaxKind.MinusToken */); },
            get createMultiply() { return getBinaryCreateFunction(41 /* SyntaxKind.AsteriskToken */); },
            get createDivide() { return getBinaryCreateFunction(43 /* SyntaxKind.SlashToken */); },
            get createModulo() { return getBinaryCreateFunction(44 /* SyntaxKind.PercentToken */); },
            get createExponent() { return getBinaryCreateFunction(42 /* SyntaxKind.AsteriskAsteriskToken */); },
            get createPrefixPlus() { return getPrefixUnaryCreateFunction(39 /* SyntaxKind.PlusToken */); },
            get createPrefixMinus() { return getPrefixUnaryCreateFunction(40 /* SyntaxKind.MinusToken */); },
            get createPrefixIncrement() { return getPrefixUnaryCreateFunction(45 /* SyntaxKind.PlusPlusToken */); },
            get createPrefixDecrement() { return getPrefixUnaryCreateFunction(46 /* SyntaxKind.MinusMinusToken */); },
            get createBitwiseNot() { return getPrefixUnaryCreateFunction(54 /* SyntaxKind.TildeToken */); },
            get createLogicalNot() { return getPrefixUnaryCreateFunction(53 /* SyntaxKind.ExclamationToken */); },
            get createPostfixIncrement() { return getPostfixUnaryCreateFunction(45 /* SyntaxKind.PlusPlusToken */); },
            get createPostfixDecrement() { return getPostfixUnaryCreateFunction(46 /* SyntaxKind.MinusMinusToken */); },
            // Compound nodes
            createImmediatelyInvokedFunctionExpression: createImmediatelyInvokedFunctionExpression,
            createImmediatelyInvokedArrowFunction: createImmediatelyInvokedArrowFunction,
            createVoidZero: createVoidZero,
            createExportDefault: createExportDefault,
            createExternalModuleExport: createExternalModuleExport,
            createTypeCheck: createTypeCheck,
            createMethodCall: createMethodCall,
            createGlobalMethodCall: createGlobalMethodCall,
            createFunctionBindCall: createFunctionBindCall,
            createFunctionCallCall: createFunctionCallCall,
            createFunctionApplyCall: createFunctionApplyCall,
            createArraySliceCall: createArraySliceCall,
            createArrayConcatCall: createArrayConcatCall,
            createObjectDefinePropertyCall: createObjectDefinePropertyCall,
            createReflectGetCall: createReflectGetCall,
            createReflectSetCall: createReflectSetCall,
            createPropertyDescriptor: createPropertyDescriptor,
            createCallBinding: createCallBinding,
            createAssignmentTargetWrapper: createAssignmentTargetWrapper,
            // Utilities
            inlineExpressions: inlineExpressions,
            getInternalName: getInternalName,
            getLocalName: getLocalName,
            getExportName: getExportName,
            getDeclarationName: getDeclarationName,
            getNamespaceMemberName: getNamespaceMemberName,
            getExternalModuleOrNamespaceExportName: getExternalModuleOrNamespaceExportName,
            restoreOuterExpressions: restoreOuterExpressions,
            restoreEnclosingLabel: restoreEnclosingLabel,
            createUseStrictPrologue: createUseStrictPrologue,
            copyPrologue: copyPrologue,
            copyStandardPrologue: copyStandardPrologue,
            copyCustomPrologue: copyCustomPrologue,
            ensureUseStrict: ensureUseStrict,
            liftToBlock: liftToBlock,
            mergeLexicalEnvironment: mergeLexicalEnvironment,
            updateModifiers: updateModifiers,
        };
        return factory;
        // @api
        function createNodeArray(elements, hasTrailingComma) {
            if (elements === undefined || elements === ts.emptyArray) {
                elements = [];
            }
            else if (ts.isNodeArray(elements)) {
                if (hasTrailingComma === undefined || elements.hasTrailingComma === hasTrailingComma) {
                    // Ensure the transform flags have been aggregated for this NodeArray
                    if (elements.transformFlags === undefined) {
                        aggregateChildrenFlags(elements);
                    }
                    ts.Debug.attachNodeArrayDebugInfo(elements);
                    return elements;
                }
                // This *was* a `NodeArray`, but the `hasTrailingComma` option differs. Recreate the
                // array with the same elements, text range, and transform flags but with the updated
                // value for `hasTrailingComma`
                var array_8 = elements.slice();
                array_8.pos = elements.pos;
                array_8.end = elements.end;
                array_8.hasTrailingComma = hasTrailingComma;
                array_8.transformFlags = elements.transformFlags;
                ts.Debug.attachNodeArrayDebugInfo(array_8);
                return array_8;
            }
            // Since the element list of a node array is typically created by starting with an empty array and
            // repeatedly calling push(), the list may not have the optimal memory layout. We invoke slice() for
            // small arrays (1 to 4 elements) to give the VM a chance to allocate an optimal representation.
            var length = elements.length;
            var array = (length >= 1 && length <= 4 ? elements.slice() : elements);
            ts.setTextRangePosEnd(array, -1, -1);
            array.hasTrailingComma = !!hasTrailingComma;
            aggregateChildrenFlags(array);
            ts.Debug.attachNodeArrayDebugInfo(array);
            return array;
        }
        function createBaseNode(kind) {
            return baseFactory.createBaseNode(kind);
        }
        function createBaseDeclaration(kind, decorators, modifiers) {
            var node = createBaseNode(kind);
            node.decorators = asNodeArray(decorators);
            node.modifiers = asNodeArray(modifiers);
            node.transformFlags |=
                propagateChildrenFlags(node.decorators) |
                    propagateChildrenFlags(node.modifiers);
            // NOTE: The following properties are commonly set by the binder and are added here to
            // ensure declarations have a stable shape.
            node.symbol = undefined; // initialized by binder
            node.localSymbol = undefined; // initialized by binder
            node.locals = undefined; // initialized by binder
            node.nextContainer = undefined; // initialized by binder
            return node;
        }
        function createBaseNamedDeclaration(kind, decorators, modifiers, name) {
            var node = createBaseDeclaration(kind, decorators, modifiers);
            name = asName(name);
            node.name = name;
            // The PropertyName of a member is allowed to be `await`.
            // We don't need to exclude `await` for type signatures since types
            // don't propagate child flags.
            if (name) {
                switch (node.kind) {
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                    case 296 /* SyntaxKind.PropertyAssignment */:
                        if (ts.isIdentifier(name)) {
                            node.transformFlags |= propagateIdentifierNameFlags(name);
                            break;
                        }
                    // fall through
                    default:
                        node.transformFlags |= propagateChildFlags(name);
                        break;
                }
            }
            return node;
        }
        function createBaseGenericNamedDeclaration(kind, decorators, modifiers, name, typeParameters) {
            var node = createBaseNamedDeclaration(kind, decorators, modifiers, name);
            node.typeParameters = asNodeArray(typeParameters);
            node.transformFlags |= propagateChildrenFlags(node.typeParameters);
            if (typeParameters)
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        function createBaseSignatureDeclaration(kind, decorators, modifiers, name, typeParameters, parameters, type) {
            var node = createBaseGenericNamedDeclaration(kind, decorators, modifiers, name, typeParameters);
            node.parameters = createNodeArray(parameters);
            node.type = type;
            node.transformFlags |=
                propagateChildrenFlags(node.parameters) |
                    propagateChildFlags(node.type);
            if (type)
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        function updateBaseSignatureDeclaration(updated, original) {
            // copy children used only for error reporting
            if (original.typeArguments)
                updated.typeArguments = original.typeArguments;
            return update(updated, original);
        }
        function createBaseFunctionLikeDeclaration(kind, decorators, modifiers, name, typeParameters, parameters, type, body) {
            var node = createBaseSignatureDeclaration(kind, decorators, modifiers, name, typeParameters, parameters, type);
            node.body = body;
            node.transformFlags |= propagateChildFlags(node.body) & ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */;
            if (!body)
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        function updateBaseFunctionLikeDeclaration(updated, original) {
            // copy children used only for error reporting
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            if (original.typeArguments)
                updated.typeArguments = original.typeArguments;
            return updateBaseSignatureDeclaration(updated, original);
        }
        function createBaseInterfaceOrClassLikeDeclaration(kind, decorators, modifiers, name, typeParameters, heritageClauses) {
            var node = createBaseGenericNamedDeclaration(kind, decorators, modifiers, name, typeParameters);
            node.heritageClauses = asNodeArray(heritageClauses);
            node.transformFlags |= propagateChildrenFlags(node.heritageClauses);
            return node;
        }
        function createBaseClassLikeDeclaration(kind, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseInterfaceOrClassLikeDeclaration(kind, decorators, modifiers, name, typeParameters, heritageClauses);
            node.members = createNodeArray(members);
            node.transformFlags |= propagateChildrenFlags(node.members);
            return node;
        }
        function createBaseBindingLikeDeclaration(kind, decorators, modifiers, name, initializer) {
            var node = createBaseNamedDeclaration(kind, decorators, modifiers, name);
            node.initializer = initializer;
            node.transformFlags |= propagateChildFlags(node.initializer);
            return node;
        }
        function createBaseVariableLikeDeclaration(kind, decorators, modifiers, name, type, initializer) {
            var node = createBaseBindingLikeDeclaration(kind, decorators, modifiers, name, initializer);
            node.type = type;
            node.transformFlags |= propagateChildFlags(type);
            if (type)
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        //
        // Literals
        //
        function createBaseLiteral(kind, text) {
            var node = createBaseToken(kind);
            node.text = text;
            return node;
        }
        // @api
        function createNumericLiteral(value, numericLiteralFlags) {
            if (numericLiteralFlags === void 0) { numericLiteralFlags = 0 /* TokenFlags.None */; }
            var node = createBaseLiteral(8 /* SyntaxKind.NumericLiteral */, typeof value === "number" ? value + "" : value);
            node.numericLiteralFlags = numericLiteralFlags;
            if (numericLiteralFlags & 384 /* TokenFlags.BinaryOrOctalSpecifier */)
                node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function createBigIntLiteral(value) {
            var node = createBaseLiteral(9 /* SyntaxKind.BigIntLiteral */, typeof value === "string" ? value : ts.pseudoBigIntToString(value) + "n");
            node.transformFlags |= 4 /* TransformFlags.ContainsESNext */;
            return node;
        }
        function createBaseStringLiteral(text, isSingleQuote) {
            var node = createBaseLiteral(10 /* SyntaxKind.StringLiteral */, text);
            node.singleQuote = isSingleQuote;
            return node;
        }
        // @api
        function createStringLiteral(text, isSingleQuote, hasExtendedUnicodeEscape) {
            var node = createBaseStringLiteral(text, isSingleQuote);
            node.hasExtendedUnicodeEscape = hasExtendedUnicodeEscape;
            if (hasExtendedUnicodeEscape)
                node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function createStringLiteralFromNode(sourceNode) {
            var node = createBaseStringLiteral(ts.getTextOfIdentifierOrLiteral(sourceNode), /*isSingleQuote*/ undefined);
            node.textSourceNode = sourceNode;
            return node;
        }
        // @api
        function createRegularExpressionLiteral(text) {
            var node = createBaseLiteral(13 /* SyntaxKind.RegularExpressionLiteral */, text);
            return node;
        }
        // @api
        function createLiteralLikeNode(kind, text) {
            switch (kind) {
                case 8 /* SyntaxKind.NumericLiteral */: return createNumericLiteral(text, /*numericLiteralFlags*/ 0);
                case 9 /* SyntaxKind.BigIntLiteral */: return createBigIntLiteral(text);
                case 10 /* SyntaxKind.StringLiteral */: return createStringLiteral(text, /*isSingleQuote*/ undefined);
                case 11 /* SyntaxKind.JsxText */: return createJsxText(text, /*containsOnlyTriviaWhiteSpaces*/ false);
                case 12 /* SyntaxKind.JsxTextAllWhiteSpaces */: return createJsxText(text, /*containsOnlyTriviaWhiteSpaces*/ true);
                case 13 /* SyntaxKind.RegularExpressionLiteral */: return createRegularExpressionLiteral(text);
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */: return createTemplateLiteralLikeNode(kind, text, /*rawText*/ undefined, /*templateFlags*/ 0);
            }
        }
        //
        // Identifiers
        //
        function createBaseIdentifier(text, originalKeywordKind) {
            if (originalKeywordKind === undefined && text) {
                originalKeywordKind = ts.stringToToken(text);
            }
            if (originalKeywordKind === 79 /* SyntaxKind.Identifier */) {
                originalKeywordKind = undefined;
            }
            var node = baseFactory.createBaseIdentifierNode(79 /* SyntaxKind.Identifier */);
            node.originalKeywordKind = originalKeywordKind;
            node.escapedText = ts.escapeLeadingUnderscores(text);
            return node;
        }
        function createBaseGeneratedIdentifier(text, autoGenerateFlags) {
            var node = createBaseIdentifier(text, /*originalKeywordKind*/ undefined);
            node.autoGenerateFlags = autoGenerateFlags;
            node.autoGenerateId = nextAutoGenerateId;
            nextAutoGenerateId++;
            return node;
        }
        // @api
        function createIdentifier(text, typeArguments, originalKeywordKind) {
            var node = createBaseIdentifier(text, originalKeywordKind);
            if (typeArguments) {
                // NOTE: we do not use `setChildren` here because typeArguments in an identifier do not contribute to transformations
                node.typeArguments = createNodeArray(typeArguments);
            }
            if (node.originalKeywordKind === 132 /* SyntaxKind.AwaitKeyword */) {
                node.transformFlags |= 16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */;
            }
            return node;
        }
        // @api
        function updateIdentifier(node, typeArguments) {
            return node.typeArguments !== typeArguments
                ? update(createIdentifier(ts.idText(node), typeArguments), node)
                : node;
        }
        // @api
        function createTempVariable(recordTempVariable, reservedInNestedScopes) {
            var flags = 1 /* GeneratedIdentifierFlags.Auto */;
            if (reservedInNestedScopes)
                flags |= 8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */;
            var name = createBaseGeneratedIdentifier("", flags);
            if (recordTempVariable) {
                recordTempVariable(name);
            }
            return name;
        }
        /** Create a unique temporary variable for use in a loop. */
        // @api
        function createLoopVariable(reservedInNestedScopes) {
            var flags = 2 /* GeneratedIdentifierFlags.Loop */;
            if (reservedInNestedScopes)
                flags |= 8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */;
            return createBaseGeneratedIdentifier("", flags);
        }
        /** Create a unique name based on the supplied text. */
        // @api
        function createUniqueName(text, flags) {
            if (flags === void 0) { flags = 0 /* GeneratedIdentifierFlags.None */; }
            ts.Debug.assert(!(flags & 7 /* GeneratedIdentifierFlags.KindMask */), "Argument out of range: flags");
            ts.Debug.assert((flags & (16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */)) !== 32 /* GeneratedIdentifierFlags.FileLevel */, "GeneratedIdentifierFlags.FileLevel cannot be set without also setting GeneratedIdentifierFlags.Optimistic");
            return createBaseGeneratedIdentifier(text, 3 /* GeneratedIdentifierFlags.Unique */ | flags);
        }
        /** Create a unique name generated for a node. */
        // @api
        function getGeneratedNameForNode(node, flags) {
            if (flags === void 0) { flags = 0; }
            ts.Debug.assert(!(flags & 7 /* GeneratedIdentifierFlags.KindMask */), "Argument out of range: flags");
            var name = createBaseGeneratedIdentifier(node && ts.isIdentifier(node) ? ts.idText(node) : "", 4 /* GeneratedIdentifierFlags.Node */ | flags);
            name.original = node;
            return name;
        }
        // @api
        function createPrivateIdentifier(text) {
            if (!ts.startsWith(text, "#"))
                ts.Debug.fail("First character of private identifier must be #: " + text);
            var node = baseFactory.createBasePrivateIdentifierNode(80 /* SyntaxKind.PrivateIdentifier */);
            node.escapedText = ts.escapeLeadingUnderscores(text);
            node.transformFlags |= 8388608 /* TransformFlags.ContainsClassFields */;
            return node;
        }
        //
        // Punctuation
        //
        function createBaseToken(kind) {
            return baseFactory.createBaseTokenNode(kind);
        }
        function createToken(token) {
            ts.Debug.assert(token >= 0 /* SyntaxKind.FirstToken */ && token <= 160 /* SyntaxKind.LastToken */, "Invalid token");
            ts.Debug.assert(token <= 14 /* SyntaxKind.FirstTemplateToken */ || token >= 17 /* SyntaxKind.LastTemplateToken */, "Invalid token. Use 'createTemplateLiteralLikeNode' to create template literals.");
            ts.Debug.assert(token <= 8 /* SyntaxKind.FirstLiteralToken */ || token >= 14 /* SyntaxKind.LastLiteralToken */, "Invalid token. Use 'createLiteralLikeNode' to create literals.");
            ts.Debug.assert(token !== 79 /* SyntaxKind.Identifier */, "Invalid token. Use 'createIdentifier' to create identifiers");
            var node = createBaseToken(token);
            var transformFlags = 0 /* TransformFlags.None */;
            switch (token) {
                case 131 /* SyntaxKind.AsyncKeyword */:
                    // 'async' modifier is ES2017 (async functions) or ES2018 (async generators)
                    transformFlags =
                        256 /* TransformFlags.ContainsES2017 */ |
                            128 /* TransformFlags.ContainsES2018 */;
                    break;
                case 123 /* SyntaxKind.PublicKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 85 /* SyntaxKind.ConstKeyword */:
                case 130 /* SyntaxKind.AnyKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                case 101 /* SyntaxKind.InKeyword */:
                case 144 /* SyntaxKind.OutKeyword */:
                case 159 /* SyntaxKind.OverrideKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */: // `undefined` is an Identifier in the expression case.
                    transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
                    break;
                case 106 /* SyntaxKind.SuperKeyword */:
                    transformFlags = 1024 /* TransformFlags.ContainsES2015 */ | 33554432 /* TransformFlags.ContainsLexicalSuper */;
                    break;
                case 124 /* SyntaxKind.StaticKeyword */:
                    transformFlags = 1024 /* TransformFlags.ContainsES2015 */;
                    break;
                case 108 /* SyntaxKind.ThisKeyword */:
                    // 'this' indicates a lexical 'this'
                    transformFlags = 8192 /* TransformFlags.ContainsLexicalThis */;
                    break;
            }
            if (transformFlags) {
                node.transformFlags |= transformFlags;
            }
            return node;
        }
        //
        // Reserved words
        //
        // @api
        function createSuper() {
            return createToken(106 /* SyntaxKind.SuperKeyword */);
        }
        // @api
        function createThis() {
            return createToken(108 /* SyntaxKind.ThisKeyword */);
        }
        // @api
        function createNull() {
            return createToken(104 /* SyntaxKind.NullKeyword */);
        }
        // @api
        function createTrue() {
            return createToken(110 /* SyntaxKind.TrueKeyword */);
        }
        // @api
        function createFalse() {
            return createToken(95 /* SyntaxKind.FalseKeyword */);
        }
        //
        // Modifiers
        //
        // @api
        function createModifier(kind) {
            return createToken(kind);
        }
        // @api
        function createModifiersFromModifierFlags(flags) {
            var result = [];
            if (flags & 1 /* ModifierFlags.Export */)
                result.push(createModifier(93 /* SyntaxKind.ExportKeyword */));
            if (flags & 2 /* ModifierFlags.Ambient */)
                result.push(createModifier(135 /* SyntaxKind.DeclareKeyword */));
            if (flags & 512 /* ModifierFlags.Default */)
                result.push(createModifier(88 /* SyntaxKind.DefaultKeyword */));
            if (flags & 2048 /* ModifierFlags.Const */)
                result.push(createModifier(85 /* SyntaxKind.ConstKeyword */));
            if (flags & 4 /* ModifierFlags.Public */)
                result.push(createModifier(123 /* SyntaxKind.PublicKeyword */));
            if (flags & 8 /* ModifierFlags.Private */)
                result.push(createModifier(121 /* SyntaxKind.PrivateKeyword */));
            if (flags & 16 /* ModifierFlags.Protected */)
                result.push(createModifier(122 /* SyntaxKind.ProtectedKeyword */));
            if (flags & 128 /* ModifierFlags.Abstract */)
                result.push(createModifier(126 /* SyntaxKind.AbstractKeyword */));
            if (flags & 32 /* ModifierFlags.Static */)
                result.push(createModifier(124 /* SyntaxKind.StaticKeyword */));
            if (flags & 16384 /* ModifierFlags.Override */)
                result.push(createModifier(159 /* SyntaxKind.OverrideKeyword */));
            if (flags & 64 /* ModifierFlags.Readonly */)
                result.push(createModifier(145 /* SyntaxKind.ReadonlyKeyword */));
            if (flags & 256 /* ModifierFlags.Async */)
                result.push(createModifier(131 /* SyntaxKind.AsyncKeyword */));
            if (flags & 32768 /* ModifierFlags.In */)
                result.push(createModifier(101 /* SyntaxKind.InKeyword */));
            if (flags & 65536 /* ModifierFlags.Out */)
                result.push(createModifier(144 /* SyntaxKind.OutKeyword */));
            return result.length ? result : undefined;
        }
        //
        // Names
        //
        // @api
        function createQualifiedName(left, right) {
            var node = createBaseNode(161 /* SyntaxKind.QualifiedName */);
            node.left = left;
            node.right = asName(right);
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateIdentifierNameFlags(node.right);
            return node;
        }
        // @api
        function updateQualifiedName(node, left, right) {
            return node.left !== left
                || node.right !== right
                ? update(createQualifiedName(left, right), node)
                : node;
        }
        // @api
        function createComputedPropertyName(expression) {
            var node = createBaseNode(162 /* SyntaxKind.ComputedPropertyName */);
            node.expression = parenthesizerRules().parenthesizeExpressionOfComputedPropertyName(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    65536 /* TransformFlags.ContainsComputedPropertyName */;
            return node;
        }
        // @api
        function updateComputedPropertyName(node, expression) {
            return node.expression !== expression
                ? update(createComputedPropertyName(expression), node)
                : node;
        }
        function createTypeParameterDeclaration(modifiersOrName, nameOrConstraint, constraintOrDefault, defaultType) {
            var name;
            var modifiers;
            var constraint;
            if (modifiersOrName === undefined || ts.isArray(modifiersOrName)) {
                modifiers = modifiersOrName;
                name = nameOrConstraint;
                constraint = constraintOrDefault;
            }
            else {
                modifiers = undefined;
                name = modifiersOrName;
                constraint = nameOrConstraint;
            }
            var node = createBaseNamedDeclaration(163 /* SyntaxKind.TypeParameter */, 
            /*decorators*/ undefined, modifiers, name);
            node.constraint = constraint;
            node.default = defaultType;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        function updateTypeParameterDeclaration(node, modifiersOrName, nameOrConstraint, constraintOrDefault, defaultType) {
            var name;
            var modifiers;
            var constraint;
            if (modifiersOrName === undefined || ts.isArray(modifiersOrName)) {
                modifiers = modifiersOrName;
                name = nameOrConstraint;
                constraint = constraintOrDefault;
            }
            else {
                modifiers = undefined;
                name = modifiersOrName;
                constraint = nameOrConstraint;
            }
            return node.modifiers !== modifiers
                || node.name !== name
                || node.constraint !== constraint
                || node.default !== defaultType
                ? update(createTypeParameterDeclaration(modifiers, name, constraint, defaultType), node)
                : node;
        }
        // @api
        function createParameterDeclaration(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(164 /* SyntaxKind.Parameter */, decorators, modifiers, name, type, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.dotDotDotToken = dotDotDotToken;
            node.questionToken = questionToken;
            if (ts.isThisIdentifier(node.name)) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.dotDotDotToken) |
                        propagateChildFlags(node.questionToken);
                if (questionToken)
                    node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
                if (ts.modifiersToFlags(node.modifiers) & 16476 /* ModifierFlags.ParameterPropertyModifier */)
                    node.transformFlags |= 4096 /* TransformFlags.ContainsTypeScriptClassSyntax */;
                if (initializer || dotDotDotToken)
                    node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            }
            return node;
        }
        // @api
        function updateParameterDeclaration(node, decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                || node.initializer !== initializer
                ? update(createParameterDeclaration(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer), node)
                : node;
        }
        // @api
        function createDecorator(expression) {
            var node = createBaseNode(165 /* SyntaxKind.Decorator */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* TransformFlags.ContainsTypeScript */ |
                    4096 /* TransformFlags.ContainsTypeScriptClassSyntax */;
            return node;
        }
        // @api
        function updateDecorator(node, expression) {
            return node.expression !== expression
                ? update(createDecorator(expression), node)
                : node;
        }
        //
        // Type Elements
        //
        // @api
        function createPropertySignature(modifiers, name, questionToken, type) {
            var node = createBaseNamedDeclaration(166 /* SyntaxKind.PropertySignature */, 
            /*decorators*/ undefined, modifiers, name);
            node.type = type;
            node.questionToken = questionToken;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updatePropertySignature(node, modifiers, name, questionToken, type) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                ? update(createPropertySignature(modifiers, name, questionToken, type), node)
                : node;
        }
        // @api
        function createPropertyDeclaration(decorators, modifiers, name, questionOrExclamationToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(167 /* SyntaxKind.PropertyDeclaration */, decorators, modifiers, name, type, initializer);
            node.questionToken = questionOrExclamationToken && ts.isQuestionToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined;
            node.exclamationToken = questionOrExclamationToken && ts.isExclamationToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined;
            node.transformFlags |=
                propagateChildFlags(node.questionToken) |
                    propagateChildFlags(node.exclamationToken) |
                    8388608 /* TransformFlags.ContainsClassFields */;
            if (ts.isComputedPropertyName(node.name) || (ts.hasStaticModifier(node) && node.initializer)) {
                node.transformFlags |= 4096 /* TransformFlags.ContainsTypeScriptClassSyntax */;
            }
            if (questionOrExclamationToken || ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updatePropertyDeclaration(node, decorators, modifiers, name, questionOrExclamationToken, type, initializer) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== (questionOrExclamationToken !== undefined && ts.isQuestionToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined)
                || node.exclamationToken !== (questionOrExclamationToken !== undefined && ts.isExclamationToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined)
                || node.type !== type
                || node.initializer !== initializer
                ? update(createPropertyDeclaration(decorators, modifiers, name, questionOrExclamationToken, type, initializer), node)
                : node;
        }
        // @api
        function createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(168 /* SyntaxKind.MethodSignature */, 
            /*decorators*/ undefined, modifiers, name, typeParameters, parameters, type);
            node.questionToken = questionToken;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateMethodSignature(node, modifiers, name, questionToken, typeParameters, parameters, type) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== questionToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type), node)
                : node;
        }
        // @api
        function createMethodDeclaration(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(169 /* SyntaxKind.MethodDeclaration */, decorators, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            node.questionToken = questionToken;
            node.transformFlags |=
                propagateChildFlags(node.asteriskToken) |
                    propagateChildFlags(node.questionToken) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (questionToken) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.modifiersToFlags(node.modifiers) & 256 /* ModifierFlags.Async */) {
                if (asteriskToken) {
                    node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
                }
                else {
                    node.transformFlags |= 256 /* TransformFlags.ContainsES2017 */;
                }
            }
            else if (asteriskToken) {
                node.transformFlags |= 2048 /* TransformFlags.ContainsGenerator */;
            }
            return node;
        }
        // @api
        function updateMethodDeclaration(node, decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createMethodDeclaration(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body), node)
                : node;
        }
        // @api
        function createClassStaticBlockDeclaration(decorators, modifiers, body) {
            var node = createBaseGenericNamedDeclaration(170 /* SyntaxKind.ClassStaticBlockDeclaration */, decorators, modifiers, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined);
            node.body = body;
            node.transformFlags = propagateChildFlags(body) | 8388608 /* TransformFlags.ContainsClassFields */;
            return node;
        }
        // @api
        function updateClassStaticBlockDeclaration(node, decorators, modifiers, body) {
            return node.decorators !== decorators
                || node.modifier !== modifiers
                || node.body !== body
                ? update(createClassStaticBlockDeclaration(decorators, modifiers, body), node)
                : node;
        }
        // @api
        function createConstructorDeclaration(decorators, modifiers, parameters, body) {
            var node = createBaseFunctionLikeDeclaration(171 /* SyntaxKind.Constructor */, decorators, modifiers, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, parameters, 
            /*type*/ undefined, body);
            node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function updateConstructorDeclaration(node, decorators, modifiers, parameters, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.parameters !== parameters
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createConstructorDeclaration(decorators, modifiers, parameters, body), node)
                : node;
        }
        // @api
        function createGetAccessorDeclaration(decorators, modifiers, name, parameters, type, body) {
            return createBaseFunctionLikeDeclaration(172 /* SyntaxKind.GetAccessor */, decorators, modifiers, name, 
            /*typeParameters*/ undefined, parameters, type, body);
        }
        // @api
        function updateGetAccessorDeclaration(node, decorators, modifiers, name, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createGetAccessorDeclaration(decorators, modifiers, name, parameters, type, body), node)
                : node;
        }
        // @api
        function createSetAccessorDeclaration(decorators, modifiers, name, parameters, body) {
            return createBaseFunctionLikeDeclaration(173 /* SyntaxKind.SetAccessor */, decorators, modifiers, name, 
            /*typeParameters*/ undefined, parameters, 
            /*type*/ undefined, body);
        }
        // @api
        function updateSetAccessorDeclaration(node, decorators, modifiers, name, parameters, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.parameters !== parameters
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createSetAccessorDeclaration(decorators, modifiers, name, parameters, body), node)
                : node;
        }
        // @api
        function createCallSignature(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(174 /* SyntaxKind.CallSignature */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, typeParameters, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateCallSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createCallSignature(typeParameters, parameters, type), node)
                : node;
        }
        // @api
        function createConstructSignature(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(175 /* SyntaxKind.ConstructSignature */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, typeParameters, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateConstructSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createConstructSignature(typeParameters, parameters, type), node)
                : node;
        }
        // @api
        function createIndexSignature(decorators, modifiers, parameters, type) {
            var node = createBaseSignatureDeclaration(176 /* SyntaxKind.IndexSignature */, decorators, modifiers, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateIndexSignature(node, decorators, modifiers, parameters, type) {
            return node.parameters !== parameters
                || node.type !== type
                || node.decorators !== decorators
                || node.modifiers !== modifiers
                ? updateBaseSignatureDeclaration(createIndexSignature(decorators, modifiers, parameters, type), node)
                : node;
        }
        // @api
        function createTemplateLiteralTypeSpan(type, literal) {
            var node = createBaseNode(199 /* SyntaxKind.TemplateLiteralTypeSpan */);
            node.type = type;
            node.literal = literal;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTemplateLiteralTypeSpan(node, type, literal) {
            return node.type !== type
                || node.literal !== literal
                ? update(createTemplateLiteralTypeSpan(type, literal), node)
                : node;
        }
        //
        // Types
        //
        // @api
        function createKeywordTypeNode(kind) {
            return createToken(kind);
        }
        // @api
        function createTypePredicateNode(assertsModifier, parameterName, type) {
            var node = createBaseNode(177 /* SyntaxKind.TypePredicate */);
            node.assertsModifier = assertsModifier;
            node.parameterName = asName(parameterName);
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypePredicateNode(node, assertsModifier, parameterName, type) {
            return node.assertsModifier !== assertsModifier
                || node.parameterName !== parameterName
                || node.type !== type
                ? update(createTypePredicateNode(assertsModifier, parameterName, type), node)
                : node;
        }
        // @api
        function createTypeReferenceNode(typeName, typeArguments) {
            var node = createBaseNode(178 /* SyntaxKind.TypeReference */);
            node.typeName = asName(typeName);
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(createNodeArray(typeArguments));
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeReferenceNode(node, typeName, typeArguments) {
            return node.typeName !== typeName
                || node.typeArguments !== typeArguments
                ? update(createTypeReferenceNode(typeName, typeArguments), node)
                : node;
        }
        // @api
        function createFunctionTypeNode(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(179 /* SyntaxKind.FunctionType */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, typeParameters, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateFunctionTypeNode(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createFunctionTypeNode(typeParameters, parameters, type), node)
                : node;
        }
        // @api
        function createConstructorTypeNode() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.length === 4 ? createConstructorTypeNode1.apply(void 0, args) :
                args.length === 3 ? createConstructorTypeNode2.apply(void 0, args) :
                    ts.Debug.fail("Incorrect number of arguments specified.");
        }
        function createConstructorTypeNode1(modifiers, typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(180 /* SyntaxKind.ConstructorType */, 
            /*decorators*/ undefined, modifiers, 
            /*name*/ undefined, typeParameters, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        /** @deprecated */
        function createConstructorTypeNode2(typeParameters, parameters, type) {
            return createConstructorTypeNode1(/*modifiers*/ undefined, typeParameters, parameters, type);
        }
        // @api
        function updateConstructorTypeNode() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.length === 5 ? updateConstructorTypeNode1.apply(void 0, args) :
                args.length === 4 ? updateConstructorTypeNode2.apply(void 0, args) :
                    ts.Debug.fail("Incorrect number of arguments specified.");
        }
        function updateConstructorTypeNode1(node, modifiers, typeParameters, parameters, type) {
            return node.modifiers !== modifiers
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createConstructorTypeNode(modifiers, typeParameters, parameters, type), node)
                : node;
        }
        /** @deprecated */
        function updateConstructorTypeNode2(node, typeParameters, parameters, type) {
            return updateConstructorTypeNode1(node, node.modifiers, typeParameters, parameters, type);
        }
        // @api
        function createTypeQueryNode(exprName, typeArguments) {
            var node = createBaseNode(181 /* SyntaxKind.TypeQuery */);
            node.exprName = exprName;
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeQueryNode(node, exprName, typeArguments) {
            return node.exprName !== exprName
                || node.typeArguments !== typeArguments
                ? update(createTypeQueryNode(exprName, typeArguments), node)
                : node;
        }
        // @api
        function createTypeLiteralNode(members) {
            var node = createBaseNode(182 /* SyntaxKind.TypeLiteral */);
            node.members = createNodeArray(members);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeLiteralNode(node, members) {
            return node.members !== members
                ? update(createTypeLiteralNode(members), node)
                : node;
        }
        // @api
        function createArrayTypeNode(elementType) {
            var node = createBaseNode(183 /* SyntaxKind.ArrayType */);
            node.elementType = parenthesizerRules().parenthesizeNonArrayTypeOfPostfixType(elementType);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateArrayTypeNode(node, elementType) {
            return node.elementType !== elementType
                ? update(createArrayTypeNode(elementType), node)
                : node;
        }
        // @api
        function createTupleTypeNode(elements) {
            var node = createBaseNode(184 /* SyntaxKind.TupleType */);
            node.elements = createNodeArray(parenthesizerRules().parenthesizeElementTypesOfTupleType(elements));
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTupleTypeNode(node, elements) {
            return node.elements !== elements
                ? update(createTupleTypeNode(elements), node)
                : node;
        }
        // @api
        function createNamedTupleMember(dotDotDotToken, name, questionToken, type) {
            var node = createBaseNode(197 /* SyntaxKind.NamedTupleMember */);
            node.dotDotDotToken = dotDotDotToken;
            node.name = name;
            node.questionToken = questionToken;
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNamedTupleMember(node, dotDotDotToken, name, questionToken, type) {
            return node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                ? update(createNamedTupleMember(dotDotDotToken, name, questionToken, type), node)
                : node;
        }
        // @api
        function createOptionalTypeNode(type) {
            var node = createBaseNode(185 /* SyntaxKind.OptionalType */);
            node.type = parenthesizerRules().parenthesizeTypeOfOptionalType(type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateOptionalTypeNode(node, type) {
            return node.type !== type
                ? update(createOptionalTypeNode(type), node)
                : node;
        }
        // @api
        function createRestTypeNode(type) {
            var node = createBaseNode(186 /* SyntaxKind.RestType */);
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateRestTypeNode(node, type) {
            return node.type !== type
                ? update(createRestTypeNode(type), node)
                : node;
        }
        function createUnionOrIntersectionTypeNode(kind, types, parenthesize) {
            var node = createBaseNode(kind);
            node.types = factory.createNodeArray(parenthesize(types));
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        function updateUnionOrIntersectionTypeNode(node, types, parenthesize) {
            return node.types !== types
                ? update(createUnionOrIntersectionTypeNode(node.kind, types, parenthesize), node)
                : node;
        }
        // @api
        function createUnionTypeNode(types) {
            return createUnionOrIntersectionTypeNode(187 /* SyntaxKind.UnionType */, types, parenthesizerRules().parenthesizeConstituentTypesOfUnionType);
        }
        // @api
        function updateUnionTypeNode(node, types) {
            return updateUnionOrIntersectionTypeNode(node, types, parenthesizerRules().parenthesizeConstituentTypesOfUnionType);
        }
        // @api
        function createIntersectionTypeNode(types) {
            return createUnionOrIntersectionTypeNode(188 /* SyntaxKind.IntersectionType */, types, parenthesizerRules().parenthesizeConstituentTypesOfIntersectionType);
        }
        // @api
        function updateIntersectionTypeNode(node, types) {
            return updateUnionOrIntersectionTypeNode(node, types, parenthesizerRules().parenthesizeConstituentTypesOfIntersectionType);
        }
        // @api
        function createConditionalTypeNode(checkType, extendsType, trueType, falseType) {
            var node = createBaseNode(189 /* SyntaxKind.ConditionalType */);
            node.checkType = parenthesizerRules().parenthesizeCheckTypeOfConditionalType(checkType);
            node.extendsType = parenthesizerRules().parenthesizeExtendsTypeOfConditionalType(extendsType);
            node.trueType = trueType;
            node.falseType = falseType;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateConditionalTypeNode(node, checkType, extendsType, trueType, falseType) {
            return node.checkType !== checkType
                || node.extendsType !== extendsType
                || node.trueType !== trueType
                || node.falseType !== falseType
                ? update(createConditionalTypeNode(checkType, extendsType, trueType, falseType), node)
                : node;
        }
        // @api
        function createInferTypeNode(typeParameter) {
            var node = createBaseNode(190 /* SyntaxKind.InferType */);
            node.typeParameter = typeParameter;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateInferTypeNode(node, typeParameter) {
            return node.typeParameter !== typeParameter
                ? update(createInferTypeNode(typeParameter), node)
                : node;
        }
        // @api
        function createTemplateLiteralType(head, templateSpans) {
            var node = createBaseNode(198 /* SyntaxKind.TemplateLiteralType */);
            node.head = head;
            node.templateSpans = createNodeArray(templateSpans);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTemplateLiteralType(node, head, templateSpans) {
            return node.head !== head
                || node.templateSpans !== templateSpans
                ? update(createTemplateLiteralType(head, templateSpans), node)
                : node;
        }
        function createImportTypeNode(argument, qualifierOrAssertions, typeArgumentsOrQualifier, isTypeOfOrTypeArguments, isTypeOf) {
            var assertion = qualifierOrAssertions && qualifierOrAssertions.kind === 295 /* SyntaxKind.ImportTypeAssertionContainer */ ? qualifierOrAssertions : undefined;
            var qualifier = qualifierOrAssertions && ts.isEntityName(qualifierOrAssertions) ? qualifierOrAssertions
                : typeArgumentsOrQualifier && !ts.isArray(typeArgumentsOrQualifier) ? typeArgumentsOrQualifier : undefined;
            var typeArguments = ts.isArray(typeArgumentsOrQualifier) ? typeArgumentsOrQualifier : ts.isArray(isTypeOfOrTypeArguments) ? isTypeOfOrTypeArguments : undefined;
            isTypeOf = typeof isTypeOfOrTypeArguments === "boolean" ? isTypeOfOrTypeArguments : typeof isTypeOf === "boolean" ? isTypeOf : false;
            var node = createBaseNode(200 /* SyntaxKind.ImportType */);
            node.argument = argument;
            node.assertions = assertion;
            node.qualifier = qualifier;
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.isTypeOf = isTypeOf;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        function updateImportTypeNode(node, argument, qualifierOrAssertions, typeArgumentsOrQualifier, isTypeOfOrTypeArguments, isTypeOf) {
            var assertion = qualifierOrAssertions && qualifierOrAssertions.kind === 295 /* SyntaxKind.ImportTypeAssertionContainer */ ? qualifierOrAssertions : undefined;
            var qualifier = qualifierOrAssertions && ts.isEntityName(qualifierOrAssertions) ? qualifierOrAssertions
                : typeArgumentsOrQualifier && !ts.isArray(typeArgumentsOrQualifier) ? typeArgumentsOrQualifier : undefined;
            var typeArguments = ts.isArray(typeArgumentsOrQualifier) ? typeArgumentsOrQualifier : ts.isArray(isTypeOfOrTypeArguments) ? isTypeOfOrTypeArguments : undefined;
            isTypeOf = typeof isTypeOfOrTypeArguments === "boolean" ? isTypeOfOrTypeArguments : typeof isTypeOf === "boolean" ? isTypeOf : node.isTypeOf;
            return node.argument !== argument
                || node.assertions !== assertion
                || node.qualifier !== qualifier
                || node.typeArguments !== typeArguments
                || node.isTypeOf !== isTypeOf
                ? update(createImportTypeNode(argument, assertion, qualifier, typeArguments, isTypeOf), node)
                : node;
        }
        // @api
        function createParenthesizedType(type) {
            var node = createBaseNode(191 /* SyntaxKind.ParenthesizedType */);
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateParenthesizedType(node, type) {
            return node.type !== type
                ? update(createParenthesizedType(type), node)
                : node;
        }
        // @api
        function createThisTypeNode() {
            var node = createBaseNode(192 /* SyntaxKind.ThisType */);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function createTypeOperatorNode(operator, type) {
            var node = createBaseNode(193 /* SyntaxKind.TypeOperator */);
            node.operator = operator;
            node.type = operator === 145 /* SyntaxKind.ReadonlyKeyword */ ?
                parenthesizerRules().parenthesizeOperandOfReadonlyTypeOperator(type) :
                parenthesizerRules().parenthesizeOperandOfTypeOperator(type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeOperatorNode(node, type) {
            return node.type !== type
                ? update(createTypeOperatorNode(node.operator, type), node)
                : node;
        }
        // @api
        function createIndexedAccessTypeNode(objectType, indexType) {
            var node = createBaseNode(194 /* SyntaxKind.IndexedAccessType */);
            node.objectType = parenthesizerRules().parenthesizeNonArrayTypeOfPostfixType(objectType);
            node.indexType = indexType;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateIndexedAccessTypeNode(node, objectType, indexType) {
            return node.objectType !== objectType
                || node.indexType !== indexType
                ? update(createIndexedAccessTypeNode(objectType, indexType), node)
                : node;
        }
        // @api
        function createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members) {
            var node = createBaseNode(195 /* SyntaxKind.MappedType */);
            node.readonlyToken = readonlyToken;
            node.typeParameter = typeParameter;
            node.nameType = nameType;
            node.questionToken = questionToken;
            node.type = type;
            node.members = members && createNodeArray(members);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type, members) {
            return node.readonlyToken !== readonlyToken
                || node.typeParameter !== typeParameter
                || node.nameType !== nameType
                || node.questionToken !== questionToken
                || node.type !== type
                || node.members !== members
                ? update(createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members), node)
                : node;
        }
        // @api
        function createLiteralTypeNode(literal) {
            var node = createBaseNode(196 /* SyntaxKind.LiteralType */);
            node.literal = literal;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateLiteralTypeNode(node, literal) {
            return node.literal !== literal
                ? update(createLiteralTypeNode(literal), node)
                : node;
        }
        //
        // Binding Patterns
        //
        // @api
        function createObjectBindingPattern(elements) {
            var node = createBaseNode(201 /* SyntaxKind.ObjectBindingPattern */);
            node.elements = createNodeArray(elements);
            node.transformFlags |=
                propagateChildrenFlags(node.elements) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    262144 /* TransformFlags.ContainsBindingPattern */;
            if (node.transformFlags & 16384 /* TransformFlags.ContainsRestOrSpread */) {
                node.transformFlags |=
                    128 /* TransformFlags.ContainsES2018 */ |
                        32768 /* TransformFlags.ContainsObjectRestOrSpread */;
            }
            return node;
        }
        // @api
        function updateObjectBindingPattern(node, elements) {
            return node.elements !== elements
                ? update(createObjectBindingPattern(elements), node)
                : node;
        }
        // @api
        function createArrayBindingPattern(elements) {
            var node = createBaseNode(202 /* SyntaxKind.ArrayBindingPattern */);
            node.elements = createNodeArray(elements);
            node.transformFlags |=
                propagateChildrenFlags(node.elements) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    262144 /* TransformFlags.ContainsBindingPattern */;
            return node;
        }
        // @api
        function updateArrayBindingPattern(node, elements) {
            return node.elements !== elements
                ? update(createArrayBindingPattern(elements), node)
                : node;
        }
        // @api
        function createBindingElement(dotDotDotToken, propertyName, name, initializer) {
            var node = createBaseBindingLikeDeclaration(203 /* SyntaxKind.BindingElement */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, name, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.propertyName = asName(propertyName);
            node.dotDotDotToken = dotDotDotToken;
            node.transformFlags |=
                propagateChildFlags(node.dotDotDotToken) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (node.propertyName) {
                node.transformFlags |= ts.isIdentifier(node.propertyName) ?
                    propagateIdentifierNameFlags(node.propertyName) :
                    propagateChildFlags(node.propertyName);
            }
            if (dotDotDotToken)
                node.transformFlags |= 16384 /* TransformFlags.ContainsRestOrSpread */;
            return node;
        }
        // @api
        function updateBindingElement(node, dotDotDotToken, propertyName, name, initializer) {
            return node.propertyName !== propertyName
                || node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.initializer !== initializer
                ? update(createBindingElement(dotDotDotToken, propertyName, name, initializer), node)
                : node;
        }
        //
        // Expression
        //
        function createBaseExpression(kind) {
            var node = createBaseNode(kind);
            // the following properties are commonly set by the checker/binder
            return node;
        }
        // @api
        function createArrayLiteralExpression(elements, multiLine) {
            var node = createBaseExpression(204 /* SyntaxKind.ArrayLiteralExpression */);
            // Ensure we add a trailing comma for something like `[NumericLiteral(1), NumericLiteral(2), OmittedExpresion]` so that
            // we end up with `[1, 2, ,]` instead of `[1, 2, ]` otherwise the `OmittedExpression` will just end up being treated like
            // a trailing comma.
            var lastElement = elements && ts.lastOrUndefined(elements);
            var elementsArray = createNodeArray(elements, lastElement && ts.isOmittedExpression(lastElement) ? true : undefined);
            node.elements = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(elementsArray);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.elements);
            return node;
        }
        // @api
        function updateArrayLiteralExpression(node, elements) {
            return node.elements !== elements
                ? update(createArrayLiteralExpression(elements, node.multiLine), node)
                : node;
        }
        // @api
        function createObjectLiteralExpression(properties, multiLine) {
            var node = createBaseExpression(205 /* SyntaxKind.ObjectLiteralExpression */);
            node.properties = createNodeArray(properties);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.properties);
            return node;
        }
        // @api
        function updateObjectLiteralExpression(node, properties) {
            return node.properties !== properties
                ? update(createObjectLiteralExpression(properties, node.multiLine), node)
                : node;
        }
        // @api
        function createPropertyAccessExpression(expression, name) {
            var node = createBaseExpression(206 /* SyntaxKind.PropertyAccessExpression */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.name = asName(name);
            node.transformFlags =
                propagateChildFlags(node.expression) |
                    (ts.isIdentifier(node.name) ?
                        propagateIdentifierNameFlags(node.name) :
                        propagateChildFlags(node.name));
            if (ts.isSuperKeyword(expression)) {
                // super method calls require a lexical 'this'
                // super method calls require 'super' hoisting in ES2017 and ES2018 async functions and async generators
                node.transformFlags |=
                    256 /* TransformFlags.ContainsES2017 */ |
                        128 /* TransformFlags.ContainsES2018 */;
            }
            return node;
        }
        // @api
        function updatePropertyAccessExpression(node, expression, name) {
            if (ts.isPropertyAccessChain(node)) {
                return updatePropertyAccessChain(node, expression, node.questionDotToken, ts.cast(name, ts.isIdentifier));
            }
            return node.expression !== expression
                || node.name !== name
                ? update(createPropertyAccessExpression(expression, name), node)
                : node;
        }
        // @api
        function createPropertyAccessChain(expression, questionDotToken, name) {
            var node = createBaseExpression(206 /* SyntaxKind.PropertyAccessExpression */);
            node.flags |= 32 /* NodeFlags.OptionalChain */;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.questionDotToken = questionDotToken;
            node.name = asName(name);
            node.transformFlags |=
                32 /* TransformFlags.ContainsES2020 */ |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    (ts.isIdentifier(node.name) ?
                        propagateIdentifierNameFlags(node.name) :
                        propagateChildFlags(node.name));
            return node;
        }
        // @api
        function updatePropertyAccessChain(node, expression, questionDotToken, name) {
            ts.Debug.assert(!!(node.flags & 32 /* NodeFlags.OptionalChain */), "Cannot update a PropertyAccessExpression using updatePropertyAccessChain. Use updatePropertyAccess instead.");
            // Because we are updating an existing PropertyAccessChain we want to inherit its emitFlags
            // instead of using the default from createPropertyAccess
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.name !== name
                ? update(createPropertyAccessChain(expression, questionDotToken, name), node)
                : node;
        }
        // @api
        function createElementAccessExpression(expression, index) {
            var node = createBaseExpression(207 /* SyntaxKind.ElementAccessExpression */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.argumentExpression = asExpression(index);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.argumentExpression);
            if (ts.isSuperKeyword(expression)) {
                // super method calls require a lexical 'this'
                // super method calls require 'super' hoisting in ES2017 and ES2018 async functions and async generators
                node.transformFlags |=
                    256 /* TransformFlags.ContainsES2017 */ |
                        128 /* TransformFlags.ContainsES2018 */;
            }
            return node;
        }
        // @api
        function updateElementAccessExpression(node, expression, argumentExpression) {
            if (ts.isElementAccessChain(node)) {
                return updateElementAccessChain(node, expression, node.questionDotToken, argumentExpression);
            }
            return node.expression !== expression
                || node.argumentExpression !== argumentExpression
                ? update(createElementAccessExpression(expression, argumentExpression), node)
                : node;
        }
        // @api
        function createElementAccessChain(expression, questionDotToken, index) {
            var node = createBaseExpression(207 /* SyntaxKind.ElementAccessExpression */);
            node.flags |= 32 /* NodeFlags.OptionalChain */;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.questionDotToken = questionDotToken;
            node.argumentExpression = asExpression(index);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    propagateChildFlags(node.argumentExpression) |
                    32 /* TransformFlags.ContainsES2020 */;
            return node;
        }
        // @api
        function updateElementAccessChain(node, expression, questionDotToken, argumentExpression) {
            ts.Debug.assert(!!(node.flags & 32 /* NodeFlags.OptionalChain */), "Cannot update a ElementAccessExpression using updateElementAccessChain. Use updateElementAccess instead.");
            // Because we are updating an existing ElementAccessChain we want to inherit its emitFlags
            // instead of using the default from createElementAccess
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.argumentExpression !== argumentExpression
                ? update(createElementAccessChain(expression, questionDotToken, argumentExpression), node)
                : node;
        }
        // @api
        function createCallExpression(expression, typeArguments, argumentsArray) {
            var node = createBaseExpression(208 /* SyntaxKind.CallExpression */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(createNodeArray(argumentsArray));
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments);
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.isImportKeyword(node.expression)) {
                node.transformFlags |= 4194304 /* TransformFlags.ContainsDynamicImport */;
            }
            else if (ts.isSuperProperty(node.expression)) {
                node.transformFlags |= 8192 /* TransformFlags.ContainsLexicalThis */;
            }
            return node;
        }
        // @api
        function updateCallExpression(node, expression, typeArguments, argumentsArray) {
            if (ts.isCallChain(node)) {
                return updateCallChain(node, expression, node.questionDotToken, typeArguments, argumentsArray);
            }
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createCallExpression(expression, typeArguments, argumentsArray), node)
                : node;
        }
        // @api
        function createCallChain(expression, questionDotToken, typeArguments, argumentsArray) {
            var node = createBaseExpression(208 /* SyntaxKind.CallExpression */);
            node.flags |= 32 /* NodeFlags.OptionalChain */;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.questionDotToken = questionDotToken;
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(createNodeArray(argumentsArray));
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments) |
                    32 /* TransformFlags.ContainsES2020 */;
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.isSuperProperty(node.expression)) {
                node.transformFlags |= 8192 /* TransformFlags.ContainsLexicalThis */;
            }
            return node;
        }
        // @api
        function updateCallChain(node, expression, questionDotToken, typeArguments, argumentsArray) {
            ts.Debug.assert(!!(node.flags & 32 /* NodeFlags.OptionalChain */), "Cannot update a CallExpression using updateCallChain. Use updateCall instead.");
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createCallChain(expression, questionDotToken, typeArguments, argumentsArray), node)
                : node;
        }
        // @api
        function createNewExpression(expression, typeArguments, argumentsArray) {
            var node = createBaseExpression(209 /* SyntaxKind.NewExpression */);
            node.expression = parenthesizerRules().parenthesizeExpressionOfNew(expression);
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = argumentsArray ? parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(argumentsArray) : undefined;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments) |
                    32 /* TransformFlags.ContainsES2020 */;
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateNewExpression(node, expression, typeArguments, argumentsArray) {
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createNewExpression(expression, typeArguments, argumentsArray), node)
                : node;
        }
        // @api
        function createTaggedTemplateExpression(tag, typeArguments, template) {
            var node = createBaseExpression(210 /* SyntaxKind.TaggedTemplateExpression */);
            node.tag = parenthesizerRules().parenthesizeLeftSideOfAccess(tag);
            node.typeArguments = asNodeArray(typeArguments);
            node.template = template;
            node.transformFlags |=
                propagateChildFlags(node.tag) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.template) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.hasInvalidEscape(node.template)) {
                node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
            }
            return node;
        }
        // @api
        function updateTaggedTemplateExpression(node, tag, typeArguments, template) {
            return node.tag !== tag
                || node.typeArguments !== typeArguments
                || node.template !== template
                ? update(createTaggedTemplateExpression(tag, typeArguments, template), node)
                : node;
        }
        // @api
        function createTypeAssertion(type, expression) {
            var node = createBaseExpression(211 /* SyntaxKind.TypeAssertionExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.type = type;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.type) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeAssertion(node, type, expression) {
            return node.type !== type
                || node.expression !== expression
                ? update(createTypeAssertion(type, expression), node)
                : node;
        }
        // @api
        function createParenthesizedExpression(expression) {
            var node = createBaseExpression(212 /* SyntaxKind.ParenthesizedExpression */);
            node.expression = expression;
            node.transformFlags = propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateParenthesizedExpression(node, expression) {
            return node.expression !== expression
                ? update(createParenthesizedExpression(expression), node)
                : node;
        }
        // @api
        function createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(213 /* SyntaxKind.FunctionExpression */, 
            /*decorators*/ undefined, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            node.transformFlags |= propagateChildFlags(node.asteriskToken);
            if (node.typeParameters) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.modifiersToFlags(node.modifiers) & 256 /* ModifierFlags.Async */) {
                if (node.asteriskToken) {
                    node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
                }
                else {
                    node.transformFlags |= 256 /* TransformFlags.ContainsES2017 */;
                }
            }
            else if (node.asteriskToken) {
                node.transformFlags |= 2048 /* TransformFlags.ContainsGenerator */;
            }
            return node;
        }
        // @api
        function updateFunctionExpression(node, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            return node.name !== name
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body), node)
                : node;
        }
        // @api
        function createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body) {
            var node = createBaseFunctionLikeDeclaration(214 /* SyntaxKind.ArrowFunction */, 
            /*decorators*/ undefined, modifiers, 
            /*name*/ undefined, typeParameters, parameters, type, parenthesizerRules().parenthesizeConciseBodyOfArrowFunction(body));
            node.equalsGreaterThanToken = equalsGreaterThanToken !== null && equalsGreaterThanToken !== void 0 ? equalsGreaterThanToken : createToken(38 /* SyntaxKind.EqualsGreaterThanToken */);
            node.transformFlags |=
                propagateChildFlags(node.equalsGreaterThanToken) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (ts.modifiersToFlags(node.modifiers) & 256 /* ModifierFlags.Async */) {
                node.transformFlags |= 256 /* TransformFlags.ContainsES2017 */ | 8192 /* TransformFlags.ContainsLexicalThis */;
            }
            return node;
        }
        // @api
        function updateArrowFunction(node, modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body) {
            return node.modifiers !== modifiers
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.equalsGreaterThanToken !== equalsGreaterThanToken
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body), node)
                : node;
        }
        // @api
        function createDeleteExpression(expression) {
            var node = createBaseExpression(215 /* SyntaxKind.DeleteExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateDeleteExpression(node, expression) {
            return node.expression !== expression
                ? update(createDeleteExpression(expression), node)
                : node;
        }
        // @api
        function createTypeOfExpression(expression) {
            var node = createBaseExpression(216 /* SyntaxKind.TypeOfExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateTypeOfExpression(node, expression) {
            return node.expression !== expression
                ? update(createTypeOfExpression(expression), node)
                : node;
        }
        // @api
        function createVoidExpression(expression) {
            var node = createBaseExpression(217 /* SyntaxKind.VoidExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateVoidExpression(node, expression) {
            return node.expression !== expression
                ? update(createVoidExpression(expression), node)
                : node;
        }
        // @api
        function createAwaitExpression(expression) {
            var node = createBaseExpression(218 /* SyntaxKind.AwaitExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    256 /* TransformFlags.ContainsES2017 */ |
                    128 /* TransformFlags.ContainsES2018 */ |
                    1048576 /* TransformFlags.ContainsAwait */;
            return node;
        }
        // @api
        function updateAwaitExpression(node, expression) {
            return node.expression !== expression
                ? update(createAwaitExpression(expression), node)
                : node;
        }
        // @api
        function createPrefixUnaryExpression(operator, operand) {
            var node = createBaseExpression(219 /* SyntaxKind.PrefixUnaryExpression */);
            node.operator = operator;
            node.operand = parenthesizerRules().parenthesizeOperandOfPrefixUnary(operand);
            node.transformFlags |= propagateChildFlags(node.operand);
            // Only set this flag for non-generated identifiers and non-"local" names. See the
            // comment in `visitPreOrPostfixUnaryExpression` in module.ts
            if ((operator === 45 /* SyntaxKind.PlusPlusToken */ || operator === 46 /* SyntaxKind.MinusMinusToken */) &&
                ts.isIdentifier(node.operand) &&
                !ts.isGeneratedIdentifier(node.operand) &&
                !ts.isLocalName(node.operand)) {
                node.transformFlags |= 67108864 /* TransformFlags.ContainsUpdateExpressionForIdentifier */;
            }
            return node;
        }
        // @api
        function updatePrefixUnaryExpression(node, operand) {
            return node.operand !== operand
                ? update(createPrefixUnaryExpression(node.operator, operand), node)
                : node;
        }
        // @api
        function createPostfixUnaryExpression(operand, operator) {
            var node = createBaseExpression(220 /* SyntaxKind.PostfixUnaryExpression */);
            node.operator = operator;
            node.operand = parenthesizerRules().parenthesizeOperandOfPostfixUnary(operand);
            node.transformFlags |= propagateChildFlags(node.operand);
            // Only set this flag for non-generated identifiers and non-"local" names. See the
            // comment in `visitPreOrPostfixUnaryExpression` in module.ts
            if (ts.isIdentifier(node.operand) &&
                !ts.isGeneratedIdentifier(node.operand) &&
                !ts.isLocalName(node.operand)) {
                node.transformFlags |= 67108864 /* TransformFlags.ContainsUpdateExpressionForIdentifier */;
            }
            return node;
        }
        // @api
        function updatePostfixUnaryExpression(node, operand) {
            return node.operand !== operand
                ? update(createPostfixUnaryExpression(operand, node.operator), node)
                : node;
        }
        // @api
        function createBinaryExpression(left, operator, right) {
            var node = createBaseExpression(221 /* SyntaxKind.BinaryExpression */);
            var operatorToken = asToken(operator);
            var operatorKind = operatorToken.kind;
            node.left = parenthesizerRules().parenthesizeLeftSideOfBinary(operatorKind, left);
            node.operatorToken = operatorToken;
            node.right = parenthesizerRules().parenthesizeRightSideOfBinary(operatorKind, node.left, right);
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateChildFlags(node.operatorToken) |
                    propagateChildFlags(node.right);
            if (operatorKind === 60 /* SyntaxKind.QuestionQuestionToken */) {
                node.transformFlags |= 32 /* TransformFlags.ContainsES2020 */;
            }
            else if (operatorKind === 63 /* SyntaxKind.EqualsToken */) {
                if (ts.isObjectLiteralExpression(node.left)) {
                    node.transformFlags |=
                        1024 /* TransformFlags.ContainsES2015 */ |
                            128 /* TransformFlags.ContainsES2018 */ |
                            4096 /* TransformFlags.ContainsDestructuringAssignment */ |
                            propagateAssignmentPatternFlags(node.left);
                }
                else if (ts.isArrayLiteralExpression(node.left)) {
                    node.transformFlags |=
                        1024 /* TransformFlags.ContainsES2015 */ |
                            4096 /* TransformFlags.ContainsDestructuringAssignment */ |
                            propagateAssignmentPatternFlags(node.left);
                }
            }
            else if (operatorKind === 42 /* SyntaxKind.AsteriskAsteriskToken */ || operatorKind === 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */) {
                node.transformFlags |= 512 /* TransformFlags.ContainsES2016 */;
            }
            else if (ts.isLogicalOrCoalescingAssignmentOperator(operatorKind)) {
                node.transformFlags |= 16 /* TransformFlags.ContainsES2021 */;
            }
            return node;
        }
        function propagateAssignmentPatternFlags(node) {
            if (node.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */)
                return 32768 /* TransformFlags.ContainsObjectRestOrSpread */;
            if (node.transformFlags & 128 /* TransformFlags.ContainsES2018 */) {
                // check for nested spread assignments, otherwise '{ x: { a, ...b } = foo } = c'
                // will not be correctly interpreted by the ES2018 transformer
                for (var _i = 0, _a = ts.getElementsOfBindingOrAssignmentPattern(node); _i < _a.length; _i++) {
                    var element = _a[_i];
                    var target = ts.getTargetOfBindingOrAssignmentElement(element);
                    if (target && ts.isAssignmentPattern(target)) {
                        if (target.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                            return 32768 /* TransformFlags.ContainsObjectRestOrSpread */;
                        }
                        if (target.transformFlags & 128 /* TransformFlags.ContainsES2018 */) {
                            var flags_1 = propagateAssignmentPatternFlags(target);
                            if (flags_1)
                                return flags_1;
                        }
                    }
                }
            }
            return 0 /* TransformFlags.None */;
        }
        // @api
        function updateBinaryExpression(node, left, operator, right) {
            return node.left !== left
                || node.operatorToken !== operator
                || node.right !== right
                ? update(createBinaryExpression(left, operator, right), node)
                : node;
        }
        // @api
        function createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse) {
            var node = createBaseExpression(222 /* SyntaxKind.ConditionalExpression */);
            node.condition = parenthesizerRules().parenthesizeConditionOfConditionalExpression(condition);
            node.questionToken = questionToken !== null && questionToken !== void 0 ? questionToken : createToken(57 /* SyntaxKind.QuestionToken */);
            node.whenTrue = parenthesizerRules().parenthesizeBranchOfConditionalExpression(whenTrue);
            node.colonToken = colonToken !== null && colonToken !== void 0 ? colonToken : createToken(58 /* SyntaxKind.ColonToken */);
            node.whenFalse = parenthesizerRules().parenthesizeBranchOfConditionalExpression(whenFalse);
            node.transformFlags |=
                propagateChildFlags(node.condition) |
                    propagateChildFlags(node.questionToken) |
                    propagateChildFlags(node.whenTrue) |
                    propagateChildFlags(node.colonToken) |
                    propagateChildFlags(node.whenFalse);
            return node;
        }
        // @api
        function updateConditionalExpression(node, condition, questionToken, whenTrue, colonToken, whenFalse) {
            return node.condition !== condition
                || node.questionToken !== questionToken
                || node.whenTrue !== whenTrue
                || node.colonToken !== colonToken
                || node.whenFalse !== whenFalse
                ? update(createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse), node)
                : node;
        }
        // @api
        function createTemplateExpression(head, templateSpans) {
            var node = createBaseExpression(223 /* SyntaxKind.TemplateExpression */);
            node.head = head;
            node.templateSpans = createNodeArray(templateSpans);
            node.transformFlags |=
                propagateChildFlags(node.head) |
                    propagateChildrenFlags(node.templateSpans) |
                    1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function updateTemplateExpression(node, head, templateSpans) {
            return node.head !== head
                || node.templateSpans !== templateSpans
                ? update(createTemplateExpression(head, templateSpans), node)
                : node;
        }
        function createTemplateLiteralLikeNodeChecked(kind, text, rawText, templateFlags) {
            if (templateFlags === void 0) { templateFlags = 0 /* TokenFlags.None */; }
            ts.Debug.assert(!(templateFlags & ~2048 /* TokenFlags.TemplateLiteralLikeFlags */), "Unsupported template flags.");
            // NOTE: without the assignment to `undefined`, we don't narrow the initial type of `cooked`.
            // eslint-disable-next-line no-undef-init
            var cooked = undefined;
            if (rawText !== undefined && rawText !== text) {
                cooked = getCookedText(kind, rawText);
                if (typeof cooked === "object") {
                    return ts.Debug.fail("Invalid raw text");
                }
            }
            if (text === undefined) {
                if (cooked === undefined) {
                    return ts.Debug.fail("Arguments 'text' and 'rawText' may not both be undefined.");
                }
                text = cooked;
            }
            else if (cooked !== undefined) {
                ts.Debug.assert(text === cooked, "Expected argument 'text' to be the normalized (i.e. 'cooked') version of argument 'rawText'.");
            }
            return createTemplateLiteralLikeNode(kind, text, rawText, templateFlags);
        }
        // @api
        function createTemplateLiteralLikeNode(kind, text, rawText, templateFlags) {
            var node = createBaseToken(kind);
            node.text = text;
            node.rawText = rawText;
            node.templateFlags = templateFlags & 2048 /* TokenFlags.TemplateLiteralLikeFlags */;
            node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            if (node.templateFlags) {
                node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
            }
            return node;
        }
        // @api
        function createTemplateHead(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(15 /* SyntaxKind.TemplateHead */, text, rawText, templateFlags);
        }
        // @api
        function createTemplateMiddle(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(16 /* SyntaxKind.TemplateMiddle */, text, rawText, templateFlags);
        }
        // @api
        function createTemplateTail(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(17 /* SyntaxKind.TemplateTail */, text, rawText, templateFlags);
        }
        // @api
        function createNoSubstitutionTemplateLiteral(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(14 /* SyntaxKind.NoSubstitutionTemplateLiteral */, text, rawText, templateFlags);
        }
        // @api
        function createYieldExpression(asteriskToken, expression) {
            ts.Debug.assert(!asteriskToken || !!expression, "A `YieldExpression` with an asteriskToken must have an expression.");
            var node = createBaseExpression(224 /* SyntaxKind.YieldExpression */);
            node.expression = expression && parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.asteriskToken = asteriskToken;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.asteriskToken) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    128 /* TransformFlags.ContainsES2018 */ |
                    524288 /* TransformFlags.ContainsYield */;
            return node;
        }
        // @api
        function updateYieldExpression(node, asteriskToken, expression) {
            return node.expression !== expression
                || node.asteriskToken !== asteriskToken
                ? update(createYieldExpression(asteriskToken, expression), node)
                : node;
        }
        // @api
        function createSpreadElement(expression) {
            var node = createBaseExpression(225 /* SyntaxKind.SpreadElement */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    16384 /* TransformFlags.ContainsRestOrSpread */;
            return node;
        }
        // @api
        function updateSpreadElement(node, expression) {
            return node.expression !== expression
                ? update(createSpreadElement(expression), node)
                : node;
        }
        // @api
        function createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseClassLikeDeclaration(226 /* SyntaxKind.ClassExpression */, decorators, modifiers, name, typeParameters, heritageClauses, members);
            node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function updateClassExpression(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        // @api
        function createOmittedExpression() {
            return createBaseExpression(227 /* SyntaxKind.OmittedExpression */);
        }
        // @api
        function createExpressionWithTypeArguments(expression, typeArguments) {
            var node = createBaseNode(228 /* SyntaxKind.ExpressionWithTypeArguments */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function updateExpressionWithTypeArguments(node, expression, typeArguments) {
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                ? update(createExpressionWithTypeArguments(expression, typeArguments), node)
                : node;
        }
        // @api
        function createAsExpression(expression, type) {
            var node = createBaseExpression(229 /* SyntaxKind.AsExpression */);
            node.expression = expression;
            node.type = type;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.type) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateAsExpression(node, expression, type) {
            return node.expression !== expression
                || node.type !== type
                ? update(createAsExpression(expression, type), node)
                : node;
        }
        // @api
        function createNonNullExpression(expression) {
            var node = createBaseExpression(230 /* SyntaxKind.NonNullExpression */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNonNullExpression(node, expression) {
            if (ts.isNonNullChain(node)) {
                return updateNonNullChain(node, expression);
            }
            return node.expression !== expression
                ? update(createNonNullExpression(expression), node)
                : node;
        }
        // @api
        function createNonNullChain(expression) {
            var node = createBaseExpression(230 /* SyntaxKind.NonNullExpression */);
            node.flags |= 32 /* NodeFlags.OptionalChain */;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNonNullChain(node, expression) {
            ts.Debug.assert(!!(node.flags & 32 /* NodeFlags.OptionalChain */), "Cannot update a NonNullExpression using updateNonNullChain. Use updateNonNullExpression instead.");
            return node.expression !== expression
                ? update(createNonNullChain(expression), node)
                : node;
        }
        // @api
        function createMetaProperty(keywordToken, name) {
            var node = createBaseExpression(231 /* SyntaxKind.MetaProperty */);
            node.keywordToken = keywordToken;
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            switch (keywordToken) {
                case 103 /* SyntaxKind.NewKeyword */:
                    node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
                    break;
                case 100 /* SyntaxKind.ImportKeyword */:
                    node.transformFlags |= 4 /* TransformFlags.ContainsESNext */;
                    break;
                default:
                    return ts.Debug.assertNever(keywordToken);
            }
            return node;
        }
        // @api
        function updateMetaProperty(node, name) {
            return node.name !== name
                ? update(createMetaProperty(node.keywordToken, name), node)
                : node;
        }
        //
        // Misc
        //
        // @api
        function createTemplateSpan(expression, literal) {
            var node = createBaseNode(233 /* SyntaxKind.TemplateSpan */);
            node.expression = expression;
            node.literal = literal;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.literal) |
                    1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function updateTemplateSpan(node, expression, literal) {
            return node.expression !== expression
                || node.literal !== literal
                ? update(createTemplateSpan(expression, literal), node)
                : node;
        }
        // @api
        function createSemicolonClassElement() {
            var node = createBaseNode(234 /* SyntaxKind.SemicolonClassElement */);
            node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        //
        // Element
        //
        // @api
        function createBlock(statements, multiLine) {
            var node = createBaseNode(235 /* SyntaxKind.Block */);
            node.statements = createNodeArray(statements);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateBlock(node, statements) {
            return node.statements !== statements
                ? update(createBlock(statements, node.multiLine), node)
                : node;
        }
        // @api
        function createVariableStatement(modifiers, declarationList) {
            var node = createBaseDeclaration(237 /* SyntaxKind.VariableStatement */, /*decorators*/ undefined, modifiers);
            node.declarationList = ts.isArray(declarationList) ? createVariableDeclarationList(declarationList) : declarationList;
            node.transformFlags |=
                propagateChildFlags(node.declarationList);
            if (ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateVariableStatement(node, modifiers, declarationList) {
            return node.modifiers !== modifiers
                || node.declarationList !== declarationList
                ? update(createVariableStatement(modifiers, declarationList), node)
                : node;
        }
        // @api
        function createEmptyStatement() {
            return createBaseNode(236 /* SyntaxKind.EmptyStatement */);
        }
        // @api
        function createExpressionStatement(expression) {
            var node = createBaseNode(238 /* SyntaxKind.ExpressionStatement */);
            node.expression = parenthesizerRules().parenthesizeExpressionOfExpressionStatement(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateExpressionStatement(node, expression) {
            return node.expression !== expression
                ? update(createExpressionStatement(expression), node)
                : node;
        }
        // @api
        function createIfStatement(expression, thenStatement, elseStatement) {
            var node = createBaseNode(239 /* SyntaxKind.IfStatement */);
            node.expression = expression;
            node.thenStatement = asEmbeddedStatement(thenStatement);
            node.elseStatement = asEmbeddedStatement(elseStatement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thenStatement) |
                    propagateChildFlags(node.elseStatement);
            return node;
        }
        // @api
        function updateIfStatement(node, expression, thenStatement, elseStatement) {
            return node.expression !== expression
                || node.thenStatement !== thenStatement
                || node.elseStatement !== elseStatement
                ? update(createIfStatement(expression, thenStatement, elseStatement), node)
                : node;
        }
        // @api
        function createDoStatement(statement, expression) {
            var node = createBaseNode(240 /* SyntaxKind.DoStatement */);
            node.statement = asEmbeddedStatement(statement);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.statement) |
                    propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateDoStatement(node, statement, expression) {
            return node.statement !== statement
                || node.expression !== expression
                ? update(createDoStatement(statement, expression), node)
                : node;
        }
        // @api
        function createWhileStatement(expression, statement) {
            var node = createBaseNode(241 /* SyntaxKind.WhileStatement */);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateWhileStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWhileStatement(expression, statement), node)
                : node;
        }
        // @api
        function createForStatement(initializer, condition, incrementor, statement) {
            var node = createBaseNode(242 /* SyntaxKind.ForStatement */);
            node.initializer = initializer;
            node.condition = condition;
            node.incrementor = incrementor;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.condition) |
                    propagateChildFlags(node.incrementor) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateForStatement(node, initializer, condition, incrementor, statement) {
            return node.initializer !== initializer
                || node.condition !== condition
                || node.incrementor !== incrementor
                || node.statement !== statement
                ? update(createForStatement(initializer, condition, incrementor, statement), node)
                : node;
        }
        // @api
        function createForInStatement(initializer, expression, statement) {
            var node = createBaseNode(243 /* SyntaxKind.ForInStatement */);
            node.initializer = initializer;
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateForInStatement(node, initializer, expression, statement) {
            return node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForInStatement(initializer, expression, statement), node)
                : node;
        }
        // @api
        function createForOfStatement(awaitModifier, initializer, expression, statement) {
            var node = createBaseNode(244 /* SyntaxKind.ForOfStatement */);
            node.awaitModifier = awaitModifier;
            node.initializer = initializer;
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.awaitModifier) |
                    propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (awaitModifier)
                node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
            return node;
        }
        // @api
        function updateForOfStatement(node, awaitModifier, initializer, expression, statement) {
            return node.awaitModifier !== awaitModifier
                || node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForOfStatement(awaitModifier, initializer, expression, statement), node)
                : node;
        }
        // @api
        function createContinueStatement(label) {
            var node = createBaseNode(245 /* SyntaxKind.ContinueStatement */);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    2097152 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
            return node;
        }
        // @api
        function updateContinueStatement(node, label) {
            return node.label !== label
                ? update(createContinueStatement(label), node)
                : node;
        }
        // @api
        function createBreakStatement(label) {
            var node = createBaseNode(246 /* SyntaxKind.BreakStatement */);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    2097152 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
            return node;
        }
        // @api
        function updateBreakStatement(node, label) {
            return node.label !== label
                ? update(createBreakStatement(label), node)
                : node;
        }
        // @api
        function createReturnStatement(expression) {
            var node = createBaseNode(247 /* SyntaxKind.ReturnStatement */);
            node.expression = expression;
            // return in an ES2018 async generator must be awaited
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    128 /* TransformFlags.ContainsES2018 */ |
                    2097152 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
            return node;
        }
        // @api
        function updateReturnStatement(node, expression) {
            return node.expression !== expression
                ? update(createReturnStatement(expression), node)
                : node;
        }
        // @api
        function createWithStatement(expression, statement) {
            var node = createBaseNode(248 /* SyntaxKind.WithStatement */);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateWithStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWithStatement(expression, statement), node)
                : node;
        }
        // @api
        function createSwitchStatement(expression, caseBlock) {
            var node = createBaseNode(249 /* SyntaxKind.SwitchStatement */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.caseBlock = caseBlock;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.caseBlock);
            return node;
        }
        // @api
        function updateSwitchStatement(node, expression, caseBlock) {
            return node.expression !== expression
                || node.caseBlock !== caseBlock
                ? update(createSwitchStatement(expression, caseBlock), node)
                : node;
        }
        // @api
        function createLabeledStatement(label, statement) {
            var node = createBaseNode(250 /* SyntaxKind.LabeledStatement */);
            node.label = asName(label);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateLabeledStatement(node, label, statement) {
            return node.label !== label
                || node.statement !== statement
                ? update(createLabeledStatement(label, statement), node)
                : node;
        }
        // @api
        function createThrowStatement(expression) {
            var node = createBaseNode(251 /* SyntaxKind.ThrowStatement */);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateThrowStatement(node, expression) {
            return node.expression !== expression
                ? update(createThrowStatement(expression), node)
                : node;
        }
        // @api
        function createTryStatement(tryBlock, catchClause, finallyBlock) {
            var node = createBaseNode(252 /* SyntaxKind.TryStatement */);
            node.tryBlock = tryBlock;
            node.catchClause = catchClause;
            node.finallyBlock = finallyBlock;
            node.transformFlags |=
                propagateChildFlags(node.tryBlock) |
                    propagateChildFlags(node.catchClause) |
                    propagateChildFlags(node.finallyBlock);
            return node;
        }
        // @api
        function updateTryStatement(node, tryBlock, catchClause, finallyBlock) {
            return node.tryBlock !== tryBlock
                || node.catchClause !== catchClause
                || node.finallyBlock !== finallyBlock
                ? update(createTryStatement(tryBlock, catchClause, finallyBlock), node)
                : node;
        }
        // @api
        function createDebuggerStatement() {
            return createBaseNode(253 /* SyntaxKind.DebuggerStatement */);
        }
        // @api
        function createVariableDeclaration(name, exclamationToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(254 /* SyntaxKind.VariableDeclaration */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, name, type, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.exclamationToken = exclamationToken;
            node.transformFlags |= propagateChildFlags(node.exclamationToken);
            if (exclamationToken) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateVariableDeclaration(node, name, exclamationToken, type, initializer) {
            return node.name !== name
                || node.type !== type
                || node.exclamationToken !== exclamationToken
                || node.initializer !== initializer
                ? update(createVariableDeclaration(name, exclamationToken, type, initializer), node)
                : node;
        }
        // @api
        function createVariableDeclarationList(declarations, flags) {
            if (flags === void 0) { flags = 0 /* NodeFlags.None */; }
            var node = createBaseNode(255 /* SyntaxKind.VariableDeclarationList */);
            node.flags |= flags & 3 /* NodeFlags.BlockScoped */;
            node.declarations = createNodeArray(declarations);
            node.transformFlags |=
                propagateChildrenFlags(node.declarations) |
                    2097152 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
            if (flags & 3 /* NodeFlags.BlockScoped */) {
                node.transformFlags |=
                    1024 /* TransformFlags.ContainsES2015 */ |
                        131072 /* TransformFlags.ContainsBlockScopedBinding */;
            }
            return node;
        }
        // @api
        function updateVariableDeclarationList(node, declarations) {
            return node.declarations !== declarations
                ? update(createVariableDeclarationList(declarations, node.flags), node)
                : node;
        }
        // @api
        function createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(256 /* SyntaxKind.FunctionDeclaration */, decorators, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            if (!node.body || ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.asteriskToken) |
                        2097152 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
                if (ts.modifiersToFlags(node.modifiers) & 256 /* ModifierFlags.Async */) {
                    if (node.asteriskToken) {
                        node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
                    }
                    else {
                        node.transformFlags |= 256 /* TransformFlags.ContainsES2017 */;
                    }
                }
                else if (node.asteriskToken) {
                    node.transformFlags |= 2048 /* TransformFlags.ContainsGenerator */;
                }
            }
            return node;
        }
        // @api
        function updateFunctionDeclaration(node, decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body), node)
                : node;
        }
        // @api
        function createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseClassLikeDeclaration(257 /* SyntaxKind.ClassDeclaration */, decorators, modifiers, name, typeParameters, heritageClauses, members);
            if (ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            else {
                node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
                if (node.transformFlags & 4096 /* TransformFlags.ContainsTypeScriptClassSyntax */) {
                    node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
                }
            }
            return node;
        }
        // @api
        function updateClassDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        // @api
        function createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseInterfaceOrClassLikeDeclaration(258 /* SyntaxKind.InterfaceDeclaration */, decorators, modifiers, name, typeParameters, heritageClauses);
            node.members = createNodeArray(members);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateInterfaceDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        // @api
        function createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type) {
            var node = createBaseGenericNamedDeclaration(259 /* SyntaxKind.TypeAliasDeclaration */, decorators, modifiers, name, typeParameters);
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeAliasDeclaration(node, decorators, modifiers, name, typeParameters, type) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.type !== type
                ? update(createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type), node)
                : node;
        }
        // @api
        function createEnumDeclaration(decorators, modifiers, name, members) {
            var node = createBaseNamedDeclaration(260 /* SyntaxKind.EnumDeclaration */, decorators, modifiers, name);
            node.members = createNodeArray(members);
            node.transformFlags |=
                propagateChildrenFlags(node.members) |
                    1 /* TransformFlags.ContainsTypeScript */;
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // Enum declarations cannot contain `await`
            return node;
        }
        // @api
        function updateEnumDeclaration(node, decorators, modifiers, name, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.members !== members
                ? update(createEnumDeclaration(decorators, modifiers, name, members), node)
                : node;
        }
        // @api
        function createModuleDeclaration(decorators, modifiers, name, body, flags) {
            if (flags === void 0) { flags = 0 /* NodeFlags.None */; }
            var node = createBaseDeclaration(261 /* SyntaxKind.ModuleDeclaration */, decorators, modifiers);
            node.flags |= flags & (16 /* NodeFlags.Namespace */ | 4 /* NodeFlags.NestedNamespace */ | 1024 /* NodeFlags.GlobalAugmentation */);
            node.name = name;
            node.body = body;
            if (ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.name) |
                        propagateChildFlags(node.body) |
                        1 /* TransformFlags.ContainsTypeScript */;
            }
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // Module declarations cannot contain `await`.
            return node;
        }
        // @api
        function updateModuleDeclaration(node, decorators, modifiers, name, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.body !== body
                ? update(createModuleDeclaration(decorators, modifiers, name, body, node.flags), node)
                : node;
        }
        // @api
        function createModuleBlock(statements) {
            var node = createBaseNode(262 /* SyntaxKind.ModuleBlock */);
            node.statements = createNodeArray(statements);
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateModuleBlock(node, statements) {
            return node.statements !== statements
                ? update(createModuleBlock(statements), node)
                : node;
        }
        // @api
        function createCaseBlock(clauses) {
            var node = createBaseNode(263 /* SyntaxKind.CaseBlock */);
            node.clauses = createNodeArray(clauses);
            node.transformFlags |= propagateChildrenFlags(node.clauses);
            return node;
        }
        // @api
        function updateCaseBlock(node, clauses) {
            return node.clauses !== clauses
                ? update(createCaseBlock(clauses), node)
                : node;
        }
        // @api
        function createNamespaceExportDeclaration(name) {
            var node = createBaseNamedDeclaration(264 /* SyntaxKind.NamespaceExportDeclaration */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, name);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNamespaceExportDeclaration(node, name) {
            return node.name !== name
                ? update(createNamespaceExportDeclaration(name), node)
                : node;
        }
        // @api
        function createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, name, moduleReference) {
            var node = createBaseNamedDeclaration(265 /* SyntaxKind.ImportEqualsDeclaration */, decorators, modifiers, name);
            node.isTypeOnly = isTypeOnly;
            node.moduleReference = moduleReference;
            node.transformFlags |= propagateChildFlags(node.moduleReference);
            if (!ts.isExternalModuleReference(node.moduleReference))
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // Import= declaration is always parsed in an Await context
            return node;
        }
        // @api
        function updateImportEqualsDeclaration(node, decorators, modifiers, isTypeOnly, name, moduleReference) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.moduleReference !== moduleReference
                ? update(createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, name, moduleReference), node)
                : node;
        }
        // @api
        function createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier, assertClause) {
            var node = createBaseDeclaration(266 /* SyntaxKind.ImportDeclaration */, decorators, modifiers);
            node.importClause = importClause;
            node.moduleSpecifier = moduleSpecifier;
            node.assertClause = assertClause;
            node.transformFlags |=
                propagateChildFlags(node.importClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateImportDeclaration(node, decorators, modifiers, importClause, moduleSpecifier, assertClause) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.importClause !== importClause
                || node.moduleSpecifier !== moduleSpecifier
                || node.assertClause !== assertClause
                ? update(createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier, assertClause), node)
                : node;
        }
        // @api
        function createImportClause(isTypeOnly, name, namedBindings) {
            var node = createBaseNode(267 /* SyntaxKind.ImportClause */);
            node.isTypeOnly = isTypeOnly;
            node.name = name;
            node.namedBindings = namedBindings;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.namedBindings);
            if (isTypeOnly) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateImportClause(node, isTypeOnly, name, namedBindings) {
            return node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.namedBindings !== namedBindings
                ? update(createImportClause(isTypeOnly, name, namedBindings), node)
                : node;
        }
        // @api
        function createAssertClause(elements, multiLine) {
            var node = createBaseNode(293 /* SyntaxKind.AssertClause */);
            node.elements = createNodeArray(elements);
            node.multiLine = multiLine;
            node.transformFlags |= 4 /* TransformFlags.ContainsESNext */;
            return node;
        }
        // @api
        function updateAssertClause(node, elements, multiLine) {
            return node.elements !== elements
                || node.multiLine !== multiLine
                ? update(createAssertClause(elements, multiLine), node)
                : node;
        }
        // @api
        function createAssertEntry(name, value) {
            var node = createBaseNode(294 /* SyntaxKind.AssertEntry */);
            node.name = name;
            node.value = value;
            node.transformFlags |= 4 /* TransformFlags.ContainsESNext */;
            return node;
        }
        // @api
        function updateAssertEntry(node, name, value) {
            return node.name !== name
                || node.value !== value
                ? update(createAssertEntry(name, value), node)
                : node;
        }
        // @api
        function createImportTypeAssertionContainer(clause, multiLine) {
            var node = createBaseNode(295 /* SyntaxKind.ImportTypeAssertionContainer */);
            node.assertClause = clause;
            node.multiLine = multiLine;
            return node;
        }
        // @api
        function updateImportTypeAssertionContainer(node, clause, multiLine) {
            return node.assertClause !== clause
                || node.multiLine !== multiLine
                ? update(createImportTypeAssertionContainer(clause, multiLine), node)
                : node;
        }
        // @api
        function createNamespaceImport(name) {
            var node = createBaseNode(268 /* SyntaxKind.NamespaceImport */);
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamespaceImport(node, name) {
            return node.name !== name
                ? update(createNamespaceImport(name), node)
                : node;
        }
        // @api
        function createNamespaceExport(name) {
            var node = createBaseNode(274 /* SyntaxKind.NamespaceExport */);
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    4 /* TransformFlags.ContainsESNext */;
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamespaceExport(node, name) {
            return node.name !== name
                ? update(createNamespaceExport(name), node)
                : node;
        }
        // @api
        function createNamedImports(elements) {
            var node = createBaseNode(269 /* SyntaxKind.NamedImports */);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamedImports(node, elements) {
            return node.elements !== elements
                ? update(createNamedImports(elements), node)
                : node;
        }
        // @api
        function createImportSpecifier(isTypeOnly, propertyName, name) {
            var node = createBaseNode(270 /* SyntaxKind.ImportSpecifier */);
            node.isTypeOnly = isTypeOnly;
            node.propertyName = propertyName;
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateImportSpecifier(node, isTypeOnly, propertyName, name) {
            return node.isTypeOnly !== isTypeOnly
                || node.propertyName !== propertyName
                || node.name !== name
                ? update(createImportSpecifier(isTypeOnly, propertyName, name), node)
                : node;
        }
        // @api
        function createExportAssignment(decorators, modifiers, isExportEquals, expression) {
            var node = createBaseDeclaration(271 /* SyntaxKind.ExportAssignment */, decorators, modifiers);
            node.isExportEquals = isExportEquals;
            node.expression = isExportEquals
                ? parenthesizerRules().parenthesizeRightSideOfBinary(63 /* SyntaxKind.EqualsToken */, /*leftSide*/ undefined, expression)
                : parenthesizerRules().parenthesizeExpressionOfExportDefault(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExportAssignment(node, decorators, modifiers, expression) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.expression !== expression
                ? update(createExportAssignment(decorators, modifiers, node.isExportEquals, expression), node)
                : node;
        }
        // @api
        function createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause) {
            var node = createBaseDeclaration(272 /* SyntaxKind.ExportDeclaration */, decorators, modifiers);
            node.isTypeOnly = isTypeOnly;
            node.exportClause = exportClause;
            node.moduleSpecifier = moduleSpecifier;
            node.assertClause = assertClause;
            node.transformFlags |=
                propagateChildFlags(node.exportClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExportDeclaration(node, decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.exportClause !== exportClause
                || node.moduleSpecifier !== moduleSpecifier
                || node.assertClause !== assertClause
                ? update(createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause), node)
                : node;
        }
        // @api
        function createNamedExports(elements) {
            var node = createBaseNode(273 /* SyntaxKind.NamedExports */);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamedExports(node, elements) {
            return node.elements !== elements
                ? update(createNamedExports(elements), node)
                : node;
        }
        // @api
        function createExportSpecifier(isTypeOnly, propertyName, name) {
            var node = createBaseNode(275 /* SyntaxKind.ExportSpecifier */);
            node.isTypeOnly = isTypeOnly;
            node.propertyName = asName(propertyName);
            node.name = asName(name);
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExportSpecifier(node, isTypeOnly, propertyName, name) {
            return node.isTypeOnly !== isTypeOnly
                || node.propertyName !== propertyName
                || node.name !== name
                ? update(createExportSpecifier(isTypeOnly, propertyName, name), node)
                : node;
        }
        // @api
        function createMissingDeclaration() {
            var node = createBaseDeclaration(276 /* SyntaxKind.MissingDeclaration */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined);
            return node;
        }
        //
        // Module references
        //
        // @api
        function createExternalModuleReference(expression) {
            var node = createBaseNode(277 /* SyntaxKind.ExternalModuleReference */);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            node.transformFlags &= ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExternalModuleReference(node, expression) {
            return node.expression !== expression
                ? update(createExternalModuleReference(expression), node)
                : node;
        }
        //
        // JSDoc
        //
        // @api
        // createJSDocAllType
        // createJSDocUnknownType
        function createJSDocPrimaryTypeWorker(kind) {
            return createBaseNode(kind);
        }
        // @api
        // createJSDocNullableType
        // createJSDocNonNullableType
        function createJSDocPrePostfixUnaryTypeWorker(kind, type, postfix) {
            if (postfix === void 0) { postfix = false; }
            var node = createJSDocUnaryTypeWorker(kind, postfix ? type && parenthesizerRules().parenthesizeNonArrayTypeOfPostfixType(type) : type);
            node.postfix = postfix;
            return node;
        }
        // @api
        // createJSDocOptionalType
        // createJSDocVariadicType
        // createJSDocNamepathType
        function createJSDocUnaryTypeWorker(kind, type) {
            var node = createBaseNode(kind);
            node.type = type;
            return node;
        }
        // @api
        // updateJSDocNonNullableType
        // updateJSDocNullableType
        function updateJSDocPrePostfixUnaryTypeWorker(kind, node, type) {
            return node.type !== type
                ? update(createJSDocPrePostfixUnaryTypeWorker(kind, type, node.postfix), node)
                : node;
        }
        // @api
        // updateJSDocOptionalType
        // updateJSDocVariadicType
        // updateJSDocNamepathType
        function updateJSDocUnaryTypeWorker(kind, node, type) {
            return node.type !== type
                ? update(createJSDocUnaryTypeWorker(kind, type), node)
                : node;
        }
        // @api
        function createJSDocFunctionType(parameters, type) {
            var node = createBaseSignatureDeclaration(317 /* SyntaxKind.JSDocFunctionType */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, parameters, type);
            return node;
        }
        // @api
        function updateJSDocFunctionType(node, parameters, type) {
            return node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocFunctionType(parameters, type), node)
                : node;
        }
        // @api
        function createJSDocTypeLiteral(propertyTags, isArrayType) {
            if (isArrayType === void 0) { isArrayType = false; }
            var node = createBaseNode(322 /* SyntaxKind.JSDocTypeLiteral */);
            node.jsDocPropertyTags = asNodeArray(propertyTags);
            node.isArrayType = isArrayType;
            return node;
        }
        // @api
        function updateJSDocTypeLiteral(node, propertyTags, isArrayType) {
            return node.jsDocPropertyTags !== propertyTags
                || node.isArrayType !== isArrayType
                ? update(createJSDocTypeLiteral(propertyTags, isArrayType), node)
                : node;
        }
        // @api
        function createJSDocTypeExpression(type) {
            var node = createBaseNode(309 /* SyntaxKind.JSDocTypeExpression */);
            node.type = type;
            return node;
        }
        // @api
        function updateJSDocTypeExpression(node, type) {
            return node.type !== type
                ? update(createJSDocTypeExpression(type), node)
                : node;
        }
        // @api
        function createJSDocSignature(typeParameters, parameters, type) {
            var node = createBaseNode(323 /* SyntaxKind.JSDocSignature */);
            node.typeParameters = asNodeArray(typeParameters);
            node.parameters = createNodeArray(parameters);
            node.type = type;
            return node;
        }
        // @api
        function updateJSDocSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocSignature(typeParameters, parameters, type), node)
                : node;
        }
        function getDefaultTagName(node) {
            var defaultTagName = getDefaultTagNameForKind(node.kind);
            return node.tagName.escapedText === ts.escapeLeadingUnderscores(defaultTagName)
                ? node.tagName
                : createIdentifier(defaultTagName);
        }
        // @api
        function createBaseJSDocTag(kind, tagName, comment) {
            var node = createBaseNode(kind);
            node.tagName = tagName;
            node.comment = comment;
            return node;
        }
        // @api
        function createJSDocTemplateTag(tagName, constraint, typeParameters, comment) {
            var node = createBaseJSDocTag(344 /* SyntaxKind.JSDocTemplateTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("template"), comment);
            node.constraint = constraint;
            node.typeParameters = createNodeArray(typeParameters);
            return node;
        }
        // @api
        function updateJSDocTemplateTag(node, tagName, constraint, typeParameters, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.constraint !== constraint
                || node.typeParameters !== typeParameters
                || node.comment !== comment
                ? update(createJSDocTemplateTag(tagName, constraint, typeParameters, comment), node)
                : node;
        }
        // @api
        function createJSDocTypedefTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(345 /* SyntaxKind.JSDocTypedefTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("typedef"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        // @api
        function updateJSDocTypedefTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocTypedefTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        // @api
        function createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(340 /* SyntaxKind.JSDocParameterTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("param"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        // @api
        function updateJSDocParameterTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        // @api
        function createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(347 /* SyntaxKind.JSDocPropertyTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("prop"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        // @api
        function updateJSDocPropertyTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        // @api
        function createJSDocCallbackTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(338 /* SyntaxKind.JSDocCallbackTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("callback"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        // @api
        function updateJSDocCallbackTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocCallbackTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        // @api
        function createJSDocAugmentsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(328 /* SyntaxKind.JSDocAugmentsTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("augments"), comment);
            node.class = className;
            return node;
        }
        // @api
        function updateJSDocAugmentsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocAugmentsTag(tagName, className, comment), node)
                : node;
        }
        // @api
        function createJSDocImplementsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(329 /* SyntaxKind.JSDocImplementsTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("implements"), comment);
            node.class = className;
            return node;
        }
        // @api
        function createJSDocSeeTag(tagName, name, comment) {
            var node = createBaseJSDocTag(346 /* SyntaxKind.JSDocSeeTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("see"), comment);
            node.name = name;
            return node;
        }
        // @api
        function updateJSDocSeeTag(node, tagName, name, comment) {
            return node.tagName !== tagName
                || node.name !== name
                || node.comment !== comment
                ? update(createJSDocSeeTag(tagName, name, comment), node)
                : node;
        }
        // @api
        function createJSDocNameReference(name) {
            var node = createBaseNode(310 /* SyntaxKind.JSDocNameReference */);
            node.name = name;
            return node;
        }
        // @api
        function updateJSDocNameReference(node, name) {
            return node.name !== name
                ? update(createJSDocNameReference(name), node)
                : node;
        }
        // @api
        function createJSDocMemberName(left, right) {
            var node = createBaseNode(311 /* SyntaxKind.JSDocMemberName */);
            node.left = left;
            node.right = right;
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateChildFlags(node.right);
            return node;
        }
        // @api
        function updateJSDocMemberName(node, left, right) {
            return node.left !== left
                || node.right !== right
                ? update(createJSDocMemberName(left, right), node)
                : node;
        }
        // @api
        function createJSDocLink(name, text) {
            var node = createBaseNode(324 /* SyntaxKind.JSDocLink */);
            node.name = name;
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocLink(node, name, text) {
            return node.name !== name
                ? update(createJSDocLink(name, text), node)
                : node;
        }
        // @api
        function createJSDocLinkCode(name, text) {
            var node = createBaseNode(325 /* SyntaxKind.JSDocLinkCode */);
            node.name = name;
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocLinkCode(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkCode(name, text), node)
                : node;
        }
        // @api
        function createJSDocLinkPlain(name, text) {
            var node = createBaseNode(326 /* SyntaxKind.JSDocLinkPlain */);
            node.name = name;
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocLinkPlain(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkPlain(name, text), node)
                : node;
        }
        // @api
        function updateJSDocImplementsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocImplementsTag(tagName, className, comment), node)
                : node;
        }
        // @api
        // createJSDocAuthorTag
        // createJSDocClassTag
        // createJSDocPublicTag
        // createJSDocPrivateTag
        // createJSDocProtectedTag
        // createJSDocReadonlyTag
        // createJSDocDeprecatedTag
        function createJSDocSimpleTagWorker(kind, tagName, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            return node;
        }
        // @api
        // updateJSDocAuthorTag
        // updateJSDocClassTag
        // updateJSDocPublicTag
        // updateJSDocPrivateTag
        // updateJSDocProtectedTag
        // updateJSDocReadonlyTag
        // updateJSDocDeprecatedTag
        function updateJSDocSimpleTagWorker(kind, node, tagName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocSimpleTagWorker(kind, tagName, comment), node) :
                node;
        }
        // @api
        // createJSDocTypeTag
        // createJSDocReturnTag
        // createJSDocThisTag
        // createJSDocEnumTag
        function createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            node.typeExpression = typeExpression;
            return node;
        }
        // @api
        // updateJSDocTypeTag
        // updateJSDocReturnTag
        // updateJSDocThisTag
        // updateJSDocEnumTag
        function updateJSDocTypeLikeTagWorker(kind, node, tagName, typeExpression, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.comment !== comment
                ? update(createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment), node)
                : node;
        }
        // @api
        function createJSDocUnknownTag(tagName, comment) {
            var node = createBaseJSDocTag(327 /* SyntaxKind.JSDocTag */, tagName, comment);
            return node;
        }
        // @api
        function updateJSDocUnknownTag(node, tagName, comment) {
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocUnknownTag(tagName, comment), node)
                : node;
        }
        // @api
        function createJSDocText(text) {
            var node = createBaseNode(321 /* SyntaxKind.JSDocText */);
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocText(node, text) {
            return node.text !== text
                ? update(createJSDocText(text), node)
                : node;
        }
        // @api
        function createJSDocComment(comment, tags) {
            var node = createBaseNode(320 /* SyntaxKind.JSDoc */);
            node.comment = comment;
            node.tags = asNodeArray(tags);
            return node;
        }
        // @api
        function updateJSDocComment(node, comment, tags) {
            return node.comment !== comment
                || node.tags !== tags
                ? update(createJSDocComment(comment, tags), node)
                : node;
        }
        //
        // JSX
        //
        // @api
        function createJsxElement(openingElement, children, closingElement) {
            var node = createBaseNode(278 /* SyntaxKind.JsxElement */);
            node.openingElement = openingElement;
            node.children = createNodeArray(children);
            node.closingElement = closingElement;
            node.transformFlags |=
                propagateChildFlags(node.openingElement) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingElement) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxElement(node, openingElement, children, closingElement) {
            return node.openingElement !== openingElement
                || node.children !== children
                || node.closingElement !== closingElement
                ? update(createJsxElement(openingElement, children, closingElement), node)
                : node;
        }
        // @api
        function createJsxSelfClosingElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(279 /* SyntaxKind.JsxSelfClosingElement */);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2 /* TransformFlags.ContainsJsx */;
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateJsxSelfClosingElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxSelfClosingElement(tagName, typeArguments, attributes), node)
                : node;
        }
        // @api
        function createJsxOpeningElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(280 /* SyntaxKind.JsxOpeningElement */);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2 /* TransformFlags.ContainsJsx */;
            if (typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateJsxOpeningElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxOpeningElement(tagName, typeArguments, attributes), node)
                : node;
        }
        // @api
        function createJsxClosingElement(tagName) {
            var node = createBaseNode(281 /* SyntaxKind.JsxClosingElement */);
            node.tagName = tagName;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxClosingElement(node, tagName) {
            return node.tagName !== tagName
                ? update(createJsxClosingElement(tagName), node)
                : node;
        }
        // @api
        function createJsxFragment(openingFragment, children, closingFragment) {
            var node = createBaseNode(282 /* SyntaxKind.JsxFragment */);
            node.openingFragment = openingFragment;
            node.children = createNodeArray(children);
            node.closingFragment = closingFragment;
            node.transformFlags |=
                propagateChildFlags(node.openingFragment) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingFragment) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxFragment(node, openingFragment, children, closingFragment) {
            return node.openingFragment !== openingFragment
                || node.children !== children
                || node.closingFragment !== closingFragment
                ? update(createJsxFragment(openingFragment, children, closingFragment), node)
                : node;
        }
        // @api
        function createJsxText(text, containsOnlyTriviaWhiteSpaces) {
            var node = createBaseNode(11 /* SyntaxKind.JsxText */);
            node.text = text;
            node.containsOnlyTriviaWhiteSpaces = !!containsOnlyTriviaWhiteSpaces;
            node.transformFlags |= 2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxText(node, text, containsOnlyTriviaWhiteSpaces) {
            return node.text !== text
                || node.containsOnlyTriviaWhiteSpaces !== containsOnlyTriviaWhiteSpaces
                ? update(createJsxText(text, containsOnlyTriviaWhiteSpaces), node)
                : node;
        }
        // @api
        function createJsxOpeningFragment() {
            var node = createBaseNode(283 /* SyntaxKind.JsxOpeningFragment */);
            node.transformFlags |= 2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function createJsxJsxClosingFragment() {
            var node = createBaseNode(284 /* SyntaxKind.JsxClosingFragment */);
            node.transformFlags |= 2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function createJsxAttribute(name, initializer) {
            var node = createBaseNode(285 /* SyntaxKind.JsxAttribute */);
            node.name = name;
            node.initializer = initializer;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxAttribute(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createJsxAttribute(name, initializer), node)
                : node;
        }
        // @api
        function createJsxAttributes(properties) {
            var node = createBaseNode(286 /* SyntaxKind.JsxAttributes */);
            node.properties = createNodeArray(properties);
            node.transformFlags |=
                propagateChildrenFlags(node.properties) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxAttributes(node, properties) {
            return node.properties !== properties
                ? update(createJsxAttributes(properties), node)
                : node;
        }
        // @api
        function createJsxSpreadAttribute(expression) {
            var node = createBaseNode(287 /* SyntaxKind.JsxSpreadAttribute */);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxSpreadAttribute(node, expression) {
            return node.expression !== expression
                ? update(createJsxSpreadAttribute(expression), node)
                : node;
        }
        // @api
        function createJsxExpression(dotDotDotToken, expression) {
            var node = createBaseNode(288 /* SyntaxKind.JsxExpression */);
            node.dotDotDotToken = dotDotDotToken;
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.dotDotDotToken) |
                    propagateChildFlags(node.expression) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxExpression(node, expression) {
            return node.expression !== expression
                ? update(createJsxExpression(node.dotDotDotToken, expression), node)
                : node;
        }
        //
        // Clauses
        //
        // @api
        function createCaseClause(expression, statements) {
            var node = createBaseNode(289 /* SyntaxKind.CaseClause */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statements = createNodeArray(statements);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateCaseClause(node, expression, statements) {
            return node.expression !== expression
                || node.statements !== statements
                ? update(createCaseClause(expression, statements), node)
                : node;
        }
        // @api
        function createDefaultClause(statements) {
            var node = createBaseNode(290 /* SyntaxKind.DefaultClause */);
            node.statements = createNodeArray(statements);
            node.transformFlags = propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateDefaultClause(node, statements) {
            return node.statements !== statements
                ? update(createDefaultClause(statements), node)
                : node;
        }
        // @api
        function createHeritageClause(token, types) {
            var node = createBaseNode(291 /* SyntaxKind.HeritageClause */);
            node.token = token;
            node.types = createNodeArray(types);
            node.transformFlags |= propagateChildrenFlags(node.types);
            switch (token) {
                case 94 /* SyntaxKind.ExtendsKeyword */:
                    node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
                    break;
                case 117 /* SyntaxKind.ImplementsKeyword */:
                    node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
                    break;
                default:
                    return ts.Debug.assertNever(token);
            }
            return node;
        }
        // @api
        function updateHeritageClause(node, types) {
            return node.types !== types
                ? update(createHeritageClause(node.token, types), node)
                : node;
        }
        // @api
        function createCatchClause(variableDeclaration, block) {
            var node = createBaseNode(292 /* SyntaxKind.CatchClause */);
            if (typeof variableDeclaration === "string" || variableDeclaration && !ts.isVariableDeclaration(variableDeclaration)) {
                variableDeclaration = createVariableDeclaration(variableDeclaration, 
                /*exclamationToken*/ undefined, 
                /*type*/ undefined, 
                /*initializer*/ undefined);
            }
            node.variableDeclaration = variableDeclaration;
            node.block = block;
            node.transformFlags |=
                propagateChildFlags(node.variableDeclaration) |
                    propagateChildFlags(node.block);
            if (!variableDeclaration)
                node.transformFlags |= 64 /* TransformFlags.ContainsES2019 */;
            return node;
        }
        // @api
        function updateCatchClause(node, variableDeclaration, block) {
            return node.variableDeclaration !== variableDeclaration
                || node.block !== block
                ? update(createCatchClause(variableDeclaration, block), node)
                : node;
        }
        //
        // Property assignments
        //
        // @api
        function createPropertyAssignment(name, initializer) {
            var node = createBaseNamedDeclaration(296 /* SyntaxKind.PropertyAssignment */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, name);
            node.initializer = parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer);
            return node;
        }
        function finishUpdatePropertyAssignment(updated, original) {
            // copy children used only for error reporting
            if (original.decorators)
                updated.decorators = original.decorators;
            if (original.modifiers)
                updated.modifiers = original.modifiers;
            if (original.questionToken)
                updated.questionToken = original.questionToken;
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            return update(updated, original);
        }
        // @api
        function updatePropertyAssignment(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? finishUpdatePropertyAssignment(createPropertyAssignment(name, initializer), node)
                : node;
        }
        // @api
        function createShorthandPropertyAssignment(name, objectAssignmentInitializer) {
            var node = createBaseNamedDeclaration(297 /* SyntaxKind.ShorthandPropertyAssignment */, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, name);
            node.objectAssignmentInitializer = objectAssignmentInitializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(objectAssignmentInitializer);
            node.transformFlags |=
                propagateChildFlags(node.objectAssignmentInitializer) |
                    1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        function finishUpdateShorthandPropertyAssignment(updated, original) {
            // copy children used only for error reporting
            if (original.decorators)
                updated.decorators = original.decorators;
            if (original.modifiers)
                updated.modifiers = original.modifiers;
            if (original.equalsToken)
                updated.equalsToken = original.equalsToken;
            if (original.questionToken)
                updated.questionToken = original.questionToken;
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            return update(updated, original);
        }
        // @api
        function updateShorthandPropertyAssignment(node, name, objectAssignmentInitializer) {
            return node.name !== name
                || node.objectAssignmentInitializer !== objectAssignmentInitializer
                ? finishUpdateShorthandPropertyAssignment(createShorthandPropertyAssignment(name, objectAssignmentInitializer), node)
                : node;
        }
        // @api
        function createSpreadAssignment(expression) {
            var node = createBaseNode(298 /* SyntaxKind.SpreadAssignment */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    128 /* TransformFlags.ContainsES2018 */ |
                    32768 /* TransformFlags.ContainsObjectRestOrSpread */;
            return node;
        }
        // @api
        function updateSpreadAssignment(node, expression) {
            return node.expression !== expression
                ? update(createSpreadAssignment(expression), node)
                : node;
        }
        //
        // Enum
        //
        // @api
        function createEnumMember(name, initializer) {
            var node = createBaseNode(299 /* SyntaxKind.EnumMember */);
            node.name = asName(name);
            node.initializer = initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateEnumMember(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createEnumMember(name, initializer), node)
                : node;
        }
        //
        // Top-level nodes
        //
        // @api
        function createSourceFile(statements, endOfFileToken, flags) {
            var node = baseFactory.createBaseSourceFileNode(305 /* SyntaxKind.SourceFile */);
            node.statements = createNodeArray(statements);
            node.endOfFileToken = endOfFileToken;
            node.flags |= flags;
            node.fileName = "";
            node.text = "";
            node.languageVersion = 0;
            node.languageVariant = 0;
            node.scriptKind = 0;
            node.isDeclarationFile = false;
            node.hasNoDefaultLib = false;
            node.transformFlags |=
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            return node;
        }
        function cloneSourceFileWithChanges(source, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences) {
            var node = (source.redirectInfo ? Object.create(source.redirectInfo.redirectTarget) : baseFactory.createBaseSourceFileNode(305 /* SyntaxKind.SourceFile */));
            for (var p in source) {
                if (p === "emitNode" || ts.hasProperty(node, p) || !ts.hasProperty(source, p))
                    continue;
                node[p] = source[p];
            }
            node.flags |= source.flags;
            node.statements = createNodeArray(statements);
            node.endOfFileToken = source.endOfFileToken;
            node.isDeclarationFile = isDeclarationFile;
            node.referencedFiles = referencedFiles;
            node.typeReferenceDirectives = typeReferences;
            node.hasNoDefaultLib = hasNoDefaultLib;
            node.libReferenceDirectives = libReferences;
            node.transformFlags =
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            node.impliedNodeFormat = source.impliedNodeFormat;
            return node;
        }
        // @api
        function updateSourceFile(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives) {
            if (isDeclarationFile === void 0) { isDeclarationFile = node.isDeclarationFile; }
            if (referencedFiles === void 0) { referencedFiles = node.referencedFiles; }
            if (typeReferenceDirectives === void 0) { typeReferenceDirectives = node.typeReferenceDirectives; }
            if (hasNoDefaultLib === void 0) { hasNoDefaultLib = node.hasNoDefaultLib; }
            if (libReferenceDirectives === void 0) { libReferenceDirectives = node.libReferenceDirectives; }
            return node.statements !== statements
                || node.isDeclarationFile !== isDeclarationFile
                || node.referencedFiles !== referencedFiles
                || node.typeReferenceDirectives !== typeReferenceDirectives
                || node.hasNoDefaultLib !== hasNoDefaultLib
                || node.libReferenceDirectives !== libReferenceDirectives
                ? update(cloneSourceFileWithChanges(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives), node)
                : node;
        }
        // @api
        function createBundle(sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            var node = createBaseNode(306 /* SyntaxKind.Bundle */);
            node.prepends = prepends;
            node.sourceFiles = sourceFiles;
            return node;
        }
        // @api
        function updateBundle(node, sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            return node.sourceFiles !== sourceFiles
                || node.prepends !== prepends
                ? update(createBundle(sourceFiles, prepends), node)
                : node;
        }
        // @api
        function createUnparsedSource(prologues, syntheticReferences, texts) {
            var node = createBaseNode(307 /* SyntaxKind.UnparsedSource */);
            node.prologues = prologues;
            node.syntheticReferences = syntheticReferences;
            node.texts = texts;
            node.fileName = "";
            node.text = "";
            node.referencedFiles = ts.emptyArray;
            node.libReferenceDirectives = ts.emptyArray;
            node.getLineAndCharacterOfPosition = function (pos) { return ts.getLineAndCharacterOfPosition(node, pos); };
            return node;
        }
        function createBaseUnparsedNode(kind, data) {
            var node = createBaseNode(kind);
            node.data = data;
            return node;
        }
        // @api
        function createUnparsedPrologue(data) {
            return createBaseUnparsedNode(300 /* SyntaxKind.UnparsedPrologue */, data);
        }
        // @api
        function createUnparsedPrepend(data, texts) {
            var node = createBaseUnparsedNode(301 /* SyntaxKind.UnparsedPrepend */, data);
            node.texts = texts;
            return node;
        }
        // @api
        function createUnparsedTextLike(data, internal) {
            return createBaseUnparsedNode(internal ? 303 /* SyntaxKind.UnparsedInternalText */ : 302 /* SyntaxKind.UnparsedText */, data);
        }
        // @api
        function createUnparsedSyntheticReference(section) {
            var node = createBaseNode(304 /* SyntaxKind.UnparsedSyntheticReference */);
            node.data = section.data;
            node.section = section;
            return node;
        }
        // @api
        function createInputFiles() {
            var node = createBaseNode(308 /* SyntaxKind.InputFiles */);
            node.javascriptText = "";
            node.declarationText = "";
            return node;
        }
        //
        // Synthetic Nodes (used by checker)
        //
        // @api
        function createSyntheticExpression(type, isSpread, tupleNameSource) {
            if (isSpread === void 0) { isSpread = false; }
            var node = createBaseNode(232 /* SyntaxKind.SyntheticExpression */);
            node.type = type;
            node.isSpread = isSpread;
            node.tupleNameSource = tupleNameSource;
            return node;
        }
        // @api
        function createSyntaxList(children) {
            var node = createBaseNode(348 /* SyntaxKind.SyntaxList */);
            node._children = children;
            return node;
        }
        //
        // Transformation nodes
        //
        /**
         * Creates a synthetic statement to act as a placeholder for a not-emitted statement in
         * order to preserve comments.
         *
         * @param original The original statement.
         */
        // @api
        function createNotEmittedStatement(original) {
            var node = createBaseNode(349 /* SyntaxKind.NotEmittedStatement */);
            node.original = original;
            ts.setTextRange(node, original);
            return node;
        }
        /**
         * Creates a synthetic expression to act as a placeholder for a not-emitted expression in
         * order to preserve comments or sourcemap positions.
         *
         * @param expression The inner expression to emit.
         * @param original The original outer expression.
         */
        // @api
        function createPartiallyEmittedExpression(expression, original) {
            var node = createBaseNode(350 /* SyntaxKind.PartiallyEmittedExpression */);
            node.expression = expression;
            node.original = original;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* TransformFlags.ContainsTypeScript */;
            ts.setTextRange(node, original);
            return node;
        }
        // @api
        function updatePartiallyEmittedExpression(node, expression) {
            return node.expression !== expression
                ? update(createPartiallyEmittedExpression(expression, node.original), node)
                : node;
        }
        function flattenCommaElements(node) {
            if (ts.nodeIsSynthesized(node) && !ts.isParseTreeNode(node) && !node.original && !node.emitNode && !node.id) {
                if (ts.isCommaListExpression(node)) {
                    return node.elements;
                }
                if (ts.isBinaryExpression(node) && ts.isCommaToken(node.operatorToken)) {
                    return [node.left, node.right];
                }
            }
            return node;
        }
        // @api
        function createCommaListExpression(elements) {
            var node = createBaseNode(351 /* SyntaxKind.CommaListExpression */);
            node.elements = createNodeArray(ts.sameFlatMap(elements, flattenCommaElements));
            node.transformFlags |= propagateChildrenFlags(node.elements);
            return node;
        }
        // @api
        function updateCommaListExpression(node, elements) {
            return node.elements !== elements
                ? update(createCommaListExpression(elements), node)
                : node;
        }
        /**
         * Creates a synthetic element to act as a placeholder for the end of an emitted declaration in
         * order to properly emit exports.
         */
        // @api
        function createEndOfDeclarationMarker(original) {
            var node = createBaseNode(353 /* SyntaxKind.EndOfDeclarationMarker */);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        /**
         * Creates a synthetic element to act as a placeholder for the beginning of a merged declaration in
         * order to properly emit exports.
         */
        // @api
        function createMergeDeclarationMarker(original) {
            var node = createBaseNode(352 /* SyntaxKind.MergeDeclarationMarker */);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        // @api
        function createSyntheticReferenceExpression(expression, thisArg) {
            var node = createBaseNode(354 /* SyntaxKind.SyntheticReferenceExpression */);
            node.expression = expression;
            node.thisArg = thisArg;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thisArg);
            return node;
        }
        // @api
        function updateSyntheticReferenceExpression(node, expression, thisArg) {
            return node.expression !== expression
                || node.thisArg !== thisArg
                ? update(createSyntheticReferenceExpression(expression, thisArg), node)
                : node;
        }
        function cloneNode(node) {
            // We don't use "clone" from core.ts here, as we need to preserve the prototype chain of
            // the original node. We also need to exclude specific properties and only include own-
            // properties (to skip members already defined on the shared prototype).
            if (node === undefined) {
                return node;
            }
            var clone = ts.isSourceFile(node) ? baseFactory.createBaseSourceFileNode(305 /* SyntaxKind.SourceFile */) :
                ts.isIdentifier(node) ? baseFactory.createBaseIdentifierNode(79 /* SyntaxKind.Identifier */) :
                    ts.isPrivateIdentifier(node) ? baseFactory.createBasePrivateIdentifierNode(80 /* SyntaxKind.PrivateIdentifier */) :
                        !ts.isNodeKind(node.kind) ? baseFactory.createBaseTokenNode(node.kind) :
                            baseFactory.createBaseNode(node.kind);
            clone.flags |= (node.flags & ~8 /* NodeFlags.Synthesized */);
            clone.transformFlags = node.transformFlags;
            setOriginalNode(clone, node);
            for (var key in node) {
                if (clone.hasOwnProperty(key) || !node.hasOwnProperty(key)) {
                    continue;
                }
                clone[key] = node[key];
            }
            return clone;
        }
        function createImmediatelyInvokedFunctionExpression(statements, param, paramValue) {
            return createCallExpression(createFunctionExpression(
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, 
            /*parameters*/ param ? [param] : [], 
            /*type*/ undefined, createBlock(statements, /*multiLine*/ true)), 
            /*typeArguments*/ undefined, 
            /*argumentsArray*/ paramValue ? [paramValue] : []);
        }
        function createImmediatelyInvokedArrowFunction(statements, param, paramValue) {
            return createCallExpression(createArrowFunction(
            /*modifiers*/ undefined, 
            /*typeParameters*/ undefined, 
            /*parameters*/ param ? [param] : [], 
            /*type*/ undefined, 
            /*equalsGreaterThanToken*/ undefined, createBlock(statements, /*multiLine*/ true)), 
            /*typeArguments*/ undefined, 
            /*argumentsArray*/ paramValue ? [paramValue] : []);
        }
        function createVoidZero() {
            return createVoidExpression(createNumericLiteral("0"));
        }
        function createExportDefault(expression) {
            return createExportAssignment(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*isExportEquals*/ false, expression);
        }
        function createExternalModuleExport(exportName) {
            return createExportDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*isTypeOnly*/ false, createNamedExports([
                createExportSpecifier(/*isTypeOnly*/ false, /*propertyName*/ undefined, exportName)
            ]));
        }
        //
        // Utilities
        //
        function createTypeCheck(value, tag) {
            return tag === "undefined"
                ? factory.createStrictEquality(value, createVoidZero())
                : factory.createStrictEquality(createTypeOfExpression(value), createStringLiteral(tag));
        }
        function createMethodCall(object, methodName, argumentsList) {
            // Preserve the optionality of `object`.
            if (ts.isCallChain(object)) {
                return createCallChain(createPropertyAccessChain(object, /*questionDotToken*/ undefined, methodName), 
                /*questionDotToken*/ undefined, 
                /*typeArguments*/ undefined, argumentsList);
            }
            return createCallExpression(createPropertyAccessExpression(object, methodName), 
            /*typeArguments*/ undefined, argumentsList);
        }
        function createFunctionBindCall(target, thisArg, argumentsList) {
            return createMethodCall(target, "bind", __spreadArray([thisArg], argumentsList, true));
        }
        function createFunctionCallCall(target, thisArg, argumentsList) {
            return createMethodCall(target, "call", __spreadArray([thisArg], argumentsList, true));
        }
        function createFunctionApplyCall(target, thisArg, argumentsExpression) {
            return createMethodCall(target, "apply", [thisArg, argumentsExpression]);
        }
        function createGlobalMethodCall(globalObjectName, methodName, argumentsList) {
            return createMethodCall(createIdentifier(globalObjectName), methodName, argumentsList);
        }
        function createArraySliceCall(array, start) {
            return createMethodCall(array, "slice", start === undefined ? [] : [asExpression(start)]);
        }
        function createArrayConcatCall(array, argumentsList) {
            return createMethodCall(array, "concat", argumentsList);
        }
        function createObjectDefinePropertyCall(target, propertyName, attributes) {
            return createGlobalMethodCall("Object", "defineProperty", [target, asExpression(propertyName), attributes]);
        }
        function createReflectGetCall(target, propertyKey, receiver) {
            return createGlobalMethodCall("Reflect", "get", receiver ? [target, propertyKey, receiver] : [target, propertyKey]);
        }
        function createReflectSetCall(target, propertyKey, value, receiver) {
            return createGlobalMethodCall("Reflect", "set", receiver ? [target, propertyKey, value, receiver] : [target, propertyKey, value]);
        }
        function tryAddPropertyAssignment(properties, propertyName, expression) {
            if (expression) {
                properties.push(createPropertyAssignment(propertyName, expression));
                return true;
            }
            return false;
        }
        function createPropertyDescriptor(attributes, singleLine) {
            var properties = [];
            tryAddPropertyAssignment(properties, "enumerable", asExpression(attributes.enumerable));
            tryAddPropertyAssignment(properties, "configurable", asExpression(attributes.configurable));
            var isData = tryAddPropertyAssignment(properties, "writable", asExpression(attributes.writable));
            isData = tryAddPropertyAssignment(properties, "value", attributes.value) || isData;
            var isAccessor = tryAddPropertyAssignment(properties, "get", attributes.get);
            isAccessor = tryAddPropertyAssignment(properties, "set", attributes.set) || isAccessor;
            ts.Debug.assert(!(isData && isAccessor), "A PropertyDescriptor may not be both an accessor descriptor and a data descriptor.");
            return createObjectLiteralExpression(properties, !singleLine);
        }
        function updateOuterExpression(outerExpression, expression) {
            switch (outerExpression.kind) {
                case 212 /* SyntaxKind.ParenthesizedExpression */: return updateParenthesizedExpression(outerExpression, expression);
                case 211 /* SyntaxKind.TypeAssertionExpression */: return updateTypeAssertion(outerExpression, outerExpression.type, expression);
                case 229 /* SyntaxKind.AsExpression */: return updateAsExpression(outerExpression, expression, outerExpression.type);
                case 230 /* SyntaxKind.NonNullExpression */: return updateNonNullExpression(outerExpression, expression);
                case 350 /* SyntaxKind.PartiallyEmittedExpression */: return updatePartiallyEmittedExpression(outerExpression, expression);
            }
        }
        /**
         * Determines whether a node is a parenthesized expression that can be ignored when recreating outer expressions.
         *
         * A parenthesized expression can be ignored when all of the following are true:
         *
         * - It's `pos` and `end` are not -1
         * - It does not have a custom source map range
         * - It does not have a custom comment range
         * - It does not have synthetic leading or trailing comments
         *
         * If an outermost parenthesized expression is ignored, but the containing expression requires a parentheses around
         * the expression to maintain precedence, a new parenthesized expression should be created automatically when
         * the containing expression is created/updated.
         */
        function isIgnorableParen(node) {
            return ts.isParenthesizedExpression(node)
                && ts.nodeIsSynthesized(node)
                && ts.nodeIsSynthesized(ts.getSourceMapRange(node))
                && ts.nodeIsSynthesized(ts.getCommentRange(node))
                && !ts.some(ts.getSyntheticLeadingComments(node))
                && !ts.some(ts.getSyntheticTrailingComments(node));
        }
        function restoreOuterExpressions(outerExpression, innerExpression, kinds) {
            if (kinds === void 0) { kinds = 15 /* OuterExpressionKinds.All */; }
            if (outerExpression && ts.isOuterExpression(outerExpression, kinds) && !isIgnorableParen(outerExpression)) {
                return updateOuterExpression(outerExpression, restoreOuterExpressions(outerExpression.expression, innerExpression));
            }
            return innerExpression;
        }
        function restoreEnclosingLabel(node, outermostLabeledStatement, afterRestoreLabelCallback) {
            if (!outermostLabeledStatement) {
                return node;
            }
            var updated = updateLabeledStatement(outermostLabeledStatement, outermostLabeledStatement.label, ts.isLabeledStatement(outermostLabeledStatement.statement)
                ? restoreEnclosingLabel(node, outermostLabeledStatement.statement)
                : node);
            if (afterRestoreLabelCallback) {
                afterRestoreLabelCallback(outermostLabeledStatement);
            }
            return updated;
        }
        function shouldBeCapturedInTempVariable(node, cacheIdentifiers) {
            var target = ts.skipParentheses(node);
            switch (target.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return cacheIdentifiers;
                case 108 /* SyntaxKind.ThisKeyword */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                    return false;
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    var elements = target.elements;
                    if (elements.length === 0) {
                        return false;
                    }
                    return true;
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    return target.properties.length > 0;
                default:
                    return true;
            }
        }
        function createCallBinding(expression, recordTempVariable, languageVersion, cacheIdentifiers) {
            if (cacheIdentifiers === void 0) { cacheIdentifiers = false; }
            var callee = ts.skipOuterExpressions(expression, 15 /* OuterExpressionKinds.All */);
            var thisArg;
            var target;
            if (ts.isSuperProperty(callee)) {
                thisArg = createThis();
                target = callee;
            }
            else if (ts.isSuperKeyword(callee)) {
                thisArg = createThis();
                target = languageVersion !== undefined && languageVersion < 2 /* ScriptTarget.ES2015 */
                    ? ts.setTextRange(createIdentifier("_super"), callee)
                    : callee;
            }
            else if (ts.getEmitFlags(callee) & 4096 /* EmitFlags.HelperName */) {
                thisArg = createVoidZero();
                target = parenthesizerRules().parenthesizeLeftSideOfAccess(callee);
            }
            else if (ts.isPropertyAccessExpression(callee)) {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    // for `a.b()` target is `(_a = a).b` and thisArg is `_a`
                    thisArg = createTempVariable(recordTempVariable);
                    target = createPropertyAccessExpression(ts.setTextRange(factory.createAssignment(thisArg, callee.expression), callee.expression), callee.name);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
            }
            else if (ts.isElementAccessExpression(callee)) {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    // for `a[b]()` target is `(_a = a)[b]` and thisArg is `_a`
                    thisArg = createTempVariable(recordTempVariable);
                    target = createElementAccessExpression(ts.setTextRange(factory.createAssignment(thisArg, callee.expression), callee.expression), callee.argumentExpression);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
            }
            else {
                // for `a()` target is `a` and thisArg is `void 0`
                thisArg = createVoidZero();
                target = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            }
            return { target: target, thisArg: thisArg };
        }
        function createAssignmentTargetWrapper(paramName, expression) {
            return createPropertyAccessExpression(
            // Explicit parens required because of v8 regression (https://bugs.chromium.org/p/v8/issues/detail?id=9560)
            createParenthesizedExpression(createObjectLiteralExpression([
                createSetAccessorDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, "value", [createParameterDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, 
                    /*dotDotDotToken*/ undefined, paramName, 
                    /*questionToken*/ undefined, 
                    /*type*/ undefined, 
                    /*initializer*/ undefined)], createBlock([
                    createExpressionStatement(expression)
                ]))
            ])), "value");
        }
        function inlineExpressions(expressions) {
            // Avoid deeply nested comma expressions as traversing them during emit can result in "Maximum call
            // stack size exceeded" errors.
            return expressions.length > 10
                ? createCommaListExpression(expressions)
                : ts.reduceLeft(expressions, factory.createComma);
        }
        function getName(node, allowComments, allowSourceMaps, emitFlags) {
            if (emitFlags === void 0) { emitFlags = 0; }
            var nodeName = ts.getNameOfDeclaration(node);
            if (nodeName && ts.isIdentifier(nodeName) && !ts.isGeneratedIdentifier(nodeName)) {
                // TODO(rbuckton): Does this need to be parented?
                var name = ts.setParent(ts.setTextRange(cloneNode(nodeName), nodeName), nodeName.parent);
                emitFlags |= ts.getEmitFlags(nodeName);
                if (!allowSourceMaps)
                    emitFlags |= 48 /* EmitFlags.NoSourceMap */;
                if (!allowComments)
                    emitFlags |= 1536 /* EmitFlags.NoComments */;
                if (emitFlags)
                    ts.setEmitFlags(name, emitFlags);
                return name;
            }
            return getGeneratedNameForNode(node);
        }
        /**
         * Gets the internal name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the body of an ES5 class function body. An internal name will *never*
         * be prefixed with an module or namespace export modifier like "exports." when emitted as an
         * expression. An internal name will also *never* be renamed due to a collision with a block
         * scoped variable.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getInternalName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 16384 /* EmitFlags.LocalName */ | 32768 /* EmitFlags.InternalName */);
        }
        /**
         * Gets the local name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the declaration's immediate scope (classes, enums, namespaces). A
         * local name will *never* be prefixed with an module or namespace export modifier like
         * "exports." when emitted as an expression.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getLocalName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 16384 /* EmitFlags.LocalName */);
        }
        /**
         * Gets the export name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the declaration's immediate scope (classes, enums, namespaces). An
         * export name will *always* be prefixed with an module or namespace export modifier like
         * `"exports."` when emitted as an expression if the name points to an exported symbol.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getExportName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 8192 /* EmitFlags.ExportName */);
        }
        /**
         * Gets the name of a declaration for use in declarations.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getDeclarationName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps);
        }
        /**
         * Gets a namespace-qualified name for use in expressions.
         *
         * @param ns The namespace identifier.
         * @param name The name.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getNamespaceMemberName(ns, name, allowComments, allowSourceMaps) {
            var qualifiedName = createPropertyAccessExpression(ns, ts.nodeIsSynthesized(name) ? name : cloneNode(name));
            ts.setTextRange(qualifiedName, name);
            var emitFlags = 0;
            if (!allowSourceMaps)
                emitFlags |= 48 /* EmitFlags.NoSourceMap */;
            if (!allowComments)
                emitFlags |= 1536 /* EmitFlags.NoComments */;
            if (emitFlags)
                ts.setEmitFlags(qualifiedName, emitFlags);
            return qualifiedName;
        }
        /**
         * Gets the exported name of a declaration for use in expressions.
         *
         * An exported name will *always* be prefixed with an module or namespace export modifier like
         * "exports." if the name points to an exported symbol.
         *
         * @param ns The namespace identifier.
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getExternalModuleOrNamespaceExportName(ns, node, allowComments, allowSourceMaps) {
            if (ns && ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                return getNamespaceMemberName(ns, getName(node), allowComments, allowSourceMaps);
            }
            return getExportName(node, allowComments, allowSourceMaps);
        }
        /**
         * Copies any necessary standard and custom prologue-directives into target array.
         * @param source origin statements array
         * @param target result statements array
         * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
         * @param visitor Optional callback used to visit any custom prologue directives.
         */
        function copyPrologue(source, target, ensureUseStrict, visitor) {
            var offset = copyStandardPrologue(source, target, 0, ensureUseStrict);
            return copyCustomPrologue(source, target, offset, visitor);
        }
        function isUseStrictPrologue(node) {
            return ts.isStringLiteral(node.expression) && node.expression.text === "use strict";
        }
        function createUseStrictPrologue() {
            return ts.startOnNewLine(createExpressionStatement(createStringLiteral("use strict")));
        }
        /**
         * Copies only the standard (string-expression) prologue-directives into the target statement-array.
         * @param source origin statements array
         * @param target result statements array
         * @param statementOffset The offset at which to begin the copy.
         * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
         * @returns Count of how many directive statements were copied.
         */
        function copyStandardPrologue(source, target, statementOffset, ensureUseStrict) {
            if (statementOffset === void 0) { statementOffset = 0; }
            ts.Debug.assert(target.length === 0, "Prologue directives should be at the first statement in the target statements array");
            var foundUseStrict = false;
            var numStatements = source.length;
            while (statementOffset < numStatements) {
                var statement = source[statementOffset];
                if (ts.isPrologueDirective(statement)) {
                    if (isUseStrictPrologue(statement)) {
                        foundUseStrict = true;
                    }
                    target.push(statement);
                }
                else {
                    break;
                }
                statementOffset++;
            }
            if (ensureUseStrict && !foundUseStrict) {
                target.push(createUseStrictPrologue());
            }
            return statementOffset;
        }
        function copyCustomPrologue(source, target, statementOffset, visitor, filter) {
            if (filter === void 0) { filter = ts.returnTrue; }
            var numStatements = source.length;
            while (statementOffset !== undefined && statementOffset < numStatements) {
                var statement = source[statementOffset];
                if (ts.getEmitFlags(statement) & 1048576 /* EmitFlags.CustomPrologue */ && filter(statement)) {
                    ts.append(target, visitor ? ts.visitNode(statement, visitor, ts.isStatement) : statement);
                }
                else {
                    break;
                }
                statementOffset++;
            }
            return statementOffset;
        }
        /**
         * Ensures "use strict" directive is added
         *
         * @param statements An array of statements
         */
        function ensureUseStrict(statements) {
            var foundUseStrict = ts.findUseStrictPrologue(statements);
            if (!foundUseStrict) {
                return ts.setTextRange(createNodeArray(__spreadArray([createUseStrictPrologue()], statements, true)), statements);
            }
            return statements;
        }
        /**
         * Lifts a NodeArray containing only Statement nodes to a block.
         *
         * @param nodes The NodeArray.
         */
        function liftToBlock(nodes) {
            ts.Debug.assert(ts.every(nodes, ts.isStatementOrBlock), "Cannot lift nodes to a Block.");
            return ts.singleOrUndefined(nodes) || createBlock(nodes);
        }
        function findSpanEnd(array, test, start) {
            var i = start;
            while (i < array.length && test(array[i])) {
                i++;
            }
            return i;
        }
        function mergeLexicalEnvironment(statements, declarations) {
            if (!ts.some(declarations)) {
                return statements;
            }
            // When we merge new lexical statements into an existing statement list, we merge them in the following manner:
            //
            // Given:
            //
            // | Left                               | Right                               |
            // |------------------------------------|-------------------------------------|
            // | [standard prologues (left)]        | [standard prologues (right)]        |
            // | [hoisted functions (left)]         | [hoisted functions (right)]         |
            // | [hoisted variables (left)]         | [hoisted variables (right)]         |
            // | [lexical init statements (left)]   | [lexical init statements (right)]   |
            // | [other statements (left)]          |                                     |
            //
            // The resulting statement list will be:
            //
            // | Result                              |
            // |-------------------------------------|
            // | [standard prologues (right)]        |
            // | [standard prologues (left)]         |
            // | [hoisted functions (right)]         |
            // | [hoisted functions (left)]          |
            // | [hoisted variables (right)]         |
            // | [hoisted variables (left)]          |
            // | [lexical init statements (right)]   |
            // | [lexical init statements (left)]    |
            // | [other statements (left)]           |
            //
            // NOTE: It is expected that new lexical init statements must be evaluated before existing lexical init statements,
            // as the prior transformation may depend on the evaluation of the lexical init statements to be in the correct state.
            // find standard prologues on left in the following order: standard directives, hoisted functions, hoisted variables, other custom
            var leftStandardPrologueEnd = findSpanEnd(statements, ts.isPrologueDirective, 0);
            var leftHoistedFunctionsEnd = findSpanEnd(statements, ts.isHoistedFunction, leftStandardPrologueEnd);
            var leftHoistedVariablesEnd = findSpanEnd(statements, ts.isHoistedVariableStatement, leftHoistedFunctionsEnd);
            // find standard prologues on right in the following order: standard directives, hoisted functions, hoisted variables, other custom
            var rightStandardPrologueEnd = findSpanEnd(declarations, ts.isPrologueDirective, 0);
            var rightHoistedFunctionsEnd = findSpanEnd(declarations, ts.isHoistedFunction, rightStandardPrologueEnd);
            var rightHoistedVariablesEnd = findSpanEnd(declarations, ts.isHoistedVariableStatement, rightHoistedFunctionsEnd);
            var rightCustomPrologueEnd = findSpanEnd(declarations, ts.isCustomPrologue, rightHoistedVariablesEnd);
            ts.Debug.assert(rightCustomPrologueEnd === declarations.length, "Expected declarations to be valid standard or custom prologues");
            // splice prologues from the right into the left. We do this in reverse order
            // so that we don't need to recompute the index on the left when we insert items.
            var left = ts.isNodeArray(statements) ? statements.slice() : statements;
            // splice other custom prologues from right into left
            if (rightCustomPrologueEnd > rightHoistedVariablesEnd) {
                left.splice.apply(left, __spreadArray([leftHoistedVariablesEnd, 0], declarations.slice(rightHoistedVariablesEnd, rightCustomPrologueEnd), false));
            }
            // splice hoisted variables from right into left
            if (rightHoistedVariablesEnd > rightHoistedFunctionsEnd) {
                left.splice.apply(left, __spreadArray([leftHoistedFunctionsEnd, 0], declarations.slice(rightHoistedFunctionsEnd, rightHoistedVariablesEnd), false));
            }
            // splice hoisted functions from right into left
            if (rightHoistedFunctionsEnd > rightStandardPrologueEnd) {
                left.splice.apply(left, __spreadArray([leftStandardPrologueEnd, 0], declarations.slice(rightStandardPrologueEnd, rightHoistedFunctionsEnd), false));
            }
            // splice standard prologues from right into left (that are not already in left)
            if (rightStandardPrologueEnd > 0) {
                if (leftStandardPrologueEnd === 0) {
                    left.splice.apply(left, __spreadArray([0, 0], declarations.slice(0, rightStandardPrologueEnd), false));
                }
                else {
                    var leftPrologues = new ts.Map();
                    for (var i = 0; i < leftStandardPrologueEnd; i++) {
                        var leftPrologue = statements[i];
                        leftPrologues.set(leftPrologue.expression.text, true);
                    }
                    for (var i = rightStandardPrologueEnd - 1; i >= 0; i--) {
                        var rightPrologue = declarations[i];
                        if (!leftPrologues.has(rightPrologue.expression.text)) {
                            left.unshift(rightPrologue);
                        }
                    }
                }
            }
            if (ts.isNodeArray(statements)) {
                return ts.setTextRange(createNodeArray(left, statements.hasTrailingComma), statements);
            }
            return statements;
        }
        function updateModifiers(node, modifiers) {
            var _a;
            var modifierArray;
            if (typeof modifiers === "number") {
                modifierArray = createModifiersFromModifierFlags(modifiers);
            }
            else {
                modifierArray = modifiers;
            }
            return ts.isParameter(node) ? updateParameterDeclaration(node, node.decorators, modifierArray, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer) :
                ts.isPropertySignature(node) ? updatePropertySignature(node, modifierArray, node.name, node.questionToken, node.type) :
                    ts.isPropertyDeclaration(node) ? updatePropertyDeclaration(node, node.decorators, modifierArray, node.name, (_a = node.questionToken) !== null && _a !== void 0 ? _a : node.exclamationToken, node.type, node.initializer) :
                        ts.isMethodSignature(node) ? updateMethodSignature(node, modifierArray, node.name, node.questionToken, node.typeParameters, node.parameters, node.type) :
                            ts.isMethodDeclaration(node) ? updateMethodDeclaration(node, node.decorators, modifierArray, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body) :
                                ts.isConstructorDeclaration(node) ? updateConstructorDeclaration(node, node.decorators, modifierArray, node.parameters, node.body) :
                                    ts.isGetAccessorDeclaration(node) ? updateGetAccessorDeclaration(node, node.decorators, modifierArray, node.name, node.parameters, node.type, node.body) :
                                        ts.isSetAccessorDeclaration(node) ? updateSetAccessorDeclaration(node, node.decorators, modifierArray, node.name, node.parameters, node.body) :
                                            ts.isIndexSignatureDeclaration(node) ? updateIndexSignature(node, node.decorators, modifierArray, node.parameters, node.type) :
                                                ts.isFunctionExpression(node) ? updateFunctionExpression(node, modifierArray, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body) :
                                                    ts.isArrowFunction(node) ? updateArrowFunction(node, modifierArray, node.typeParameters, node.parameters, node.type, node.equalsGreaterThanToken, node.body) :
                                                        ts.isClassExpression(node) ? updateClassExpression(node, node.decorators, modifierArray, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                            ts.isVariableStatement(node) ? updateVariableStatement(node, modifierArray, node.declarationList) :
                                                                ts.isFunctionDeclaration(node) ? updateFunctionDeclaration(node, node.decorators, modifierArray, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body) :
                                                                    ts.isClassDeclaration(node) ? updateClassDeclaration(node, node.decorators, modifierArray, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                                        ts.isInterfaceDeclaration(node) ? updateInterfaceDeclaration(node, node.decorators, modifierArray, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                                            ts.isTypeAliasDeclaration(node) ? updateTypeAliasDeclaration(node, node.decorators, modifierArray, node.name, node.typeParameters, node.type) :
                                                                                ts.isEnumDeclaration(node) ? updateEnumDeclaration(node, node.decorators, modifierArray, node.name, node.members) :
                                                                                    ts.isModuleDeclaration(node) ? updateModuleDeclaration(node, node.decorators, modifierArray, node.name, node.body) :
                                                                                        ts.isImportEqualsDeclaration(node) ? updateImportEqualsDeclaration(node, node.decorators, modifierArray, node.isTypeOnly, node.name, node.moduleReference) :
                                                                                            ts.isImportDeclaration(node) ? updateImportDeclaration(node, node.decorators, modifierArray, node.importClause, node.moduleSpecifier, node.assertClause) :
                                                                                                ts.isExportAssignment(node) ? updateExportAssignment(node, node.decorators, modifierArray, node.expression) :
                                                                                                    ts.isExportDeclaration(node) ? updateExportDeclaration(node, node.decorators, modifierArray, node.isTypeOnly, node.exportClause, node.moduleSpecifier, node.assertClause) :
                                                                                                        ts.Debug.assertNever(node);
        }
        function asNodeArray(array) {
            return array ? createNodeArray(array) : undefined;
        }
        function asName(name) {
            return typeof name === "string" ? createIdentifier(name) :
                name;
        }
        function asExpression(value) {
            return typeof value === "string" ? createStringLiteral(value) :
                typeof value === "number" ? createNumericLiteral(value) :
                    typeof value === "boolean" ? value ? createTrue() : createFalse() :
                        value;
        }
        function asToken(value) {
            return typeof value === "number" ? createToken(value) : value;
        }
        function asEmbeddedStatement(statement) {
            return statement && ts.isNotEmittedStatement(statement) ? ts.setTextRange(setOriginalNode(createEmptyStatement(), statement), statement) : statement;
        }
    }
    ts.createNodeFactory = createNodeFactory;
    function updateWithoutOriginal(updated, original) {
        if (updated !== original) {
            ts.setTextRange(updated, original);
        }
        return updated;
    }
    function updateWithOriginal(updated, original) {
        if (updated !== original) {
            setOriginalNode(updated, original);
            ts.setTextRange(updated, original);
        }
        return updated;
    }
    function getDefaultTagNameForKind(kind) {
        switch (kind) {
            case 343 /* SyntaxKind.JSDocTypeTag */: return "type";
            case 341 /* SyntaxKind.JSDocReturnTag */: return "returns";
            case 342 /* SyntaxKind.JSDocThisTag */: return "this";
            case 339 /* SyntaxKind.JSDocEnumTag */: return "enum";
            case 330 /* SyntaxKind.JSDocAuthorTag */: return "author";
            case 332 /* SyntaxKind.JSDocClassTag */: return "class";
            case 333 /* SyntaxKind.JSDocPublicTag */: return "public";
            case 334 /* SyntaxKind.JSDocPrivateTag */: return "private";
            case 335 /* SyntaxKind.JSDocProtectedTag */: return "protected";
            case 336 /* SyntaxKind.JSDocReadonlyTag */: return "readonly";
            case 337 /* SyntaxKind.JSDocOverrideTag */: return "override";
            case 344 /* SyntaxKind.JSDocTemplateTag */: return "template";
            case 345 /* SyntaxKind.JSDocTypedefTag */: return "typedef";
            case 340 /* SyntaxKind.JSDocParameterTag */: return "param";
            case 347 /* SyntaxKind.JSDocPropertyTag */: return "prop";
            case 338 /* SyntaxKind.JSDocCallbackTag */: return "callback";
            case 328 /* SyntaxKind.JSDocAugmentsTag */: return "augments";
            case 329 /* SyntaxKind.JSDocImplementsTag */: return "implements";
            default:
                return ts.Debug.fail("Unsupported kind: ".concat(ts.Debug.formatSyntaxKind(kind)));
        }
    }
    var rawTextScanner;
    var invalidValueSentinel = {};
    function getCookedText(kind, rawText) {
        if (!rawTextScanner) {
            rawTextScanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ false, 0 /* LanguageVariant.Standard */);
        }
        switch (kind) {
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                rawTextScanner.setText("`" + rawText + "`");
                break;
            case 15 /* SyntaxKind.TemplateHead */:
                // tslint:disable-next-line no-invalid-template-strings
                rawTextScanner.setText("`" + rawText + "${");
                break;
            case 16 /* SyntaxKind.TemplateMiddle */:
                // tslint:disable-next-line no-invalid-template-strings
                rawTextScanner.setText("}" + rawText + "${");
                break;
            case 17 /* SyntaxKind.TemplateTail */:
                rawTextScanner.setText("}" + rawText + "`");
                break;
        }
        var token = rawTextScanner.scan();
        if (token === 19 /* SyntaxKind.CloseBraceToken */) {
            token = rawTextScanner.reScanTemplateToken(/*isTaggedTemplate*/ false);
        }
        if (rawTextScanner.isUnterminated()) {
            rawTextScanner.setText(undefined);
            return invalidValueSentinel;
        }
        var tokenValue;
        switch (token) {
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 15 /* SyntaxKind.TemplateHead */:
            case 16 /* SyntaxKind.TemplateMiddle */:
            case 17 /* SyntaxKind.TemplateTail */:
                tokenValue = rawTextScanner.getTokenValue();
                break;
        }
        if (tokenValue === undefined || rawTextScanner.scan() !== 1 /* SyntaxKind.EndOfFileToken */) {
            rawTextScanner.setText(undefined);
            return invalidValueSentinel;
        }
        rawTextScanner.setText(undefined);
        return tokenValue;
    }
    function propagateIdentifierNameFlags(node) {
        // An IdentifierName is allowed to be `await`
        return propagateChildFlags(node) & ~16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */;
    }
    function propagatePropertyNameFlagsOfChild(node, transformFlags) {
        return transformFlags | (node.transformFlags & 33562624 /* TransformFlags.PropertyNamePropagatingFlags */);
    }
    function propagateChildFlags(child) {
        if (!child)
            return 0 /* TransformFlags.None */;
        var childFlags = child.transformFlags & ~getTransformFlagsSubtreeExclusions(child.kind);
        return ts.isNamedDeclaration(child) && ts.isPropertyName(child.name) ? propagatePropertyNameFlagsOfChild(child.name, childFlags) : childFlags;
    }
    function propagateChildrenFlags(children) {
        return children ? children.transformFlags : 0 /* TransformFlags.None */;
    }
    function aggregateChildrenFlags(children) {
        var subtreeFlags = 0 /* TransformFlags.None */;
        for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
            var child = children_2[_i];
            subtreeFlags |= propagateChildFlags(child);
        }
        children.transformFlags = subtreeFlags;
    }
    /**
     * Gets the transform flags to exclude when unioning the transform flags of a subtree.
     */
    /* @internal */
    function getTransformFlagsSubtreeExclusions(kind) {
        if (kind >= 177 /* SyntaxKind.FirstTypeNode */ && kind <= 200 /* SyntaxKind.LastTypeNode */) {
            return -2 /* TransformFlags.TypeExcludes */;
        }
        switch (kind) {
            case 208 /* SyntaxKind.CallExpression */:
            case 209 /* SyntaxKind.NewExpression */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                return 536887296 /* TransformFlags.ArrayLiteralOrCallOrNewExcludes */;
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return 589443072 /* TransformFlags.ModuleExcludes */;
            case 164 /* SyntaxKind.Parameter */:
                return 536870912 /* TransformFlags.ParameterExcludes */;
            case 214 /* SyntaxKind.ArrowFunction */:
                return 557748224 /* TransformFlags.ArrowFunctionExcludes */;
            case 213 /* SyntaxKind.FunctionExpression */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
                return 591310848 /* TransformFlags.FunctionExcludes */;
            case 255 /* SyntaxKind.VariableDeclarationList */:
                return 537165824 /* TransformFlags.VariableDeclarationListExcludes */;
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
                return 536940544 /* TransformFlags.ClassExcludes */;
            case 171 /* SyntaxKind.Constructor */:
                return 591306752 /* TransformFlags.ConstructorExcludes */;
            case 167 /* SyntaxKind.PropertyDeclaration */:
                return 570433536 /* TransformFlags.PropertyExcludes */;
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
                return 574529536 /* TransformFlags.MethodOrAccessorExcludes */;
            case 130 /* SyntaxKind.AnyKeyword */:
            case 147 /* SyntaxKind.NumberKeyword */:
            case 158 /* SyntaxKind.BigIntKeyword */:
            case 143 /* SyntaxKind.NeverKeyword */:
            case 150 /* SyntaxKind.StringKeyword */:
            case 148 /* SyntaxKind.ObjectKeyword */:
            case 133 /* SyntaxKind.BooleanKeyword */:
            case 151 /* SyntaxKind.SymbolKeyword */:
            case 114 /* SyntaxKind.VoidKeyword */:
            case 163 /* SyntaxKind.TypeParameter */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 174 /* SyntaxKind.CallSignature */:
            case 175 /* SyntaxKind.ConstructSignature */:
            case 176 /* SyntaxKind.IndexSignature */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
                return -2 /* TransformFlags.TypeExcludes */;
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
                return 536973312 /* TransformFlags.ObjectLiteralExcludes */;
            case 292 /* SyntaxKind.CatchClause */:
                return 536903680 /* TransformFlags.CatchClauseExcludes */;
            case 201 /* SyntaxKind.ObjectBindingPattern */:
            case 202 /* SyntaxKind.ArrayBindingPattern */:
                return 536887296 /* TransformFlags.BindingPatternExcludes */;
            case 211 /* SyntaxKind.TypeAssertionExpression */:
            case 229 /* SyntaxKind.AsExpression */:
            case 350 /* SyntaxKind.PartiallyEmittedExpression */:
            case 212 /* SyntaxKind.ParenthesizedExpression */:
            case 106 /* SyntaxKind.SuperKeyword */:
                return 536870912 /* TransformFlags.OuterExpressionExcludes */;
            case 206 /* SyntaxKind.PropertyAccessExpression */:
            case 207 /* SyntaxKind.ElementAccessExpression */:
                return 536870912 /* TransformFlags.PropertyAccessExcludes */;
            default:
                return 536870912 /* TransformFlags.NodeExcludes */;
        }
    }
    ts.getTransformFlagsSubtreeExclusions = getTransformFlagsSubtreeExclusions;
    var baseFactory = ts.createBaseNodeFactory();
    function makeSynthetic(node) {
        node.flags |= 8 /* NodeFlags.Synthesized */;
        return node;
    }
    var syntheticFactory = {
        createBaseSourceFileNode: function (kind) { return makeSynthetic(baseFactory.createBaseSourceFileNode(kind)); },
        createBaseIdentifierNode: function (kind) { return makeSynthetic(baseFactory.createBaseIdentifierNode(kind)); },
        createBasePrivateIdentifierNode: function (kind) { return makeSynthetic(baseFactory.createBasePrivateIdentifierNode(kind)); },
        createBaseTokenNode: function (kind) { return makeSynthetic(baseFactory.createBaseTokenNode(kind)); },
        createBaseNode: function (kind) { return makeSynthetic(baseFactory.createBaseNode(kind)); },
    };
    ts.factory = createNodeFactory(4 /* NodeFactoryFlags.NoIndentationOnFreshPropertyAccess */, syntheticFactory);
    function createUnparsedSourceFile(textOrInputFiles, mapPathOrType, mapTextOrStripInternal) {
        var stripInternal;
        var bundleFileInfo;
        var fileName;
        var text;
        var length;
        var sourceMapPath;
        var sourceMapText;
        var getText;
        var getSourceMapText;
        var oldFileOfCurrentEmit;
        if (!ts.isString(textOrInputFiles)) {
            ts.Debug.assert(mapPathOrType === "js" || mapPathOrType === "dts");
            fileName = (mapPathOrType === "js" ? textOrInputFiles.javascriptPath : textOrInputFiles.declarationPath) || "";
            sourceMapPath = mapPathOrType === "js" ? textOrInputFiles.javascriptMapPath : textOrInputFiles.declarationMapPath;
            getText = function () { return mapPathOrType === "js" ? textOrInputFiles.javascriptText : textOrInputFiles.declarationText; };
            getSourceMapText = function () { return mapPathOrType === "js" ? textOrInputFiles.javascriptMapText : textOrInputFiles.declarationMapText; };
            length = function () { return getText().length; };
            if (textOrInputFiles.buildInfo && textOrInputFiles.buildInfo.bundle) {
                ts.Debug.assert(mapTextOrStripInternal === undefined || typeof mapTextOrStripInternal === "boolean");
                stripInternal = mapTextOrStripInternal;
                bundleFileInfo = mapPathOrType === "js" ? textOrInputFiles.buildInfo.bundle.js : textOrInputFiles.buildInfo.bundle.dts;
                oldFileOfCurrentEmit = textOrInputFiles.oldFileOfCurrentEmit;
            }
        }
        else {
            fileName = "";
            text = textOrInputFiles;
            length = textOrInputFiles.length;
            sourceMapPath = mapPathOrType;
            sourceMapText = mapTextOrStripInternal;
        }
        var node = oldFileOfCurrentEmit ?
            parseOldFileOfCurrentEmit(ts.Debug.checkDefined(bundleFileInfo)) :
            parseUnparsedSourceFile(bundleFileInfo, stripInternal, length);
        node.fileName = fileName;
        node.sourceMapPath = sourceMapPath;
        node.oldFileOfCurrentEmit = oldFileOfCurrentEmit;
        if (getText && getSourceMapText) {
            Object.defineProperty(node, "text", { get: getText });
            Object.defineProperty(node, "sourceMapText", { get: getSourceMapText });
        }
        else {
            ts.Debug.assert(!oldFileOfCurrentEmit);
            node.text = text !== null && text !== void 0 ? text : "";
            node.sourceMapText = sourceMapText;
        }
        return node;
    }
    ts.createUnparsedSourceFile = createUnparsedSourceFile;
    function parseUnparsedSourceFile(bundleFileInfo, stripInternal, length) {
        var prologues;
        var helpers;
        var referencedFiles;
        var typeReferenceDirectives;
        var libReferenceDirectives;
        var prependChildren;
        var texts;
        var hasNoDefaultLib;
        for (var _i = 0, _a = bundleFileInfo ? bundleFileInfo.sections : ts.emptyArray; _i < _a.length; _i++) {
            var section = _a[_i];
            switch (section.kind) {
                case "prologue" /* BundleFileSectionKind.Prologue */:
                    prologues = ts.append(prologues, ts.setTextRange(ts.factory.createUnparsedPrologue(section.data), section));
                    break;
                case "emitHelpers" /* BundleFileSectionKind.EmitHelpers */:
                    helpers = ts.append(helpers, ts.getAllUnscopedEmitHelpers().get(section.data));
                    break;
                case "no-default-lib" /* BundleFileSectionKind.NoDefaultLib */:
                    hasNoDefaultLib = true;
                    break;
                case "reference" /* BundleFileSectionKind.Reference */:
                    referencedFiles = ts.append(referencedFiles, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "type" /* BundleFileSectionKind.Type */:
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "type-import" /* BundleFileSectionKind.TypeResolutionModeImport */:
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, { pos: -1, end: -1, fileName: section.data, resolutionMode: ts.ModuleKind.ESNext });
                    break;
                case "type-require" /* BundleFileSectionKind.TypeResolutionModeRequire */:
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, { pos: -1, end: -1, fileName: section.data, resolutionMode: ts.ModuleKind.CommonJS });
                    break;
                case "lib" /* BundleFileSectionKind.Lib */:
                    libReferenceDirectives = ts.append(libReferenceDirectives, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "prepend" /* BundleFileSectionKind.Prepend */:
                    var prependTexts = void 0;
                    for (var _b = 0, _c = section.texts; _b < _c.length; _b++) {
                        var text = _c[_b];
                        if (!stripInternal || text.kind !== "internal" /* BundleFileSectionKind.Internal */) {
                            prependTexts = ts.append(prependTexts, ts.setTextRange(ts.factory.createUnparsedTextLike(text.data, text.kind === "internal" /* BundleFileSectionKind.Internal */), text));
                        }
                    }
                    prependChildren = ts.addRange(prependChildren, prependTexts);
                    texts = ts.append(texts, ts.factory.createUnparsedPrepend(section.data, prependTexts !== null && prependTexts !== void 0 ? prependTexts : ts.emptyArray));
                    break;
                case "internal" /* BundleFileSectionKind.Internal */:
                    if (stripInternal) {
                        if (!texts)
                            texts = [];
                        break;
                    }
                // falls through
                case "text" /* BundleFileSectionKind.Text */:
                    texts = ts.append(texts, ts.setTextRange(ts.factory.createUnparsedTextLike(section.data, section.kind === "internal" /* BundleFileSectionKind.Internal */), section));
                    break;
                default:
                    ts.Debug.assertNever(section);
            }
        }
        if (!texts) {
            var textNode = ts.factory.createUnparsedTextLike(/*data*/ undefined, /*internal*/ false);
            ts.setTextRangePosWidth(textNode, 0, typeof length === "function" ? length() : length);
            texts = [textNode];
        }
        var node = ts.parseNodeFactory.createUnparsedSource(prologues !== null && prologues !== void 0 ? prologues : ts.emptyArray, /*syntheticReferences*/ undefined, texts);
        ts.setEachParent(prologues, node);
        ts.setEachParent(texts, node);
        ts.setEachParent(prependChildren, node);
        node.hasNoDefaultLib = hasNoDefaultLib;
        node.helpers = helpers;
        node.referencedFiles = referencedFiles || ts.emptyArray;
        node.typeReferenceDirectives = typeReferenceDirectives;
        node.libReferenceDirectives = libReferenceDirectives || ts.emptyArray;
        return node;
    }
    function parseOldFileOfCurrentEmit(bundleFileInfo) {
        var texts;
        var syntheticReferences;
        for (var _i = 0, _a = bundleFileInfo.sections; _i < _a.length; _i++) {
            var section = _a[_i];
            switch (section.kind) {
                case "internal" /* BundleFileSectionKind.Internal */:
                case "text" /* BundleFileSectionKind.Text */:
                    texts = ts.append(texts, ts.setTextRange(ts.factory.createUnparsedTextLike(section.data, section.kind === "internal" /* BundleFileSectionKind.Internal */), section));
                    break;
                case "no-default-lib" /* BundleFileSectionKind.NoDefaultLib */:
                case "reference" /* BundleFileSectionKind.Reference */:
                case "type" /* BundleFileSectionKind.Type */:
                case "type-import" /* BundleFileSectionKind.TypeResolutionModeImport */:
                case "type-require" /* BundleFileSectionKind.TypeResolutionModeRequire */:
                case "lib" /* BundleFileSectionKind.Lib */:
                    syntheticReferences = ts.append(syntheticReferences, ts.setTextRange(ts.factory.createUnparsedSyntheticReference(section), section));
                    break;
                // Ignore
                case "prologue" /* BundleFileSectionKind.Prologue */:
                case "emitHelpers" /* BundleFileSectionKind.EmitHelpers */:
                case "prepend" /* BundleFileSectionKind.Prepend */:
                    break;
                default:
                    ts.Debug.assertNever(section);
            }
        }
        var node = ts.factory.createUnparsedSource(ts.emptyArray, syntheticReferences, texts !== null && texts !== void 0 ? texts : ts.emptyArray);
        ts.setEachParent(syntheticReferences, node);
        ts.setEachParent(texts, node);
        node.helpers = ts.map(bundleFileInfo.sources && bundleFileInfo.sources.helpers, function (name) { return ts.getAllUnscopedEmitHelpers().get(name); });
        return node;
    }
    function createInputFiles(javascriptTextOrReadFileText, declarationTextOrJavascriptPath, javascriptMapPath, javascriptMapTextOrDeclarationPath, declarationMapPath, declarationMapTextOrBuildInfoPath, javascriptPath, declarationPath, buildInfoPath, buildInfo, oldFileOfCurrentEmit) {
        var node = ts.parseNodeFactory.createInputFiles();
        if (!ts.isString(javascriptTextOrReadFileText)) {
            var cache_1 = new ts.Map();
            var textGetter_1 = function (path) {
                if (path === undefined)
                    return undefined;
                var value = cache_1.get(path);
                if (value === undefined) {
                    value = javascriptTextOrReadFileText(path);
                    cache_1.set(path, value !== undefined ? value : false);
                }
                return value !== false ? value : undefined;
            };
            var definedTextGetter_1 = function (path) {
                var result = textGetter_1(path);
                return result !== undefined ? result : "/* Input file ".concat(path, " was missing */\r\n");
            };
            var buildInfo_1;
            var getAndCacheBuildInfo_1 = function (getText) {
                if (buildInfo_1 === undefined) {
                    var result = getText();
                    buildInfo_1 = result !== undefined ? ts.getBuildInfo(result) : false;
                }
                return buildInfo_1 || undefined;
            };
            node.javascriptPath = declarationTextOrJavascriptPath;
            node.javascriptMapPath = javascriptMapPath;
            node.declarationPath = ts.Debug.checkDefined(javascriptMapTextOrDeclarationPath);
            node.declarationMapPath = declarationMapPath;
            node.buildInfoPath = declarationMapTextOrBuildInfoPath;
            Object.defineProperties(node, {
                javascriptText: { get: function () { return definedTextGetter_1(declarationTextOrJavascriptPath); } },
                javascriptMapText: { get: function () { return textGetter_1(javascriptMapPath); } },
                declarationText: { get: function () { return definedTextGetter_1(ts.Debug.checkDefined(javascriptMapTextOrDeclarationPath)); } },
                declarationMapText: { get: function () { return textGetter_1(declarationMapPath); } },
                buildInfo: { get: function () { return getAndCacheBuildInfo_1(function () { return textGetter_1(declarationMapTextOrBuildInfoPath); }); } }
            });
        }
        else {
            node.javascriptText = javascriptTextOrReadFileText;
            node.javascriptMapPath = javascriptMapPath;
            node.javascriptMapText = javascriptMapTextOrDeclarationPath;
            node.declarationText = declarationTextOrJavascriptPath;
            node.declarationMapPath = declarationMapPath;
            node.declarationMapText = declarationMapTextOrBuildInfoPath;
            node.javascriptPath = javascriptPath;
            node.declarationPath = declarationPath;
            node.buildInfoPath = buildInfoPath;
            node.buildInfo = buildInfo;
            node.oldFileOfCurrentEmit = oldFileOfCurrentEmit;
        }
        return node;
    }
    ts.createInputFiles = createInputFiles;
    // tslint:disable-next-line variable-name
    var SourceMapSource;
    /**
     * Create an external source map source file reference
     */
    function createSourceMapSource(fileName, text, skipTrivia) {
        return new (SourceMapSource || (SourceMapSource = ts.objectAllocator.getSourceMapSourceConstructor()))(fileName, text, skipTrivia);
    }
    ts.createSourceMapSource = createSourceMapSource;
    // Utilities
    function setOriginalNode(node, original) {
        node.original = original;
        if (original) {
            var emitNode = original.emitNode;
            if (emitNode)
                node.emitNode = mergeEmitNode(emitNode, node.emitNode);
        }
        return node;
    }
    ts.setOriginalNode = setOriginalNode;
    function mergeEmitNode(sourceEmitNode, destEmitNode) {
        var flags = sourceEmitNode.flags, leadingComments = sourceEmitNode.leadingComments, trailingComments = sourceEmitNode.trailingComments, commentRange = sourceEmitNode.commentRange, sourceMapRange = sourceEmitNode.sourceMapRange, tokenSourceMapRanges = sourceEmitNode.tokenSourceMapRanges, constantValue = sourceEmitNode.constantValue, helpers = sourceEmitNode.helpers, startsOnNewLine = sourceEmitNode.startsOnNewLine;
        if (!destEmitNode)
            destEmitNode = {};
        // We are using `.slice()` here in case `destEmitNode.leadingComments` is pushed to later.
        if (leadingComments)
            destEmitNode.leadingComments = ts.addRange(leadingComments.slice(), destEmitNode.leadingComments);
        if (trailingComments)
            destEmitNode.trailingComments = ts.addRange(trailingComments.slice(), destEmitNode.trailingComments);
        if (flags)
            destEmitNode.flags = flags & ~268435456 /* EmitFlags.Immutable */;
        if (commentRange)
            destEmitNode.commentRange = commentRange;
        if (sourceMapRange)
            destEmitNode.sourceMapRange = sourceMapRange;
        if (tokenSourceMapRanges)
            destEmitNode.tokenSourceMapRanges = mergeTokenSourceMapRanges(tokenSourceMapRanges, destEmitNode.tokenSourceMapRanges);
        if (constantValue !== undefined)
            destEmitNode.constantValue = constantValue;
        if (helpers) {
            for (var _i = 0, helpers_1 = helpers; _i < helpers_1.length; _i++) {
                var helper = helpers_1[_i];
                destEmitNode.helpers = ts.appendIfUnique(destEmitNode.helpers, helper);
            }
        }
        if (startsOnNewLine !== undefined)
            destEmitNode.startsOnNewLine = startsOnNewLine;
        return destEmitNode;
    }
    function mergeTokenSourceMapRanges(sourceRanges, destRanges) {
        if (!destRanges)
            destRanges = [];
        for (var key in sourceRanges) {
            destRanges[key] = sourceRanges[key];
        }
        return destRanges;
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    /**
     * Associates a node with the current transformation, initializing
     * various transient transformation properties.
     * @internal
     */
    function getOrCreateEmitNode(node) {
        var _a;
        if (!node.emitNode) {
            if (ts.isParseTreeNode(node)) {
                // To avoid holding onto transformation artifacts, we keep track of any
                // parse tree node we are annotating. This allows us to clean them up after
                // all transformations have completed.
                if (node.kind === 305 /* SyntaxKind.SourceFile */) {
                    return node.emitNode = { annotatedNodes: [node] };
                }
                var sourceFile = (_a = ts.getSourceFileOfNode(ts.getParseTreeNode(ts.getSourceFileOfNode(node)))) !== null && _a !== void 0 ? _a : ts.Debug.fail("Could not determine parsed source file.");
                getOrCreateEmitNode(sourceFile).annotatedNodes.push(node);
            }
            node.emitNode = {};
        }
        else {
            ts.Debug.assert(!(node.emitNode.flags & 268435456 /* EmitFlags.Immutable */), "Invalid attempt to mutate an immutable node.");
        }
        return node.emitNode;
    }
    ts.getOrCreateEmitNode = getOrCreateEmitNode;
    /**
     * Clears any `EmitNode` entries from parse-tree nodes.
     * @param sourceFile A source file.
     */
    function disposeEmitNodes(sourceFile) {
        var _a, _b;
        // During transformation we may need to annotate a parse tree node with transient
        // transformation properties. As parse tree nodes live longer than transformation
        // nodes, we need to make sure we reclaim any memory allocated for custom ranges
        // from these nodes to ensure we do not hold onto entire subtrees just for position
        // information. We also need to reset these nodes to a pre-transformation state
        // for incremental parsing scenarios so that we do not impact later emit.
        var annotatedNodes = (_b = (_a = ts.getSourceFileOfNode(ts.getParseTreeNode(sourceFile))) === null || _a === void 0 ? void 0 : _a.emitNode) === null || _b === void 0 ? void 0 : _b.annotatedNodes;
        if (annotatedNodes) {
            for (var _i = 0, annotatedNodes_1 = annotatedNodes; _i < annotatedNodes_1.length; _i++) {
                var node = annotatedNodes_1[_i];
                node.emitNode = undefined;
            }
        }
    }
    ts.disposeEmitNodes = disposeEmitNodes;
    /**
     * Sets `EmitFlags.NoComments` on a node and removes any leading and trailing synthetic comments.
     * @internal
     */
    function removeAllComments(node) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.flags |= 1536 /* EmitFlags.NoComments */;
        emitNode.leadingComments = undefined;
        emitNode.trailingComments = undefined;
        return node;
    }
    ts.removeAllComments = removeAllComments;
    /**
     * Sets flags that control emit behavior of a node.
     */
    function setEmitFlags(node, emitFlags) {
        getOrCreateEmitNode(node).flags = emitFlags;
        return node;
    }
    ts.setEmitFlags = setEmitFlags;
    /**
     * Sets flags that control emit behavior of a node.
     */
    /* @internal */
    function addEmitFlags(node, emitFlags) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.flags = emitNode.flags | emitFlags;
        return node;
    }
    ts.addEmitFlags = addEmitFlags;
    /**
     * Gets a custom text range to use when emitting source maps.
     */
    function getSourceMapRange(node) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.sourceMapRange) !== null && _b !== void 0 ? _b : node;
    }
    ts.getSourceMapRange = getSourceMapRange;
    /**
     * Sets a custom text range to use when emitting source maps.
     */
    function setSourceMapRange(node, range) {
        getOrCreateEmitNode(node).sourceMapRange = range;
        return node;
    }
    ts.setSourceMapRange = setSourceMapRange;
    /**
     * Gets the TextRange to use for source maps for a token of a node.
     */
    function getTokenSourceMapRange(node, token) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.tokenSourceMapRanges) === null || _b === void 0 ? void 0 : _b[token];
    }
    ts.getTokenSourceMapRange = getTokenSourceMapRange;
    /**
     * Sets the TextRange to use for source maps for a token of a node.
     */
    function setTokenSourceMapRange(node, token, range) {
        var _a;
        var emitNode = getOrCreateEmitNode(node);
        var tokenSourceMapRanges = (_a = emitNode.tokenSourceMapRanges) !== null && _a !== void 0 ? _a : (emitNode.tokenSourceMapRanges = []);
        tokenSourceMapRanges[token] = range;
        return node;
    }
    ts.setTokenSourceMapRange = setTokenSourceMapRange;
    /**
     * Gets a custom text range to use when emitting comments.
     */
    /*@internal*/
    function getStartsOnNewLine(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.startsOnNewLine;
    }
    ts.getStartsOnNewLine = getStartsOnNewLine;
    /**
     * Sets a custom text range to use when emitting comments.
     */
    /*@internal*/
    function setStartsOnNewLine(node, newLine) {
        getOrCreateEmitNode(node).startsOnNewLine = newLine;
        return node;
    }
    ts.setStartsOnNewLine = setStartsOnNewLine;
    /**
     * Gets a custom text range to use when emitting comments.
     */
    function getCommentRange(node) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.commentRange) !== null && _b !== void 0 ? _b : node;
    }
    ts.getCommentRange = getCommentRange;
    /**
     * Sets a custom text range to use when emitting comments.
     */
    function setCommentRange(node, range) {
        getOrCreateEmitNode(node).commentRange = range;
        return node;
    }
    ts.setCommentRange = setCommentRange;
    function getSyntheticLeadingComments(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.leadingComments;
    }
    ts.getSyntheticLeadingComments = getSyntheticLeadingComments;
    function setSyntheticLeadingComments(node, comments) {
        getOrCreateEmitNode(node).leadingComments = comments;
        return node;
    }
    ts.setSyntheticLeadingComments = setSyntheticLeadingComments;
    function addSyntheticLeadingComment(node, kind, text, hasTrailingNewLine) {
        return setSyntheticLeadingComments(node, ts.append(getSyntheticLeadingComments(node), { kind: kind, pos: -1, end: -1, hasTrailingNewLine: hasTrailingNewLine, text: text }));
    }
    ts.addSyntheticLeadingComment = addSyntheticLeadingComment;
    function getSyntheticTrailingComments(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.trailingComments;
    }
    ts.getSyntheticTrailingComments = getSyntheticTrailingComments;
    function setSyntheticTrailingComments(node, comments) {
        getOrCreateEmitNode(node).trailingComments = comments;
        return node;
    }
    ts.setSyntheticTrailingComments = setSyntheticTrailingComments;
    function addSyntheticTrailingComment(node, kind, text, hasTrailingNewLine) {
        return setSyntheticTrailingComments(node, ts.append(getSyntheticTrailingComments(node), { kind: kind, pos: -1, end: -1, hasTrailingNewLine: hasTrailingNewLine, text: text }));
    }
    ts.addSyntheticTrailingComment = addSyntheticTrailingComment;
    function moveSyntheticComments(node, original) {
        setSyntheticLeadingComments(node, getSyntheticLeadingComments(original));
        setSyntheticTrailingComments(node, getSyntheticTrailingComments(original));
        var emit = getOrCreateEmitNode(original);
        emit.leadingComments = undefined;
        emit.trailingComments = undefined;
        return node;
    }
    ts.moveSyntheticComments = moveSyntheticComments;
    /**
     * Gets the constant value to emit for an expression representing an enum.
     */
    function getConstantValue(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.constantValue;
    }
    ts.getConstantValue = getConstantValue;
    /**
     * Sets the constant value to emit for an expression.
     */
    function setConstantValue(node, value) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.constantValue = value;
        return node;
    }
    ts.setConstantValue = setConstantValue;
    /**
     * Adds an EmitHelper to a node.
     */
    function addEmitHelper(node, helper) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.helpers = ts.append(emitNode.helpers, helper);
        return node;
    }
    ts.addEmitHelper = addEmitHelper;
    /**
     * Add EmitHelpers to a node.
     */
    function addEmitHelpers(node, helpers) {
        if (ts.some(helpers)) {
            var emitNode = getOrCreateEmitNode(node);
            for (var _i = 0, helpers_2 = helpers; _i < helpers_2.length; _i++) {
                var helper = helpers_2[_i];
                emitNode.helpers = ts.appendIfUnique(emitNode.helpers, helper);
            }
        }
        return node;
    }
    ts.addEmitHelpers = addEmitHelpers;
    /**
     * Removes an EmitHelper from a node.
     */
    function removeEmitHelper(node, helper) {
        var _a;
        var helpers = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.helpers;
        if (helpers) {
            return ts.orderedRemoveItem(helpers, helper);
        }
        return false;
    }
    ts.removeEmitHelper = removeEmitHelper;
    /**
     * Gets the EmitHelpers of a node.
     */
    function getEmitHelpers(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.helpers;
    }
    ts.getEmitHelpers = getEmitHelpers;
    /**
     * Moves matching emit helpers from a source node to a target node.
     */
    function moveEmitHelpers(source, target, predicate) {
        var sourceEmitNode = source.emitNode;
        var sourceEmitHelpers = sourceEmitNode && sourceEmitNode.helpers;
        if (!ts.some(sourceEmitHelpers))
            return;
        var targetEmitNode = getOrCreateEmitNode(target);
        var helpersRemoved = 0;
        for (var i = 0; i < sourceEmitHelpers.length; i++) {
            var helper = sourceEmitHelpers[i];
            if (predicate(helper)) {
                helpersRemoved++;
                targetEmitNode.helpers = ts.appendIfUnique(targetEmitNode.helpers, helper);
            }
            else if (helpersRemoved > 0) {
                sourceEmitHelpers[i - helpersRemoved] = helper;
            }
        }
        if (helpersRemoved > 0) {
            sourceEmitHelpers.length -= helpersRemoved;
        }
    }
    ts.moveEmitHelpers = moveEmitHelpers;
    /**
     * Gets the SnippetElement of a node.
     */
    /* @internal */
    function getSnippetElement(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.snippetElement;
    }
    ts.getSnippetElement = getSnippetElement;
    /**
     * Sets the SnippetElement of a node.
     */
    /* @internal */
    function setSnippetElement(node, snippet) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.snippetElement = snippet;
        return node;
    }
    ts.setSnippetElement = setSnippetElement;
    /* @internal */
    function ignoreSourceNewlines(node) {
        getOrCreateEmitNode(node).flags |= 134217728 /* EmitFlags.IgnoreSourceNewlines */;
        return node;
    }
    ts.ignoreSourceNewlines = ignoreSourceNewlines;
    /* @internal */
    function setTypeNode(node, type) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.typeNode = type;
        return node;
    }
    ts.setTypeNode = setTypeNode;
    /* @internal */
    function getTypeNode(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.typeNode;
    }
    ts.getTypeNode = getTypeNode;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createEmitHelperFactory(context) {
        var factory = context.factory;
        var immutableTrue = ts.memoize(function () { return ts.setEmitFlags(factory.createTrue(), 268435456 /* EmitFlags.Immutable */); });
        var immutableFalse = ts.memoize(function () { return ts.setEmitFlags(factory.createFalse(), 268435456 /* EmitFlags.Immutable */); });
        return {
            getUnscopedHelperName: getUnscopedHelperName,
            // TypeScript Helpers
            createDecorateHelper: createDecorateHelper,
            createMetadataHelper: createMetadataHelper,
            createParamHelper: createParamHelper,
            // ES2018 Helpers
            createAssignHelper: createAssignHelper,
            createAwaitHelper: createAwaitHelper,
            createAsyncGeneratorHelper: createAsyncGeneratorHelper,
            createAsyncDelegatorHelper: createAsyncDelegatorHelper,
            createAsyncValuesHelper: createAsyncValuesHelper,
            // ES2018 Destructuring Helpers
            createRestHelper: createRestHelper,
            // ES2017 Helpers
            createAwaiterHelper: createAwaiterHelper,
            // ES2015 Helpers
            createExtendsHelper: createExtendsHelper,
            createTemplateObjectHelper: createTemplateObjectHelper,
            createSpreadArrayHelper: createSpreadArrayHelper,
            // ES2015 Destructuring Helpers
            createValuesHelper: createValuesHelper,
            createReadHelper: createReadHelper,
            // ES2015 Generator Helpers
            createGeneratorHelper: createGeneratorHelper,
            // ES Module Helpers
            createCreateBindingHelper: createCreateBindingHelper,
            createImportStarHelper: createImportStarHelper,
            createImportStarCallbackHelper: createImportStarCallbackHelper,
            createImportDefaultHelper: createImportDefaultHelper,
            createExportStarHelper: createExportStarHelper,
            // Class Fields Helpers
            createClassPrivateFieldGetHelper: createClassPrivateFieldGetHelper,
            createClassPrivateFieldSetHelper: createClassPrivateFieldSetHelper,
            createClassPrivateFieldInHelper: createClassPrivateFieldInHelper
        };
        /**
         * Gets an identifier for the name of an *unscoped* emit helper.
         */
        function getUnscopedHelperName(name) {
            return ts.setEmitFlags(factory.createIdentifier(name), 4096 /* EmitFlags.HelperName */ | 2 /* EmitFlags.AdviseOnEmitNode */);
        }
        // TypeScript Helpers
        function createDecorateHelper(decoratorExpressions, target, memberName, descriptor) {
            context.requestEmitHelper(ts.decorateHelper);
            var argumentsArray = [];
            argumentsArray.push(factory.createArrayLiteralExpression(decoratorExpressions, /*multiLine*/ true));
            argumentsArray.push(target);
            if (memberName) {
                argumentsArray.push(memberName);
                if (descriptor) {
                    argumentsArray.push(descriptor);
                }
            }
            return factory.createCallExpression(getUnscopedHelperName("__decorate"), 
            /*typeArguments*/ undefined, argumentsArray);
        }
        function createMetadataHelper(metadataKey, metadataValue) {
            context.requestEmitHelper(ts.metadataHelper);
            return factory.createCallExpression(getUnscopedHelperName("__metadata"), 
            /*typeArguments*/ undefined, [
                factory.createStringLiteral(metadataKey),
                metadataValue
            ]);
        }
        function createParamHelper(expression, parameterOffset, location) {
            context.requestEmitHelper(ts.paramHelper);
            return ts.setTextRange(factory.createCallExpression(getUnscopedHelperName("__param"), 
            /*typeArguments*/ undefined, [
                factory.createNumericLiteral(parameterOffset + ""),
                expression
            ]), location);
        }
        // ES2018 Helpers
        function createAssignHelper(attributesSegments) {
            if (ts.getEmitScriptTarget(context.getCompilerOptions()) >= 2 /* ScriptTarget.ES2015 */) {
                return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "assign"), 
                /*typeArguments*/ undefined, attributesSegments);
            }
            context.requestEmitHelper(ts.assignHelper);
            return factory.createCallExpression(getUnscopedHelperName("__assign"), 
            /*typeArguments*/ undefined, attributesSegments);
        }
        function createAwaitHelper(expression) {
            context.requestEmitHelper(ts.awaitHelper);
            return factory.createCallExpression(getUnscopedHelperName("__await"), /*typeArguments*/ undefined, [expression]);
        }
        function createAsyncGeneratorHelper(generatorFunc, hasLexicalThis) {
            context.requestEmitHelper(ts.awaitHelper);
            context.requestEmitHelper(ts.asyncGeneratorHelper);
            // Mark this node as originally an async function
            (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144 /* EmitFlags.AsyncFunctionBody */ | 524288 /* EmitFlags.ReuseTempVariableScope */;
            return factory.createCallExpression(getUnscopedHelperName("__asyncGenerator"), 
            /*typeArguments*/ undefined, [
                hasLexicalThis ? factory.createThis() : factory.createVoidZero(),
                factory.createIdentifier("arguments"),
                generatorFunc
            ]);
        }
        function createAsyncDelegatorHelper(expression) {
            context.requestEmitHelper(ts.awaitHelper);
            context.requestEmitHelper(ts.asyncDelegator);
            return factory.createCallExpression(getUnscopedHelperName("__asyncDelegator"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createAsyncValuesHelper(expression) {
            context.requestEmitHelper(ts.asyncValues);
            return factory.createCallExpression(getUnscopedHelperName("__asyncValues"), 
            /*typeArguments*/ undefined, [expression]);
        }
        // ES2018 Destructuring Helpers
        /** Given value: o, propName: p, pattern: { a, b, ...p } from the original statement
         * `{ a, b, ...p } = o`, create `p = __rest(o, ["a", "b"]);`
         */
        function createRestHelper(value, elements, computedTempVariables, location) {
            context.requestEmitHelper(ts.restHelper);
            var propertyNames = [];
            var computedTempVariableOffset = 0;
            for (var i = 0; i < elements.length - 1; i++) {
                var propertyName = ts.getPropertyNameOfBindingOrAssignmentElement(elements[i]);
                if (propertyName) {
                    if (ts.isComputedPropertyName(propertyName)) {
                        ts.Debug.assertIsDefined(computedTempVariables, "Encountered computed property name but 'computedTempVariables' argument was not provided.");
                        var temp = computedTempVariables[computedTempVariableOffset];
                        computedTempVariableOffset++;
                        // typeof _tmp === "symbol" ? _tmp : _tmp + ""
                        propertyNames.push(factory.createConditionalExpression(factory.createTypeCheck(temp, "symbol"), 
                        /*questionToken*/ undefined, temp, 
                        /*colonToken*/ undefined, factory.createAdd(temp, factory.createStringLiteral(""))));
                    }
                    else {
                        propertyNames.push(factory.createStringLiteralFromNode(propertyName));
                    }
                }
            }
            return factory.createCallExpression(getUnscopedHelperName("__rest"), 
            /*typeArguments*/ undefined, [
                value,
                ts.setTextRange(factory.createArrayLiteralExpression(propertyNames), location)
            ]);
        }
        // ES2017 Helpers
        function createAwaiterHelper(hasLexicalThis, hasLexicalArguments, promiseConstructor, body) {
            context.requestEmitHelper(ts.awaiterHelper);
            var generatorFunc = factory.createFunctionExpression(
            /*modifiers*/ undefined, factory.createToken(41 /* SyntaxKind.AsteriskToken */), 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, 
            /*parameters*/ [], 
            /*type*/ undefined, body);
            // Mark this node as originally an async function
            (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144 /* EmitFlags.AsyncFunctionBody */ | 524288 /* EmitFlags.ReuseTempVariableScope */;
            return factory.createCallExpression(getUnscopedHelperName("__awaiter"), 
            /*typeArguments*/ undefined, [
                hasLexicalThis ? factory.createThis() : factory.createVoidZero(),
                hasLexicalArguments ? factory.createIdentifier("arguments") : factory.createVoidZero(),
                promiseConstructor ? ts.createExpressionFromEntityName(factory, promiseConstructor) : factory.createVoidZero(),
                generatorFunc
            ]);
        }
        // ES2015 Helpers
        function createExtendsHelper(name) {
            context.requestEmitHelper(ts.extendsHelper);
            return factory.createCallExpression(getUnscopedHelperName("__extends"), 
            /*typeArguments*/ undefined, [name, factory.createUniqueName("_super", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */)]);
        }
        function createTemplateObjectHelper(cooked, raw) {
            context.requestEmitHelper(ts.templateObjectHelper);
            return factory.createCallExpression(getUnscopedHelperName("__makeTemplateObject"), 
            /*typeArguments*/ undefined, [cooked, raw]);
        }
        function createSpreadArrayHelper(to, from, packFrom) {
            context.requestEmitHelper(ts.spreadArrayHelper);
            return factory.createCallExpression(getUnscopedHelperName("__spreadArray"), 
            /*typeArguments*/ undefined, [to, from, packFrom ? immutableTrue() : immutableFalse()]);
        }
        // ES2015 Destructuring Helpers
        function createValuesHelper(expression) {
            context.requestEmitHelper(ts.valuesHelper);
            return factory.createCallExpression(getUnscopedHelperName("__values"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createReadHelper(iteratorRecord, count) {
            context.requestEmitHelper(ts.readHelper);
            return factory.createCallExpression(getUnscopedHelperName("__read"), 
            /*typeArguments*/ undefined, count !== undefined
                ? [iteratorRecord, factory.createNumericLiteral(count + "")]
                : [iteratorRecord]);
        }
        // ES2015 Generator Helpers
        function createGeneratorHelper(body) {
            context.requestEmitHelper(ts.generatorHelper);
            return factory.createCallExpression(getUnscopedHelperName("__generator"), 
            /*typeArguments*/ undefined, [factory.createThis(), body]);
        }
        // ES Module Helpers
        function createCreateBindingHelper(module, inputName, outputName) {
            context.requestEmitHelper(ts.createBindingHelper);
            return factory.createCallExpression(getUnscopedHelperName("__createBinding"), 
            /*typeArguments*/ undefined, __spreadArray([factory.createIdentifier("exports"), module, inputName], (outputName ? [outputName] : []), true));
        }
        function createImportStarHelper(expression) {
            context.requestEmitHelper(ts.importStarHelper);
            return factory.createCallExpression(getUnscopedHelperName("__importStar"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createImportStarCallbackHelper() {
            context.requestEmitHelper(ts.importStarHelper);
            return getUnscopedHelperName("__importStar");
        }
        function createImportDefaultHelper(expression) {
            context.requestEmitHelper(ts.importDefaultHelper);
            return factory.createCallExpression(getUnscopedHelperName("__importDefault"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createExportStarHelper(moduleExpression, exportsExpression) {
            if (exportsExpression === void 0) { exportsExpression = factory.createIdentifier("exports"); }
            context.requestEmitHelper(ts.exportStarHelper);
            context.requestEmitHelper(ts.createBindingHelper);
            return factory.createCallExpression(getUnscopedHelperName("__exportStar"), 
            /*typeArguments*/ undefined, [moduleExpression, exportsExpression]);
        }
        // Class Fields Helpers
        function createClassPrivateFieldGetHelper(receiver, state, kind, f) {
            context.requestEmitHelper(ts.classPrivateFieldGetHelper);
            var args;
            if (!f) {
                args = [receiver, state, factory.createStringLiteral(kind)];
            }
            else {
                args = [receiver, state, factory.createStringLiteral(kind), f];
            }
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldGet"), /*typeArguments*/ undefined, args);
        }
        function createClassPrivateFieldSetHelper(receiver, state, value, kind, f) {
            context.requestEmitHelper(ts.classPrivateFieldSetHelper);
            var args;
            if (!f) {
                args = [receiver, state, value, factory.createStringLiteral(kind)];
            }
            else {
                args = [receiver, state, value, factory.createStringLiteral(kind), f];
            }
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldSet"), /*typeArguments*/ undefined, args);
        }
        function createClassPrivateFieldInHelper(state, receiver) {
            context.requestEmitHelper(ts.classPrivateFieldInHelper);
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldIn"), /* typeArguments*/ undefined, [state, receiver]);
        }
    }
    ts.createEmitHelperFactory = createEmitHelperFactory;
    /* @internal */
    function compareEmitHelpers(x, y) {
        if (x === y)
            return 0 /* Comparison.EqualTo */;
        if (x.priority === y.priority)
            return 0 /* Comparison.EqualTo */;
        if (x.priority === undefined)
            return 1 /* Comparison.GreaterThan */;
        if (y.priority === undefined)
            return -1 /* Comparison.LessThan */;
        return ts.compareValues(x.priority, y.priority);
    }
    ts.compareEmitHelpers = compareEmitHelpers;
    /**
     * @param input Template string input strings
     * @param args Names which need to be made file-level unique
     */
    function helperString(input) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return function (uniqueName) {
            var result = "";
            for (var i = 0; i < args.length; i++) {
                result += input[i];
                result += uniqueName(args[i]);
            }
            result += input[input.length - 1];
            return result;
        };
    }
    ts.helperString = helperString;
    // TypeScript Helpers
    ts.decorateHelper = {
        name: "typescript:decorate",
        importName: "__decorate",
        scoped: false,
        priority: 2,
        text: "\n            var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n                var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n                if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n                else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n                return c > 3 && r && Object.defineProperty(target, key, r), r;\n            };"
    };
    ts.metadataHelper = {
        name: "typescript:metadata",
        importName: "__metadata",
        scoped: false,
        priority: 3,
        text: "\n            var __metadata = (this && this.__metadata) || function (k, v) {\n                if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n            };"
    };
    ts.paramHelper = {
        name: "typescript:param",
        importName: "__param",
        scoped: false,
        priority: 4,
        text: "\n            var __param = (this && this.__param) || function (paramIndex, decorator) {\n                return function (target, key) { decorator(target, key, paramIndex); }\n            };"
    };
    // ES2018 Helpers
    ts.assignHelper = {
        name: "typescript:assign",
        importName: "__assign",
        scoped: false,
        priority: 1,
        text: "\n            var __assign = (this && this.__assign) || function () {\n                __assign = Object.assign || function(t) {\n                    for (var s, i = 1, n = arguments.length; i < n; i++) {\n                        s = arguments[i];\n                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                            t[p] = s[p];\n                    }\n                    return t;\n                };\n                return __assign.apply(this, arguments);\n            };"
    };
    ts.awaitHelper = {
        name: "typescript:await",
        importName: "__await",
        scoped: false,
        text: "\n            var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }"
    };
    ts.asyncGeneratorHelper = {
        name: "typescript:asyncGenerator",
        importName: "__asyncGenerator",
        scoped: false,
        dependencies: [ts.awaitHelper],
        text: "\n            var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var g = generator.apply(thisArg, _arguments || []), i, q = [];\n                return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n                function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n                function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n                function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n                function fulfill(value) { resume(\"next\", value); }\n                function reject(value) { resume(\"throw\", value); }\n                function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n            };"
    };
    ts.asyncDelegator = {
        name: "typescript:asyncDelegator",
        importName: "__asyncDelegator",
        scoped: false,
        dependencies: [ts.awaitHelper],
        text: "\n            var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {\n                var i, p;\n                return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n                function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\n            };"
    };
    ts.asyncValues = {
        name: "typescript:asyncValues",
        importName: "__asyncValues",
        scoped: false,
        text: "\n            var __asyncValues = (this && this.__asyncValues) || function (o) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var m = o[Symbol.asyncIterator], i;\n                return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n                function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n                function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n            };"
    };
    // ES2018 Destructuring Helpers
    ts.restHelper = {
        name: "typescript:rest",
        importName: "__rest",
        scoped: false,
        text: "\n            var __rest = (this && this.__rest) || function (s, e) {\n                var t = {};\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n                    t[p] = s[p];\n                if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                            t[p[i]] = s[p[i]];\n                    }\n                return t;\n            };"
    };
    // ES2017 Helpers
    ts.awaiterHelper = {
        name: "typescript:awaiter",
        importName: "__awaiter",
        scoped: false,
        priority: 5,
        text: "\n            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n                return new (P || (P = Promise))(function (resolve, reject) {\n                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n                    function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n                    step((generator = generator.apply(thisArg, _arguments || [])).next());\n                });\n            };"
    };
    // ES2015 Helpers
    ts.extendsHelper = {
        name: "typescript:extends",
        importName: "__extends",
        scoped: false,
        priority: 0,
        text: "\n            var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d, b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n                    return extendStatics(d, b);\n                };\n\n                return function (d, b) {\n                    if (typeof b !== \"function\" && b !== null)\n                        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                    extendStatics(d, b);\n                    function __() { this.constructor = d; }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            })();"
    };
    ts.templateObjectHelper = {
        name: "typescript:makeTemplateObject",
        importName: "__makeTemplateObject",
        scoped: false,
        priority: 0,
        text: "\n            var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\n                if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n                return cooked;\n            };"
    };
    ts.readHelper = {
        name: "typescript:read",
        importName: "__read",
        scoped: false,
        text: "\n            var __read = (this && this.__read) || function (o, n) {\n                var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n                if (!m) return o;\n                var i = m.call(o), r, ar = [], e;\n                try {\n                    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n                }\n                catch (error) { e = { error: error }; }\n                finally {\n                    try {\n                        if (r && !r.done && (m = i[\"return\"])) m.call(i);\n                    }\n                    finally { if (e) throw e.error; }\n                }\n                return ar;\n            };"
    };
    ts.spreadArrayHelper = {
        name: "typescript:spreadArray",
        importName: "__spreadArray",
        scoped: false,
        text: "\n            var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n                if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n                    if (ar || !(i in from)) {\n                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                        ar[i] = from[i];\n                    }\n                }\n                return to.concat(ar || Array.prototype.slice.call(from));\n            };"
    };
    // ES2015 Destructuring Helpers
    ts.valuesHelper = {
        name: "typescript:values",
        importName: "__values",
        scoped: false,
        text: "\n            var __values = (this && this.__values) || function(o) {\n                var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n                if (m) return m.call(o);\n                if (o && typeof o.length === \"number\") return {\n                    next: function () {\n                        if (o && i >= o.length) o = void 0;\n                        return { value: o && o[i++], done: !o };\n                    }\n                };\n                throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n            };"
    };
    // ES2015 Generator Helpers
    // The __generator helper is used by down-level transformations to emulate the runtime
    // semantics of an ES2015 generator function. When called, this helper returns an
    // object that implements the Iterator protocol, in that it has `next`, `return`, and
    // `throw` methods that step through the generator when invoked.
    //
    // parameters:
    //  @param thisArg  The value to use as the `this` binding for the transformed generator body.
    //  @param body     A function that acts as the transformed generator body.
    //
    // variables:
    //  _       Persistent state for the generator that is shared between the helper and the
    //          generator body. The state object has the following members:
    //            sent() - A method that returns or throws the current completion value.
    //            label  - The next point at which to resume evaluation of the generator body.
    //            trys   - A stack of protected regions (try/catch/finally blocks).
    //            ops    - A stack of pending instructions when inside of a finally block.
    //  f       A value indicating whether the generator is executing.
    //  y       An iterator to delegate for a yield*.
    //  t       A temporary variable that holds one of the following values (note that these
    //          cases do not overlap):
    //          - The completion value when resuming from a `yield` or `yield*`.
    //          - The error value for a catch block.
    //          - The current protected region (array of try/catch/finally/end labels).
    //          - The verb (`next`, `throw`, or `return` method) to delegate to the expression
    //            of a `yield*`.
    //          - The result of evaluating the verb delegated to the expression of a `yield*`.
    //
    // functions:
    //  verb(n)     Creates a bound callback to the `step` function for opcode `n`.
    //  step(op)    Evaluates opcodes in a generator body until execution is suspended or
    //              completed.
    //
    // The __generator helper understands a limited set of instructions:
    //  0: next(value?)     - Start or resume the generator with the specified value.
    //  1: throw(error)     - Resume the generator with an exception. If the generator is
    //                        suspended inside of one or more protected regions, evaluates
    //                        any intervening finally blocks between the current label and
    //                        the nearest catch block or function boundary. If uncaught, the
    //                        exception is thrown to the caller.
    //  2: return(value?)   - Resume the generator as if with a return. If the generator is
    //                        suspended inside of one or more protected regions, evaluates any
    //                        intervening finally blocks.
    //  3: break(label)     - Jump to the specified label. If the label is outside of the
    //                        current protected region, evaluates any intervening finally
    //                        blocks.
    //  4: yield(value?)    - Yield execution to the caller with an optional value. When
    //                        resumed, the generator will continue at the next label.
    //  5: yield*(value)    - Delegates evaluation to the supplied iterator. When
    //                        delegation completes, the generator will continue at the next
    //                        label.
    //  6: catch(error)     - Handles an exception thrown from within the generator body. If
    //                        the current label is inside of one or more protected regions,
    //                        evaluates any intervening finally blocks between the current
    //                        label and the nearest catch block or function boundary. If
    //                        uncaught, the exception is thrown to the caller.
    //  7: endfinally       - Ends a finally block, resuming the last instruction prior to
    //                        entering a finally block.
    //
    // For examples of how these are used, see the comments in ./transformers/generators.ts
    ts.generatorHelper = {
        name: "typescript:generator",
        importName: "__generator",
        scoped: false,
        priority: 6,
        text: "\n            var __generator = (this && this.__generator) || function (thisArg, body) {\n                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n                return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n                function verb(n) { return function (v) { return step([n, v]); }; }\n                function step(op) {\n                    if (f) throw new TypeError(\"Generator is already executing.\");\n                    while (_) try {\n                        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                        if (y = 0, t) op = [op[0] & 2, t.value];\n                        switch (op[0]) {\n                            case 0: case 1: t = op; break;\n                            case 4: _.label++; return { value: op[1], done: false };\n                            case 5: _.label++; y = op[1]; op = [0]; continue;\n                            case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                            default:\n                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                                if (t[2]) _.ops.pop();\n                                _.trys.pop(); continue;\n                        }\n                        op = body.call(thisArg, _);\n                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n                }\n            };"
    };
    // ES Module Helpers
    ts.createBindingHelper = {
        name: "typescript:commonjscreatebinding",
        importName: "__createBinding",
        scoped: false,
        priority: 1,
        text: "\n            var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n                if (k2 === undefined) k2 = k;\n                var desc = Object.getOwnPropertyDescriptor(m, k);\n                if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n                  desc = { enumerable: true, get: function() { return m[k]; } };\n                }\n                Object.defineProperty(o, k2, desc);\n            }) : (function(o, m, k, k2) {\n                if (k2 === undefined) k2 = k;\n                o[k2] = m[k];\n            }));"
    };
    ts.setModuleDefaultHelper = {
        name: "typescript:commonjscreatevalue",
        importName: "__setModuleDefault",
        scoped: false,
        priority: 1,
        text: "\n            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n                Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n            }) : function(o, v) {\n                o[\"default\"] = v;\n            });"
    };
    // emit helper for `import * as Name from "foo"`
    ts.importStarHelper = {
        name: "typescript:commonjsimportstar",
        importName: "__importStar",
        scoped: false,
        dependencies: [ts.createBindingHelper, ts.setModuleDefaultHelper],
        priority: 2,
        text: "\n            var __importStar = (this && this.__importStar) || function (mod) {\n                if (mod && mod.__esModule) return mod;\n                var result = {};\n                if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n                __setModuleDefault(result, mod);\n                return result;\n            };"
    };
    // emit helper for `import Name from "foo"`
    ts.importDefaultHelper = {
        name: "typescript:commonjsimportdefault",
        importName: "__importDefault",
        scoped: false,
        text: "\n            var __importDefault = (this && this.__importDefault) || function (mod) {\n                return (mod && mod.__esModule) ? mod : { \"default\": mod };\n            };"
    };
    ts.exportStarHelper = {
        name: "typescript:export-star",
        importName: "__exportStar",
        scoped: false,
        dependencies: [ts.createBindingHelper],
        priority: 2,
        text: "\n            var __exportStar = (this && this.__exportStar) || function(m, exports) {\n                for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n            };"
    };
    /**
     * Parameters:
     *  @param receiver — The object from which the private member will be read.
     *  @param state — One of the following:
     *      - A WeakMap used to read a private instance field.
     *      - A WeakSet used as an instance brand for private instance methods and accessors.
     *      - A function value that should be the undecorated class constructor used to brand check private static fields, methods, and accessors.
     *  @param kind — (optional pre TS 4.3, required for TS 4.3+) One of the following values:
     *      - undefined — Indicates a private instance field (pre TS 4.3).
     *      - "f" — Indicates a private field (instance or static).
     *      - "m" — Indicates a private method (instance or static).
     *      - "a" — Indicates a private accessor (instance or static).
     *  @param f — (optional pre TS 4.3) Depends on the arguments for state and kind:
     *      - If kind is "m", this should be the function corresponding to the static or instance method.
     *      - If kind is "a", this should be the function corresponding to the getter method, or undefined if the getter was not defined.
     *      - If kind is "f" and state is a function, this should be an object holding the value of a static field, or undefined if the static field declaration has not yet been evaluated.
     * Usage:
     * This helper will only ever be used by the compiler in the following ways:
     *
     * Reading from a private instance field (pre TS 4.3):
     *      __classPrivateFieldGet(<any>, <WeakMap>)
     *
     * Reading from a private instance field (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakMap>, "f")
     *
     * Reading from a private instance get accessor (when defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "a", <function>)
     *
     * Reading from a private instance get accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Reading from a private instance method (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "m", <function>)
     *
     * Reading from a private static field (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "f", <{ value: any }>)
     *
     * Reading from a private static get accessor (when defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "a", <function>)
     *
     * Reading from a private static get accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Reading from a private static method (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "m", <function>)
     */
    ts.classPrivateFieldGetHelper = {
        name: "typescript:classPrivateFieldGet",
        importName: "__classPrivateFieldGet",
        scoped: false,
        text: "\n            var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n                if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n                if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n                return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n            };"
    };
    /**
     * Parameters:
     *  @param receiver — The object on which the private member will be set.
     *  @param state — One of the following:
     *      - A WeakMap used to store a private instance field.
     *      - A WeakSet used as an instance brand for private instance methods and accessors.
     *      - A function value that should be the undecorated class constructor used to brand check private static fields, methods, and accessors.
     *  @param value — The value to set.
     *  @param kind — (optional pre TS 4.3, required for TS 4.3+) One of the following values:
     *       - undefined — Indicates a private instance field (pre TS 4.3).
     *       - "f" — Indicates a private field (instance or static).
     *       - "m" — Indicates a private method (instance or static).
     *       - "a" — Indicates a private accessor (instance or static).
     *   @param f — (optional pre TS 4.3) Depends on the arguments for state and kind:
     *       - If kind is "m", this should be the function corresponding to the static or instance method.
     *       - If kind is "a", this should be the function corresponding to the setter method, or undefined if the setter was not defined.
     *       - If kind is "f" and state is a function, this should be an object holding the value of a static field, or undefined if the static field declaration has not yet been evaluated.
     * Usage:
     * This helper will only ever be used by the compiler in the following ways:
     *
     * Writing to a private instance field (pre TS 4.3):
     *      __classPrivateFieldSet(<any>, <WeakMap>, <any>)
     *
     * Writing to a private instance field (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakMap>, <any>, "f")
     *
     * Writing to a private instance set accessor (when defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "a", <function>)
     *
     * Writing to a private instance set accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private instance method (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "m", <function>)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private static field (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "f", <{ value: any }>)
     *
     * Writing to a private static set accessor (when defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "a", <function>)
     *
     * Writing to a private static set accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private static method (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "m", <function>)
     *      NOTE: This always results in a runtime error.
     */
    ts.classPrivateFieldSetHelper = {
        name: "typescript:classPrivateFieldSet",
        importName: "__classPrivateFieldSet",
        scoped: false,
        text: "\n            var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n                if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n                if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n                if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n                return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n            };"
    };
    /**
     * Parameters:
     *  @param state — One of the following:
     *      - A WeakMap when the member is a private instance field.
     *      - A WeakSet when the member is a private instance method or accessor.
     *      - A function value that should be the undecorated class constructor when the member is a private static field, method, or accessor.
     *  @param receiver — The object being checked if it has the private member.
     *
     * Usage:
     * This helper is used to transform `#field in expression` to
     *      `__classPrivateFieldIn(<weakMap/weakSet/constructor>, expression)`
     */
    ts.classPrivateFieldInHelper = {
        name: "typescript:classPrivateFieldIn",
        importName: "__classPrivateFieldIn",
        scoped: false,
        text: "\n            var __classPrivateFieldIn = (this && this.__classPrivateFieldIn) || function(state, receiver) {\n                if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n                return typeof state === \"function\" ? receiver === state : state.has(receiver);\n            };"
    };
    var allUnscopedEmitHelpers;
    function getAllUnscopedEmitHelpers() {
        return allUnscopedEmitHelpers || (allUnscopedEmitHelpers = ts.arrayToMap([
            ts.decorateHelper,
            ts.metadataHelper,
            ts.paramHelper,
            ts.assignHelper,
            ts.awaitHelper,
            ts.asyncGeneratorHelper,
            ts.asyncDelegator,
            ts.asyncValues,
            ts.restHelper,
            ts.awaiterHelper,
            ts.extendsHelper,
            ts.templateObjectHelper,
            ts.spreadArrayHelper,
            ts.valuesHelper,
            ts.readHelper,
            ts.generatorHelper,
            ts.importStarHelper,
            ts.importDefaultHelper,
            ts.exportStarHelper,
            ts.classPrivateFieldGetHelper,
            ts.classPrivateFieldSetHelper,
            ts.classPrivateFieldInHelper,
            ts.createBindingHelper,
            ts.setModuleDefaultHelper
        ], function (helper) { return helper.name; }));
    }
    ts.getAllUnscopedEmitHelpers = getAllUnscopedEmitHelpers;
    ts.asyncSuperHelper = {
        name: "typescript:async-super",
        scoped: true,
        text: helperString(__makeTemplateObject(["\n            const ", " = name => super[name];"], ["\n            const ", " = name => super[name];"]), "_superIndex")
    };
    ts.advancedAsyncSuperHelper = {
        name: "typescript:advanced-async-super",
        scoped: true,
        text: helperString(__makeTemplateObject(["\n            const ", " = (function (geti, seti) {\n                const cache = Object.create(null);\n                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });\n            })(name => super[name], (name, value) => super[name] = value);"], ["\n            const ", " = (function (geti, seti) {\n                const cache = Object.create(null);\n                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });\n            })(name => super[name], (name, value) => super[name] = value);"]), "_superIndex")
    };
    function isCallToHelper(firstSegment, helperName) {
        return ts.isCallExpression(firstSegment)
            && ts.isIdentifier(firstSegment.expression)
            && (ts.getEmitFlags(firstSegment.expression) & 4096 /* EmitFlags.HelperName */) !== 0
            && firstSegment.expression.escapedText === helperName;
    }
    ts.isCallToHelper = isCallToHelper;
})(ts || (ts = {}));
var ts;
(function (ts) {
    // Literals
    function isNumericLiteral(node) {
        return node.kind === 8 /* SyntaxKind.NumericLiteral */;
    }
    ts.isNumericLiteral = isNumericLiteral;
    function isBigIntLiteral(node) {
        return node.kind === 9 /* SyntaxKind.BigIntLiteral */;
    }
    ts.isBigIntLiteral = isBigIntLiteral;
    function isStringLiteral(node) {
        return node.kind === 10 /* SyntaxKind.StringLiteral */;
    }
    ts.isStringLiteral = isStringLiteral;
    function isJsxText(node) {
        return node.kind === 11 /* SyntaxKind.JsxText */;
    }
    ts.isJsxText = isJsxText;
    function isRegularExpressionLiteral(node) {
        return node.kind === 13 /* SyntaxKind.RegularExpressionLiteral */;
    }
    ts.isRegularExpressionLiteral = isRegularExpressionLiteral;
    function isNoSubstitutionTemplateLiteral(node) {
        return node.kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */;
    }
    ts.isNoSubstitutionTemplateLiteral = isNoSubstitutionTemplateLiteral;
    // Pseudo-literals
    function isTemplateHead(node) {
        return node.kind === 15 /* SyntaxKind.TemplateHead */;
    }
    ts.isTemplateHead = isTemplateHead;
    function isTemplateMiddle(node) {
        return node.kind === 16 /* SyntaxKind.TemplateMiddle */;
    }
    ts.isTemplateMiddle = isTemplateMiddle;
    function isTemplateTail(node) {
        return node.kind === 17 /* SyntaxKind.TemplateTail */;
    }
    ts.isTemplateTail = isTemplateTail;
    // Punctuation
    function isDotDotDotToken(node) {
        return node.kind === 25 /* SyntaxKind.DotDotDotToken */;
    }
    ts.isDotDotDotToken = isDotDotDotToken;
    /*@internal*/
    function isCommaToken(node) {
        return node.kind === 27 /* SyntaxKind.CommaToken */;
    }
    ts.isCommaToken = isCommaToken;
    function isPlusToken(node) {
        return node.kind === 39 /* SyntaxKind.PlusToken */;
    }
    ts.isPlusToken = isPlusToken;
    function isMinusToken(node) {
        return node.kind === 40 /* SyntaxKind.MinusToken */;
    }
    ts.isMinusToken = isMinusToken;
    function isAsteriskToken(node) {
        return node.kind === 41 /* SyntaxKind.AsteriskToken */;
    }
    ts.isAsteriskToken = isAsteriskToken;
    /*@internal*/
    function isExclamationToken(node) {
        return node.kind === 53 /* SyntaxKind.ExclamationToken */;
    }
    ts.isExclamationToken = isExclamationToken;
    /*@internal*/
    function isQuestionToken(node) {
        return node.kind === 57 /* SyntaxKind.QuestionToken */;
    }
    ts.isQuestionToken = isQuestionToken;
    /*@internal*/
    function isColonToken(node) {
        return node.kind === 58 /* SyntaxKind.ColonToken */;
    }
    ts.isColonToken = isColonToken;
    /*@internal*/
    function isQuestionDotToken(node) {
        return node.kind === 28 /* SyntaxKind.QuestionDotToken */;
    }
    ts.isQuestionDotToken = isQuestionDotToken;
    /*@internal*/
    function isEqualsGreaterThanToken(node) {
        return node.kind === 38 /* SyntaxKind.EqualsGreaterThanToken */;
    }
    ts.isEqualsGreaterThanToken = isEqualsGreaterThanToken;
    // Identifiers
    function isIdentifier(node) {
        return node.kind === 79 /* SyntaxKind.Identifier */;
    }
    ts.isIdentifier = isIdentifier;
    function isPrivateIdentifier(node) {
        return node.kind === 80 /* SyntaxKind.PrivateIdentifier */;
    }
    ts.isPrivateIdentifier = isPrivateIdentifier;
    // Reserved Words
    /* @internal */
    function isExportModifier(node) {
        return node.kind === 93 /* SyntaxKind.ExportKeyword */;
    }
    ts.isExportModifier = isExportModifier;
    /* @internal */
    function isAsyncModifier(node) {
        return node.kind === 131 /* SyntaxKind.AsyncKeyword */;
    }
    ts.isAsyncModifier = isAsyncModifier;
    /* @internal */
    function isAssertsKeyword(node) {
        return node.kind === 128 /* SyntaxKind.AssertsKeyword */;
    }
    ts.isAssertsKeyword = isAssertsKeyword;
    /* @internal */
    function isAwaitKeyword(node) {
        return node.kind === 132 /* SyntaxKind.AwaitKeyword */;
    }
    ts.isAwaitKeyword = isAwaitKeyword;
    /* @internal */
    function isReadonlyKeyword(node) {
        return node.kind === 145 /* SyntaxKind.ReadonlyKeyword */;
    }
    ts.isReadonlyKeyword = isReadonlyKeyword;
    /* @internal */
    function isStaticModifier(node) {
        return node.kind === 124 /* SyntaxKind.StaticKeyword */;
    }
    ts.isStaticModifier = isStaticModifier;
    /* @internal */
    function isAbstractModifier(node) {
        return node.kind === 126 /* SyntaxKind.AbstractKeyword */;
    }
    ts.isAbstractModifier = isAbstractModifier;
    /*@internal*/
    function isSuperKeyword(node) {
        return node.kind === 106 /* SyntaxKind.SuperKeyword */;
    }
    ts.isSuperKeyword = isSuperKeyword;
    /*@internal*/
    function isImportKeyword(node) {
        return node.kind === 100 /* SyntaxKind.ImportKeyword */;
    }
    ts.isImportKeyword = isImportKeyword;
    // Names
    function isQualifiedName(node) {
        return node.kind === 161 /* SyntaxKind.QualifiedName */;
    }
    ts.isQualifiedName = isQualifiedName;
    function isComputedPropertyName(node) {
        return node.kind === 162 /* SyntaxKind.ComputedPropertyName */;
    }
    ts.isComputedPropertyName = isComputedPropertyName;
    // Signature elements
    function isTypeParameterDeclaration(node) {
        return node.kind === 163 /* SyntaxKind.TypeParameter */;
    }
    ts.isTypeParameterDeclaration = isTypeParameterDeclaration;
    // TODO(rbuckton): Rename to 'isParameterDeclaration'
    function isParameter(node) {
        return node.kind === 164 /* SyntaxKind.Parameter */;
    }
    ts.isParameter = isParameter;
    function isDecorator(node) {
        return node.kind === 165 /* SyntaxKind.Decorator */;
    }
    ts.isDecorator = isDecorator;
    // TypeMember
    function isPropertySignature(node) {
        return node.kind === 166 /* SyntaxKind.PropertySignature */;
    }
    ts.isPropertySignature = isPropertySignature;
    function isPropertyDeclaration(node) {
        return node.kind === 167 /* SyntaxKind.PropertyDeclaration */;
    }
    ts.isPropertyDeclaration = isPropertyDeclaration;
    function isMethodSignature(node) {
        return node.kind === 168 /* SyntaxKind.MethodSignature */;
    }
    ts.isMethodSignature = isMethodSignature;
    function isMethodDeclaration(node) {
        return node.kind === 169 /* SyntaxKind.MethodDeclaration */;
    }
    ts.isMethodDeclaration = isMethodDeclaration;
    function isClassStaticBlockDeclaration(node) {
        return node.kind === 170 /* SyntaxKind.ClassStaticBlockDeclaration */;
    }
    ts.isClassStaticBlockDeclaration = isClassStaticBlockDeclaration;
    function isConstructorDeclaration(node) {
        return node.kind === 171 /* SyntaxKind.Constructor */;
    }
    ts.isConstructorDeclaration = isConstructorDeclaration;
    function isGetAccessorDeclaration(node) {
        return node.kind === 172 /* SyntaxKind.GetAccessor */;
    }
    ts.isGetAccessorDeclaration = isGetAccessorDeclaration;
    function isSetAccessorDeclaration(node) {
        return node.kind === 173 /* SyntaxKind.SetAccessor */;
    }
    ts.isSetAccessorDeclaration = isSetAccessorDeclaration;
    function isCallSignatureDeclaration(node) {
        return node.kind === 174 /* SyntaxKind.CallSignature */;
    }
    ts.isCallSignatureDeclaration = isCallSignatureDeclaration;
    function isConstructSignatureDeclaration(node) {
        return node.kind === 175 /* SyntaxKind.ConstructSignature */;
    }
    ts.isConstructSignatureDeclaration = isConstructSignatureDeclaration;
    function isIndexSignatureDeclaration(node) {
        return node.kind === 176 /* SyntaxKind.IndexSignature */;
    }
    ts.isIndexSignatureDeclaration = isIndexSignatureDeclaration;
    // Type
    function isTypePredicateNode(node) {
        return node.kind === 177 /* SyntaxKind.TypePredicate */;
    }
    ts.isTypePredicateNode = isTypePredicateNode;
    function isTypeReferenceNode(node) {
        return node.kind === 178 /* SyntaxKind.TypeReference */;
    }
    ts.isTypeReferenceNode = isTypeReferenceNode;
    function isFunctionTypeNode(node) {
        return node.kind === 179 /* SyntaxKind.FunctionType */;
    }
    ts.isFunctionTypeNode = isFunctionTypeNode;
    function isConstructorTypeNode(node) {
        return node.kind === 180 /* SyntaxKind.ConstructorType */;
    }
    ts.isConstructorTypeNode = isConstructorTypeNode;
    function isTypeQueryNode(node) {
        return node.kind === 181 /* SyntaxKind.TypeQuery */;
    }
    ts.isTypeQueryNode = isTypeQueryNode;
    function isTypeLiteralNode(node) {
        return node.kind === 182 /* SyntaxKind.TypeLiteral */;
    }
    ts.isTypeLiteralNode = isTypeLiteralNode;
    function isArrayTypeNode(node) {
        return node.kind === 183 /* SyntaxKind.ArrayType */;
    }
    ts.isArrayTypeNode = isArrayTypeNode;
    function isTupleTypeNode(node) {
        return node.kind === 184 /* SyntaxKind.TupleType */;
    }
    ts.isTupleTypeNode = isTupleTypeNode;
    function isNamedTupleMember(node) {
        return node.kind === 197 /* SyntaxKind.NamedTupleMember */;
    }
    ts.isNamedTupleMember = isNamedTupleMember;
    function isOptionalTypeNode(node) {
        return node.kind === 185 /* SyntaxKind.OptionalType */;
    }
    ts.isOptionalTypeNode = isOptionalTypeNode;
    function isRestTypeNode(node) {
        return node.kind === 186 /* SyntaxKind.RestType */;
    }
    ts.isRestTypeNode = isRestTypeNode;
    function isUnionTypeNode(node) {
        return node.kind === 187 /* SyntaxKind.UnionType */;
    }
    ts.isUnionTypeNode = isUnionTypeNode;
    function isIntersectionTypeNode(node) {
        return node.kind === 188 /* SyntaxKind.IntersectionType */;
    }
    ts.isIntersectionTypeNode = isIntersectionTypeNode;
    function isConditionalTypeNode(node) {
        return node.kind === 189 /* SyntaxKind.ConditionalType */;
    }
    ts.isConditionalTypeNode = isConditionalTypeNode;
    function isInferTypeNode(node) {
        return node.kind === 190 /* SyntaxKind.InferType */;
    }
    ts.isInferTypeNode = isInferTypeNode;
    function isParenthesizedTypeNode(node) {
        return node.kind === 191 /* SyntaxKind.ParenthesizedType */;
    }
    ts.isParenthesizedTypeNode = isParenthesizedTypeNode;
    function isThisTypeNode(node) {
        return node.kind === 192 /* SyntaxKind.ThisType */;
    }
    ts.isThisTypeNode = isThisTypeNode;
    function isTypeOperatorNode(node) {
        return node.kind === 193 /* SyntaxKind.TypeOperator */;
    }
    ts.isTypeOperatorNode = isTypeOperatorNode;
    function isIndexedAccessTypeNode(node) {
        return node.kind === 194 /* SyntaxKind.IndexedAccessType */;
    }
    ts.isIndexedAccessTypeNode = isIndexedAccessTypeNode;
    function isMappedTypeNode(node) {
        return node.kind === 195 /* SyntaxKind.MappedType */;
    }
    ts.isMappedTypeNode = isMappedTypeNode;
    function isLiteralTypeNode(node) {
        return node.kind === 196 /* SyntaxKind.LiteralType */;
    }
    ts.isLiteralTypeNode = isLiteralTypeNode;
    function isImportTypeNode(node) {
        return node.kind === 200 /* SyntaxKind.ImportType */;
    }
    ts.isImportTypeNode = isImportTypeNode;
    function isTemplateLiteralTypeSpan(node) {
        return node.kind === 199 /* SyntaxKind.TemplateLiteralTypeSpan */;
    }
    ts.isTemplateLiteralTypeSpan = isTemplateLiteralTypeSpan;
    function isTemplateLiteralTypeNode(node) {
        return node.kind === 198 /* SyntaxKind.TemplateLiteralType */;
    }
    ts.isTemplateLiteralTypeNode = isTemplateLiteralTypeNode;
    // Binding patterns
    function isObjectBindingPattern(node) {
        return node.kind === 201 /* SyntaxKind.ObjectBindingPattern */;
    }
    ts.isObjectBindingPattern = isObjectBindingPattern;
    function isArrayBindingPattern(node) {
        return node.kind === 202 /* SyntaxKind.ArrayBindingPattern */;
    }
    ts.isArrayBindingPattern = isArrayBindingPattern;
    function isBindingElement(node) {
        return node.kind === 203 /* SyntaxKind.BindingElement */;
    }
    ts.isBindingElement = isBindingElement;
    // Expression
    function isArrayLiteralExpression(node) {
        return node.kind === 204 /* SyntaxKind.ArrayLiteralExpression */;
    }
    ts.isArrayLiteralExpression = isArrayLiteralExpression;
    function isObjectLiteralExpression(node) {
        return node.kind === 205 /* SyntaxKind.ObjectLiteralExpression */;
    }
    ts.isObjectLiteralExpression = isObjectLiteralExpression;
    function isPropertyAccessExpression(node) {
        return node.kind === 206 /* SyntaxKind.PropertyAccessExpression */;
    }
    ts.isPropertyAccessExpression = isPropertyAccessExpression;
    function isElementAccessExpression(node) {
        return node.kind === 207 /* SyntaxKind.ElementAccessExpression */;
    }
    ts.isElementAccessExpression = isElementAccessExpression;
    function isCallExpression(node) {
        return node.kind === 208 /* SyntaxKind.CallExpression */;
    }
    ts.isCallExpression = isCallExpression;
    function isNewExpression(node) {
        return node.kind === 209 /* SyntaxKind.NewExpression */;
    }
    ts.isNewExpression = isNewExpression;
    function isTaggedTemplateExpression(node) {
        return node.kind === 210 /* SyntaxKind.TaggedTemplateExpression */;
    }
    ts.isTaggedTemplateExpression = isTaggedTemplateExpression;
    function isTypeAssertionExpression(node) {
        return node.kind === 211 /* SyntaxKind.TypeAssertionExpression */;
    }
    ts.isTypeAssertionExpression = isTypeAssertionExpression;
    function isParenthesizedExpression(node) {
        return node.kind === 212 /* SyntaxKind.ParenthesizedExpression */;
    }
    ts.isParenthesizedExpression = isParenthesizedExpression;
    function isFunctionExpression(node) {
        return node.kind === 213 /* SyntaxKind.FunctionExpression */;
    }
    ts.isFunctionExpression = isFunctionExpression;
    function isArrowFunction(node) {
        return node.kind === 214 /* SyntaxKind.ArrowFunction */;
    }
    ts.isArrowFunction = isArrowFunction;
    function isDeleteExpression(node) {
        return node.kind === 215 /* SyntaxKind.DeleteExpression */;
    }
    ts.isDeleteExpression = isDeleteExpression;
    function isTypeOfExpression(node) {
        return node.kind === 216 /* SyntaxKind.TypeOfExpression */;
    }
    ts.isTypeOfExpression = isTypeOfExpression;
    function isVoidExpression(node) {
        return node.kind === 217 /* SyntaxKind.VoidExpression */;
    }
    ts.isVoidExpression = isVoidExpression;
    function isAwaitExpression(node) {
        return node.kind === 218 /* SyntaxKind.AwaitExpression */;
    }
    ts.isAwaitExpression = isAwaitExpression;
    function isPrefixUnaryExpression(node) {
        return node.kind === 219 /* SyntaxKind.PrefixUnaryExpression */;
    }
    ts.isPrefixUnaryExpression = isPrefixUnaryExpression;
    function isPostfixUnaryExpression(node) {
        return node.kind === 220 /* SyntaxKind.PostfixUnaryExpression */;
    }
    ts.isPostfixUnaryExpression = isPostfixUnaryExpression;
    function isBinaryExpression(node) {
        return node.kind === 221 /* SyntaxKind.BinaryExpression */;
    }
    ts.isBinaryExpression = isBinaryExpression;
    function isConditionalExpression(node) {
        return node.kind === 222 /* SyntaxKind.ConditionalExpression */;
    }
    ts.isConditionalExpression = isConditionalExpression;
    function isTemplateExpression(node) {
        return node.kind === 223 /* SyntaxKind.TemplateExpression */;
    }
    ts.isTemplateExpression = isTemplateExpression;
    function isYieldExpression(node) {
        return node.kind === 224 /* SyntaxKind.YieldExpression */;
    }
    ts.isYieldExpression = isYieldExpression;
    function isSpreadElement(node) {
        return node.kind === 225 /* SyntaxKind.SpreadElement */;
    }
    ts.isSpreadElement = isSpreadElement;
    function isClassExpression(node) {
        return node.kind === 226 /* SyntaxKind.ClassExpression */;
    }
    ts.isClassExpression = isClassExpression;
    function isOmittedExpression(node) {
        return node.kind === 227 /* SyntaxKind.OmittedExpression */;
    }
    ts.isOmittedExpression = isOmittedExpression;
    function isExpressionWithTypeArguments(node) {
        return node.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */;
    }
    ts.isExpressionWithTypeArguments = isExpressionWithTypeArguments;
    function isAsExpression(node) {
        return node.kind === 229 /* SyntaxKind.AsExpression */;
    }
    ts.isAsExpression = isAsExpression;
    function isNonNullExpression(node) {
        return node.kind === 230 /* SyntaxKind.NonNullExpression */;
    }
    ts.isNonNullExpression = isNonNullExpression;
    function isMetaProperty(node) {
        return node.kind === 231 /* SyntaxKind.MetaProperty */;
    }
    ts.isMetaProperty = isMetaProperty;
    function isSyntheticExpression(node) {
        return node.kind === 232 /* SyntaxKind.SyntheticExpression */;
    }
    ts.isSyntheticExpression = isSyntheticExpression;
    function isPartiallyEmittedExpression(node) {
        return node.kind === 350 /* SyntaxKind.PartiallyEmittedExpression */;
    }
    ts.isPartiallyEmittedExpression = isPartiallyEmittedExpression;
    function isCommaListExpression(node) {
        return node.kind === 351 /* SyntaxKind.CommaListExpression */;
    }
    ts.isCommaListExpression = isCommaListExpression;
    // Misc
    function isTemplateSpan(node) {
        return node.kind === 233 /* SyntaxKind.TemplateSpan */;
    }
    ts.isTemplateSpan = isTemplateSpan;
    function isSemicolonClassElement(node) {
        return node.kind === 234 /* SyntaxKind.SemicolonClassElement */;
    }
    ts.isSemicolonClassElement = isSemicolonClassElement;
    // Elements
    function isBlock(node) {
        return node.kind === 235 /* SyntaxKind.Block */;
    }
    ts.isBlock = isBlock;
    function isVariableStatement(node) {
        return node.kind === 237 /* SyntaxKind.VariableStatement */;
    }
    ts.isVariableStatement = isVariableStatement;
    function isEmptyStatement(node) {
        return node.kind === 236 /* SyntaxKind.EmptyStatement */;
    }
    ts.isEmptyStatement = isEmptyStatement;
    function isExpressionStatement(node) {
        return node.kind === 238 /* SyntaxKind.ExpressionStatement */;
    }
    ts.isExpressionStatement = isExpressionStatement;
    function isIfStatement(node) {
        return node.kind === 239 /* SyntaxKind.IfStatement */;
    }
    ts.isIfStatement = isIfStatement;
    function isDoStatement(node) {
        return node.kind === 240 /* SyntaxKind.DoStatement */;
    }
    ts.isDoStatement = isDoStatement;
    function isWhileStatement(node) {
        return node.kind === 241 /* SyntaxKind.WhileStatement */;
    }
    ts.isWhileStatement = isWhileStatement;
    function isForStatement(node) {
        return node.kind === 242 /* SyntaxKind.ForStatement */;
    }
    ts.isForStatement = isForStatement;
    function isForInStatement(node) {
        return node.kind === 243 /* SyntaxKind.ForInStatement */;
    }
    ts.isForInStatement = isForInStatement;
    function isForOfStatement(node) {
        return node.kind === 244 /* SyntaxKind.ForOfStatement */;
    }
    ts.isForOfStatement = isForOfStatement;
    function isContinueStatement(node) {
        return node.kind === 245 /* SyntaxKind.ContinueStatement */;
    }
    ts.isContinueStatement = isContinueStatement;
    function isBreakStatement(node) {
        return node.kind === 246 /* SyntaxKind.BreakStatement */;
    }
    ts.isBreakStatement = isBreakStatement;
    function isReturnStatement(node) {
        return node.kind === 247 /* SyntaxKind.ReturnStatement */;
    }
    ts.isReturnStatement = isReturnStatement;
    function isWithStatement(node) {
        return node.kind === 248 /* SyntaxKind.WithStatement */;
    }
    ts.isWithStatement = isWithStatement;
    function isSwitchStatement(node) {
        return node.kind === 249 /* SyntaxKind.SwitchStatement */;
    }
    ts.isSwitchStatement = isSwitchStatement;
    function isLabeledStatement(node) {
        return node.kind === 250 /* SyntaxKind.LabeledStatement */;
    }
    ts.isLabeledStatement = isLabeledStatement;
    function isThrowStatement(node) {
        return node.kind === 251 /* SyntaxKind.ThrowStatement */;
    }
    ts.isThrowStatement = isThrowStatement;
    function isTryStatement(node) {
        return node.kind === 252 /* SyntaxKind.TryStatement */;
    }
    ts.isTryStatement = isTryStatement;
    function isDebuggerStatement(node) {
        return node.kind === 253 /* SyntaxKind.DebuggerStatement */;
    }
    ts.isDebuggerStatement = isDebuggerStatement;
    function isVariableDeclaration(node) {
        return node.kind === 254 /* SyntaxKind.VariableDeclaration */;
    }
    ts.isVariableDeclaration = isVariableDeclaration;
    function isVariableDeclarationList(node) {
        return node.kind === 255 /* SyntaxKind.VariableDeclarationList */;
    }
    ts.isVariableDeclarationList = isVariableDeclarationList;
    function isFunctionDeclaration(node) {
        return node.kind === 256 /* SyntaxKind.FunctionDeclaration */;
    }
    ts.isFunctionDeclaration = isFunctionDeclaration;
    function isClassDeclaration(node) {
        return node.kind === 257 /* SyntaxKind.ClassDeclaration */;
    }
    ts.isClassDeclaration = isClassDeclaration;
    function isInterfaceDeclaration(node) {
        return node.kind === 258 /* SyntaxKind.InterfaceDeclaration */;
    }
    ts.isInterfaceDeclaration = isInterfaceDeclaration;
    function isTypeAliasDeclaration(node) {
        return node.kind === 259 /* SyntaxKind.TypeAliasDeclaration */;
    }
    ts.isTypeAliasDeclaration = isTypeAliasDeclaration;
    function isEnumDeclaration(node) {
        return node.kind === 260 /* SyntaxKind.EnumDeclaration */;
    }
    ts.isEnumDeclaration = isEnumDeclaration;
    function isModuleDeclaration(node) {
        return node.kind === 261 /* SyntaxKind.ModuleDeclaration */;
    }
    ts.isModuleDeclaration = isModuleDeclaration;
    function isModuleBlock(node) {
        return node.kind === 262 /* SyntaxKind.ModuleBlock */;
    }
    ts.isModuleBlock = isModuleBlock;
    function isCaseBlock(node) {
        return node.kind === 263 /* SyntaxKind.CaseBlock */;
    }
    ts.isCaseBlock = isCaseBlock;
    function isNamespaceExportDeclaration(node) {
        return node.kind === 264 /* SyntaxKind.NamespaceExportDeclaration */;
    }
    ts.isNamespaceExportDeclaration = isNamespaceExportDeclaration;
    function isImportEqualsDeclaration(node) {
        return node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */;
    }
    ts.isImportEqualsDeclaration = isImportEqualsDeclaration;
    function isImportDeclaration(node) {
        return node.kind === 266 /* SyntaxKind.ImportDeclaration */;
    }
    ts.isImportDeclaration = isImportDeclaration;
    function isImportClause(node) {
        return node.kind === 267 /* SyntaxKind.ImportClause */;
    }
    ts.isImportClause = isImportClause;
    function isImportTypeAssertionContainer(node) {
        return node.kind === 295 /* SyntaxKind.ImportTypeAssertionContainer */;
    }
    ts.isImportTypeAssertionContainer = isImportTypeAssertionContainer;
    function isAssertClause(node) {
        return node.kind === 293 /* SyntaxKind.AssertClause */;
    }
    ts.isAssertClause = isAssertClause;
    function isAssertEntry(node) {
        return node.kind === 294 /* SyntaxKind.AssertEntry */;
    }
    ts.isAssertEntry = isAssertEntry;
    function isNamespaceImport(node) {
        return node.kind === 268 /* SyntaxKind.NamespaceImport */;
    }
    ts.isNamespaceImport = isNamespaceImport;
    function isNamespaceExport(node) {
        return node.kind === 274 /* SyntaxKind.NamespaceExport */;
    }
    ts.isNamespaceExport = isNamespaceExport;
    function isNamedImports(node) {
        return node.kind === 269 /* SyntaxKind.NamedImports */;
    }
    ts.isNamedImports = isNamedImports;
    function isImportSpecifier(node) {
        return node.kind === 270 /* SyntaxKind.ImportSpecifier */;
    }
    ts.isImportSpecifier = isImportSpecifier;
    function isExportAssignment(node) {
        return node.kind === 271 /* SyntaxKind.ExportAssignment */;
    }
    ts.isExportAssignment = isExportAssignment;
    function isExportDeclaration(node) {
        return node.kind === 272 /* SyntaxKind.ExportDeclaration */;
    }
    ts.isExportDeclaration = isExportDeclaration;
    function isNamedExports(node) {
        return node.kind === 273 /* SyntaxKind.NamedExports */;
    }
    ts.isNamedExports = isNamedExports;
    function isExportSpecifier(node) {
        return node.kind === 275 /* SyntaxKind.ExportSpecifier */;
    }
    ts.isExportSpecifier = isExportSpecifier;
    function isMissingDeclaration(node) {
        return node.kind === 276 /* SyntaxKind.MissingDeclaration */;
    }
    ts.isMissingDeclaration = isMissingDeclaration;
    function isNotEmittedStatement(node) {
        return node.kind === 349 /* SyntaxKind.NotEmittedStatement */;
    }
    ts.isNotEmittedStatement = isNotEmittedStatement;
    /* @internal */
    function isSyntheticReference(node) {
        return node.kind === 354 /* SyntaxKind.SyntheticReferenceExpression */;
    }
    ts.isSyntheticReference = isSyntheticReference;
    /* @internal */
    function isMergeDeclarationMarker(node) {
        return node.kind === 352 /* SyntaxKind.MergeDeclarationMarker */;
    }
    ts.isMergeDeclarationMarker = isMergeDeclarationMarker;
    /* @internal */
    function isEndOfDeclarationMarker(node) {
        return node.kind === 353 /* SyntaxKind.EndOfDeclarationMarker */;
    }
    ts.isEndOfDeclarationMarker = isEndOfDeclarationMarker;
    // Module References
    function isExternalModuleReference(node) {
        return node.kind === 277 /* SyntaxKind.ExternalModuleReference */;
    }
    ts.isExternalModuleReference = isExternalModuleReference;
    // JSX
    function isJsxElement(node) {
        return node.kind === 278 /* SyntaxKind.JsxElement */;
    }
    ts.isJsxElement = isJsxElement;
    function isJsxSelfClosingElement(node) {
        return node.kind === 279 /* SyntaxKind.JsxSelfClosingElement */;
    }
    ts.isJsxSelfClosingElement = isJsxSelfClosingElement;
    function isJsxOpeningElement(node) {
        return node.kind === 280 /* SyntaxKind.JsxOpeningElement */;
    }
    ts.isJsxOpeningElement = isJsxOpeningElement;
    function isJsxClosingElement(node) {
        return node.kind === 281 /* SyntaxKind.JsxClosingElement */;
    }
    ts.isJsxClosingElement = isJsxClosingElement;
    function isJsxFragment(node) {
        return node.kind === 282 /* SyntaxKind.JsxFragment */;
    }
    ts.isJsxFragment = isJsxFragment;
    function isJsxOpeningFragment(node) {
        return node.kind === 283 /* SyntaxKind.JsxOpeningFragment */;
    }
    ts.isJsxOpeningFragment = isJsxOpeningFragment;
    function isJsxClosingFragment(node) {
        return node.kind === 284 /* SyntaxKind.JsxClosingFragment */;
    }
    ts.isJsxClosingFragment = isJsxClosingFragment;
    function isJsxAttribute(node) {
        return node.kind === 285 /* SyntaxKind.JsxAttribute */;
    }
    ts.isJsxAttribute = isJsxAttribute;
    function isJsxAttributes(node) {
        return node.kind === 286 /* SyntaxKind.JsxAttributes */;
    }
    ts.isJsxAttributes = isJsxAttributes;
    function isJsxSpreadAttribute(node) {
        return node.kind === 287 /* SyntaxKind.JsxSpreadAttribute */;
    }
    ts.isJsxSpreadAttribute = isJsxSpreadAttribute;
    function isJsxExpression(node) {
        return node.kind === 288 /* SyntaxKind.JsxExpression */;
    }
    ts.isJsxExpression = isJsxExpression;
    // Clauses
    function isCaseClause(node) {
        return node.kind === 289 /* SyntaxKind.CaseClause */;
    }
    ts.isCaseClause = isCaseClause;
    function isDefaultClause(node) {
        return node.kind === 290 /* SyntaxKind.DefaultClause */;
    }
    ts.isDefaultClause = isDefaultClause;
    function isHeritageClause(node) {
        return node.kind === 291 /* SyntaxKind.HeritageClause */;
    }
    ts.isHeritageClause = isHeritageClause;
    function isCatchClause(node) {
        return node.kind === 292 /* SyntaxKind.CatchClause */;
    }
    ts.isCatchClause = isCatchClause;
    // Property assignments
    function isPropertyAssignment(node) {
        return node.kind === 296 /* SyntaxKind.PropertyAssignment */;
    }
    ts.isPropertyAssignment = isPropertyAssignment;
    function isShorthandPropertyAssignment(node) {
        return node.kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */;
    }
    ts.isShorthandPropertyAssignment = isShorthandPropertyAssignment;
    function isSpreadAssignment(node) {
        return node.kind === 298 /* SyntaxKind.SpreadAssignment */;
    }
    ts.isSpreadAssignment = isSpreadAssignment;
    // Enum
    function isEnumMember(node) {
        return node.kind === 299 /* SyntaxKind.EnumMember */;
    }
    ts.isEnumMember = isEnumMember;
    // Unparsed
    // TODO(rbuckton): isUnparsedPrologue
    function isUnparsedPrepend(node) {
        return node.kind === 301 /* SyntaxKind.UnparsedPrepend */;
    }
    ts.isUnparsedPrepend = isUnparsedPrepend;
    // TODO(rbuckton): isUnparsedText
    // TODO(rbuckton): isUnparsedInternalText
    // TODO(rbuckton): isUnparsedSyntheticReference
    // Top-level nodes
    function isSourceFile(node) {
        return node.kind === 305 /* SyntaxKind.SourceFile */;
    }
    ts.isSourceFile = isSourceFile;
    function isBundle(node) {
        return node.kind === 306 /* SyntaxKind.Bundle */;
    }
    ts.isBundle = isBundle;
    function isUnparsedSource(node) {
        return node.kind === 307 /* SyntaxKind.UnparsedSource */;
    }
    ts.isUnparsedSource = isUnparsedSource;
    // TODO(rbuckton): isInputFiles
    // JSDoc Elements
    function isJSDocTypeExpression(node) {
        return node.kind === 309 /* SyntaxKind.JSDocTypeExpression */;
    }
    ts.isJSDocTypeExpression = isJSDocTypeExpression;
    function isJSDocNameReference(node) {
        return node.kind === 310 /* SyntaxKind.JSDocNameReference */;
    }
    ts.isJSDocNameReference = isJSDocNameReference;
    function isJSDocMemberName(node) {
        return node.kind === 311 /* SyntaxKind.JSDocMemberName */;
    }
    ts.isJSDocMemberName = isJSDocMemberName;
    function isJSDocLink(node) {
        return node.kind === 324 /* SyntaxKind.JSDocLink */;
    }
    ts.isJSDocLink = isJSDocLink;
    function isJSDocLinkCode(node) {
        return node.kind === 325 /* SyntaxKind.JSDocLinkCode */;
    }
    ts.isJSDocLinkCode = isJSDocLinkCode;
    function isJSDocLinkPlain(node) {
        return node.kind === 326 /* SyntaxKind.JSDocLinkPlain */;
    }
    ts.isJSDocLinkPlain = isJSDocLinkPlain;
    function isJSDocAllType(node) {
        return node.kind === 312 /* SyntaxKind.JSDocAllType */;
    }
    ts.isJSDocAllType = isJSDocAllType;
    function isJSDocUnknownType(node) {
        return node.kind === 313 /* SyntaxKind.JSDocUnknownType */;
    }
    ts.isJSDocUnknownType = isJSDocUnknownType;
    function isJSDocNullableType(node) {
        return node.kind === 314 /* SyntaxKind.JSDocNullableType */;
    }
    ts.isJSDocNullableType = isJSDocNullableType;
    function isJSDocNonNullableType(node) {
        return node.kind === 315 /* SyntaxKind.JSDocNonNullableType */;
    }
    ts.isJSDocNonNullableType = isJSDocNonNullableType;
    function isJSDocOptionalType(node) {
        return node.kind === 316 /* SyntaxKind.JSDocOptionalType */;
    }
    ts.isJSDocOptionalType = isJSDocOptionalType;
    function isJSDocFunctionType(node) {
        return node.kind === 317 /* SyntaxKind.JSDocFunctionType */;
    }
    ts.isJSDocFunctionType = isJSDocFunctionType;
    function isJSDocVariadicType(node) {
        return node.kind === 318 /* SyntaxKind.JSDocVariadicType */;
    }
    ts.isJSDocVariadicType = isJSDocVariadicType;
    function isJSDocNamepathType(node) {
        return node.kind === 319 /* SyntaxKind.JSDocNamepathType */;
    }
    ts.isJSDocNamepathType = isJSDocNamepathType;
    function isJSDoc(node) {
        return node.kind === 320 /* SyntaxKind.JSDoc */;
    }
    ts.isJSDoc = isJSDoc;
    function isJSDocTypeLiteral(node) {
        return node.kind === 322 /* SyntaxKind.JSDocTypeLiteral */;
    }
    ts.isJSDocTypeLiteral = isJSDocTypeLiteral;
    function isJSDocSignature(node) {
        return node.kind === 323 /* SyntaxKind.JSDocSignature */;
    }
    ts.isJSDocSignature = isJSDocSignature;
    // JSDoc Tags
    function isJSDocAugmentsTag(node) {
        return node.kind === 328 /* SyntaxKind.JSDocAugmentsTag */;
    }
    ts.isJSDocAugmentsTag = isJSDocAugmentsTag;
    function isJSDocAuthorTag(node) {
        return node.kind === 330 /* SyntaxKind.JSDocAuthorTag */;
    }
    ts.isJSDocAuthorTag = isJSDocAuthorTag;
    function isJSDocClassTag(node) {
        return node.kind === 332 /* SyntaxKind.JSDocClassTag */;
    }
    ts.isJSDocClassTag = isJSDocClassTag;
    function isJSDocCallbackTag(node) {
        return node.kind === 338 /* SyntaxKind.JSDocCallbackTag */;
    }
    ts.isJSDocCallbackTag = isJSDocCallbackTag;
    function isJSDocPublicTag(node) {
        return node.kind === 333 /* SyntaxKind.JSDocPublicTag */;
    }
    ts.isJSDocPublicTag = isJSDocPublicTag;
    function isJSDocPrivateTag(node) {
        return node.kind === 334 /* SyntaxKind.JSDocPrivateTag */;
    }
    ts.isJSDocPrivateTag = isJSDocPrivateTag;
    function isJSDocProtectedTag(node) {
        return node.kind === 335 /* SyntaxKind.JSDocProtectedTag */;
    }
    ts.isJSDocProtectedTag = isJSDocProtectedTag;
    function isJSDocReadonlyTag(node) {
        return node.kind === 336 /* SyntaxKind.JSDocReadonlyTag */;
    }
    ts.isJSDocReadonlyTag = isJSDocReadonlyTag;
    function isJSDocOverrideTag(node) {
        return node.kind === 337 /* SyntaxKind.JSDocOverrideTag */;
    }
    ts.isJSDocOverrideTag = isJSDocOverrideTag;
    function isJSDocDeprecatedTag(node) {
        return node.kind === 331 /* SyntaxKind.JSDocDeprecatedTag */;
    }
    ts.isJSDocDeprecatedTag = isJSDocDeprecatedTag;
    function isJSDocSeeTag(node) {
        return node.kind === 346 /* SyntaxKind.JSDocSeeTag */;
    }
    ts.isJSDocSeeTag = isJSDocSeeTag;
    function isJSDocEnumTag(node) {
        return node.kind === 339 /* SyntaxKind.JSDocEnumTag */;
    }
    ts.isJSDocEnumTag = isJSDocEnumTag;
    function isJSDocParameterTag(node) {
        return node.kind === 340 /* SyntaxKind.JSDocParameterTag */;
    }
    ts.isJSDocParameterTag = isJSDocParameterTag;
    function isJSDocReturnTag(node) {
        return node.kind === 341 /* SyntaxKind.JSDocReturnTag */;
    }
    ts.isJSDocReturnTag = isJSDocReturnTag;
    function isJSDocThisTag(node) {
        return node.kind === 342 /* SyntaxKind.JSDocThisTag */;
    }
    ts.isJSDocThisTag = isJSDocThisTag;
    function isJSDocTypeTag(node) {
        return node.kind === 343 /* SyntaxKind.JSDocTypeTag */;
    }
    ts.isJSDocTypeTag = isJSDocTypeTag;
    function isJSDocTemplateTag(node) {
        return node.kind === 344 /* SyntaxKind.JSDocTemplateTag */;
    }
    ts.isJSDocTemplateTag = isJSDocTemplateTag;
    function isJSDocTypedefTag(node) {
        return node.kind === 345 /* SyntaxKind.JSDocTypedefTag */;
    }
    ts.isJSDocTypedefTag = isJSDocTypedefTag;
    function isJSDocUnknownTag(node) {
        return node.kind === 327 /* SyntaxKind.JSDocTag */;
    }
    ts.isJSDocUnknownTag = isJSDocUnknownTag;
    function isJSDocPropertyTag(node) {
        return node.kind === 347 /* SyntaxKind.JSDocPropertyTag */;
    }
    ts.isJSDocPropertyTag = isJSDocPropertyTag;
    function isJSDocImplementsTag(node) {
        return node.kind === 329 /* SyntaxKind.JSDocImplementsTag */;
    }
    ts.isJSDocImplementsTag = isJSDocImplementsTag;
    // Synthesized list
    /* @internal */
    function isSyntaxList(n) {
        return n.kind === 348 /* SyntaxKind.SyntaxList */;
    }
    ts.isSyntaxList = isSyntaxList;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    // Compound nodes
    function createEmptyExports(factory) {
        return factory.createExportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*isTypeOnly*/ false, factory.createNamedExports([]), /*moduleSpecifier*/ undefined);
    }
    ts.createEmptyExports = createEmptyExports;
    function createMemberAccessForPropertyName(factory, target, memberName, location) {
        if (ts.isComputedPropertyName(memberName)) {
            return ts.setTextRange(factory.createElementAccessExpression(target, memberName.expression), location);
        }
        else {
            var expression = ts.setTextRange(ts.isMemberName(memberName)
                ? factory.createPropertyAccessExpression(target, memberName)
                : factory.createElementAccessExpression(target, memberName), memberName);
            ts.getOrCreateEmitNode(expression).flags |= 64 /* EmitFlags.NoNestedSourceMaps */;
            return expression;
        }
    }
    ts.createMemberAccessForPropertyName = createMemberAccessForPropertyName;
    function createReactNamespace(reactNamespace, parent) {
        // To ensure the emit resolver can properly resolve the namespace, we need to
        // treat this identifier as if it were a source tree node by clearing the `Synthesized`
        // flag and setting a parent node.
        var react = ts.parseNodeFactory.createIdentifier(reactNamespace || "React");
        // Set the parent that is in parse tree
        // this makes sure that parent chain is intact for checker to traverse complete scope tree
        ts.setParent(react, ts.getParseTreeNode(parent));
        return react;
    }
    function createJsxFactoryExpressionFromEntityName(factory, jsxFactory, parent) {
        if (ts.isQualifiedName(jsxFactory)) {
            var left = createJsxFactoryExpressionFromEntityName(factory, jsxFactory.left, parent);
            var right = factory.createIdentifier(ts.idText(jsxFactory.right));
            right.escapedText = jsxFactory.right.escapedText;
            return factory.createPropertyAccessExpression(left, right);
        }
        else {
            return createReactNamespace(ts.idText(jsxFactory), parent);
        }
    }
    function createJsxFactoryExpression(factory, jsxFactoryEntity, reactNamespace, parent) {
        return jsxFactoryEntity ?
            createJsxFactoryExpressionFromEntityName(factory, jsxFactoryEntity, parent) :
            factory.createPropertyAccessExpression(createReactNamespace(reactNamespace, parent), "createElement");
    }
    ts.createJsxFactoryExpression = createJsxFactoryExpression;
    function createJsxFragmentFactoryExpression(factory, jsxFragmentFactoryEntity, reactNamespace, parent) {
        return jsxFragmentFactoryEntity ?
            createJsxFactoryExpressionFromEntityName(factory, jsxFragmentFactoryEntity, parent) :
            factory.createPropertyAccessExpression(createReactNamespace(reactNamespace, parent), "Fragment");
    }
    function createExpressionForJsxElement(factory, callee, tagName, props, children, location) {
        var argumentsList = [tagName];
        if (props) {
            argumentsList.push(props);
        }
        if (children && children.length > 0) {
            if (!props) {
                argumentsList.push(factory.createNull());
            }
            if (children.length > 1) {
                for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                    var child = children_3[_i];
                    startOnNewLine(child);
                    argumentsList.push(child);
                }
            }
            else {
                argumentsList.push(children[0]);
            }
        }
        return ts.setTextRange(factory.createCallExpression(callee, 
        /*typeArguments*/ undefined, argumentsList), location);
    }
    ts.createExpressionForJsxElement = createExpressionForJsxElement;
    function createExpressionForJsxFragment(factory, jsxFactoryEntity, jsxFragmentFactoryEntity, reactNamespace, children, parentElement, location) {
        var tagName = createJsxFragmentFactoryExpression(factory, jsxFragmentFactoryEntity, reactNamespace, parentElement);
        var argumentsList = [tagName, factory.createNull()];
        if (children && children.length > 0) {
            if (children.length > 1) {
                for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                    var child = children_4[_i];
                    startOnNewLine(child);
                    argumentsList.push(child);
                }
            }
            else {
                argumentsList.push(children[0]);
            }
        }
        return ts.setTextRange(factory.createCallExpression(createJsxFactoryExpression(factory, jsxFactoryEntity, reactNamespace, parentElement), 
        /*typeArguments*/ undefined, argumentsList), location);
    }
    ts.createExpressionForJsxFragment = createExpressionForJsxFragment;
    // Utilities
    function createForOfBindingStatement(factory, node, boundValue) {
        if (ts.isVariableDeclarationList(node)) {
            var firstDeclaration = ts.first(node.declarations);
            var updatedDeclaration = factory.updateVariableDeclaration(firstDeclaration, firstDeclaration.name, 
            /*exclamationToken*/ undefined, 
            /*type*/ undefined, boundValue);
            return ts.setTextRange(factory.createVariableStatement(
            /*modifiers*/ undefined, factory.updateVariableDeclarationList(node, [updatedDeclaration])), 
            /*location*/ node);
        }
        else {
            var updatedExpression = ts.setTextRange(factory.createAssignment(node, boundValue), /*location*/ node);
            return ts.setTextRange(factory.createExpressionStatement(updatedExpression), /*location*/ node);
        }
    }
    ts.createForOfBindingStatement = createForOfBindingStatement;
    function insertLeadingStatement(factory, dest, source) {
        if (ts.isBlock(dest)) {
            return factory.updateBlock(dest, ts.setTextRange(factory.createNodeArray(__spreadArray([source], dest.statements, true)), dest.statements));
        }
        else {
            return factory.createBlock(factory.createNodeArray([dest, source]), /*multiLine*/ true);
        }
    }
    ts.insertLeadingStatement = insertLeadingStatement;
    function createExpressionFromEntityName(factory, node) {
        if (ts.isQualifiedName(node)) {
            var left = createExpressionFromEntityName(factory, node.left);
            // TODO(rbuckton): Does this need to be parented?
            var right = ts.setParent(ts.setTextRange(factory.cloneNode(node.right), node.right), node.right.parent);
            return ts.setTextRange(factory.createPropertyAccessExpression(left, right), node);
        }
        else {
            // TODO(rbuckton): Does this need to be parented?
            return ts.setParent(ts.setTextRange(factory.cloneNode(node), node), node.parent);
        }
    }
    ts.createExpressionFromEntityName = createExpressionFromEntityName;
    function createExpressionForPropertyName(factory, memberName) {
        if (ts.isIdentifier(memberName)) {
            return factory.createStringLiteralFromNode(memberName);
        }
        else if (ts.isComputedPropertyName(memberName)) {
            // TODO(rbuckton): Does this need to be parented?
            return ts.setParent(ts.setTextRange(factory.cloneNode(memberName.expression), memberName.expression), memberName.expression.parent);
        }
        else {
            // TODO(rbuckton): Does this need to be parented?
            return ts.setParent(ts.setTextRange(factory.cloneNode(memberName), memberName), memberName.parent);
        }
    }
    ts.createExpressionForPropertyName = createExpressionForPropertyName;
    function createExpressionForAccessorDeclaration(factory, properties, property, receiver, multiLine) {
        var _a = ts.getAllAccessorDeclarations(properties, property), firstAccessor = _a.firstAccessor, getAccessor = _a.getAccessor, setAccessor = _a.setAccessor;
        if (property === firstAccessor) {
            return ts.setTextRange(factory.createObjectDefinePropertyCall(receiver, createExpressionForPropertyName(factory, property.name), factory.createPropertyDescriptor({
                enumerable: factory.createFalse(),
                configurable: true,
                get: getAccessor && ts.setTextRange(ts.setOriginalNode(factory.createFunctionExpression(getAccessor.modifiers, 
                /*asteriskToken*/ undefined, 
                /*name*/ undefined, 
                /*typeParameters*/ undefined, getAccessor.parameters, 
                /*type*/ undefined, getAccessor.body // TODO: GH#18217
                ), getAccessor), getAccessor),
                set: setAccessor && ts.setTextRange(ts.setOriginalNode(factory.createFunctionExpression(setAccessor.modifiers, 
                /*asteriskToken*/ undefined, 
                /*name*/ undefined, 
                /*typeParameters*/ undefined, setAccessor.parameters, 
                /*type*/ undefined, setAccessor.body // TODO: GH#18217
                ), setAccessor), setAccessor)
            }, !multiLine)), firstAccessor);
        }
        return undefined;
    }
    function createExpressionForPropertyAssignment(factory, property, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, property.name, /*location*/ property.name), property.initializer), property), property);
    }
    function createExpressionForShorthandPropertyAssignment(factory, property, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, property.name, /*location*/ property.name), factory.cloneNode(property.name)), 
        /*location*/ property), 
        /*original*/ property);
    }
    function createExpressionForMethodDeclaration(factory, method, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, method.name, /*location*/ method.name), ts.setOriginalNode(ts.setTextRange(factory.createFunctionExpression(method.modifiers, method.asteriskToken, 
        /*name*/ undefined, 
        /*typeParameters*/ undefined, method.parameters, 
        /*type*/ undefined, method.body // TODO: GH#18217
        ), 
        /*location*/ method), 
        /*original*/ method)), 
        /*location*/ method), 
        /*original*/ method);
    }
    function createExpressionForObjectLiteralElementLike(factory, node, property, receiver) {
        if (property.name && ts.isPrivateIdentifier(property.name)) {
            ts.Debug.failBadSyntaxKind(property.name, "Private identifiers are not allowed in object literals.");
        }
        switch (property.kind) {
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
                return createExpressionForAccessorDeclaration(factory, node.properties, property, receiver, !!node.multiLine);
            case 296 /* SyntaxKind.PropertyAssignment */:
                return createExpressionForPropertyAssignment(factory, property, receiver);
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                return createExpressionForShorthandPropertyAssignment(factory, property, receiver);
            case 169 /* SyntaxKind.MethodDeclaration */:
                return createExpressionForMethodDeclaration(factory, property, receiver);
        }
    }
    ts.createExpressionForObjectLiteralElementLike = createExpressionForObjectLiteralElementLike;
    /**
     * Expand the read and increment/decrement operations a pre- or post-increment or pre- or post-decrement expression.
     *
     * ```ts
     * // input
     * <expression>++
     * // output (if result is not discarded)
     * var <temp>;
     * (<temp> = <expression>, <resultVariable> = <temp>++, <temp>)
     * // output (if result is discarded)
     * var <temp>;
     * (<temp> = <expression>, <temp>++, <temp>)
     *
     * // input
     * ++<expression>
     * // output (if result is not discarded)
     * var <temp>;
     * (<temp> = <expression>, <resultVariable> = ++<temp>)
     * // output (if result is discarded)
     * var <temp>;
     * (<temp> = <expression>, ++<temp>)
     * ```
     *
     * It is up to the caller to supply a temporary variable for `<resultVariable>` if one is needed.
     * The temporary variable `<temp>` is injected so that `++` and `--` work uniformly with `number` and `bigint`.
     * The result of the expression is always the final result of incrementing or decrementing the expression, so that it can be used for storage.
     *
     * @param factory {@link NodeFactory} used to create the expanded representation.
     * @param node The original prefix or postfix unary node.
     * @param expression The expression to use as the value to increment or decrement
     * @param resultVariable A temporary variable in which to store the result. Pass `undefined` if the result is discarded, or if the value of `<temp>` is the expected result.
     */
    function expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, recordTempVariable, resultVariable) {
        var operator = node.operator;
        ts.Debug.assert(operator === 45 /* SyntaxKind.PlusPlusToken */ || operator === 46 /* SyntaxKind.MinusMinusToken */, "Expected 'node' to be a pre- or post-increment or pre- or post-decrement expression");
        var temp = factory.createTempVariable(recordTempVariable);
        expression = factory.createAssignment(temp, expression);
        ts.setTextRange(expression, node.operand);
        var operation = ts.isPrefixUnaryExpression(node) ?
            factory.createPrefixUnaryExpression(operator, temp) :
            factory.createPostfixUnaryExpression(temp, operator);
        ts.setTextRange(operation, node);
        if (resultVariable) {
            operation = factory.createAssignment(resultVariable, operation);
            ts.setTextRange(operation, node);
        }
        expression = factory.createComma(expression, operation);
        ts.setTextRange(expression, node);
        if (ts.isPostfixUnaryExpression(node)) {
            expression = factory.createComma(expression, temp);
            ts.setTextRange(expression, node);
        }
        return expression;
    }
    ts.expandPreOrPostfixIncrementOrDecrementExpression = expandPreOrPostfixIncrementOrDecrementExpression;
    /**
     * Gets whether an identifier should only be referred to by its internal name.
     */
    function isInternalName(node) {
        return (ts.getEmitFlags(node) & 32768 /* EmitFlags.InternalName */) !== 0;
    }
    ts.isInternalName = isInternalName;
    /**
     * Gets whether an identifier should only be referred to by its local name.
     */
    function isLocalName(node) {
        return (ts.getEmitFlags(node) & 16384 /* EmitFlags.LocalName */) !== 0;
    }
    ts.isLocalName = isLocalName;
    /**
     * Gets whether an identifier should only be referred to by its export representation if the
     * name points to an exported symbol.
     */
    function isExportName(node) {
        return (ts.getEmitFlags(node) & 8192 /* EmitFlags.ExportName */) !== 0;
    }
    ts.isExportName = isExportName;
    function isUseStrictPrologue(node) {
        return ts.isStringLiteral(node.expression) && node.expression.text === "use strict";
    }
    function findUseStrictPrologue(statements) {
        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
            var statement = statements_1[_i];
            if (ts.isPrologueDirective(statement)) {
                if (isUseStrictPrologue(statement)) {
                    return statement;
                }
            }
            else {
                break;
            }
        }
        return undefined;
    }
    ts.findUseStrictPrologue = findUseStrictPrologue;
    function startsWithUseStrict(statements) {
        var firstStatement = ts.firstOrUndefined(statements);
        return firstStatement !== undefined
            && ts.isPrologueDirective(firstStatement)
            && isUseStrictPrologue(firstStatement);
    }
    ts.startsWithUseStrict = startsWithUseStrict;
    function isCommaSequence(node) {
        return node.kind === 221 /* SyntaxKind.BinaryExpression */ && node.operatorToken.kind === 27 /* SyntaxKind.CommaToken */ ||
            node.kind === 351 /* SyntaxKind.CommaListExpression */;
    }
    ts.isCommaSequence = isCommaSequence;
    function isJSDocTypeAssertion(node) {
        return ts.isParenthesizedExpression(node)
            && ts.isInJSFile(node)
            && !!ts.getJSDocTypeTag(node);
    }
    ts.isJSDocTypeAssertion = isJSDocTypeAssertion;
    function getJSDocTypeAssertionType(node) {
        var type = ts.getJSDocType(node);
        ts.Debug.assertIsDefined(type);
        return type;
    }
    ts.getJSDocTypeAssertionType = getJSDocTypeAssertionType;
    function isOuterExpression(node, kinds) {
        if (kinds === void 0) { kinds = 15 /* OuterExpressionKinds.All */; }
        switch (node.kind) {
            case 212 /* SyntaxKind.ParenthesizedExpression */:
                if (kinds & 16 /* OuterExpressionKinds.ExcludeJSDocTypeAssertion */ && isJSDocTypeAssertion(node)) {
                    return false;
                }
                return (kinds & 1 /* OuterExpressionKinds.Parentheses */) !== 0;
            case 211 /* SyntaxKind.TypeAssertionExpression */:
            case 229 /* SyntaxKind.AsExpression */:
                return (kinds & 2 /* OuterExpressionKinds.TypeAssertions */) !== 0;
            case 230 /* SyntaxKind.NonNullExpression */:
                return (kinds & 4 /* OuterExpressionKinds.NonNullAssertions */) !== 0;
            case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                return (kinds & 8 /* OuterExpressionKinds.PartiallyEmittedExpressions */) !== 0;
        }
        return false;
    }
    ts.isOuterExpression = isOuterExpression;
    function skipOuterExpressions(node, kinds) {
        if (kinds === void 0) { kinds = 15 /* OuterExpressionKinds.All */; }
        while (isOuterExpression(node, kinds)) {
            node = node.expression;
        }
        return node;
    }
    ts.skipOuterExpressions = skipOuterExpressions;
    function skipAssertions(node) {
        return skipOuterExpressions(node, 6 /* OuterExpressionKinds.Assertions */);
    }
    ts.skipAssertions = skipAssertions;
    function startOnNewLine(node) {
        return ts.setStartsOnNewLine(node, /*newLine*/ true);
    }
    ts.startOnNewLine = startOnNewLine;
    function getExternalHelpersModuleName(node) {
        var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
        var emitNode = parseNode && parseNode.emitNode;
        return emitNode && emitNode.externalHelpersModuleName;
    }
    ts.getExternalHelpersModuleName = getExternalHelpersModuleName;
    function hasRecordedExternalHelpers(sourceFile) {
        var parseNode = ts.getOriginalNode(sourceFile, ts.isSourceFile);
        var emitNode = parseNode && parseNode.emitNode;
        return !!emitNode && (!!emitNode.externalHelpersModuleName || !!emitNode.externalHelpers);
    }
    ts.hasRecordedExternalHelpers = hasRecordedExternalHelpers;
    function createExternalHelpersImportDeclarationIfNeeded(nodeFactory, helperFactory, sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar, hasImportDefault) {
        if (compilerOptions.importHelpers && ts.isEffectiveExternalModule(sourceFile, compilerOptions)) {
            var namedBindings = void 0;
            var moduleKind = ts.getEmitModuleKind(compilerOptions);
            if ((moduleKind >= ts.ModuleKind.ES2015 && moduleKind <= ts.ModuleKind.ESNext) || sourceFile.impliedNodeFormat === ts.ModuleKind.ESNext) {
                // use named imports
                var helpers = ts.getEmitHelpers(sourceFile);
                if (helpers) {
                    var helperNames = [];
                    for (var _i = 0, helpers_3 = helpers; _i < helpers_3.length; _i++) {
                        var helper = helpers_3[_i];
                        if (!helper.scoped) {
                            var importName = helper.importName;
                            if (importName) {
                                ts.pushIfUnique(helperNames, importName);
                            }
                        }
                    }
                    if (ts.some(helperNames)) {
                        helperNames.sort(ts.compareStringsCaseSensitive);
                        // Alias the imports if the names are used somewhere in the file.
                        // NOTE: We don't need to care about global import collisions as this is a module.
                        namedBindings = nodeFactory.createNamedImports(ts.map(helperNames, function (name) { return ts.isFileLevelUniqueName(sourceFile, name)
                            ? nodeFactory.createImportSpecifier(/*isTypeOnly*/ false, /*propertyName*/ undefined, nodeFactory.createIdentifier(name))
                            : nodeFactory.createImportSpecifier(/*isTypeOnly*/ false, nodeFactory.createIdentifier(name), helperFactory.getUnscopedHelperName(name)); }));
                        var parseNode = ts.getOriginalNode(sourceFile, ts.isSourceFile);
                        var emitNode = ts.getOrCreateEmitNode(parseNode);
                        emitNode.externalHelpers = true;
                    }
                }
            }
            else {
                // use a namespace import
                var externalHelpersModuleName = getOrCreateExternalHelpersModuleNameIfNeeded(nodeFactory, sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar || hasImportDefault);
                if (externalHelpersModuleName) {
                    namedBindings = nodeFactory.createNamespaceImport(externalHelpersModuleName);
                }
            }
            if (namedBindings) {
                var externalHelpersImportDeclaration = nodeFactory.createImportDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, nodeFactory.createImportClause(/*isTypeOnly*/ false, /*name*/ undefined, namedBindings), nodeFactory.createStringLiteral(ts.externalHelpersModuleNameText), 
                /*assertClause*/ undefined);
                ts.addEmitFlags(externalHelpersImportDeclaration, 67108864 /* EmitFlags.NeverApplyImportHelper */);
                return externalHelpersImportDeclaration;
            }
        }
    }
    ts.createExternalHelpersImportDeclarationIfNeeded = createExternalHelpersImportDeclarationIfNeeded;
    function getOrCreateExternalHelpersModuleNameIfNeeded(factory, node, compilerOptions, hasExportStarsToExportValues, hasImportStarOrImportDefault) {
        if (compilerOptions.importHelpers && ts.isEffectiveExternalModule(node, compilerOptions)) {
            var externalHelpersModuleName = getExternalHelpersModuleName(node);
            if (externalHelpersModuleName) {
                return externalHelpersModuleName;
            }
            var moduleKind = ts.getEmitModuleKind(compilerOptions);
            var create = (hasExportStarsToExportValues || (ts.getESModuleInterop(compilerOptions) && hasImportStarOrImportDefault))
                && moduleKind !== ts.ModuleKind.System
                && (moduleKind < ts.ModuleKind.ES2015 || node.impliedNodeFormat === ts.ModuleKind.CommonJS);
            if (!create) {
                var helpers = ts.getEmitHelpers(node);
                if (helpers) {
                    for (var _i = 0, helpers_4 = helpers; _i < helpers_4.length; _i++) {
                        var helper = helpers_4[_i];
                        if (!helper.scoped) {
                            create = true;
                            break;
                        }
                    }
                }
            }
            if (create) {
                var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
                var emitNode = ts.getOrCreateEmitNode(parseNode);
                return emitNode.externalHelpersModuleName || (emitNode.externalHelpersModuleName = factory.createUniqueName(ts.externalHelpersModuleNameText));
            }
        }
    }
    ts.getOrCreateExternalHelpersModuleNameIfNeeded = getOrCreateExternalHelpersModuleNameIfNeeded;
    /**
     * Get the name of that target module from an import or export declaration
     */
    function getLocalNameForExternalImport(factory, node, sourceFile) {
        var namespaceDeclaration = ts.getNamespaceDeclarationNode(node);
        if (namespaceDeclaration && !ts.isDefaultImport(node) && !ts.isExportNamespaceAsDefaultDeclaration(node)) {
            var name = namespaceDeclaration.name;
            return ts.isGeneratedIdentifier(name) ? name : factory.createIdentifier(ts.getSourceTextOfNodeFromSourceFile(sourceFile, name) || ts.idText(name));
        }
        if (node.kind === 266 /* SyntaxKind.ImportDeclaration */ && node.importClause) {
            return factory.getGeneratedNameForNode(node);
        }
        if (node.kind === 272 /* SyntaxKind.ExportDeclaration */ && node.moduleSpecifier) {
            return factory.getGeneratedNameForNode(node);
        }
        return undefined;
    }
    ts.getLocalNameForExternalImport = getLocalNameForExternalImport;
    /**
     * Get the name of a target module from an import/export declaration as should be written in the emitted output.
     * The emitted output name can be different from the input if:
     *  1. The module has a /// <amd-module name="<new name>" />
     *  2. --out or --outFile is used, making the name relative to the rootDir
     *  3- The containing SourceFile has an entry in renamedDependencies for the import as requested by some module loaders (e.g. System).
     * Otherwise, a new StringLiteral node representing the module name will be returned.
     */
    function getExternalModuleNameLiteral(factory, importNode, sourceFile, host, resolver, compilerOptions) {
        var moduleName = ts.getExternalModuleName(importNode);
        if (moduleName && ts.isStringLiteral(moduleName)) {
            return tryGetModuleNameFromDeclaration(importNode, host, factory, resolver, compilerOptions)
                || tryRenameExternalModule(factory, moduleName, sourceFile)
                || factory.cloneNode(moduleName);
        }
        return undefined;
    }
    ts.getExternalModuleNameLiteral = getExternalModuleNameLiteral;
    /**
     * Some bundlers (SystemJS builder) sometimes want to rename dependencies.
     * Here we check if alternative name was provided for a given moduleName and return it if possible.
     */
    function tryRenameExternalModule(factory, moduleName, sourceFile) {
        var rename = sourceFile.renamedDependencies && sourceFile.renamedDependencies.get(moduleName.text);
        return rename ? factory.createStringLiteral(rename) : undefined;
    }
    /**
     * Get the name of a module as should be written in the emitted output.
     * The emitted output name can be different from the input if:
     *  1. The module has a /// <amd-module name="<new name>" />
     *  2. --out or --outFile is used, making the name relative to the rootDir
     * Otherwise, a new StringLiteral node representing the module name will be returned.
     */
    function tryGetModuleNameFromFile(factory, file, host, options) {
        if (!file) {
            return undefined;
        }
        if (file.moduleName) {
            return factory.createStringLiteral(file.moduleName);
        }
        if (!file.isDeclarationFile && ts.outFile(options)) {
            return factory.createStringLiteral(ts.getExternalModuleNameFromPath(host, file.fileName));
        }
        return undefined;
    }
    ts.tryGetModuleNameFromFile = tryGetModuleNameFromFile;
    function tryGetModuleNameFromDeclaration(declaration, host, factory, resolver, compilerOptions) {
        return tryGetModuleNameFromFile(factory, resolver.getExternalModuleFileFromDeclaration(declaration), host, compilerOptions);
    }
    /**
     * Gets the initializer of an BindingOrAssignmentElement.
     */
    function getInitializerOfBindingOrAssignmentElement(bindingElement) {
        if (ts.isDeclarationBindingElement(bindingElement)) {
            // `1` in `let { a = 1 } = ...`
            // `1` in `let { a: b = 1 } = ...`
            // `1` in `let { a: {b} = 1 } = ...`
            // `1` in `let { a: [b] = 1 } = ...`
            // `1` in `let [a = 1] = ...`
            // `1` in `let [{a} = 1] = ...`
            // `1` in `let [[a] = 1] = ...`
            return bindingElement.initializer;
        }
        if (ts.isPropertyAssignment(bindingElement)) {
            // `1` in `({ a: b = 1 } = ...)`
            // `1` in `({ a: {b} = 1 } = ...)`
            // `1` in `({ a: [b] = 1 } = ...)`
            var initializer = bindingElement.initializer;
            return ts.isAssignmentExpression(initializer, /*excludeCompoundAssignment*/ true)
                ? initializer.right
                : undefined;
        }
        if (ts.isShorthandPropertyAssignment(bindingElement)) {
            // `1` in `({ a = 1 } = ...)`
            return bindingElement.objectAssignmentInitializer;
        }
        if (ts.isAssignmentExpression(bindingElement, /*excludeCompoundAssignment*/ true)) {
            // `1` in `[a = 1] = ...`
            // `1` in `[{a} = 1] = ...`
            // `1` in `[[a] = 1] = ...`
            return bindingElement.right;
        }
        if (ts.isSpreadElement(bindingElement)) {
            // Recovery consistent with existing emit.
            return getInitializerOfBindingOrAssignmentElement(bindingElement.expression);
        }
    }
    ts.getInitializerOfBindingOrAssignmentElement = getInitializerOfBindingOrAssignmentElement;
    /**
     * Gets the name of an BindingOrAssignmentElement.
     */
    function getTargetOfBindingOrAssignmentElement(bindingElement) {
        if (ts.isDeclarationBindingElement(bindingElement)) {
            // `a` in `let { a } = ...`
            // `a` in `let { a = 1 } = ...`
            // `b` in `let { a: b } = ...`
            // `b` in `let { a: b = 1 } = ...`
            // `a` in `let { ...a } = ...`
            // `{b}` in `let { a: {b} } = ...`
            // `{b}` in `let { a: {b} = 1 } = ...`
            // `[b]` in `let { a: [b] } = ...`
            // `[b]` in `let { a: [b] = 1 } = ...`
            // `a` in `let [a] = ...`
            // `a` in `let [a = 1] = ...`
            // `a` in `let [...a] = ...`
            // `{a}` in `let [{a}] = ...`
            // `{a}` in `let [{a} = 1] = ...`
            // `[a]` in `let [[a]] = ...`
            // `[a]` in `let [[a] = 1] = ...`
            return bindingElement.name;
        }
        if (ts.isObjectLiteralElementLike(bindingElement)) {
            switch (bindingElement.kind) {
                case 296 /* SyntaxKind.PropertyAssignment */:
                    // `b` in `({ a: b } = ...)`
                    // `b` in `({ a: b = 1 } = ...)`
                    // `{b}` in `({ a: {b} } = ...)`
                    // `{b}` in `({ a: {b} = 1 } = ...)`
                    // `[b]` in `({ a: [b] } = ...)`
                    // `[b]` in `({ a: [b] = 1 } = ...)`
                    // `b.c` in `({ a: b.c } = ...)`
                    // `b.c` in `({ a: b.c = 1 } = ...)`
                    // `b[0]` in `({ a: b[0] } = ...)`
                    // `b[0]` in `({ a: b[0] = 1 } = ...)`
                    return getTargetOfBindingOrAssignmentElement(bindingElement.initializer);
                case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                    // `a` in `({ a } = ...)`
                    // `a` in `({ a = 1 } = ...)`
                    return bindingElement.name;
                case 298 /* SyntaxKind.SpreadAssignment */:
                    // `a` in `({ ...a } = ...)`
                    return getTargetOfBindingOrAssignmentElement(bindingElement.expression);
            }
            // no target
            return undefined;
        }
        if (ts.isAssignmentExpression(bindingElement, /*excludeCompoundAssignment*/ true)) {
            // `a` in `[a = 1] = ...`
            // `{a}` in `[{a} = 1] = ...`
            // `[a]` in `[[a] = 1] = ...`
            // `a.b` in `[a.b = 1] = ...`
            // `a[0]` in `[a[0] = 1] = ...`
            return getTargetOfBindingOrAssignmentElement(bindingElement.left);
        }
        if (ts.isSpreadElement(bindingElement)) {
            // `a` in `[...a] = ...`
            return getTargetOfBindingOrAssignmentElement(bindingElement.expression);
        }
        // `a` in `[a] = ...`
        // `{a}` in `[{a}] = ...`
        // `[a]` in `[[a]] = ...`
        // `a.b` in `[a.b] = ...`
        // `a[0]` in `[a[0]] = ...`
        return bindingElement;
    }
    ts.getTargetOfBindingOrAssignmentElement = getTargetOfBindingOrAssignmentElement;
    /**
     * Determines whether an BindingOrAssignmentElement is a rest element.
     */
    function getRestIndicatorOfBindingOrAssignmentElement(bindingElement) {
        switch (bindingElement.kind) {
            case 164 /* SyntaxKind.Parameter */:
            case 203 /* SyntaxKind.BindingElement */:
                // `...` in `let [...a] = ...`
                return bindingElement.dotDotDotToken;
            case 225 /* SyntaxKind.SpreadElement */:
            case 298 /* SyntaxKind.SpreadAssignment */:
                // `...` in `[...a] = ...`
                return bindingElement;
        }
        return undefined;
    }
    ts.getRestIndicatorOfBindingOrAssignmentElement = getRestIndicatorOfBindingOrAssignmentElement;
    /**
     * Gets the property name of a BindingOrAssignmentElement
     */
    function getPropertyNameOfBindingOrAssignmentElement(bindingElement) {
        var propertyName = tryGetPropertyNameOfBindingOrAssignmentElement(bindingElement);
        ts.Debug.assert(!!propertyName || ts.isSpreadAssignment(bindingElement), "Invalid property name for binding element.");
        return propertyName;
    }
    ts.getPropertyNameOfBindingOrAssignmentElement = getPropertyNameOfBindingOrAssignmentElement;
    function tryGetPropertyNameOfBindingOrAssignmentElement(bindingElement) {
        switch (bindingElement.kind) {
            case 203 /* SyntaxKind.BindingElement */:
                // `a` in `let { a: b } = ...`
                // `[a]` in `let { [a]: b } = ...`
                // `"a"` in `let { "a": b } = ...`
                // `1` in `let { 1: b } = ...`
                if (bindingElement.propertyName) {
                    var propertyName = bindingElement.propertyName;
                    if (ts.isPrivateIdentifier(propertyName)) {
                        return ts.Debug.failBadSyntaxKind(propertyName);
                    }
                    return ts.isComputedPropertyName(propertyName) && isStringOrNumericLiteral(propertyName.expression)
                        ? propertyName.expression
                        : propertyName;
                }
                break;
            case 296 /* SyntaxKind.PropertyAssignment */:
                // `a` in `({ a: b } = ...)`
                // `[a]` in `({ [a]: b } = ...)`
                // `"a"` in `({ "a": b } = ...)`
                // `1` in `({ 1: b } = ...)`
                if (bindingElement.name) {
                    var propertyName = bindingElement.name;
                    if (ts.isPrivateIdentifier(propertyName)) {
                        return ts.Debug.failBadSyntaxKind(propertyName);
                    }
                    return ts.isComputedPropertyName(propertyName) && isStringOrNumericLiteral(propertyName.expression)
                        ? propertyName.expression
                        : propertyName;
                }
                break;
            case 298 /* SyntaxKind.SpreadAssignment */:
                // `a` in `({ ...a } = ...)`
                if (bindingElement.name && ts.isPrivateIdentifier(bindingElement.name)) {
                    return ts.Debug.failBadSyntaxKind(bindingElement.name);
                }
                return bindingElement.name;
        }
        var target = getTargetOfBindingOrAssignmentElement(bindingElement);
        if (target && ts.isPropertyName(target)) {
            return target;
        }
    }
    ts.tryGetPropertyNameOfBindingOrAssignmentElement = tryGetPropertyNameOfBindingOrAssignmentElement;
    function isStringOrNumericLiteral(node) {
        var kind = node.kind;
        return kind === 10 /* SyntaxKind.StringLiteral */
            || kind === 8 /* SyntaxKind.NumericLiteral */;
    }
    /**
     * Gets the elements of a BindingOrAssignmentPattern
     */
    function getElementsOfBindingOrAssignmentPattern(name) {
        switch (name.kind) {
            case 201 /* SyntaxKind.ObjectBindingPattern */:
            case 202 /* SyntaxKind.ArrayBindingPattern */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                // `a` in `{a}`
                // `a` in `[a]`
                return name.elements;
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
                // `a` in `{a}`
                return name.properties;
        }
    }
    ts.getElementsOfBindingOrAssignmentPattern = getElementsOfBindingOrAssignmentPattern;
    /* @internal */
    function getJSDocTypeAliasName(fullName) {
        if (fullName) {
            var rightNode = fullName;
            while (true) {
                if (ts.isIdentifier(rightNode) || !rightNode.body) {
                    return ts.isIdentifier(rightNode) ? rightNode : rightNode.name;
                }
                rightNode = rightNode.body;
            }
        }
    }
    ts.getJSDocTypeAliasName = getJSDocTypeAliasName;
    function canHaveModifiers(node) {
        var kind = node.kind;
        return kind === 164 /* SyntaxKind.Parameter */
            || kind === 166 /* SyntaxKind.PropertySignature */
            || kind === 167 /* SyntaxKind.PropertyDeclaration */
            || kind === 168 /* SyntaxKind.MethodSignature */
            || kind === 169 /* SyntaxKind.MethodDeclaration */
            || kind === 171 /* SyntaxKind.Constructor */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */
            || kind === 176 /* SyntaxKind.IndexSignature */
            || kind === 213 /* SyntaxKind.FunctionExpression */
            || kind === 214 /* SyntaxKind.ArrowFunction */
            || kind === 226 /* SyntaxKind.ClassExpression */
            || kind === 237 /* SyntaxKind.VariableStatement */
            || kind === 256 /* SyntaxKind.FunctionDeclaration */
            || kind === 257 /* SyntaxKind.ClassDeclaration */
            || kind === 258 /* SyntaxKind.InterfaceDeclaration */
            || kind === 259 /* SyntaxKind.TypeAliasDeclaration */
            || kind === 260 /* SyntaxKind.EnumDeclaration */
            || kind === 261 /* SyntaxKind.ModuleDeclaration */
            || kind === 265 /* SyntaxKind.ImportEqualsDeclaration */
            || kind === 266 /* SyntaxKind.ImportDeclaration */
            || kind === 271 /* SyntaxKind.ExportAssignment */
            || kind === 272 /* SyntaxKind.ExportDeclaration */;
    }
    ts.canHaveModifiers = canHaveModifiers;
    ts.isTypeNodeOrTypeParameterDeclaration = ts.or(ts.isTypeNode, ts.isTypeParameterDeclaration);
    ts.isQuestionOrExclamationToken = ts.or(ts.isQuestionToken, ts.isExclamationToken);
    ts.isIdentifierOrThisTypeNode = ts.or(ts.isIdentifier, ts.isThisTypeNode);
    ts.isReadonlyKeywordOrPlusOrMinusToken = ts.or(ts.isReadonlyKeyword, ts.isPlusToken, ts.isMinusToken);
    ts.isQuestionOrPlusOrMinusToken = ts.or(ts.isQuestionToken, ts.isPlusToken, ts.isMinusToken);
    ts.isModuleName = ts.or(ts.isIdentifier, ts.isStringLiteral);
    function isLiteralTypeLikeExpression(node) {
        var kind = node.kind;
        return kind === 104 /* SyntaxKind.NullKeyword */
            || kind === 110 /* SyntaxKind.TrueKeyword */
            || kind === 95 /* SyntaxKind.FalseKeyword */
            || ts.isLiteralExpression(node)
            || ts.isPrefixUnaryExpression(node);
    }
    ts.isLiteralTypeLikeExpression = isLiteralTypeLikeExpression;
    function isExponentiationOperator(kind) {
        return kind === 42 /* SyntaxKind.AsteriskAsteriskToken */;
    }
    function isMultiplicativeOperator(kind) {
        return kind === 41 /* SyntaxKind.AsteriskToken */
            || kind === 43 /* SyntaxKind.SlashToken */
            || kind === 44 /* SyntaxKind.PercentToken */;
    }
    function isMultiplicativeOperatorOrHigher(kind) {
        return isExponentiationOperator(kind)
            || isMultiplicativeOperator(kind);
    }
    function isAdditiveOperator(kind) {
        return kind === 39 /* SyntaxKind.PlusToken */
            || kind === 40 /* SyntaxKind.MinusToken */;
    }
    function isAdditiveOperatorOrHigher(kind) {
        return isAdditiveOperator(kind)
            || isMultiplicativeOperatorOrHigher(kind);
    }
    function isShiftOperator(kind) {
        return kind === 47 /* SyntaxKind.LessThanLessThanToken */
            || kind === 48 /* SyntaxKind.GreaterThanGreaterThanToken */
            || kind === 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */;
    }
    function isShiftOperatorOrHigher(kind) {
        return isShiftOperator(kind)
            || isAdditiveOperatorOrHigher(kind);
    }
    function isRelationalOperator(kind) {
        return kind === 29 /* SyntaxKind.LessThanToken */
            || kind === 32 /* SyntaxKind.LessThanEqualsToken */
            || kind === 31 /* SyntaxKind.GreaterThanToken */
            || kind === 33 /* SyntaxKind.GreaterThanEqualsToken */
            || kind === 102 /* SyntaxKind.InstanceOfKeyword */
            || kind === 101 /* SyntaxKind.InKeyword */;
    }
    function isRelationalOperatorOrHigher(kind) {
        return isRelationalOperator(kind)
            || isShiftOperatorOrHigher(kind);
    }
    function isEqualityOperator(kind) {
        return kind === 34 /* SyntaxKind.EqualsEqualsToken */
            || kind === 36 /* SyntaxKind.EqualsEqualsEqualsToken */
            || kind === 35 /* SyntaxKind.ExclamationEqualsToken */
            || kind === 37 /* SyntaxKind.ExclamationEqualsEqualsToken */;
    }
    function isEqualityOperatorOrHigher(kind) {
        return isEqualityOperator(kind)
            || isRelationalOperatorOrHigher(kind);
    }
    function isBitwiseOperator(kind) {
        return kind === 50 /* SyntaxKind.AmpersandToken */
            || kind === 51 /* SyntaxKind.BarToken */
            || kind === 52 /* SyntaxKind.CaretToken */;
    }
    function isBitwiseOperatorOrHigher(kind) {
        return isBitwiseOperator(kind)
            || isEqualityOperatorOrHigher(kind);
    }
    // NOTE: The version in utilities includes ExclamationToken, which is not a binary operator.
    function isLogicalOperator(kind) {
        return kind === 55 /* SyntaxKind.AmpersandAmpersandToken */
            || kind === 56 /* SyntaxKind.BarBarToken */;
    }
    function isLogicalOperatorOrHigher(kind) {
        return isLogicalOperator(kind)
            || isBitwiseOperatorOrHigher(kind);
    }
    function isAssignmentOperatorOrHigher(kind) {
        return kind === 60 /* SyntaxKind.QuestionQuestionToken */
            || isLogicalOperatorOrHigher(kind)
            || ts.isAssignmentOperator(kind);
    }
    function isBinaryOperator(kind) {
        return isAssignmentOperatorOrHigher(kind)
            || kind === 27 /* SyntaxKind.CommaToken */;
    }
    function isBinaryOperatorToken(node) {
        return isBinaryOperator(node.kind);
    }
    ts.isBinaryOperatorToken = isBinaryOperatorToken;
    var BinaryExpressionState;
    (function (BinaryExpressionState) {
        /**
         * Handles walking into a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function enter(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, outerState) {
            var prevUserState = stackIndex > 0 ? userStateStack[stackIndex - 1] : undefined;
            ts.Debug.assertEqual(stateStack[stackIndex], enter);
            userStateStack[stackIndex] = machine.onEnter(nodeStack[stackIndex], prevUserState, outerState);
            stateStack[stackIndex] = nextState(machine, enter);
            return stackIndex;
        }
        BinaryExpressionState.enter = enter;
        /**
         * Handles walking the `left` side of a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function left(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], left);
            ts.Debug.assertIsDefined(machine.onLeft);
            stateStack[stackIndex] = nextState(machine, left);
            var nextNode = machine.onLeft(nodeStack[stackIndex].left, userStateStack[stackIndex], nodeStack[stackIndex]);
            if (nextNode) {
                checkCircularity(stackIndex, nodeStack, nextNode);
                return pushStack(stackIndex, stateStack, nodeStack, userStateStack, nextNode);
            }
            return stackIndex;
        }
        BinaryExpressionState.left = left;
        /**
         * Handles walking the `operatorToken` of a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function operator(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], operator);
            ts.Debug.assertIsDefined(machine.onOperator);
            stateStack[stackIndex] = nextState(machine, operator);
            machine.onOperator(nodeStack[stackIndex].operatorToken, userStateStack[stackIndex], nodeStack[stackIndex]);
            return stackIndex;
        }
        BinaryExpressionState.operator = operator;
        /**
         * Handles walking the `right` side of a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function right(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], right);
            ts.Debug.assertIsDefined(machine.onRight);
            stateStack[stackIndex] = nextState(machine, right);
            var nextNode = machine.onRight(nodeStack[stackIndex].right, userStateStack[stackIndex], nodeStack[stackIndex]);
            if (nextNode) {
                checkCircularity(stackIndex, nodeStack, nextNode);
                return pushStack(stackIndex, stateStack, nodeStack, userStateStack, nextNode);
            }
            return stackIndex;
        }
        BinaryExpressionState.right = right;
        /**
         * Handles walking out of a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function exit(machine, stackIndex, stateStack, nodeStack, userStateStack, resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], exit);
            stateStack[stackIndex] = nextState(machine, exit);
            var result = machine.onExit(nodeStack[stackIndex], userStateStack[stackIndex]);
            if (stackIndex > 0) {
                stackIndex--;
                if (machine.foldState) {
                    var side = stateStack[stackIndex] === exit ? "right" : "left";
                    userStateStack[stackIndex] = machine.foldState(userStateStack[stackIndex], result, side);
                }
            }
            else {
                resultHolder.value = result;
            }
            return stackIndex;
        }
        BinaryExpressionState.exit = exit;
        /**
         * Handles a frame that is already done.
         * @returns The `done` state.
         */
        function done(_machine, stackIndex, stateStack, _nodeStack, _userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], done);
            return stackIndex;
        }
        BinaryExpressionState.done = done;
        function nextState(machine, currentState) {
            switch (currentState) {
                case enter:
                    if (machine.onLeft)
                        return left;
                // falls through
                case left:
                    if (machine.onOperator)
                        return operator;
                // falls through
                case operator:
                    if (machine.onRight)
                        return right;
                // falls through
                case right: return exit;
                case exit: return done;
                case done: return done;
                default: ts.Debug.fail("Invalid state");
            }
        }
        BinaryExpressionState.nextState = nextState;
        function pushStack(stackIndex, stateStack, nodeStack, userStateStack, node) {
            stackIndex++;
            stateStack[stackIndex] = enter;
            nodeStack[stackIndex] = node;
            userStateStack[stackIndex] = undefined;
            return stackIndex;
        }
        function checkCircularity(stackIndex, nodeStack, node) {
            if (ts.Debug.shouldAssert(2 /* AssertionLevel.Aggressive */)) {
                while (stackIndex >= 0) {
                    ts.Debug.assert(nodeStack[stackIndex] !== node, "Circular traversal detected.");
                    stackIndex--;
                }
            }
        }
    })(BinaryExpressionState || (BinaryExpressionState = {}));
    /**
     * Holds state machine handler functions
     */
    var BinaryExpressionStateMachine = /** @class */ (function () {
        function BinaryExpressionStateMachine(onEnter, onLeft, onOperator, onRight, onExit, foldState) {
            this.onEnter = onEnter;
            this.onLeft = onLeft;
            this.onOperator = onOperator;
            this.onRight = onRight;
            this.onExit = onExit;
            this.foldState = foldState;
        }
        return BinaryExpressionStateMachine;
    }());
    function createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState) {
        var machine = new BinaryExpressionStateMachine(onEnter, onLeft, onOperator, onRight, onExit, foldState);
        return trampoline;
        function trampoline(node, outerState) {
            var resultHolder = { value: undefined };
            var stateStack = [BinaryExpressionState.enter];
            var nodeStack = [node];
            var userStateStack = [undefined];
            var stackIndex = 0;
            while (stateStack[stackIndex] !== BinaryExpressionState.done) {
                stackIndex = stateStack[stackIndex](machine, stackIndex, stateStack, nodeStack, userStateStack, resultHolder, outerState);
            }
            ts.Debug.assertEqual(stackIndex, 0);
            return resultHolder.value;
        }
    }
    ts.createBinaryExpressionTrampoline = createBinaryExpressionTrampoline;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function setTextRange(range, location) {
        return location ? ts.setTextRangePosEnd(range, location.pos, location.end) : range;
    }
    ts.setTextRange = setTextRange;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var SignatureFlags;
    (function (SignatureFlags) {
        SignatureFlags[SignatureFlags["None"] = 0] = "None";
        SignatureFlags[SignatureFlags["Yield"] = 1] = "Yield";
        SignatureFlags[SignatureFlags["Await"] = 2] = "Await";
        SignatureFlags[SignatureFlags["Type"] = 4] = "Type";
        SignatureFlags[SignatureFlags["IgnoreMissingOpenBrace"] = 16] = "IgnoreMissingOpenBrace";
        SignatureFlags[SignatureFlags["JSDoc"] = 32] = "JSDoc";
    })(SignatureFlags || (SignatureFlags = {}));
    var SpeculationKind;
    (function (SpeculationKind) {
        SpeculationKind[SpeculationKind["TryParse"] = 0] = "TryParse";
        SpeculationKind[SpeculationKind["Lookahead"] = 1] = "Lookahead";
        SpeculationKind[SpeculationKind["Reparse"] = 2] = "Reparse";
    })(SpeculationKind || (SpeculationKind = {}));
    var NodeConstructor;
    var TokenConstructor;
    var IdentifierConstructor;
    var PrivateIdentifierConstructor;
    var SourceFileConstructor;
    /**
     * NOTE: You should not use this, it is only exported to support `createNode` in `~/src/deprecatedCompat/deprecations.ts`.
     */
    /* @internal */
    ts.parseBaseNodeFactory = {
        createBaseSourceFileNode: function (kind) { return new (SourceFileConstructor || (SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor()))(kind, -1, -1); },
        createBaseIdentifierNode: function (kind) { return new (IdentifierConstructor || (IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor()))(kind, -1, -1); },
        createBasePrivateIdentifierNode: function (kind) { return new (PrivateIdentifierConstructor || (PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor()))(kind, -1, -1); },
        createBaseTokenNode: function (kind) { return new (TokenConstructor || (TokenConstructor = ts.objectAllocator.getTokenConstructor()))(kind, -1, -1); },
        createBaseNode: function (kind) { return new (NodeConstructor || (NodeConstructor = ts.objectAllocator.getNodeConstructor()))(kind, -1, -1); },
    };
    /* @internal */
    ts.parseNodeFactory = ts.createNodeFactory(1 /* NodeFactoryFlags.NoParenthesizerRules */, ts.parseBaseNodeFactory);
    function visitNode(cbNode, node) {
        return node && cbNode(node);
    }
    function visitNodes(cbNode, cbNodes, nodes) {
        if (nodes) {
            if (cbNodes) {
                return cbNodes(nodes);
            }
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                var result = cbNode(node);
                if (result) {
                    return result;
                }
            }
        }
    }
    /*@internal*/
    function isJSDocLikeText(text, start) {
        return text.charCodeAt(start + 1) === 42 /* CharacterCodes.asterisk */ &&
            text.charCodeAt(start + 2) === 42 /* CharacterCodes.asterisk */ &&
            text.charCodeAt(start + 3) !== 47 /* CharacterCodes.slash */;
    }
    ts.isJSDocLikeText = isJSDocLikeText;
    /*@internal*/
    function isFileProbablyExternalModule(sourceFile) {
        // Try to use the first top-level import/export when available, then
        // fall back to looking for an 'import.meta' somewhere in the tree if necessary.
        return ts.forEach(sourceFile.statements, isAnExternalModuleIndicatorNode) ||
            getImportMetaIfNecessary(sourceFile);
    }
    ts.isFileProbablyExternalModule = isFileProbablyExternalModule;
    function isAnExternalModuleIndicatorNode(node) {
        return hasModifierOfKind(node, 93 /* SyntaxKind.ExportKeyword */)
            || ts.isImportEqualsDeclaration(node) && ts.isExternalModuleReference(node.moduleReference)
            || ts.isImportDeclaration(node)
            || ts.isExportAssignment(node)
            || ts.isExportDeclaration(node) ? node : undefined;
    }
    function getImportMetaIfNecessary(sourceFile) {
        return sourceFile.flags & 4194304 /* NodeFlags.PossiblyContainsImportMeta */ ?
            walkTreeForImportMeta(sourceFile) :
            undefined;
    }
    function walkTreeForImportMeta(node) {
        return isImportMeta(node) ? node : forEachChild(node, walkTreeForImportMeta);
    }
    /** Do not use hasModifier inside the parser; it relies on parent pointers. Use this instead. */
    function hasModifierOfKind(node, kind) {
        return ts.some(node.modifiers, function (m) { return m.kind === kind; });
    }
    function isImportMeta(node) {
        return ts.isMetaProperty(node) && node.keywordToken === 100 /* SyntaxKind.ImportKeyword */ && node.name.escapedText === "meta";
    }
    /**
     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
     * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
     *
     * @param node a given node to visit its children
     * @param cbNode a callback to be invoked for all child nodes
     * @param cbNodes a callback to be invoked for embedded array
     *
     * @remarks `forEachChild` must visit the children of a node in the order
     * that they appear in the source code. The language service depends on this property to locate nodes by position.
     */
    function forEachChild(node, cbNode, cbNodes) {
        if (!node || node.kind <= 160 /* SyntaxKind.LastToken */) {
            return;
        }
        switch (node.kind) {
            case 161 /* SyntaxKind.QualifiedName */:
                return visitNode(cbNode, node.left) ||
                    visitNode(cbNode, node.right);
            case 163 /* SyntaxKind.TypeParameter */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.constraint) ||
                    visitNode(cbNode, node.default) ||
                    visitNode(cbNode, node.expression);
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.equalsToken) ||
                    visitNode(cbNode, node.objectAssignmentInitializer);
            case 298 /* SyntaxKind.SpreadAssignment */:
                return visitNode(cbNode, node.expression);
            case 164 /* SyntaxKind.Parameter */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 167 /* SyntaxKind.PropertyDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 166 /* SyntaxKind.PropertySignature */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 296 /* SyntaxKind.PropertyAssignment */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.initializer);
            case 254 /* SyntaxKind.VariableDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 203 /* SyntaxKind.BindingElement */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.propertyName) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.initializer);
            case 179 /* SyntaxKind.FunctionType */:
            case 180 /* SyntaxKind.ConstructorType */:
            case 174 /* SyntaxKind.CallSignature */:
            case 175 /* SyntaxKind.ConstructSignature */:
            case 176 /* SyntaxKind.IndexSignature */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 171 /* SyntaxKind.Constructor */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 214 /* SyntaxKind.ArrowFunction */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.asteriskToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.equalsGreaterThanToken) ||
                    visitNode(cbNode, node.body);
            case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.body);
            case 178 /* SyntaxKind.TypeReference */:
                return visitNode(cbNode, node.typeName) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 177 /* SyntaxKind.TypePredicate */:
                return visitNode(cbNode, node.assertsModifier) ||
                    visitNode(cbNode, node.parameterName) ||
                    visitNode(cbNode, node.type);
            case 181 /* SyntaxKind.TypeQuery */:
                return visitNode(cbNode, node.exprName) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 182 /* SyntaxKind.TypeLiteral */:
                return visitNodes(cbNode, cbNodes, node.members);
            case 183 /* SyntaxKind.ArrayType */:
                return visitNode(cbNode, node.elementType);
            case 184 /* SyntaxKind.TupleType */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 187 /* SyntaxKind.UnionType */:
            case 188 /* SyntaxKind.IntersectionType */:
                return visitNodes(cbNode, cbNodes, node.types);
            case 189 /* SyntaxKind.ConditionalType */:
                return visitNode(cbNode, node.checkType) ||
                    visitNode(cbNode, node.extendsType) ||
                    visitNode(cbNode, node.trueType) ||
                    visitNode(cbNode, node.falseType);
            case 190 /* SyntaxKind.InferType */:
                return visitNode(cbNode, node.typeParameter);
            case 200 /* SyntaxKind.ImportType */:
                return visitNode(cbNode, node.argument) ||
                    visitNode(cbNode, node.assertions) ||
                    visitNode(cbNode, node.qualifier) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 295 /* SyntaxKind.ImportTypeAssertionContainer */:
                return visitNode(cbNode, node.assertClause);
            case 191 /* SyntaxKind.ParenthesizedType */:
            case 193 /* SyntaxKind.TypeOperator */:
                return visitNode(cbNode, node.type);
            case 194 /* SyntaxKind.IndexedAccessType */:
                return visitNode(cbNode, node.objectType) ||
                    visitNode(cbNode, node.indexType);
            case 195 /* SyntaxKind.MappedType */:
                return visitNode(cbNode, node.readonlyToken) ||
                    visitNode(cbNode, node.typeParameter) ||
                    visitNode(cbNode, node.nameType) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 196 /* SyntaxKind.LiteralType */:
                return visitNode(cbNode, node.literal);
            case 197 /* SyntaxKind.NamedTupleMember */:
                return visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type);
            case 201 /* SyntaxKind.ObjectBindingPattern */:
            case 202 /* SyntaxKind.ArrayBindingPattern */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
                return visitNodes(cbNode, cbNodes, node.properties);
            case 206 /* SyntaxKind.PropertyAccessExpression */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNode(cbNode, node.name);
            case 207 /* SyntaxKind.ElementAccessExpression */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNode(cbNode, node.argumentExpression);
            case 208 /* SyntaxKind.CallExpression */:
            case 209 /* SyntaxKind.NewExpression */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments) ||
                    visitNodes(cbNode, cbNodes, node.arguments);
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
                return visitNode(cbNode, node.tag) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments) ||
                    visitNode(cbNode, node.template);
            case 211 /* SyntaxKind.TypeAssertionExpression */:
                return visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.expression);
            case 212 /* SyntaxKind.ParenthesizedExpression */:
                return visitNode(cbNode, node.expression);
            case 215 /* SyntaxKind.DeleteExpression */:
                return visitNode(cbNode, node.expression);
            case 216 /* SyntaxKind.TypeOfExpression */:
                return visitNode(cbNode, node.expression);
            case 217 /* SyntaxKind.VoidExpression */:
                return visitNode(cbNode, node.expression);
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
                return visitNode(cbNode, node.operand);
            case 224 /* SyntaxKind.YieldExpression */:
                return visitNode(cbNode, node.asteriskToken) ||
                    visitNode(cbNode, node.expression);
            case 218 /* SyntaxKind.AwaitExpression */:
                return visitNode(cbNode, node.expression);
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
                return visitNode(cbNode, node.operand);
            case 221 /* SyntaxKind.BinaryExpression */:
                return visitNode(cbNode, node.left) ||
                    visitNode(cbNode, node.operatorToken) ||
                    visitNode(cbNode, node.right);
            case 229 /* SyntaxKind.AsExpression */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.type);
            case 230 /* SyntaxKind.NonNullExpression */:
                return visitNode(cbNode, node.expression);
            case 231 /* SyntaxKind.MetaProperty */:
                return visitNode(cbNode, node.name);
            case 222 /* SyntaxKind.ConditionalExpression */:
                return visitNode(cbNode, node.condition) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.whenTrue) ||
                    visitNode(cbNode, node.colonToken) ||
                    visitNode(cbNode, node.whenFalse);
            case 225 /* SyntaxKind.SpreadElement */:
                return visitNode(cbNode, node.expression);
            case 235 /* SyntaxKind.Block */:
            case 262 /* SyntaxKind.ModuleBlock */:
                return visitNodes(cbNode, cbNodes, node.statements);
            case 305 /* SyntaxKind.SourceFile */:
                return visitNodes(cbNode, cbNodes, node.statements) ||
                    visitNode(cbNode, node.endOfFileToken);
            case 237 /* SyntaxKind.VariableStatement */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.declarationList);
            case 255 /* SyntaxKind.VariableDeclarationList */:
                return visitNodes(cbNode, cbNodes, node.declarations);
            case 238 /* SyntaxKind.ExpressionStatement */:
                return visitNode(cbNode, node.expression);
            case 239 /* SyntaxKind.IfStatement */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.thenStatement) ||
                    visitNode(cbNode, node.elseStatement);
            case 240 /* SyntaxKind.DoStatement */:
                return visitNode(cbNode, node.statement) ||
                    visitNode(cbNode, node.expression);
            case 241 /* SyntaxKind.WhileStatement */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 242 /* SyntaxKind.ForStatement */:
                return visitNode(cbNode, node.initializer) ||
                    visitNode(cbNode, node.condition) ||
                    visitNode(cbNode, node.incrementor) ||
                    visitNode(cbNode, node.statement);
            case 243 /* SyntaxKind.ForInStatement */:
                return visitNode(cbNode, node.initializer) ||
                    visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 244 /* SyntaxKind.ForOfStatement */:
                return visitNode(cbNode, node.awaitModifier) ||
                    visitNode(cbNode, node.initializer) ||
                    visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 245 /* SyntaxKind.ContinueStatement */:
            case 246 /* SyntaxKind.BreakStatement */:
                return visitNode(cbNode, node.label);
            case 247 /* SyntaxKind.ReturnStatement */:
                return visitNode(cbNode, node.expression);
            case 248 /* SyntaxKind.WithStatement */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 249 /* SyntaxKind.SwitchStatement */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.caseBlock);
            case 263 /* SyntaxKind.CaseBlock */:
                return visitNodes(cbNode, cbNodes, node.clauses);
            case 289 /* SyntaxKind.CaseClause */:
                return visitNode(cbNode, node.expression) ||
                    visitNodes(cbNode, cbNodes, node.statements);
            case 290 /* SyntaxKind.DefaultClause */:
                return visitNodes(cbNode, cbNodes, node.statements);
            case 250 /* SyntaxKind.LabeledStatement */:
                return visitNode(cbNode, node.label) ||
                    visitNode(cbNode, node.statement);
            case 251 /* SyntaxKind.ThrowStatement */:
                return visitNode(cbNode, node.expression);
            case 252 /* SyntaxKind.TryStatement */:
                return visitNode(cbNode, node.tryBlock) ||
                    visitNode(cbNode, node.catchClause) ||
                    visitNode(cbNode, node.finallyBlock);
            case 292 /* SyntaxKind.CatchClause */:
                return visitNode(cbNode, node.variableDeclaration) ||
                    visitNode(cbNode, node.block);
            case 165 /* SyntaxKind.Decorator */:
                return visitNode(cbNode, node.expression);
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.heritageClauses) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 258 /* SyntaxKind.InterfaceDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.heritageClauses) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNode(cbNode, node.type);
            case 260 /* SyntaxKind.EnumDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 299 /* SyntaxKind.EnumMember */:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.initializer);
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.body);
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.moduleReference);
            case 266 /* SyntaxKind.ImportDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.importClause) ||
                    visitNode(cbNode, node.moduleSpecifier) ||
                    visitNode(cbNode, node.assertClause);
            case 267 /* SyntaxKind.ImportClause */:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.namedBindings);
            case 293 /* SyntaxKind.AssertClause */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 294 /* SyntaxKind.AssertEntry */:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.value);
            case 264 /* SyntaxKind.NamespaceExportDeclaration */:
                return visitNode(cbNode, node.name);
            case 268 /* SyntaxKind.NamespaceImport */:
                return visitNode(cbNode, node.name);
            case 274 /* SyntaxKind.NamespaceExport */:
                return visitNode(cbNode, node.name);
            case 269 /* SyntaxKind.NamedImports */:
            case 273 /* SyntaxKind.NamedExports */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 272 /* SyntaxKind.ExportDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.exportClause) ||
                    visitNode(cbNode, node.moduleSpecifier) ||
                    visitNode(cbNode, node.assertClause);
            case 270 /* SyntaxKind.ImportSpecifier */:
            case 275 /* SyntaxKind.ExportSpecifier */:
                return visitNode(cbNode, node.propertyName) ||
                    visitNode(cbNode, node.name);
            case 271 /* SyntaxKind.ExportAssignment */:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.expression);
            case 223 /* SyntaxKind.TemplateExpression */:
                return visitNode(cbNode, node.head) || visitNodes(cbNode, cbNodes, node.templateSpans);
            case 233 /* SyntaxKind.TemplateSpan */:
                return visitNode(cbNode, node.expression) || visitNode(cbNode, node.literal);
            case 198 /* SyntaxKind.TemplateLiteralType */:
                return visitNode(cbNode, node.head) || visitNodes(cbNode, cbNodes, node.templateSpans);
            case 199 /* SyntaxKind.TemplateLiteralTypeSpan */:
                return visitNode(cbNode, node.type) || visitNode(cbNode, node.literal);
            case 162 /* SyntaxKind.ComputedPropertyName */:
                return visitNode(cbNode, node.expression);
            case 291 /* SyntaxKind.HeritageClause */:
                return visitNodes(cbNode, cbNodes, node.types);
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                return visitNode(cbNode, node.expression) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 277 /* SyntaxKind.ExternalModuleReference */:
                return visitNode(cbNode, node.expression);
            case 276 /* SyntaxKind.MissingDeclaration */:
                return visitNodes(cbNode, cbNodes, node.decorators);
            case 351 /* SyntaxKind.CommaListExpression */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 278 /* SyntaxKind.JsxElement */:
                return visitNode(cbNode, node.openingElement) ||
                    visitNodes(cbNode, cbNodes, node.children) ||
                    visitNode(cbNode, node.closingElement);
            case 282 /* SyntaxKind.JsxFragment */:
                return visitNode(cbNode, node.openingFragment) ||
                    visitNodes(cbNode, cbNodes, node.children) ||
                    visitNode(cbNode, node.closingFragment);
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
            case 280 /* SyntaxKind.JsxOpeningElement */:
                return visitNode(cbNode, node.tagName) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments) ||
                    visitNode(cbNode, node.attributes);
            case 286 /* SyntaxKind.JsxAttributes */:
                return visitNodes(cbNode, cbNodes, node.properties);
            case 285 /* SyntaxKind.JsxAttribute */:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.initializer);
            case 287 /* SyntaxKind.JsxSpreadAttribute */:
                return visitNode(cbNode, node.expression);
            case 288 /* SyntaxKind.JsxExpression */:
                return visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.expression);
            case 281 /* SyntaxKind.JsxClosingElement */:
                return visitNode(cbNode, node.tagName);
            case 185 /* SyntaxKind.OptionalType */:
            case 186 /* SyntaxKind.RestType */:
            case 309 /* SyntaxKind.JSDocTypeExpression */:
            case 315 /* SyntaxKind.JSDocNonNullableType */:
            case 314 /* SyntaxKind.JSDocNullableType */:
            case 316 /* SyntaxKind.JSDocOptionalType */:
            case 318 /* SyntaxKind.JSDocVariadicType */:
                return visitNode(cbNode, node.type);
            case 317 /* SyntaxKind.JSDocFunctionType */:
                return visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 320 /* SyntaxKind.JSDoc */:
                return (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment))
                    || visitNodes(cbNode, cbNodes, node.tags);
            case 346 /* SyntaxKind.JSDocSeeTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.name) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 310 /* SyntaxKind.JSDocNameReference */:
                return visitNode(cbNode, node.name);
            case 311 /* SyntaxKind.JSDocMemberName */:
                return visitNode(cbNode, node.left) ||
                    visitNode(cbNode, node.right);
            case 340 /* SyntaxKind.JSDocParameterTag */:
            case 347 /* SyntaxKind.JSDocPropertyTag */:
                return visitNode(cbNode, node.tagName) ||
                    (node.isNameFirst
                        ? visitNode(cbNode, node.name) ||
                            visitNode(cbNode, node.typeExpression) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment))
                        : visitNode(cbNode, node.typeExpression) ||
                            visitNode(cbNode, node.name) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment)));
            case 330 /* SyntaxKind.JSDocAuthorTag */:
                return visitNode(cbNode, node.tagName) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 329 /* SyntaxKind.JSDocImplementsTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.class) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 328 /* SyntaxKind.JSDocAugmentsTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.class) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 344 /* SyntaxKind.JSDocTemplateTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.constraint) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 345 /* SyntaxKind.JSDocTypedefTag */:
                return visitNode(cbNode, node.tagName) ||
                    (node.typeExpression &&
                        node.typeExpression.kind === 309 /* SyntaxKind.JSDocTypeExpression */
                        ? visitNode(cbNode, node.typeExpression) ||
                            visitNode(cbNode, node.fullName) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment))
                        : visitNode(cbNode, node.fullName) ||
                            visitNode(cbNode, node.typeExpression) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment)));
            case 338 /* SyntaxKind.JSDocCallbackTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.fullName) ||
                    visitNode(cbNode, node.typeExpression) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 341 /* SyntaxKind.JSDocReturnTag */:
            case 343 /* SyntaxKind.JSDocTypeTag */:
            case 342 /* SyntaxKind.JSDocThisTag */:
            case 339 /* SyntaxKind.JSDocEnumTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.typeExpression) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 323 /* SyntaxKind.JSDocSignature */:
                return ts.forEach(node.typeParameters, cbNode) ||
                    ts.forEach(node.parameters, cbNode) ||
                    visitNode(cbNode, node.type);
            case 324 /* SyntaxKind.JSDocLink */:
            case 325 /* SyntaxKind.JSDocLinkCode */:
            case 326 /* SyntaxKind.JSDocLinkPlain */:
                return visitNode(cbNode, node.name);
            case 322 /* SyntaxKind.JSDocTypeLiteral */:
                return ts.forEach(node.jsDocPropertyTags, cbNode);
            case 327 /* SyntaxKind.JSDocTag */:
            case 332 /* SyntaxKind.JSDocClassTag */:
            case 333 /* SyntaxKind.JSDocPublicTag */:
            case 334 /* SyntaxKind.JSDocPrivateTag */:
            case 335 /* SyntaxKind.JSDocProtectedTag */:
            case 336 /* SyntaxKind.JSDocReadonlyTag */:
            case 331 /* SyntaxKind.JSDocDeprecatedTag */:
                return visitNode(cbNode, node.tagName)
                    || (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                return visitNode(cbNode, node.expression);
        }
    }
    ts.forEachChild = forEachChild;
    /** @internal */
    /**
     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; additionally,
     * unlike `forEachChild`, embedded arrays are flattened and the 'cbNode' callback is invoked for each element.
     *  If a callback returns a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
     *
     * @param node a given node to visit its children
     * @param cbNode a callback to be invoked for all child nodes
     * @param cbNodes a callback to be invoked for embedded array
     *
     * @remarks Unlike `forEachChild`, `forEachChildRecursively` handles recursively invoking the traversal on each child node found,
     * and while doing so, handles traversing the structure without relying on the callstack to encode the tree structure.
     */
    function forEachChildRecursively(rootNode, cbNode, cbNodes) {
        var queue = gatherPossibleChildren(rootNode);
        var parents = []; // tracks parent references for elements in queue
        while (parents.length < queue.length) {
            parents.push(rootNode);
        }
        while (queue.length !== 0) {
            var current = queue.pop();
            var parent = parents.pop();
            if (ts.isArray(current)) {
                if (cbNodes) {
                    var res = cbNodes(current, parent);
                    if (res) {
                        if (res === "skip")
                            continue;
                        return res;
                    }
                }
                for (var i = current.length - 1; i >= 0; --i) {
                    queue.push(current[i]);
                    parents.push(parent);
                }
            }
            else {
                var res = cbNode(current, parent);
                if (res) {
                    if (res === "skip")
                        continue;
                    return res;
                }
                if (current.kind >= 161 /* SyntaxKind.FirstNode */) {
                    // add children in reverse order to the queue, so popping gives the first child
                    for (var _i = 0, _a = gatherPossibleChildren(current); _i < _a.length; _i++) {
                        var child = _a[_i];
                        queue.push(child);
                        parents.push(current);
                    }
                }
            }
        }
    }
    ts.forEachChildRecursively = forEachChildRecursively;
    function gatherPossibleChildren(node) {
        var children = [];
        forEachChild(node, addWorkItem, addWorkItem); // By using a stack above and `unshift` here, we emulate a depth-first preorder traversal
        return children;
        function addWorkItem(n) {
            children.unshift(n);
        }
    }
    function setExternalModuleIndicator(sourceFile) {
        sourceFile.externalModuleIndicator = isFileProbablyExternalModule(sourceFile);
    }
    function createSourceFile(fileName, sourceText, languageVersionOrOptions, setParentNodes, scriptKind) {
        if (setParentNodes === void 0) { setParentNodes = false; }
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("parse" /* tracing.Phase.Parse */, "createSourceFile", { path: fileName }, /*separateBeginAndEnd*/ true);
        ts.performance.mark("beforeParse");
        var result;
        ts.perfLogger.logStartParseSourceFile(fileName);
        var _a = typeof languageVersionOrOptions === "object" ? languageVersionOrOptions : { languageVersion: languageVersionOrOptions }, languageVersion = _a.languageVersion, overrideSetExternalModuleIndicator = _a.setExternalModuleIndicator, format = _a.impliedNodeFormat;
        if (languageVersion === 100 /* ScriptTarget.JSON */) {
            result = Parser.parseSourceFile(fileName, sourceText, languageVersion, /*syntaxCursor*/ undefined, setParentNodes, 6 /* ScriptKind.JSON */, ts.noop);
        }
        else {
            var setIndicator = format === undefined ? overrideSetExternalModuleIndicator : function (file) {
                file.impliedNodeFormat = format;
                return (overrideSetExternalModuleIndicator || setExternalModuleIndicator)(file);
            };
            result = Parser.parseSourceFile(fileName, sourceText, languageVersion, /*syntaxCursor*/ undefined, setParentNodes, scriptKind, setIndicator);
        }
        ts.perfLogger.logStopParseSourceFile();
        ts.performance.mark("afterParse");
        ts.performance.measure("Parse", "beforeParse", "afterParse");
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        return result;
    }
    ts.createSourceFile = createSourceFile;
    function parseIsolatedEntityName(text, languageVersion) {
        return Parser.parseIsolatedEntityName(text, languageVersion);
    }
    ts.parseIsolatedEntityName = parseIsolatedEntityName;
    /**
     * Parse json text into SyntaxTree and return node and parse errors if any
     * @param fileName
     * @param sourceText
     */
    function parseJsonText(fileName, sourceText) {
        return Parser.parseJsonText(fileName, sourceText);
    }
    ts.parseJsonText = parseJsonText;
    // See also `isExternalOrCommonJsModule` in utilities.ts
    function isExternalModule(file) {
        return file.externalModuleIndicator !== undefined;
    }
    ts.isExternalModule = isExternalModule;
    // Produces a new SourceFile for the 'newText' provided. The 'textChangeRange' parameter
    // indicates what changed between the 'text' that this SourceFile has and the 'newText'.
    // The SourceFile will be created with the compiler attempting to reuse as many nodes from
    // this file as possible.
    //
    // Note: this function mutates nodes from this SourceFile. That means any existing nodes
    // from this SourceFile that are being held onto may change as a result (including
    // becoming detached from any SourceFile).  It is recommended that this SourceFile not
    // be used once 'update' is called on it.
    function updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks) {
        if (aggressiveChecks === void 0) { aggressiveChecks = false; }
        var newSourceFile = IncrementalParser.updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks);
        // Because new source file node is created, it may not have the flag PossiblyContainDynamicImport. This is the case if there is no new edit to add dynamic import.
        // We will manually port the flag to the new source file.
        newSourceFile.flags |= (sourceFile.flags & 6291456 /* NodeFlags.PermanentlySetIncrementalFlags */);
        return newSourceFile;
    }
    ts.updateSourceFile = updateSourceFile;
    /* @internal */
    function parseIsolatedJSDocComment(content, start, length) {
        var result = Parser.JSDocParser.parseIsolatedJSDocComment(content, start, length);
        if (result && result.jsDoc) {
            // because the jsDocComment was parsed out of the source file, it might
            // not be covered by the fixupParentReferences.
            Parser.fixupParentReferences(result.jsDoc);
        }
        return result;
    }
    ts.parseIsolatedJSDocComment = parseIsolatedJSDocComment;
    /* @internal */
    // Exposed only for testing.
    function parseJSDocTypeExpressionForTests(content, start, length) {
        return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start, length);
    }
    ts.parseJSDocTypeExpressionForTests = parseJSDocTypeExpressionForTests;
    // Implement the parser as a singleton module.  We do this for perf reasons because creating
    // parser instances can actually be expensive enough to impact us on projects with many source
    // files.
    var Parser;
    (function (Parser) {
        // Share a single scanner across all calls to parse a source file.  This helps speed things
        // up by avoiding the cost of creating/compiling scanners over and over again.
        var scanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ true);
        var disallowInAndDecoratorContext = 4096 /* NodeFlags.DisallowInContext */ | 16384 /* NodeFlags.DecoratorContext */;
        // capture constructors in 'initializeState' to avoid null checks
        // tslint:disable variable-name
        var NodeConstructor;
        var TokenConstructor;
        var IdentifierConstructor;
        var PrivateIdentifierConstructor;
        var SourceFileConstructor;
        // tslint:enable variable-name
        function countNode(node) {
            nodeCount++;
            return node;
        }
        // Rather than using `createBaseNodeFactory` here, we establish a `BaseNodeFactory` that closes over the
        // constructors above, which are reset each time `initializeState` is called.
        var baseNodeFactory = {
            createBaseSourceFileNode: function (kind) { return countNode(new SourceFileConstructor(kind, /*pos*/ 0, /*end*/ 0)); },
            createBaseIdentifierNode: function (kind) { return countNode(new IdentifierConstructor(kind, /*pos*/ 0, /*end*/ 0)); },
            createBasePrivateIdentifierNode: function (kind) { return countNode(new PrivateIdentifierConstructor(kind, /*pos*/ 0, /*end*/ 0)); },
            createBaseTokenNode: function (kind) { return countNode(new TokenConstructor(kind, /*pos*/ 0, /*end*/ 0)); },
            createBaseNode: function (kind) { return countNode(new NodeConstructor(kind, /*pos*/ 0, /*end*/ 0)); }
        };
        var factory = ts.createNodeFactory(1 /* NodeFactoryFlags.NoParenthesizerRules */ | 2 /* NodeFactoryFlags.NoNodeConverters */ | 8 /* NodeFactoryFlags.NoOriginalNode */, baseNodeFactory);
        var fileName;
        var sourceFlags;
        var sourceText;
        var languageVersion;
        var scriptKind;
        var languageVariant;
        var parseDiagnostics;
        var jsDocDiagnostics;
        var syntaxCursor;
        var currentToken;
        var nodeCount;
        var identifiers;
        var privateIdentifiers;
        var identifierCount;
        var parsingContext;
        var notParenthesizedArrow;
        // Flags that dictate what parsing context we're in.  For example:
        // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is
        // that some tokens that would be considered identifiers may be considered keywords.
        //
        // When adding more parser context flags, consider which is the more common case that the
        // flag will be in.  This should be the 'false' state for that flag.  The reason for this is
        // that we don't store data in our nodes unless the value is in the *non-default* state.  So,
        // for example, more often than code 'allows-in' (or doesn't 'disallow-in').  We opt for
        // 'disallow-in' set to 'false'.  Otherwise, if we had 'allowsIn' set to 'true', then almost
        // all nodes would need extra state on them to store this info.
        //
        // Note: 'allowIn' and 'allowYield' track 1:1 with the [in] and [yield] concepts in the ES6
        // grammar specification.
        //
        // An important thing about these context concepts.  By default they are effectively inherited
        // while parsing through every grammar production.  i.e. if you don't change them, then when
        // you parse a sub-production, it will have the same context values as the parent production.
        // This is great most of the time.  After all, consider all the 'expression' grammar productions
        // and how nearly all of them pass along the 'in' and 'yield' context values:
        //
        // EqualityExpression[In, Yield] :
        //      RelationalExpression[?In, ?Yield]
        //      EqualityExpression[?In, ?Yield] == RelationalExpression[?In, ?Yield]
        //      EqualityExpression[?In, ?Yield] != RelationalExpression[?In, ?Yield]
        //      EqualityExpression[?In, ?Yield] === RelationalExpression[?In, ?Yield]
        //      EqualityExpression[?In, ?Yield] !== RelationalExpression[?In, ?Yield]
        //
        // Where you have to be careful is then understanding what the points are in the grammar
        // where the values are *not* passed along.  For example:
        //
        // SingleNameBinding[Yield,GeneratorParameter]
        //      [+GeneratorParameter]BindingIdentifier[Yield] Initializer[In]opt
        //      [~GeneratorParameter]BindingIdentifier[?Yield]Initializer[In, ?Yield]opt
        //
        // Here this is saying that if the GeneratorParameter context flag is set, that we should
        // explicitly set the 'yield' context flag to false before calling into the BindingIdentifier
        // and we should explicitly unset the 'yield' context flag before calling into the Initializer.
        // production.  Conversely, if the GeneratorParameter context flag is not set, then we
        // should leave the 'yield' context flag alone.
        //
        // Getting this all correct is tricky and requires careful reading of the grammar to
        // understand when these values should be changed versus when they should be inherited.
        //
        // Note: it should not be necessary to save/restore these flags during speculative/lookahead
        // parsing.  These context flags are naturally stored and restored through normal recursive
        // descent parsing and unwinding.
        var contextFlags;
        // Indicates whether we are currently parsing top-level statements.
        var topLevel = true;
        // Whether or not we've had a parse error since creating the last AST node.  If we have
        // encountered an error, it will be stored on the next AST node we create.  Parse errors
        // can be broken down into three categories:
        //
        // 1) An error that occurred during scanning.  For example, an unterminated literal, or a
        //    character that was completely not understood.
        //
        // 2) A token was expected, but was not present.  This type of error is commonly produced
        //    by the 'parseExpected' function.
        //
        // 3) A token was present that no parsing function was able to consume.  This type of error
        //    only occurs in the 'abortParsingListOrMoveToNextToken' function when the parser
        //    decides to skip the token.
        //
        // In all of these cases, we want to mark the next node as having had an error before it.
        // With this mark, we can know in incremental settings if this node can be reused, or if
        // we have to reparse it.  If we don't keep this information around, we may just reuse the
        // node.  in that event we would then not produce the same errors as we did before, causing
        // significant confusion problems.
        //
        // Note: it is necessary that this value be saved/restored during speculative/lookahead
        // parsing.  During lookahead parsing, we will often create a node.  That node will have
        // this value attached, and then this value will be set back to 'false'.  If we decide to
        // rewind, we must get back to the same value we had prior to the lookahead.
        //
        // Note: any errors at the end of the file that do not precede a regular node, should get
        // attached to the EOF token.
        var parseErrorBeforeNextFinishedNode = false;
        function parseSourceFile(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes, scriptKind, setExternalModuleIndicatorOverride) {
            var _a;
            if (setParentNodes === void 0) { setParentNodes = false; }
            scriptKind = ts.ensureScriptKind(fileName, scriptKind);
            if (scriptKind === 6 /* ScriptKind.JSON */) {
                var result_3 = parseJsonText(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes);
                ts.convertToObjectWorker(result_3, (_a = result_3.statements[0]) === null || _a === void 0 ? void 0 : _a.expression, result_3.parseDiagnostics, /*returnValue*/ false, /*knownRootOptions*/ undefined, /*jsonConversionNotifier*/ undefined);
                result_3.referencedFiles = ts.emptyArray;
                result_3.typeReferenceDirectives = ts.emptyArray;
                result_3.libReferenceDirectives = ts.emptyArray;
                result_3.amdDependencies = ts.emptyArray;
                result_3.hasNoDefaultLib = false;
                result_3.pragmas = ts.emptyMap;
                return result_3;
            }
            initializeState(fileName, sourceText, languageVersion, syntaxCursor, scriptKind);
            var result = parseSourceFileWorker(languageVersion, setParentNodes, scriptKind, setExternalModuleIndicatorOverride || setExternalModuleIndicator);
            clearState();
            return result;
        }
        Parser.parseSourceFile = parseSourceFile;
        function parseIsolatedEntityName(content, languageVersion) {
            // Choice of `isDeclarationFile` should be arbitrary
            initializeState("", content, languageVersion, /*syntaxCursor*/ undefined, 1 /* ScriptKind.JS */);
            // Prime the scanner.
            nextToken();
            var entityName = parseEntityName(/*allowReservedWords*/ true);
            var isInvalid = token() === 1 /* SyntaxKind.EndOfFileToken */ && !parseDiagnostics.length;
            clearState();
            return isInvalid ? entityName : undefined;
        }
        Parser.parseIsolatedEntityName = parseIsolatedEntityName;
        function parseJsonText(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes) {
            if (languageVersion === void 0) { languageVersion = 2 /* ScriptTarget.ES2015 */; }
            if (setParentNodes === void 0) { setParentNodes = false; }
            initializeState(fileName, sourceText, languageVersion, syntaxCursor, 6 /* ScriptKind.JSON */);
            sourceFlags = contextFlags;
            // Prime the scanner.
            nextToken();
            var pos = getNodePos();
            var statements, endOfFileToken;
            if (token() === 1 /* SyntaxKind.EndOfFileToken */) {
                statements = createNodeArray([], pos, pos);
                endOfFileToken = parseTokenNode();
            }
            else {
                // Loop and synthesize an ArrayLiteralExpression if there are more than
                // one top-level expressions to ensure all input text is consumed.
                var expressions = void 0;
                while (token() !== 1 /* SyntaxKind.EndOfFileToken */) {
                    var expression_1 = void 0;
                    switch (token()) {
                        case 22 /* SyntaxKind.OpenBracketToken */:
                            expression_1 = parseArrayLiteralExpression();
                            break;
                        case 110 /* SyntaxKind.TrueKeyword */:
                        case 95 /* SyntaxKind.FalseKeyword */:
                        case 104 /* SyntaxKind.NullKeyword */:
                            expression_1 = parseTokenNode();
                            break;
                        case 40 /* SyntaxKind.MinusToken */:
                            if (lookAhead(function () { return nextToken() === 8 /* SyntaxKind.NumericLiteral */ && nextToken() !== 58 /* SyntaxKind.ColonToken */; })) {
                                expression_1 = parsePrefixUnaryExpression();
                            }
                            else {
                                expression_1 = parseObjectLiteralExpression();
                            }
                            break;
                        case 8 /* SyntaxKind.NumericLiteral */:
                        case 10 /* SyntaxKind.StringLiteral */:
                            if (lookAhead(function () { return nextToken() !== 58 /* SyntaxKind.ColonToken */; })) {
                                expression_1 = parseLiteralNode();
                                break;
                            }
                        // falls through
                        default:
                            expression_1 = parseObjectLiteralExpression();
                            break;
                    }
                    // Error recovery: collect multiple top-level expressions
                    if (expressions && ts.isArray(expressions)) {
                        expressions.push(expression_1);
                    }
                    else if (expressions) {
                        expressions = [expressions, expression_1];
                    }
                    else {
                        expressions = expression_1;
                        if (token() !== 1 /* SyntaxKind.EndOfFileToken */) {
                            parseErrorAtCurrentToken(ts.Diagnostics.Unexpected_token);
                        }
                    }
                }
                var expression = ts.isArray(expressions) ? finishNode(factory.createArrayLiteralExpression(expressions), pos) : ts.Debug.checkDefined(expressions);
                var statement = factory.createExpressionStatement(expression);
                finishNode(statement, pos);
                statements = createNodeArray([statement], pos);
                endOfFileToken = parseExpectedToken(1 /* SyntaxKind.EndOfFileToken */, ts.Diagnostics.Unexpected_token);
            }
            // Set source file so that errors will be reported with this file name
            var sourceFile = createSourceFile(fileName, 2 /* ScriptTarget.ES2015 */, 6 /* ScriptKind.JSON */, /*isDeclaration*/ false, statements, endOfFileToken, sourceFlags, ts.noop);
            if (setParentNodes) {
                fixupParentReferences(sourceFile);
            }
            sourceFile.nodeCount = nodeCount;
            sourceFile.identifierCount = identifierCount;
            sourceFile.identifiers = identifiers;
            sourceFile.parseDiagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
            if (jsDocDiagnostics) {
                sourceFile.jsDocDiagnostics = ts.attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
            }
            var result = sourceFile;
            clearState();
            return result;
        }
        Parser.parseJsonText = parseJsonText;
        function initializeState(_fileName, _sourceText, _languageVersion, _syntaxCursor, _scriptKind) {
            NodeConstructor = ts.objectAllocator.getNodeConstructor();
            TokenConstructor = ts.objectAllocator.getTokenConstructor();
            IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor();
            PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor();
            SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor();
            fileName = ts.normalizePath(_fileName);
            sourceText = _sourceText;
            languageVersion = _languageVersion;
            syntaxCursor = _syntaxCursor;
            scriptKind = _scriptKind;
            languageVariant = ts.getLanguageVariant(_scriptKind);
            parseDiagnostics = [];
            parsingContext = 0;
            identifiers = new ts.Map();
            privateIdentifiers = new ts.Map();
            identifierCount = 0;
            nodeCount = 0;
            sourceFlags = 0;
            topLevel = true;
            switch (scriptKind) {
                case 1 /* ScriptKind.JS */:
                case 2 /* ScriptKind.JSX */:
                    contextFlags = 262144 /* NodeFlags.JavaScriptFile */;
                    break;
                case 6 /* ScriptKind.JSON */:
                    contextFlags = 262144 /* NodeFlags.JavaScriptFile */ | 67108864 /* NodeFlags.JsonFile */;
                    break;
                default:
                    contextFlags = 0 /* NodeFlags.None */;
                    break;
            }
            parseErrorBeforeNextFinishedNode = false;
            // Initialize and prime the scanner before parsing the source elements.
            scanner.setText(sourceText);
            scanner.setOnError(scanError);
            scanner.setScriptTarget(languageVersion);
            scanner.setLanguageVariant(languageVariant);
        }
        function clearState() {
            // Clear out the text the scanner is pointing at, so it doesn't keep anything alive unnecessarily.
            scanner.clearCommentDirectives();
            scanner.setText("");
            scanner.setOnError(undefined);
            // Clear any data.  We don't want to accidentally hold onto it for too long.
            sourceText = undefined;
            languageVersion = undefined;
            syntaxCursor = undefined;
            scriptKind = undefined;
            languageVariant = undefined;
            sourceFlags = 0;
            parseDiagnostics = undefined;
            jsDocDiagnostics = undefined;
            parsingContext = 0;
            identifiers = undefined;
            notParenthesizedArrow = undefined;
            topLevel = true;
        }
        function parseSourceFileWorker(languageVersion, setParentNodes, scriptKind, setExternalModuleIndicator) {
            var isDeclarationFile = isDeclarationFileName(fileName);
            if (isDeclarationFile) {
                contextFlags |= 16777216 /* NodeFlags.Ambient */;
            }
            sourceFlags = contextFlags;
            // Prime the scanner.
            nextToken();
            var statements = parseList(0 /* ParsingContext.SourceElements */, parseStatement);
            ts.Debug.assert(token() === 1 /* SyntaxKind.EndOfFileToken */);
            var endOfFileToken = addJSDocComment(parseTokenNode());
            var sourceFile = createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile, statements, endOfFileToken, sourceFlags, setExternalModuleIndicator);
            // A member of ReadonlyArray<T> isn't assignable to a member of T[] (and prevents a direct cast) - but this is where we set up those members so they can be readonly in the future
            processCommentPragmas(sourceFile, sourceText);
            processPragmasIntoFields(sourceFile, reportPragmaDiagnostic);
            sourceFile.commentDirectives = scanner.getCommentDirectives();
            sourceFile.nodeCount = nodeCount;
            sourceFile.identifierCount = identifierCount;
            sourceFile.identifiers = identifiers;
            sourceFile.parseDiagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
            if (jsDocDiagnostics) {
                sourceFile.jsDocDiagnostics = ts.attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
            }
            if (setParentNodes) {
                fixupParentReferences(sourceFile);
            }
            return sourceFile;
            function reportPragmaDiagnostic(pos, end, diagnostic) {
                parseDiagnostics.push(ts.createDetachedDiagnostic(fileName, pos, end, diagnostic));
            }
        }
        function withJSDoc(node, hasJSDoc) {
            return hasJSDoc ? addJSDocComment(node) : node;
        }
        var hasDeprecatedTag = false;
        function addJSDocComment(node) {
            ts.Debug.assert(!node.jsDoc); // Should only be called once per node
            var jsDoc = ts.mapDefined(ts.getJSDocCommentRanges(node, sourceText), function (comment) { return JSDocParser.parseJSDocComment(node, comment.pos, comment.end - comment.pos); });
            if (jsDoc.length)
                node.jsDoc = jsDoc;
            if (hasDeprecatedTag) {
                hasDeprecatedTag = false;
                node.flags |= 268435456 /* NodeFlags.Deprecated */;
            }
            return node;
        }
        function reparseTopLevelAwait(sourceFile) {
            var savedSyntaxCursor = syntaxCursor;
            var baseSyntaxCursor = IncrementalParser.createSyntaxCursor(sourceFile);
            syntaxCursor = { currentNode: currentNode };
            var statements = [];
            var savedParseDiagnostics = parseDiagnostics;
            parseDiagnostics = [];
            var pos = 0;
            var start = findNextStatementWithAwait(sourceFile.statements, 0);
            var _loop_3 = function () {
                // append all statements between pos and start
                var prevStatement = sourceFile.statements[pos];
                var nextStatement = sourceFile.statements[start];
                ts.addRange(statements, sourceFile.statements, pos, start);
                pos = findNextStatementWithoutAwait(sourceFile.statements, start);
                // append all diagnostics associated with the copied range
                var diagnosticStart = ts.findIndex(savedParseDiagnostics, function (diagnostic) { return diagnostic.start >= prevStatement.pos; });
                var diagnosticEnd = diagnosticStart >= 0 ? ts.findIndex(savedParseDiagnostics, function (diagnostic) { return diagnostic.start >= nextStatement.pos; }, diagnosticStart) : -1;
                if (diagnosticStart >= 0) {
                    ts.addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart, diagnosticEnd >= 0 ? diagnosticEnd : undefined);
                }
                // reparse all statements between start and pos. We skip existing diagnostics for the same range and allow the parser to generate new ones.
                speculationHelper(function () {
                    var savedContextFlags = contextFlags;
                    contextFlags |= 32768 /* NodeFlags.AwaitContext */;
                    scanner.setTextPos(nextStatement.pos);
                    nextToken();
                    while (token() !== 1 /* SyntaxKind.EndOfFileToken */) {
                        var startPos = scanner.getStartPos();
                        var statement = parseListElement(0 /* ParsingContext.SourceElements */, parseStatement);
                        statements.push(statement);
                        if (startPos === scanner.getStartPos()) {
                            nextToken();
                        }
                        if (pos >= 0) {
                            var nonAwaitStatement = sourceFile.statements[pos];
                            if (statement.end === nonAwaitStatement.pos) {
                                // done reparsing this section
                                break;
                            }
                            if (statement.end > nonAwaitStatement.pos) {
                                // we ate into the next statement, so we must reparse it.
                                pos = findNextStatementWithoutAwait(sourceFile.statements, pos + 1);
                            }
                        }
                    }
                    contextFlags = savedContextFlags;
                }, 2 /* SpeculationKind.Reparse */);
                // find the next statement containing an `await`
                start = pos >= 0 ? findNextStatementWithAwait(sourceFile.statements, pos) : -1;
            };
            while (start !== -1) {
                _loop_3();
            }
            // append all statements between pos and the end of the list
            if (pos >= 0) {
                var prevStatement_1 = sourceFile.statements[pos];
                ts.addRange(statements, sourceFile.statements, pos);
                // append all diagnostics associated with the copied range
                var diagnosticStart = ts.findIndex(savedParseDiagnostics, function (diagnostic) { return diagnostic.start >= prevStatement_1.pos; });
                if (diagnosticStart >= 0) {
                    ts.addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart);
                }
            }
            syntaxCursor = savedSyntaxCursor;
            return factory.updateSourceFile(sourceFile, ts.setTextRange(factory.createNodeArray(statements), sourceFile.statements));
            function containsPossibleTopLevelAwait(node) {
                return !(node.flags & 32768 /* NodeFlags.AwaitContext */)
                    && !!(node.transformFlags & 16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */);
            }
            function findNextStatementWithAwait(statements, start) {
                for (var i = start; i < statements.length; i++) {
                    if (containsPossibleTopLevelAwait(statements[i])) {
                        return i;
                    }
                }
                return -1;
            }
            function findNextStatementWithoutAwait(statements, start) {
                for (var i = start; i < statements.length; i++) {
                    if (!containsPossibleTopLevelAwait(statements[i])) {
                        return i;
                    }
                }
                return -1;
            }
            function currentNode(position) {
                var node = baseSyntaxCursor.currentNode(position);
                if (topLevel && node && containsPossibleTopLevelAwait(node)) {
                    node.intersectsChange = true;
                }
                return node;
            }
        }
        function fixupParentReferences(rootNode) {
            // normally parent references are set during binding. However, for clients that only need
            // a syntax tree, and no semantic features, then the binding process is an unnecessary
            // overhead.  This functions allows us to set all the parents, without all the expense of
            // binding.
            ts.setParentRecursive(rootNode, /*incremental*/ true);
        }
        Parser.fixupParentReferences = fixupParentReferences;
        function createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile, statements, endOfFileToken, flags, setExternalModuleIndicator) {
            // code from createNode is inlined here so createNode won't have to deal with special case of creating source files
            // this is quite rare comparing to other nodes and createNode should be as fast as possible
            var sourceFile = factory.createSourceFile(statements, endOfFileToken, flags);
            ts.setTextRangePosWidth(sourceFile, 0, sourceText.length);
            setFields(sourceFile);
            // If we parsed this as an external module, it may contain top-level await
            if (!isDeclarationFile && isExternalModule(sourceFile) && sourceFile.transformFlags & 16777216 /* TransformFlags.ContainsPossibleTopLevelAwait */) {
                sourceFile = reparseTopLevelAwait(sourceFile);
                setFields(sourceFile);
            }
            return sourceFile;
            function setFields(sourceFile) {
                sourceFile.text = sourceText;
                sourceFile.bindDiagnostics = [];
                sourceFile.bindSuggestionDiagnostics = undefined;
                sourceFile.languageVersion = languageVersion;
                sourceFile.fileName = fileName;
                sourceFile.languageVariant = ts.getLanguageVariant(scriptKind);
                sourceFile.isDeclarationFile = isDeclarationFile;
                sourceFile.scriptKind = scriptKind;
                setExternalModuleIndicator(sourceFile);
                sourceFile.setExternalModuleIndicator = setExternalModuleIndicator;
            }
        }
        function setContextFlag(val, flag) {
            if (val) {
                contextFlags |= flag;
            }
            else {
                contextFlags &= ~flag;
            }
        }
        function setDisallowInContext(val) {
            setContextFlag(val, 4096 /* NodeFlags.DisallowInContext */);
        }
        function setYieldContext(val) {
            setContextFlag(val, 8192 /* NodeFlags.YieldContext */);
        }
        function setDecoratorContext(val) {
            setContextFlag(val, 16384 /* NodeFlags.DecoratorContext */);
        }
        function setAwaitContext(val) {
            setContextFlag(val, 32768 /* NodeFlags.AwaitContext */);
        }
        function doOutsideOfContext(context, func) {
            // contextFlagsToClear will contain only the context flags that are
            // currently set that we need to temporarily clear
            // We don't just blindly reset to the previous flags to ensure
            // that we do not mutate cached flags for the incremental
            // parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and
            // HasAggregatedChildData).
            var contextFlagsToClear = context & contextFlags;
            if (contextFlagsToClear) {
                // clear the requested context flags
                setContextFlag(/*val*/ false, contextFlagsToClear);
                var result = func();
                // restore the context flags we just cleared
                setContextFlag(/*val*/ true, contextFlagsToClear);
                return result;
            }
            // no need to do anything special as we are not in any of the requested contexts
            return func();
        }
        function doInsideOfContext(context, func) {
            // contextFlagsToSet will contain only the context flags that
            // are not currently set that we need to temporarily enable.
            // We don't just blindly reset to the previous flags to ensure
            // that we do not mutate cached flags for the incremental
            // parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and
            // HasAggregatedChildData).
            var contextFlagsToSet = context & ~contextFlags;
            if (contextFlagsToSet) {
                // set the requested context flags
                setContextFlag(/*val*/ true, contextFlagsToSet);
                var result = func();
                // reset the context flags we just set
                setContextFlag(/*val*/ false, contextFlagsToSet);
                return result;
            }
            // no need to do anything special as we are already in all of the requested contexts
            return func();
        }
        function allowInAnd(func) {
            return doOutsideOfContext(4096 /* NodeFlags.DisallowInContext */, func);
        }
        function disallowInAnd(func) {
            return doInsideOfContext(4096 /* NodeFlags.DisallowInContext */, func);
        }
        function allowConditionalTypesAnd(func) {
            return doOutsideOfContext(65536 /* NodeFlags.DisallowConditionalTypesContext */, func);
        }
        function disallowConditionalTypesAnd(func) {
            return doInsideOfContext(65536 /* NodeFlags.DisallowConditionalTypesContext */, func);
        }
        function doInYieldContext(func) {
            return doInsideOfContext(8192 /* NodeFlags.YieldContext */, func);
        }
        function doInDecoratorContext(func) {
            return doInsideOfContext(16384 /* NodeFlags.DecoratorContext */, func);
        }
        function doInAwaitContext(func) {
            return doInsideOfContext(32768 /* NodeFlags.AwaitContext */, func);
        }
        function doOutsideOfAwaitContext(func) {
            return doOutsideOfContext(32768 /* NodeFlags.AwaitContext */, func);
        }
        function doInYieldAndAwaitContext(func) {
            return doInsideOfContext(8192 /* NodeFlags.YieldContext */ | 32768 /* NodeFlags.AwaitContext */, func);
        }
        function doOutsideOfYieldAndAwaitContext(func) {
            return doOutsideOfContext(8192 /* NodeFlags.YieldContext */ | 32768 /* NodeFlags.AwaitContext */, func);
        }
        function inContext(flags) {
            return (contextFlags & flags) !== 0;
        }
        function inYieldContext() {
            return inContext(8192 /* NodeFlags.YieldContext */);
        }
        function inDisallowInContext() {
            return inContext(4096 /* NodeFlags.DisallowInContext */);
        }
        function inDisallowConditionalTypesContext() {
            return inContext(65536 /* NodeFlags.DisallowConditionalTypesContext */);
        }
        function inDecoratorContext() {
            return inContext(16384 /* NodeFlags.DecoratorContext */);
        }
        function inAwaitContext() {
            return inContext(32768 /* NodeFlags.AwaitContext */);
        }
        function parseErrorAtCurrentToken(message, arg0) {
            return parseErrorAt(scanner.getTokenPos(), scanner.getTextPos(), message, arg0);
        }
        function parseErrorAtPosition(start, length, message, arg0) {
            // Don't report another error if it would just be at the same position as the last error.
            var lastError = ts.lastOrUndefined(parseDiagnostics);
            var result;
            if (!lastError || start !== lastError.start) {
                result = ts.createDetachedDiagnostic(fileName, start, length, message, arg0);
                parseDiagnostics.push(result);
            }
            // Mark that we've encountered an error.  We'll set an appropriate bit on the next
            // node we finish so that it can't be reused incrementally.
            parseErrorBeforeNextFinishedNode = true;
            return result;
        }
        function parseErrorAt(start, end, message, arg0) {
            return parseErrorAtPosition(start, end - start, message, arg0);
        }
        function parseErrorAtRange(range, message, arg0) {
            parseErrorAt(range.pos, range.end, message, arg0);
        }
        function scanError(message, length) {
            parseErrorAtPosition(scanner.getTextPos(), length, message);
        }
        function getNodePos() {
            return scanner.getStartPos();
        }
        function hasPrecedingJSDocComment() {
            return scanner.hasPrecedingJSDocComment();
        }
        // Use this function to access the current token instead of reading the currentToken
        // variable. Since function results aren't narrowed in control flow analysis, this ensures
        // that the type checker doesn't make wrong assumptions about the type of the current
        // token (e.g. a call to nextToken() changes the current token but the checker doesn't
        // reason about this side effect).  Mainstream VMs inline simple functions like this, so
        // there is no performance penalty.
        function token() {
            return currentToken;
        }
        function nextTokenWithoutCheck() {
            return currentToken = scanner.scan();
        }
        function nextTokenAnd(func) {
            nextToken();
            return func();
        }
        function nextToken() {
            // if the keyword had an escape
            if (ts.isKeyword(currentToken) && (scanner.hasUnicodeEscape() || scanner.hasExtendedUnicodeEscape())) {
                // issue a parse error for the escape
                parseErrorAt(scanner.getTokenPos(), scanner.getTextPos(), ts.Diagnostics.Keywords_cannot_contain_escape_characters);
            }
            return nextTokenWithoutCheck();
        }
        function nextTokenJSDoc() {
            return currentToken = scanner.scanJsDocToken();
        }
        function reScanGreaterToken() {
            return currentToken = scanner.reScanGreaterToken();
        }
        function reScanSlashToken() {
            return currentToken = scanner.reScanSlashToken();
        }
        function reScanTemplateToken(isTaggedTemplate) {
            return currentToken = scanner.reScanTemplateToken(isTaggedTemplate);
        }
        function reScanTemplateHeadOrNoSubstitutionTemplate() {
            return currentToken = scanner.reScanTemplateHeadOrNoSubstitutionTemplate();
        }
        function reScanLessThanToken() {
            return currentToken = scanner.reScanLessThanToken();
        }
        function reScanHashToken() {
            return currentToken = scanner.reScanHashToken();
        }
        function scanJsxIdentifier() {
            return currentToken = scanner.scanJsxIdentifier();
        }
        function scanJsxText() {
            return currentToken = scanner.scanJsxToken();
        }
        function scanJsxAttributeValue() {
            return currentToken = scanner.scanJsxAttributeValue();
        }
        function speculationHelper(callback, speculationKind) {
            // Keep track of the state we'll need to rollback to if lookahead fails (or if the
            // caller asked us to always reset our state).
            var saveToken = currentToken;
            var saveParseDiagnosticsLength = parseDiagnostics.length;
            var saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;
            // Note: it is not actually necessary to save/restore the context flags here.  That's
            // because the saving/restoring of these flags happens naturally through the recursive
            // descent nature of our parser.  However, we still store this here just so we can
            // assert that invariant holds.
            var saveContextFlags = contextFlags;
            // If we're only looking ahead, then tell the scanner to only lookahead as well.
            // Otherwise, if we're actually speculatively parsing, then tell the scanner to do the
            // same.
            var result = speculationKind !== 0 /* SpeculationKind.TryParse */
                ? scanner.lookAhead(callback)
                : scanner.tryScan(callback);
            ts.Debug.assert(saveContextFlags === contextFlags);
            // If our callback returned something 'falsy' or we're just looking ahead,
            // then unconditionally restore us to where we were.
            if (!result || speculationKind !== 0 /* SpeculationKind.TryParse */) {
                currentToken = saveToken;
                if (speculationKind !== 2 /* SpeculationKind.Reparse */) {
                    parseDiagnostics.length = saveParseDiagnosticsLength;
                }
                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;
            }
            return result;
        }
        /** Invokes the provided callback then unconditionally restores the parser to the state it
         * was in immediately prior to invoking the callback.  The result of invoking the callback
         * is returned from this function.
         */
        function lookAhead(callback) {
            return speculationHelper(callback, 1 /* SpeculationKind.Lookahead */);
        }
        /** Invokes the provided callback.  If the callback returns something falsy, then it restores
         * the parser to the state it was in immediately prior to invoking the callback.  If the
         * callback returns something truthy, then the parser state is not rolled back.  The result
         * of invoking the callback is returned from this function.
         */
        function tryParse(callback) {
            return speculationHelper(callback, 0 /* SpeculationKind.TryParse */);
        }
        function isBindingIdentifier() {
            if (token() === 79 /* SyntaxKind.Identifier */) {
                return true;
            }
            // `let await`/`let yield` in [Yield] or [Await] are allowed here and disallowed in the binder.
            return token() > 116 /* SyntaxKind.LastReservedWord */;
        }
        // Ignore strict mode flag because we will report an error in type checker instead.
        function isIdentifier() {
            if (token() === 79 /* SyntaxKind.Identifier */) {
                return true;
            }
            // If we have a 'yield' keyword, and we're in the [yield] context, then 'yield' is
            // considered a keyword and is not an identifier.
            if (token() === 125 /* SyntaxKind.YieldKeyword */ && inYieldContext()) {
                return false;
            }
            // If we have a 'await' keyword, and we're in the [Await] context, then 'await' is
            // considered a keyword and is not an identifier.
            if (token() === 132 /* SyntaxKind.AwaitKeyword */ && inAwaitContext()) {
                return false;
            }
            return token() > 116 /* SyntaxKind.LastReservedWord */;
        }
        function parseExpected(kind, diagnosticMessage, shouldAdvance) {
            if (shouldAdvance === void 0) { shouldAdvance = true; }
            if (token() === kind) {
                if (shouldAdvance) {
                    nextToken();
                }
                return true;
            }
            // Report specific message if provided with one.  Otherwise, report generic fallback message.
            if (diagnosticMessage) {
                parseErrorAtCurrentToken(diagnosticMessage);
            }
            else {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(kind));
            }
            return false;
        }
        var viableKeywordSuggestions = Object.keys(ts.textToKeywordObj).filter(function (keyword) { return keyword.length > 2; });
        /**
         * Provides a better error message than the generic "';' expected" if possible for
         * known common variants of a missing semicolon, such as from a mispelled names.
         *
         * @param node Node preceding the expected semicolon location.
         */
        function parseErrorForMissingSemicolonAfter(node) {
            var _a;
            // Tagged template literals are sometimes used in places where only simple strings are allowed, i.e.:
            //   module `M1` {
            //   ^^^^^^^^^^^ This block is parsed as a template literal like module`M1`.
            if (ts.isTaggedTemplateExpression(node)) {
                parseErrorAt(ts.skipTrivia(sourceText, node.template.pos), node.template.end, ts.Diagnostics.Module_declaration_names_may_only_use_or_quoted_strings);
                return;
            }
            // Otherwise, if this isn't a well-known keyword-like identifier, give the generic fallback message.
            var expressionText = ts.isIdentifier(node) ? ts.idText(node) : undefined;
            if (!expressionText || !ts.isIdentifierText(expressionText, languageVersion)) {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(26 /* SyntaxKind.SemicolonToken */));
                return;
            }
            var pos = ts.skipTrivia(sourceText, node.pos);
            // Some known keywords are likely signs of syntax being used improperly.
            switch (expressionText) {
                case "const":
                case "let":
                case "var":
                    parseErrorAt(pos, node.end, ts.Diagnostics.Variable_declaration_not_allowed_at_this_location);
                    return;
                case "declare":
                    // If a declared node failed to parse, it would have emitted a diagnostic already.
                    return;
                case "interface":
                    parseErrorForInvalidName(ts.Diagnostics.Interface_name_cannot_be_0, ts.Diagnostics.Interface_must_be_given_a_name, 18 /* SyntaxKind.OpenBraceToken */);
                    return;
                case "is":
                    parseErrorAt(pos, scanner.getTextPos(), ts.Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
                    return;
                case "module":
                case "namespace":
                    parseErrorForInvalidName(ts.Diagnostics.Namespace_name_cannot_be_0, ts.Diagnostics.Namespace_must_be_given_a_name, 18 /* SyntaxKind.OpenBraceToken */);
                    return;
                case "type":
                    parseErrorForInvalidName(ts.Diagnostics.Type_alias_name_cannot_be_0, ts.Diagnostics.Type_alias_must_be_given_a_name, 63 /* SyntaxKind.EqualsToken */);
                    return;
            }
            // The user alternatively might have misspelled or forgotten to add a space after a common keyword.
            var suggestion = (_a = ts.getSpellingSuggestion(expressionText, viableKeywordSuggestions, function (n) { return n; })) !== null && _a !== void 0 ? _a : getSpaceSuggestion(expressionText);
            if (suggestion) {
                parseErrorAt(pos, node.end, ts.Diagnostics.Unknown_keyword_or_identifier_Did_you_mean_0, suggestion);
                return;
            }
            // Unknown tokens are handled with their own errors in the scanner
            if (token() === 0 /* SyntaxKind.Unknown */) {
                return;
            }
            // Otherwise, we know this some kind of unknown word, not just a missing expected semicolon.
            parseErrorAt(pos, node.end, ts.Diagnostics.Unexpected_keyword_or_identifier);
        }
        /**
         * Reports a diagnostic error for the current token being an invalid name.
         *
         * @param blankDiagnostic Diagnostic to report for the case of the name being blank (matched tokenIfBlankName).
         * @param nameDiagnostic Diagnostic to report for all other cases.
         * @param tokenIfBlankName Current token if the name was invalid for being blank (not provided / skipped).
         */
        function parseErrorForInvalidName(nameDiagnostic, blankDiagnostic, tokenIfBlankName) {
            if (token() === tokenIfBlankName) {
                parseErrorAtCurrentToken(blankDiagnostic);
            }
            else {
                parseErrorAtCurrentToken(nameDiagnostic, scanner.getTokenValue());
            }
        }
        function getSpaceSuggestion(expressionText) {
            for (var _i = 0, viableKeywordSuggestions_1 = viableKeywordSuggestions; _i < viableKeywordSuggestions_1.length; _i++) {
                var keyword = viableKeywordSuggestions_1[_i];
                if (expressionText.length > keyword.length + 2 && ts.startsWith(expressionText, keyword)) {
                    return "".concat(keyword, " ").concat(expressionText.slice(keyword.length));
                }
            }
            return undefined;
        }
        function parseSemicolonAfterPropertyName(name, type, initializer) {
            if (token() === 59 /* SyntaxKind.AtToken */ && !scanner.hasPrecedingLineBreak()) {
                parseErrorAtCurrentToken(ts.Diagnostics.Decorators_must_precede_the_name_and_all_keywords_of_property_declarations);
                return;
            }
            if (token() === 20 /* SyntaxKind.OpenParenToken */) {
                parseErrorAtCurrentToken(ts.Diagnostics.Cannot_start_a_function_call_in_a_type_annotation);
                nextToken();
                return;
            }
            if (type && !canParseSemicolon()) {
                if (initializer) {
                    parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(26 /* SyntaxKind.SemicolonToken */));
                }
                else {
                    parseErrorAtCurrentToken(ts.Diagnostics.Expected_for_property_initializer);
                }
                return;
            }
            if (tryParseSemicolon()) {
                return;
            }
            if (initializer) {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(26 /* SyntaxKind.SemicolonToken */));
                return;
            }
            parseErrorForMissingSemicolonAfter(name);
        }
        function parseExpectedJSDoc(kind) {
            if (token() === kind) {
                nextTokenJSDoc();
                return true;
            }
            parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(kind));
            return false;
        }
        function parseExpectedMatchingBrackets(openKind, closeKind, openParsed, openPosition) {
            if (token() === closeKind) {
                nextToken();
                return;
            }
            var lastError = parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(closeKind));
            if (!openParsed) {
                return;
            }
            if (lastError) {
                ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openPosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, ts.tokenToString(openKind), ts.tokenToString(closeKind)));
            }
        }
        function parseOptional(t) {
            if (token() === t) {
                nextToken();
                return true;
            }
            return false;
        }
        function parseOptionalToken(t) {
            if (token() === t) {
                return parseTokenNode();
            }
            return undefined;
        }
        function parseOptionalTokenJSDoc(t) {
            if (token() === t) {
                return parseTokenNodeJSDoc();
            }
            return undefined;
        }
        function parseExpectedToken(t, diagnosticMessage, arg0) {
            return parseOptionalToken(t) ||
                createMissingNode(t, /*reportAtCurrentPosition*/ false, diagnosticMessage || ts.Diagnostics._0_expected, arg0 || ts.tokenToString(t));
        }
        function parseExpectedTokenJSDoc(t) {
            return parseOptionalTokenJSDoc(t) ||
                createMissingNode(t, /*reportAtCurrentPosition*/ false, ts.Diagnostics._0_expected, ts.tokenToString(t));
        }
        function parseTokenNode() {
            var pos = getNodePos();
            var kind = token();
            nextToken();
            return finishNode(factory.createToken(kind), pos);
        }
        function parseTokenNodeJSDoc() {
            var pos = getNodePos();
            var kind = token();
            nextTokenJSDoc();
            return finishNode(factory.createToken(kind), pos);
        }
        function canParseSemicolon() {
            // If there's a real semicolon, then we can always parse it out.
            if (token() === 26 /* SyntaxKind.SemicolonToken */) {
                return true;
            }
            // We can parse out an optional semicolon in ASI cases in the following cases.
            return token() === 19 /* SyntaxKind.CloseBraceToken */ || token() === 1 /* SyntaxKind.EndOfFileToken */ || scanner.hasPrecedingLineBreak();
        }
        function tryParseSemicolon() {
            if (!canParseSemicolon()) {
                return false;
            }
            if (token() === 26 /* SyntaxKind.SemicolonToken */) {
                // consume the semicolon if it was explicitly provided.
                nextToken();
            }
            return true;
        }
        function parseSemicolon() {
            return tryParseSemicolon() || parseExpected(26 /* SyntaxKind.SemicolonToken */);
        }
        function createNodeArray(elements, pos, end, hasTrailingComma) {
            var array = factory.createNodeArray(elements, hasTrailingComma);
            ts.setTextRangePosEnd(array, pos, end !== null && end !== void 0 ? end : scanner.getStartPos());
            return array;
        }
        function finishNode(node, pos, end) {
            ts.setTextRangePosEnd(node, pos, end !== null && end !== void 0 ? end : scanner.getStartPos());
            if (contextFlags) {
                node.flags |= contextFlags;
            }
            // Keep track on the node if we encountered an error while parsing it.  If we did, then
            // we cannot reuse the node incrementally.  Once we've marked this node, clear out the
            // flag so that we don't mark any subsequent nodes.
            if (parseErrorBeforeNextFinishedNode) {
                parseErrorBeforeNextFinishedNode = false;
                node.flags |= 131072 /* NodeFlags.ThisNodeHasError */;
            }
            return node;
        }
        function createMissingNode(kind, reportAtCurrentPosition, diagnosticMessage, arg0) {
            if (reportAtCurrentPosition) {
                parseErrorAtPosition(scanner.getStartPos(), 0, diagnosticMessage, arg0);
            }
            else if (diagnosticMessage) {
                parseErrorAtCurrentToken(diagnosticMessage, arg0);
            }
            var pos = getNodePos();
            var result = kind === 79 /* SyntaxKind.Identifier */ ? factory.createIdentifier("", /*typeArguments*/ undefined, /*originalKeywordKind*/ undefined) :
                ts.isTemplateLiteralKind(kind) ? factory.createTemplateLiteralLikeNode(kind, "", "", /*templateFlags*/ undefined) :
                    kind === 8 /* SyntaxKind.NumericLiteral */ ? factory.createNumericLiteral("", /*numericLiteralFlags*/ undefined) :
                        kind === 10 /* SyntaxKind.StringLiteral */ ? factory.createStringLiteral("", /*isSingleQuote*/ undefined) :
                            kind === 276 /* SyntaxKind.MissingDeclaration */ ? factory.createMissingDeclaration() :
                                factory.createToken(kind);
            return finishNode(result, pos);
        }
        function internIdentifier(text) {
            var identifier = identifiers.get(text);
            if (identifier === undefined) {
                identifiers.set(text, identifier = text);
            }
            return identifier;
        }
        // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues
        // with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for
        // each identifier in order to reduce memory consumption.
        function createIdentifier(isIdentifier, diagnosticMessage, privateIdentifierDiagnosticMessage) {
            if (isIdentifier) {
                identifierCount++;
                var pos = getNodePos();
                // Store original token kind if it is not just an Identifier so we can report appropriate error later in type checker
                var originalKeywordKind = token();
                var text = internIdentifier(scanner.getTokenValue());
                nextTokenWithoutCheck();
                return finishNode(factory.createIdentifier(text, /*typeArguments*/ undefined, originalKeywordKind), pos);
            }
            if (token() === 80 /* SyntaxKind.PrivateIdentifier */) {
                parseErrorAtCurrentToken(privateIdentifierDiagnosticMessage || ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
                return createIdentifier(/*isIdentifier*/ true);
            }
            if (token() === 0 /* SyntaxKind.Unknown */ && scanner.tryScan(function () { return scanner.reScanInvalidIdentifier() === 79 /* SyntaxKind.Identifier */; })) {
                // Scanner has already recorded an 'Invalid character' error, so no need to add another from the parser.
                return createIdentifier(/*isIdentifier*/ true);
            }
            identifierCount++;
            // Only for end of file because the error gets reported incorrectly on embedded script tags.
            var reportAtCurrentPosition = token() === 1 /* SyntaxKind.EndOfFileToken */;
            var isReservedWord = scanner.isReservedWord();
            var msgArg = scanner.getTokenText();
            var defaultMessage = isReservedWord ?
                ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here :
                ts.Diagnostics.Identifier_expected;
            return createMissingNode(79 /* SyntaxKind.Identifier */, reportAtCurrentPosition, diagnosticMessage || defaultMessage, msgArg);
        }
        function parseBindingIdentifier(privateIdentifierDiagnosticMessage) {
            return createIdentifier(isBindingIdentifier(), /*diagnosticMessage*/ undefined, privateIdentifierDiagnosticMessage);
        }
        function parseIdentifier(diagnosticMessage, privateIdentifierDiagnosticMessage) {
            return createIdentifier(isIdentifier(), diagnosticMessage, privateIdentifierDiagnosticMessage);
        }
        function parseIdentifierName(diagnosticMessage) {
            return createIdentifier(ts.tokenIsIdentifierOrKeyword(token()), diagnosticMessage);
        }
        function isLiteralPropertyName() {
            return ts.tokenIsIdentifierOrKeyword(token()) ||
                token() === 10 /* SyntaxKind.StringLiteral */ ||
                token() === 8 /* SyntaxKind.NumericLiteral */;
        }
        function isAssertionKey() {
            return ts.tokenIsIdentifierOrKeyword(token()) ||
                token() === 10 /* SyntaxKind.StringLiteral */;
        }
        function parsePropertyNameWorker(allowComputedPropertyNames) {
            if (token() === 10 /* SyntaxKind.StringLiteral */ || token() === 8 /* SyntaxKind.NumericLiteral */) {
                var node = parseLiteralNode();
                node.text = internIdentifier(node.text);
                return node;
            }
            if (allowComputedPropertyNames && token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return parseComputedPropertyName();
            }
            if (token() === 80 /* SyntaxKind.PrivateIdentifier */) {
                return parsePrivateIdentifier();
            }
            return parseIdentifierName();
        }
        function parsePropertyName() {
            return parsePropertyNameWorker(/*allowComputedPropertyNames*/ true);
        }
        function parseComputedPropertyName() {
            // PropertyName [Yield]:
            //      LiteralPropertyName
            //      ComputedPropertyName[?Yield]
            var pos = getNodePos();
            parseExpected(22 /* SyntaxKind.OpenBracketToken */);
            // We parse any expression (including a comma expression). But the grammar
            // says that only an assignment expression is allowed, so the grammar checker
            // will error if it sees a comma expression.
            var expression = allowInAnd(parseExpression);
            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
            return finishNode(factory.createComputedPropertyName(expression), pos);
        }
        function internPrivateIdentifier(text) {
            var privateIdentifier = privateIdentifiers.get(text);
            if (privateIdentifier === undefined) {
                privateIdentifiers.set(text, privateIdentifier = text);
            }
            return privateIdentifier;
        }
        function parsePrivateIdentifier() {
            var pos = getNodePos();
            var node = factory.createPrivateIdentifier(internPrivateIdentifier(scanner.getTokenText()));
            nextToken();
            return finishNode(node, pos);
        }
        function parseContextualModifier(t) {
            return token() === t && tryParse(nextTokenCanFollowModifier);
        }
        function nextTokenIsOnSameLineAndCanFollowModifier() {
            nextToken();
            if (scanner.hasPrecedingLineBreak()) {
                return false;
            }
            return canFollowModifier();
        }
        function nextTokenCanFollowModifier() {
            switch (token()) {
                case 85 /* SyntaxKind.ConstKeyword */:
                    // 'const' is only a modifier if followed by 'enum'.
                    return nextToken() === 92 /* SyntaxKind.EnumKeyword */;
                case 93 /* SyntaxKind.ExportKeyword */:
                    nextToken();
                    if (token() === 88 /* SyntaxKind.DefaultKeyword */) {
                        return lookAhead(nextTokenCanFollowDefaultKeyword);
                    }
                    if (token() === 152 /* SyntaxKind.TypeKeyword */) {
                        return lookAhead(nextTokenCanFollowExportModifier);
                    }
                    return canFollowExportModifier();
                case 88 /* SyntaxKind.DefaultKeyword */:
                    return nextTokenCanFollowDefaultKeyword();
                case 124 /* SyntaxKind.StaticKeyword */:
                case 136 /* SyntaxKind.GetKeyword */:
                case 149 /* SyntaxKind.SetKeyword */:
                    nextToken();
                    return canFollowModifier();
                default:
                    return nextTokenIsOnSameLineAndCanFollowModifier();
            }
        }
        function canFollowExportModifier() {
            return token() !== 41 /* SyntaxKind.AsteriskToken */
                && token() !== 127 /* SyntaxKind.AsKeyword */
                && token() !== 18 /* SyntaxKind.OpenBraceToken */
                && canFollowModifier();
        }
        function nextTokenCanFollowExportModifier() {
            nextToken();
            return canFollowExportModifier();
        }
        function parseAnyContextualModifier() {
            return ts.isModifierKind(token()) && tryParse(nextTokenCanFollowModifier);
        }
        function canFollowModifier() {
            return token() === 22 /* SyntaxKind.OpenBracketToken */
                || token() === 18 /* SyntaxKind.OpenBraceToken */
                || token() === 41 /* SyntaxKind.AsteriskToken */
                || token() === 25 /* SyntaxKind.DotDotDotToken */
                || isLiteralPropertyName();
        }
        function nextTokenCanFollowDefaultKeyword() {
            nextToken();
            return token() === 84 /* SyntaxKind.ClassKeyword */ || token() === 98 /* SyntaxKind.FunctionKeyword */ ||
                token() === 118 /* SyntaxKind.InterfaceKeyword */ ||
                (token() === 126 /* SyntaxKind.AbstractKeyword */ && lookAhead(nextTokenIsClassKeywordOnSameLine)) ||
                (token() === 131 /* SyntaxKind.AsyncKeyword */ && lookAhead(nextTokenIsFunctionKeywordOnSameLine));
        }
        // True if positioned at the start of a list element
        function isListElement(parsingContext, inErrorRecovery) {
            var node = currentNode(parsingContext);
            if (node) {
                return true;
            }
            switch (parsingContext) {
                case 0 /* ParsingContext.SourceElements */:
                case 1 /* ParsingContext.BlockStatements */:
                case 3 /* ParsingContext.SwitchClauseStatements */:
                    // If we're in error recovery, then we don't want to treat ';' as an empty statement.
                    // The problem is that ';' can show up in far too many contexts, and if we see one
                    // and assume it's a statement, then we may bail out inappropriately from whatever
                    // we're parsing.  For example, if we have a semicolon in the middle of a class, then
                    // we really don't want to assume the class is over and we're on a statement in the
                    // outer module.  We just want to consume and move on.
                    return !(token() === 26 /* SyntaxKind.SemicolonToken */ && inErrorRecovery) && isStartOfStatement();
                case 2 /* ParsingContext.SwitchClauses */:
                    return token() === 82 /* SyntaxKind.CaseKeyword */ || token() === 88 /* SyntaxKind.DefaultKeyword */;
                case 4 /* ParsingContext.TypeMembers */:
                    return lookAhead(isTypeMemberStart);
                case 5 /* ParsingContext.ClassMembers */:
                    // We allow semicolons as class elements (as specified by ES6) as long as we're
                    // not in error recovery.  If we're in error recovery, we don't want an errant
                    // semicolon to be treated as a class member (since they're almost always used
                    // for statements.
                    return lookAhead(isClassMemberStart) || (token() === 26 /* SyntaxKind.SemicolonToken */ && !inErrorRecovery);
                case 6 /* ParsingContext.EnumMembers */:
                    // Include open bracket computed properties. This technically also lets in indexers,
                    // which would be a candidate for improved error reporting.
                    return token() === 22 /* SyntaxKind.OpenBracketToken */ || isLiteralPropertyName();
                case 12 /* ParsingContext.ObjectLiteralMembers */:
                    switch (token()) {
                        case 22 /* SyntaxKind.OpenBracketToken */:
                        case 41 /* SyntaxKind.AsteriskToken */:
                        case 25 /* SyntaxKind.DotDotDotToken */:
                        case 24 /* SyntaxKind.DotToken */: // Not an object literal member, but don't want to close the object (see `tests/cases/fourslash/completionsDotInObjectLiteral.ts`)
                            return true;
                        default:
                            return isLiteralPropertyName();
                    }
                case 18 /* ParsingContext.RestProperties */:
                    return isLiteralPropertyName();
                case 9 /* ParsingContext.ObjectBindingElements */:
                    return token() === 22 /* SyntaxKind.OpenBracketToken */ || token() === 25 /* SyntaxKind.DotDotDotToken */ || isLiteralPropertyName();
                case 24 /* ParsingContext.AssertEntries */:
                    return isAssertionKey();
                case 7 /* ParsingContext.HeritageClauseElement */:
                    // If we see `{ ... }` then only consume it as an expression if it is followed by `,` or `{`
                    // That way we won't consume the body of a class in its heritage clause.
                    if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                        return lookAhead(isValidHeritageClauseObjectLiteral);
                    }
                    if (!inErrorRecovery) {
                        return isStartOfLeftHandSideExpression() && !isHeritageClauseExtendsOrImplementsKeyword();
                    }
                    else {
                        // If we're in error recovery we tighten up what we're willing to match.
                        // That way we don't treat something like "this" as a valid heritage clause
                        // element during recovery.
                        return isIdentifier() && !isHeritageClauseExtendsOrImplementsKeyword();
                    }
                case 8 /* ParsingContext.VariableDeclarations */:
                    return isBindingIdentifierOrPrivateIdentifierOrPattern();
                case 10 /* ParsingContext.ArrayBindingElements */:
                    return token() === 27 /* SyntaxKind.CommaToken */ || token() === 25 /* SyntaxKind.DotDotDotToken */ || isBindingIdentifierOrPrivateIdentifierOrPattern();
                case 19 /* ParsingContext.TypeParameters */:
                    return token() === 101 /* SyntaxKind.InKeyword */ || isIdentifier();
                case 15 /* ParsingContext.ArrayLiteralMembers */:
                    switch (token()) {
                        case 27 /* SyntaxKind.CommaToken */:
                        case 24 /* SyntaxKind.DotToken */: // Not an array literal member, but don't want to close the array (see `tests/cases/fourslash/completionsDotInArrayLiteralInObjectLiteral.ts`)
                            return true;
                    }
                // falls through
                case 11 /* ParsingContext.ArgumentExpressions */:
                    return token() === 25 /* SyntaxKind.DotDotDotToken */ || isStartOfExpression();
                case 16 /* ParsingContext.Parameters */:
                    return isStartOfParameter(/*isJSDocParameter*/ false);
                case 17 /* ParsingContext.JSDocParameters */:
                    return isStartOfParameter(/*isJSDocParameter*/ true);
                case 20 /* ParsingContext.TypeArguments */:
                case 21 /* ParsingContext.TupleElementTypes */:
                    return token() === 27 /* SyntaxKind.CommaToken */ || isStartOfType();
                case 22 /* ParsingContext.HeritageClauses */:
                    return isHeritageClause();
                case 23 /* ParsingContext.ImportOrExportSpecifiers */:
                    return ts.tokenIsIdentifierOrKeyword(token());
                case 13 /* ParsingContext.JsxAttributes */:
                    return ts.tokenIsIdentifierOrKeyword(token()) || token() === 18 /* SyntaxKind.OpenBraceToken */;
                case 14 /* ParsingContext.JsxChildren */:
                    return true;
            }
            return ts.Debug.fail("Non-exhaustive case in 'isListElement'.");
        }
        function isValidHeritageClauseObjectLiteral() {
            ts.Debug.assert(token() === 18 /* SyntaxKind.OpenBraceToken */);
            if (nextToken() === 19 /* SyntaxKind.CloseBraceToken */) {
                // if we see "extends {}" then only treat the {} as what we're extending (and not
                // the class body) if we have:
                //
                //      extends {} {
                //      extends {},
                //      extends {} extends
                //      extends {} implements
                var next = nextToken();
                return next === 27 /* SyntaxKind.CommaToken */ || next === 18 /* SyntaxKind.OpenBraceToken */ || next === 94 /* SyntaxKind.ExtendsKeyword */ || next === 117 /* SyntaxKind.ImplementsKeyword */;
            }
            return true;
        }
        function nextTokenIsIdentifier() {
            nextToken();
            return isIdentifier();
        }
        function nextTokenIsIdentifierOrKeyword() {
            nextToken();
            return ts.tokenIsIdentifierOrKeyword(token());
        }
        function nextTokenIsIdentifierOrKeywordOrGreaterThan() {
            nextToken();
            return ts.tokenIsIdentifierOrKeywordOrGreaterThan(token());
        }
        function isHeritageClauseExtendsOrImplementsKeyword() {
            if (token() === 117 /* SyntaxKind.ImplementsKeyword */ ||
                token() === 94 /* SyntaxKind.ExtendsKeyword */) {
                return lookAhead(nextTokenIsStartOfExpression);
            }
            return false;
        }
        function nextTokenIsStartOfExpression() {
            nextToken();
            return isStartOfExpression();
        }
        function nextTokenIsStartOfType() {
            nextToken();
            return isStartOfType();
        }
        // True if positioned at a list terminator
        function isListTerminator(kind) {
            if (token() === 1 /* SyntaxKind.EndOfFileToken */) {
                // Being at the end of the file ends all lists.
                return true;
            }
            switch (kind) {
                case 1 /* ParsingContext.BlockStatements */:
                case 2 /* ParsingContext.SwitchClauses */:
                case 4 /* ParsingContext.TypeMembers */:
                case 5 /* ParsingContext.ClassMembers */:
                case 6 /* ParsingContext.EnumMembers */:
                case 12 /* ParsingContext.ObjectLiteralMembers */:
                case 9 /* ParsingContext.ObjectBindingElements */:
                case 23 /* ParsingContext.ImportOrExportSpecifiers */:
                case 24 /* ParsingContext.AssertEntries */:
                    return token() === 19 /* SyntaxKind.CloseBraceToken */;
                case 3 /* ParsingContext.SwitchClauseStatements */:
                    return token() === 19 /* SyntaxKind.CloseBraceToken */ || token() === 82 /* SyntaxKind.CaseKeyword */ || token() === 88 /* SyntaxKind.DefaultKeyword */;
                case 7 /* ParsingContext.HeritageClauseElement */:
                    return token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 94 /* SyntaxKind.ExtendsKeyword */ || token() === 117 /* SyntaxKind.ImplementsKeyword */;
                case 8 /* ParsingContext.VariableDeclarations */:
                    return isVariableDeclaratorListTerminator();
                case 19 /* ParsingContext.TypeParameters */:
                    // Tokens other than '>' are here for better error recovery
                    return token() === 31 /* SyntaxKind.GreaterThanToken */ || token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 94 /* SyntaxKind.ExtendsKeyword */ || token() === 117 /* SyntaxKind.ImplementsKeyword */;
                case 11 /* ParsingContext.ArgumentExpressions */:
                    // Tokens other than ')' are here for better error recovery
                    return token() === 21 /* SyntaxKind.CloseParenToken */ || token() === 26 /* SyntaxKind.SemicolonToken */;
                case 15 /* ParsingContext.ArrayLiteralMembers */:
                case 21 /* ParsingContext.TupleElementTypes */:
                case 10 /* ParsingContext.ArrayBindingElements */:
                    return token() === 23 /* SyntaxKind.CloseBracketToken */;
                case 17 /* ParsingContext.JSDocParameters */:
                case 16 /* ParsingContext.Parameters */:
                case 18 /* ParsingContext.RestProperties */:
                    // Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery
                    return token() === 21 /* SyntaxKind.CloseParenToken */ || token() === 23 /* SyntaxKind.CloseBracketToken */ /*|| token === SyntaxKind.OpenBraceToken*/;
                case 20 /* ParsingContext.TypeArguments */:
                    // All other tokens should cause the type-argument to terminate except comma token
                    return token() !== 27 /* SyntaxKind.CommaToken */;
                case 22 /* ParsingContext.HeritageClauses */:
                    return token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 19 /* SyntaxKind.CloseBraceToken */;
                case 13 /* ParsingContext.JsxAttributes */:
                    return token() === 31 /* SyntaxKind.GreaterThanToken */ || token() === 43 /* SyntaxKind.SlashToken */;
                case 14 /* ParsingContext.JsxChildren */:
                    return token() === 29 /* SyntaxKind.LessThanToken */ && lookAhead(nextTokenIsSlash);
                default:
                    return false;
            }
        }
        function isVariableDeclaratorListTerminator() {
            // If we can consume a semicolon (either explicitly, or with ASI), then consider us done
            // with parsing the list of variable declarators.
            if (canParseSemicolon()) {
                return true;
            }
            // in the case where we're parsing the variable declarator of a 'for-in' statement, we
            // are done if we see an 'in' keyword in front of us. Same with for-of
            if (isInOrOfKeyword(token())) {
                return true;
            }
            // ERROR RECOVERY TWEAK:
            // For better error recovery, if we see an '=>' then we just stop immediately.  We've got an
            // arrow function here and it's going to be very unlikely that we'll resynchronize and get
            // another variable declaration.
            if (token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                return true;
            }
            // Keep trying to parse out variable declarators.
            return false;
        }
        // True if positioned at element or terminator of the current list or any enclosing list
        function isInSomeParsingContext() {
            for (var kind = 0; kind < 25 /* ParsingContext.Count */; kind++) {
                if (parsingContext & (1 << kind)) {
                    if (isListElement(kind, /*inErrorRecovery*/ true) || isListTerminator(kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        // Parses a list of elements
        function parseList(kind, parseElement) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var list = [];
            var listPos = getNodePos();
            while (!isListTerminator(kind)) {
                if (isListElement(kind, /*inErrorRecovery*/ false)) {
                    list.push(parseListElement(kind, parseElement));
                    continue;
                }
                if (abortParsingListOrMoveToNextToken(kind)) {
                    break;
                }
            }
            parsingContext = saveParsingContext;
            return createNodeArray(list, listPos);
        }
        function parseListElement(parsingContext, parseElement) {
            var node = currentNode(parsingContext);
            if (node) {
                return consumeNode(node);
            }
            return parseElement();
        }
        function currentNode(parsingContext) {
            // If we don't have a cursor or the parsing context isn't reusable, there's nothing to reuse.
            //
            // If there is an outstanding parse error that we've encountered, but not attached to
            // some node, then we cannot get a node from the old source tree.  This is because we
            // want to mark the next node we encounter as being unusable.
            //
            // Note: This may be too conservative.  Perhaps we could reuse the node and set the bit
            // on it (or its leftmost child) as having the error.  For now though, being conservative
            // is nice and likely won't ever affect perf.
            if (!syntaxCursor || !isReusableParsingContext(parsingContext) || parseErrorBeforeNextFinishedNode) {
                return undefined;
            }
            var node = syntaxCursor.currentNode(scanner.getStartPos());
            // Can't reuse a missing node.
            // Can't reuse a node that intersected the change range.
            // Can't reuse a node that contains a parse error.  This is necessary so that we
            // produce the same set of errors again.
            if (ts.nodeIsMissing(node) || node.intersectsChange || ts.containsParseError(node)) {
                return undefined;
            }
            // We can only reuse a node if it was parsed under the same strict mode that we're
            // currently in.  i.e. if we originally parsed a node in non-strict mode, but then
            // the user added 'using strict' at the top of the file, then we can't use that node
            // again as the presence of strict mode may cause us to parse the tokens in the file
            // differently.
            //
            // Note: we *can* reuse tokens when the strict mode changes.  That's because tokens
            // are unaffected by strict mode.  It's just the parser will decide what to do with it
            // differently depending on what mode it is in.
            //
            // This also applies to all our other context flags as well.
            var nodeContextFlags = node.flags & 50720768 /* NodeFlags.ContextFlags */;
            if (nodeContextFlags !== contextFlags) {
                return undefined;
            }
            // Ok, we have a node that looks like it could be reused.  Now verify that it is valid
            // in the current list parsing context that we're currently at.
            if (!canReuseNode(node, parsingContext)) {
                return undefined;
            }
            if (node.jsDocCache) {
                // jsDocCache may include tags from parent nodes, which might have been modified.
                node.jsDocCache = undefined;
            }
            return node;
        }
        function consumeNode(node) {
            // Move the scanner so it is after the node we just consumed.
            scanner.setTextPos(node.end);
            nextToken();
            return node;
        }
        function isReusableParsingContext(parsingContext) {
            switch (parsingContext) {
                case 5 /* ParsingContext.ClassMembers */:
                case 2 /* ParsingContext.SwitchClauses */:
                case 0 /* ParsingContext.SourceElements */:
                case 1 /* ParsingContext.BlockStatements */:
                case 3 /* ParsingContext.SwitchClauseStatements */:
                case 6 /* ParsingContext.EnumMembers */:
                case 4 /* ParsingContext.TypeMembers */:
                case 8 /* ParsingContext.VariableDeclarations */:
                case 17 /* ParsingContext.JSDocParameters */:
                case 16 /* ParsingContext.Parameters */:
                    return true;
            }
            return false;
        }
        function canReuseNode(node, parsingContext) {
            switch (parsingContext) {
                case 5 /* ParsingContext.ClassMembers */:
                    return isReusableClassMember(node);
                case 2 /* ParsingContext.SwitchClauses */:
                    return isReusableSwitchClause(node);
                case 0 /* ParsingContext.SourceElements */:
                case 1 /* ParsingContext.BlockStatements */:
                case 3 /* ParsingContext.SwitchClauseStatements */:
                    return isReusableStatement(node);
                case 6 /* ParsingContext.EnumMembers */:
                    return isReusableEnumMember(node);
                case 4 /* ParsingContext.TypeMembers */:
                    return isReusableTypeMember(node);
                case 8 /* ParsingContext.VariableDeclarations */:
                    return isReusableVariableDeclaration(node);
                case 17 /* ParsingContext.JSDocParameters */:
                case 16 /* ParsingContext.Parameters */:
                    return isReusableParameter(node);
                // Any other lists we do not care about reusing nodes in.  But feel free to add if
                // you can do so safely.  Danger areas involve nodes that may involve speculative
                // parsing.  If speculative parsing is involved with the node, then the range the
                // parser reached while looking ahead might be in the edited range (see the example
                // in canReuseVariableDeclaratorNode for a good case of this).
                // case ParsingContext.HeritageClauses:
                // This would probably be safe to reuse.  There is no speculative parsing with
                // heritage clauses.
                // case ParsingContext.TypeParameters:
                // This would probably be safe to reuse.  There is no speculative parsing with
                // type parameters.  Note that that's because type *parameters* only occur in
                // unambiguous *type* contexts.  While type *arguments* occur in very ambiguous
                // *expression* contexts.
                // case ParsingContext.TupleElementTypes:
                // This would probably be safe to reuse.  There is no speculative parsing with
                // tuple types.
                // Technically, type argument list types are probably safe to reuse.  While
                // speculative parsing is involved with them (since type argument lists are only
                // produced from speculative parsing a < as a type argument list), we only have
                // the types because speculative parsing succeeded.  Thus, the lookahead never
                // went past the end of the list and rewound.
                // case ParsingContext.TypeArguments:
                // Note: these are almost certainly not safe to ever reuse.  Expressions commonly
                // need a large amount of lookahead, and we should not reuse them as they may
                // have actually intersected the edit.
                // case ParsingContext.ArgumentExpressions:
                // This is not safe to reuse for the same reason as the 'AssignmentExpression'
                // cases.  i.e. a property assignment may end with an expression, and thus might
                // have lookahead far beyond it's old node.
                // case ParsingContext.ObjectLiteralMembers:
                // This is probably not safe to reuse.  There can be speculative parsing with
                // type names in a heritage clause.  There can be generic names in the type
                // name list, and there can be left hand side expressions (which can have type
                // arguments.)
                // case ParsingContext.HeritageClauseElement:
                // Perhaps safe to reuse, but it's unlikely we'd see more than a dozen attributes
                // on any given element. Same for children.
                // case ParsingContext.JsxAttributes:
                // case ParsingContext.JsxChildren:
            }
            return false;
        }
        function isReusableClassMember(node) {
            if (node) {
                switch (node.kind) {
                    case 171 /* SyntaxKind.Constructor */:
                    case 176 /* SyntaxKind.IndexSignature */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                    case 234 /* SyntaxKind.SemicolonClassElement */:
                        return true;
                    case 169 /* SyntaxKind.MethodDeclaration */:
                        // Method declarations are not necessarily reusable.  An object-literal
                        // may have a method calls "constructor(...)" and we must reparse that
                        // into an actual .ConstructorDeclaration.
                        var methodDeclaration = node;
                        var nameIsConstructor = methodDeclaration.name.kind === 79 /* SyntaxKind.Identifier */ &&
                            methodDeclaration.name.originalKeywordKind === 134 /* SyntaxKind.ConstructorKeyword */;
                        return !nameIsConstructor;
                }
            }
            return false;
        }
        function isReusableSwitchClause(node) {
            if (node) {
                switch (node.kind) {
                    case 289 /* SyntaxKind.CaseClause */:
                    case 290 /* SyntaxKind.DefaultClause */:
                        return true;
                }
            }
            return false;
        }
        function isReusableStatement(node) {
            if (node) {
                switch (node.kind) {
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                    case 237 /* SyntaxKind.VariableStatement */:
                    case 235 /* SyntaxKind.Block */:
                    case 239 /* SyntaxKind.IfStatement */:
                    case 238 /* SyntaxKind.ExpressionStatement */:
                    case 251 /* SyntaxKind.ThrowStatement */:
                    case 247 /* SyntaxKind.ReturnStatement */:
                    case 249 /* SyntaxKind.SwitchStatement */:
                    case 246 /* SyntaxKind.BreakStatement */:
                    case 245 /* SyntaxKind.ContinueStatement */:
                    case 243 /* SyntaxKind.ForInStatement */:
                    case 244 /* SyntaxKind.ForOfStatement */:
                    case 242 /* SyntaxKind.ForStatement */:
                    case 241 /* SyntaxKind.WhileStatement */:
                    case 248 /* SyntaxKind.WithStatement */:
                    case 236 /* SyntaxKind.EmptyStatement */:
                    case 252 /* SyntaxKind.TryStatement */:
                    case 250 /* SyntaxKind.LabeledStatement */:
                    case 240 /* SyntaxKind.DoStatement */:
                    case 253 /* SyntaxKind.DebuggerStatement */:
                    case 266 /* SyntaxKind.ImportDeclaration */:
                    case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    case 272 /* SyntaxKind.ExportDeclaration */:
                    case 271 /* SyntaxKind.ExportAssignment */:
                    case 261 /* SyntaxKind.ModuleDeclaration */:
                    case 257 /* SyntaxKind.ClassDeclaration */:
                    case 258 /* SyntaxKind.InterfaceDeclaration */:
                    case 260 /* SyntaxKind.EnumDeclaration */:
                    case 259 /* SyntaxKind.TypeAliasDeclaration */:
                        return true;
                }
            }
            return false;
        }
        function isReusableEnumMember(node) {
            return node.kind === 299 /* SyntaxKind.EnumMember */;
        }
        function isReusableTypeMember(node) {
            if (node) {
                switch (node.kind) {
                    case 175 /* SyntaxKind.ConstructSignature */:
                    case 168 /* SyntaxKind.MethodSignature */:
                    case 176 /* SyntaxKind.IndexSignature */:
                    case 166 /* SyntaxKind.PropertySignature */:
                    case 174 /* SyntaxKind.CallSignature */:
                        return true;
                }
            }
            return false;
        }
        function isReusableVariableDeclaration(node) {
            if (node.kind !== 254 /* SyntaxKind.VariableDeclaration */) {
                return false;
            }
            // Very subtle incremental parsing bug.  Consider the following code:
            //
            //      let v = new List < A, B
            //
            // This is actually legal code.  It's a list of variable declarators "v = new List<A"
            // on one side and "B" on the other. If you then change that to:
            //
            //      let v = new List < A, B >()
            //
            // then we have a problem.  "v = new List<A" doesn't intersect the change range, so we
            // start reparsing at "B" and we completely fail to handle this properly.
            //
            // In order to prevent this, we do not allow a variable declarator to be reused if it
            // has an initializer.
            var variableDeclarator = node;
            return variableDeclarator.initializer === undefined;
        }
        function isReusableParameter(node) {
            if (node.kind !== 164 /* SyntaxKind.Parameter */) {
                return false;
            }
            // See the comment in isReusableVariableDeclaration for why we do this.
            var parameter = node;
            return parameter.initializer === undefined;
        }
        // Returns true if we should abort parsing.
        function abortParsingListOrMoveToNextToken(kind) {
            parsingContextErrors(kind);
            if (isInSomeParsingContext()) {
                return true;
            }
            nextToken();
            return false;
        }
        function parsingContextErrors(context) {
            switch (context) {
                case 0 /* ParsingContext.SourceElements */:
                    return token() === 88 /* SyntaxKind.DefaultKeyword */
                        ? parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(93 /* SyntaxKind.ExportKeyword */))
                        : parseErrorAtCurrentToken(ts.Diagnostics.Declaration_or_statement_expected);
                case 1 /* ParsingContext.BlockStatements */: return parseErrorAtCurrentToken(ts.Diagnostics.Declaration_or_statement_expected);
                case 2 /* ParsingContext.SwitchClauses */: return parseErrorAtCurrentToken(ts.Diagnostics.case_or_default_expected);
                case 3 /* ParsingContext.SwitchClauseStatements */: return parseErrorAtCurrentToken(ts.Diagnostics.Statement_expected);
                case 18 /* ParsingContext.RestProperties */: // fallthrough
                case 4 /* ParsingContext.TypeMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Property_or_signature_expected);
                case 5 /* ParsingContext.ClassMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected);
                case 6 /* ParsingContext.EnumMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Enum_member_expected);
                case 7 /* ParsingContext.HeritageClauseElement */: return parseErrorAtCurrentToken(ts.Diagnostics.Expression_expected);
                case 8 /* ParsingContext.VariableDeclarations */:
                    return ts.isKeyword(token())
                        ? parseErrorAtCurrentToken(ts.Diagnostics._0_is_not_allowed_as_a_variable_declaration_name, ts.tokenToString(token()))
                        : parseErrorAtCurrentToken(ts.Diagnostics.Variable_declaration_expected);
                case 9 /* ParsingContext.ObjectBindingElements */: return parseErrorAtCurrentToken(ts.Diagnostics.Property_destructuring_pattern_expected);
                case 10 /* ParsingContext.ArrayBindingElements */: return parseErrorAtCurrentToken(ts.Diagnostics.Array_element_destructuring_pattern_expected);
                case 11 /* ParsingContext.ArgumentExpressions */: return parseErrorAtCurrentToken(ts.Diagnostics.Argument_expression_expected);
                case 12 /* ParsingContext.ObjectLiteralMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Property_assignment_expected);
                case 15 /* ParsingContext.ArrayLiteralMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Expression_or_comma_expected);
                case 17 /* ParsingContext.JSDocParameters */: return parseErrorAtCurrentToken(ts.Diagnostics.Parameter_declaration_expected);
                case 16 /* ParsingContext.Parameters */:
                    return ts.isKeyword(token())
                        ? parseErrorAtCurrentToken(ts.Diagnostics._0_is_not_allowed_as_a_parameter_name, ts.tokenToString(token()))
                        : parseErrorAtCurrentToken(ts.Diagnostics.Parameter_declaration_expected);
                case 19 /* ParsingContext.TypeParameters */: return parseErrorAtCurrentToken(ts.Diagnostics.Type_parameter_declaration_expected);
                case 20 /* ParsingContext.TypeArguments */: return parseErrorAtCurrentToken(ts.Diagnostics.Type_argument_expected);
                case 21 /* ParsingContext.TupleElementTypes */: return parseErrorAtCurrentToken(ts.Diagnostics.Type_expected);
                case 22 /* ParsingContext.HeritageClauses */: return parseErrorAtCurrentToken(ts.Diagnostics.Unexpected_token_expected);
                case 23 /* ParsingContext.ImportOrExportSpecifiers */: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_expected);
                case 13 /* ParsingContext.JsxAttributes */: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_expected);
                case 14 /* ParsingContext.JsxChildren */: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_expected);
                default: return [undefined]; // TODO: GH#18217 `default: Debug.assertNever(context);`
            }
        }
        function parseDelimitedList(kind, parseElement, considerSemicolonAsDelimiter) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var list = [];
            var listPos = getNodePos();
            var commaStart = -1; // Meaning the previous token was not a comma
            while (true) {
                if (isListElement(kind, /*inErrorRecovery*/ false)) {
                    var startPos = scanner.getStartPos();
                    var result = parseListElement(kind, parseElement);
                    if (!result) {
                        parsingContext = saveParsingContext;
                        return undefined;
                    }
                    list.push(result);
                    commaStart = scanner.getTokenPos();
                    if (parseOptional(27 /* SyntaxKind.CommaToken */)) {
                        // No need to check for a zero length node since we know we parsed a comma
                        continue;
                    }
                    commaStart = -1; // Back to the state where the last token was not a comma
                    if (isListTerminator(kind)) {
                        break;
                    }
                    // We didn't get a comma, and the list wasn't terminated, explicitly parse
                    // out a comma so we give a good error message.
                    parseExpected(27 /* SyntaxKind.CommaToken */, getExpectedCommaDiagnostic(kind));
                    // If the token was a semicolon, and the caller allows that, then skip it and
                    // continue.  This ensures we get back on track and don't result in tons of
                    // parse errors.  For example, this can happen when people do things like use
                    // a semicolon to delimit object literal members.   Note: we'll have already
                    // reported an error when we called parseExpected above.
                    if (considerSemicolonAsDelimiter && token() === 26 /* SyntaxKind.SemicolonToken */ && !scanner.hasPrecedingLineBreak()) {
                        nextToken();
                    }
                    if (startPos === scanner.getStartPos()) {
                        // What we're parsing isn't actually remotely recognizable as a element and we've consumed no tokens whatsoever
                        // Consume a token to advance the parser in some way and avoid an infinite loop
                        // This can happen when we're speculatively parsing parenthesized expressions which we think may be arrow functions,
                        // or when a modifier keyword which is disallowed as a parameter name (ie, `static` in strict mode) is supplied
                        nextToken();
                    }
                    continue;
                }
                if (isListTerminator(kind)) {
                    break;
                }
                if (abortParsingListOrMoveToNextToken(kind)) {
                    break;
                }
            }
            parsingContext = saveParsingContext;
            // Recording the trailing comma is deliberately done after the previous
            // loop, and not just if we see a list terminator. This is because the list
            // may have ended incorrectly, but it is still important to know if there
            // was a trailing comma.
            // Check if the last token was a comma.
            // Always preserve a trailing comma by marking it on the NodeArray
            return createNodeArray(list, listPos, /*end*/ undefined, commaStart >= 0);
        }
        function getExpectedCommaDiagnostic(kind) {
            return kind === 6 /* ParsingContext.EnumMembers */ ? ts.Diagnostics.An_enum_member_name_must_be_followed_by_a_or : undefined;
        }
        function createMissingList() {
            var list = createNodeArray([], getNodePos());
            list.isMissingList = true;
            return list;
        }
        function isMissingList(arr) {
            return !!arr.isMissingList;
        }
        function parseBracketedList(kind, parseElement, open, close) {
            if (parseExpected(open)) {
                var result = parseDelimitedList(kind, parseElement);
                parseExpected(close);
                return result;
            }
            return createMissingList();
        }
        function parseEntityName(allowReservedWords, diagnosticMessage) {
            var pos = getNodePos();
            var entity = allowReservedWords ? parseIdentifierName(diagnosticMessage) : parseIdentifier(diagnosticMessage);
            var dotPos = getNodePos();
            while (parseOptional(24 /* SyntaxKind.DotToken */)) {
                if (token() === 29 /* SyntaxKind.LessThanToken */) {
                    // the entity is part of a JSDoc-style generic, so record the trailing dot for later error reporting
                    entity.jsdocDotPos = dotPos;
                    break;
                }
                dotPos = getNodePos();
                entity = finishNode(factory.createQualifiedName(entity, parseRightSideOfDot(allowReservedWords, /* allowPrivateIdentifiers */ false)), pos);
            }
            return entity;
        }
        function createQualifiedName(entity, name) {
            return finishNode(factory.createQualifiedName(entity, name), entity.pos);
        }
        function parseRightSideOfDot(allowIdentifierNames, allowPrivateIdentifiers) {
            // Technically a keyword is valid here as all identifiers and keywords are identifier names.
            // However, often we'll encounter this in error situations when the identifier or keyword
            // is actually starting another valid construct.
            //
            // So, we check for the following specific case:
            //
            //      name.
            //      identifierOrKeyword identifierNameOrKeyword
            //
            // Note: the newlines are important here.  For example, if that above code
            // were rewritten into:
            //
            //      name.identifierOrKeyword
            //      identifierNameOrKeyword
            //
            // Then we would consider it valid.  That's because ASI would take effect and
            // the code would be implicitly: "name.identifierOrKeyword; identifierNameOrKeyword".
            // In the first case though, ASI will not take effect because there is not a
            // line terminator after the identifier or keyword.
            if (scanner.hasPrecedingLineBreak() && ts.tokenIsIdentifierOrKeyword(token())) {
                var matchesPattern = lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);
                if (matchesPattern) {
                    // Report that we need an identifier.  However, report it right after the dot,
                    // and not on the next token.  This is because the next token might actually
                    // be an identifier and the error would be quite confusing.
                    return createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.Identifier_expected);
                }
            }
            if (token() === 80 /* SyntaxKind.PrivateIdentifier */) {
                var node = parsePrivateIdentifier();
                return allowPrivateIdentifiers ? node : createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.Identifier_expected);
            }
            return allowIdentifierNames ? parseIdentifierName() : parseIdentifier();
        }
        function parseTemplateSpans(isTaggedTemplate) {
            var pos = getNodePos();
            var list = [];
            var node;
            do {
                node = parseTemplateSpan(isTaggedTemplate);
                list.push(node);
            } while (node.literal.kind === 16 /* SyntaxKind.TemplateMiddle */);
            return createNodeArray(list, pos);
        }
        function parseTemplateExpression(isTaggedTemplate) {
            var pos = getNodePos();
            return finishNode(factory.createTemplateExpression(parseTemplateHead(isTaggedTemplate), parseTemplateSpans(isTaggedTemplate)), pos);
        }
        function parseTemplateType() {
            var pos = getNodePos();
            return finishNode(factory.createTemplateLiteralType(parseTemplateHead(/*isTaggedTemplate*/ false), parseTemplateTypeSpans()), pos);
        }
        function parseTemplateTypeSpans() {
            var pos = getNodePos();
            var list = [];
            var node;
            do {
                node = parseTemplateTypeSpan();
                list.push(node);
            } while (node.literal.kind === 16 /* SyntaxKind.TemplateMiddle */);
            return createNodeArray(list, pos);
        }
        function parseTemplateTypeSpan() {
            var pos = getNodePos();
            return finishNode(factory.createTemplateLiteralTypeSpan(parseType(), parseLiteralOfTemplateSpan(/*isTaggedTemplate*/ false)), pos);
        }
        function parseLiteralOfTemplateSpan(isTaggedTemplate) {
            if (token() === 19 /* SyntaxKind.CloseBraceToken */) {
                reScanTemplateToken(isTaggedTemplate);
                return parseTemplateMiddleOrTemplateTail();
            }
            else {
                // TODO(rbuckton): Do we need to call `parseExpectedToken` or can we just call `createMissingNode` directly?
                return parseExpectedToken(17 /* SyntaxKind.TemplateTail */, ts.Diagnostics._0_expected, ts.tokenToString(19 /* SyntaxKind.CloseBraceToken */));
            }
        }
        function parseTemplateSpan(isTaggedTemplate) {
            var pos = getNodePos();
            return finishNode(factory.createTemplateSpan(allowInAnd(parseExpression), parseLiteralOfTemplateSpan(isTaggedTemplate)), pos);
        }
        function parseLiteralNode() {
            return parseLiteralLikeNode(token());
        }
        function parseTemplateHead(isTaggedTemplate) {
            if (isTaggedTemplate) {
                reScanTemplateHeadOrNoSubstitutionTemplate();
            }
            var fragment = parseLiteralLikeNode(token());
            ts.Debug.assert(fragment.kind === 15 /* SyntaxKind.TemplateHead */, "Template head has wrong token kind");
            return fragment;
        }
        function parseTemplateMiddleOrTemplateTail() {
            var fragment = parseLiteralLikeNode(token());
            ts.Debug.assert(fragment.kind === 16 /* SyntaxKind.TemplateMiddle */ || fragment.kind === 17 /* SyntaxKind.TemplateTail */, "Template fragment has wrong token kind");
            return fragment;
        }
        function getTemplateLiteralRawText(kind) {
            var isLast = kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ || kind === 17 /* SyntaxKind.TemplateTail */;
            var tokenText = scanner.getTokenText();
            return tokenText.substring(1, tokenText.length - (scanner.isUnterminated() ? 0 : isLast ? 1 : 2));
        }
        function parseLiteralLikeNode(kind) {
            var pos = getNodePos();
            var node = ts.isTemplateLiteralKind(kind) ? factory.createTemplateLiteralLikeNode(kind, scanner.getTokenValue(), getTemplateLiteralRawText(kind), scanner.getTokenFlags() & 2048 /* TokenFlags.TemplateLiteralLikeFlags */) :
                // Octal literals are not allowed in strict mode or ES5
                // Note that theoretically the following condition would hold true literals like 009,
                // which is not octal. But because of how the scanner separates the tokens, we would
                // never get a token like this. Instead, we would get 00 and 9 as two separate tokens.
                // We also do not need to check for negatives because any prefix operator would be part of a
                // parent unary expression.
                kind === 8 /* SyntaxKind.NumericLiteral */ ? factory.createNumericLiteral(scanner.getTokenValue(), scanner.getNumericLiteralFlags()) :
                    kind === 10 /* SyntaxKind.StringLiteral */ ? factory.createStringLiteral(scanner.getTokenValue(), /*isSingleQuote*/ undefined, scanner.hasExtendedUnicodeEscape()) :
                        ts.isLiteralKind(kind) ? factory.createLiteralLikeNode(kind, scanner.getTokenValue()) :
                            ts.Debug.fail();
            if (scanner.hasExtendedUnicodeEscape()) {
                node.hasExtendedUnicodeEscape = true;
            }
            if (scanner.isUnterminated()) {
                node.isUnterminated = true;
            }
            nextToken();
            return finishNode(node, pos);
        }
        // TYPES
        function parseEntityNameOfTypeReference() {
            return parseEntityName(/*allowReservedWords*/ true, ts.Diagnostics.Type_expected);
        }
        function parseTypeArgumentsOfTypeReference() {
            if (!scanner.hasPrecedingLineBreak() && reScanLessThanToken() === 29 /* SyntaxKind.LessThanToken */) {
                return parseBracketedList(20 /* ParsingContext.TypeArguments */, parseType, 29 /* SyntaxKind.LessThanToken */, 31 /* SyntaxKind.GreaterThanToken */);
            }
        }
        function parseTypeReference() {
            var pos = getNodePos();
            return finishNode(factory.createTypeReferenceNode(parseEntityNameOfTypeReference(), parseTypeArgumentsOfTypeReference()), pos);
        }
        // If true, we should abort parsing an error function.
        function typeHasArrowFunctionBlockingParseError(node) {
            switch (node.kind) {
                case 178 /* SyntaxKind.TypeReference */:
                    return ts.nodeIsMissing(node.typeName);
                case 179 /* SyntaxKind.FunctionType */:
                case 180 /* SyntaxKind.ConstructorType */: {
                    var _a = node, parameters = _a.parameters, type = _a.type;
                    return isMissingList(parameters) || typeHasArrowFunctionBlockingParseError(type);
                }
                case 191 /* SyntaxKind.ParenthesizedType */:
                    return typeHasArrowFunctionBlockingParseError(node.type);
                default:
                    return false;
            }
        }
        function parseThisTypePredicate(lhs) {
            nextToken();
            return finishNode(factory.createTypePredicateNode(/*assertsModifier*/ undefined, lhs, parseType()), lhs.pos);
        }
        function parseThisTypeNode() {
            var pos = getNodePos();
            nextToken();
            return finishNode(factory.createThisTypeNode(), pos);
        }
        function parseJSDocAllType() {
            var pos = getNodePos();
            nextToken();
            return finishNode(factory.createJSDocAllType(), pos);
        }
        function parseJSDocNonNullableType() {
            var pos = getNodePos();
            nextToken();
            return finishNode(factory.createJSDocNonNullableType(parseNonArrayType(), /*postfix*/ false), pos);
        }
        function parseJSDocUnknownOrNullableType() {
            var pos = getNodePos();
            // skip the ?
            nextToken();
            // Need to lookahead to decide if this is a nullable or unknown type.
            // Here are cases where we'll pick the unknown type:
            //
            //      Foo(?,
            //      { a: ? }
            //      Foo(?)
            //      Foo<?>
            //      Foo(?=
            //      (?|
            if (token() === 27 /* SyntaxKind.CommaToken */ ||
                token() === 19 /* SyntaxKind.CloseBraceToken */ ||
                token() === 21 /* SyntaxKind.CloseParenToken */ ||
                token() === 31 /* SyntaxKind.GreaterThanToken */ ||
                token() === 63 /* SyntaxKind.EqualsToken */ ||
                token() === 51 /* SyntaxKind.BarToken */) {
                return finishNode(factory.createJSDocUnknownType(), pos);
            }
            else {
                return finishNode(factory.createJSDocNullableType(parseType(), /*postfix*/ false), pos);
            }
        }
        function parseJSDocFunctionType() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            if (lookAhead(nextTokenIsOpenParen)) {
                nextToken();
                var parameters = parseParameters(4 /* SignatureFlags.Type */ | 32 /* SignatureFlags.JSDoc */);
                var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
                return withJSDoc(finishNode(factory.createJSDocFunctionType(parameters, type), pos), hasJSDoc);
            }
            return finishNode(factory.createTypeReferenceNode(parseIdentifierName(), /*typeArguments*/ undefined), pos);
        }
        function parseJSDocParameter() {
            var pos = getNodePos();
            var name;
            if (token() === 108 /* SyntaxKind.ThisKeyword */ || token() === 103 /* SyntaxKind.NewKeyword */) {
                name = parseIdentifierName();
                parseExpected(58 /* SyntaxKind.ColonToken */);
            }
            return finishNode(factory.createParameterDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*dotDotDotToken*/ undefined, 
            // TODO(rbuckton): JSDoc parameters don't have names (except `this`/`new`), should we manufacture an empty identifier?
            name, 
            /*questionToken*/ undefined, parseJSDocType(), 
            /*initializer*/ undefined), pos);
        }
        function parseJSDocType() {
            scanner.setInJSDocType(true);
            var pos = getNodePos();
            if (parseOptional(141 /* SyntaxKind.ModuleKeyword */)) {
                // TODO(rbuckton): We never set the type for a JSDocNamepathType. What should we put here?
                var moduleTag = factory.createJSDocNamepathType(/*type*/ undefined);
                terminate: while (true) {
                    switch (token()) {
                        case 19 /* SyntaxKind.CloseBraceToken */:
                        case 1 /* SyntaxKind.EndOfFileToken */:
                        case 27 /* SyntaxKind.CommaToken */:
                        case 5 /* SyntaxKind.WhitespaceTrivia */:
                            break terminate;
                        default:
                            nextTokenJSDoc();
                    }
                }
                scanner.setInJSDocType(false);
                return finishNode(moduleTag, pos);
            }
            var hasDotDotDot = parseOptional(25 /* SyntaxKind.DotDotDotToken */);
            var type = parseTypeOrTypePredicate();
            scanner.setInJSDocType(false);
            if (hasDotDotDot) {
                type = finishNode(factory.createJSDocVariadicType(type), pos);
            }
            if (token() === 63 /* SyntaxKind.EqualsToken */) {
                nextToken();
                return finishNode(factory.createJSDocOptionalType(type), pos);
            }
            return type;
        }
        function parseTypeQuery() {
            var pos = getNodePos();
            parseExpected(112 /* SyntaxKind.TypeOfKeyword */);
            var entityName = parseEntityName(/*allowReservedWords*/ true);
            // Make sure we perform ASI to prevent parsing the next line's type arguments as part of an instantiation expression.
            var typeArguments = !scanner.hasPrecedingLineBreak() ? tryParseTypeArguments() : undefined;
            return finishNode(factory.createTypeQueryNode(entityName, typeArguments), pos);
        }
        function parseTypeParameter() {
            var pos = getNodePos();
            var modifiers = parseModifiers();
            var name = parseIdentifier();
            var constraint;
            var expression;
            if (parseOptional(94 /* SyntaxKind.ExtendsKeyword */)) {
                // It's not uncommon for people to write improper constraints to a generic.  If the
                // user writes a constraint that is an expression and not an actual type, then parse
                // it out as an expression (so we can recover well), but report that a type is needed
                // instead.
                if (isStartOfType() || !isStartOfExpression()) {
                    constraint = parseType();
                }
                else {
                    // It was not a type, and it looked like an expression.  Parse out an expression
                    // here so we recover well.  Note: it is important that we call parseUnaryExpression
                    // and not parseExpression here.  If the user has:
                    //
                    //      <T extends "">
                    //
                    // We do *not* want to consume the `>` as we're consuming the expression for "".
                    expression = parseUnaryExpressionOrHigher();
                }
            }
            var defaultType = parseOptional(63 /* SyntaxKind.EqualsToken */) ? parseType() : undefined;
            var node = factory.createTypeParameterDeclaration(modifiers, name, constraint, defaultType);
            node.expression = expression;
            return finishNode(node, pos);
        }
        function parseTypeParameters() {
            if (token() === 29 /* SyntaxKind.LessThanToken */) {
                return parseBracketedList(19 /* ParsingContext.TypeParameters */, parseTypeParameter, 29 /* SyntaxKind.LessThanToken */, 31 /* SyntaxKind.GreaterThanToken */);
            }
        }
        function isStartOfParameter(isJSDocParameter) {
            return token() === 25 /* SyntaxKind.DotDotDotToken */ ||
                isBindingIdentifierOrPrivateIdentifierOrPattern() ||
                ts.isModifierKind(token()) ||
                token() === 59 /* SyntaxKind.AtToken */ ||
                isStartOfType(/*inStartOfParameter*/ !isJSDocParameter);
        }
        function parseNameOfParameter(modifiers) {
            // FormalParameter [Yield,Await]:
            //      BindingElement[?Yield,?Await]
            var name = parseIdentifierOrPattern(ts.Diagnostics.Private_identifiers_cannot_be_used_as_parameters);
            if (ts.getFullWidth(name) === 0 && !ts.some(modifiers) && ts.isModifierKind(token())) {
                // in cases like
                // 'use strict'
                // function foo(static)
                // isParameter('static') === true, because of isModifier('static')
                // however 'static' is not a legal identifier in a strict mode.
                // so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)
                // and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)
                // to avoid this we'll advance cursor to the next token.
                nextToken();
            }
            return name;
        }
        function isParameterNameStart() {
            // Be permissive about await and yield by calling isBindingIdentifier instead of isIdentifier; disallowing
            // them during a speculative parse leads to many more follow-on errors than allowing the function to parse then later
            // complaining about the use of the keywords.
            return isBindingIdentifier() || token() === 22 /* SyntaxKind.OpenBracketToken */ || token() === 18 /* SyntaxKind.OpenBraceToken */;
        }
        function parseParameter(inOuterAwaitContext) {
            return parseParameterWorker(inOuterAwaitContext);
        }
        function parseParameterForSpeculation(inOuterAwaitContext) {
            return parseParameterWorker(inOuterAwaitContext, /*allowAmbiguity*/ false);
        }
        function parseParameterWorker(inOuterAwaitContext, allowAmbiguity) {
            if (allowAmbiguity === void 0) { allowAmbiguity = true; }
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            // FormalParameter [Yield,Await]:
            //      BindingElement[?Yield,?Await]
            // Decorators are parsed in the outer [Await] context, the rest of the parameter is parsed in the function's [Await] context.
            var decorators = inOuterAwaitContext ? doInAwaitContext(parseDecorators) : parseDecorators();
            if (token() === 108 /* SyntaxKind.ThisKeyword */) {
                var node_1 = factory.createParameterDeclaration(decorators, 
                /*modifiers*/ undefined, 
                /*dotDotDotToken*/ undefined, createIdentifier(/*isIdentifier*/ true), 
                /*questionToken*/ undefined, parseTypeAnnotation(), 
                /*initializer*/ undefined);
                if (decorators) {
                    parseErrorAtRange(decorators[0], ts.Diagnostics.Decorators_may_not_be_applied_to_this_parameters);
                }
                return withJSDoc(finishNode(node_1, pos), hasJSDoc);
            }
            var savedTopLevel = topLevel;
            topLevel = false;
            var modifiers = parseModifiers();
            var dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
            if (!allowAmbiguity && !isParameterNameStart()) {
                return undefined;
            }
            var node = withJSDoc(finishNode(factory.createParameterDeclaration(decorators, modifiers, dotDotDotToken, parseNameOfParameter(modifiers), parseOptionalToken(57 /* SyntaxKind.QuestionToken */), parseTypeAnnotation(), parseInitializer()), pos), hasJSDoc);
            topLevel = savedTopLevel;
            return node;
        }
        function parseReturnType(returnToken, isType) {
            if (shouldParseReturnType(returnToken, isType)) {
                return allowConditionalTypesAnd(parseTypeOrTypePredicate);
            }
        }
        function shouldParseReturnType(returnToken, isType) {
            if (returnToken === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                parseExpected(returnToken);
                return true;
            }
            else if (parseOptional(58 /* SyntaxKind.ColonToken */)) {
                return true;
            }
            else if (isType && token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                // This is easy to get backward, especially in type contexts, so parse the type anyway
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(58 /* SyntaxKind.ColonToken */));
                nextToken();
                return true;
            }
            return false;
        }
        function parseParametersWorker(flags, allowAmbiguity) {
            // FormalParameters [Yield,Await]: (modified)
            //      [empty]
            //      FormalParameterList[?Yield,Await]
            //
            // FormalParameter[Yield,Await]: (modified)
            //      BindingElement[?Yield,Await]
            //
            // BindingElement [Yield,Await]: (modified)
            //      SingleNameBinding[?Yield,?Await]
            //      BindingPattern[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
            //
            // SingleNameBinding [Yield,Await]:
            //      BindingIdentifier[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
            var savedYieldContext = inYieldContext();
            var savedAwaitContext = inAwaitContext();
            setYieldContext(!!(flags & 1 /* SignatureFlags.Yield */));
            setAwaitContext(!!(flags & 2 /* SignatureFlags.Await */));
            var parameters = flags & 32 /* SignatureFlags.JSDoc */ ?
                parseDelimitedList(17 /* ParsingContext.JSDocParameters */, parseJSDocParameter) :
                parseDelimitedList(16 /* ParsingContext.Parameters */, function () { return allowAmbiguity ? parseParameter(savedAwaitContext) : parseParameterForSpeculation(savedAwaitContext); });
            setYieldContext(savedYieldContext);
            setAwaitContext(savedAwaitContext);
            return parameters;
        }
        function parseParameters(flags) {
            // FormalParameters [Yield,Await]: (modified)
            //      [empty]
            //      FormalParameterList[?Yield,Await]
            //
            // FormalParameter[Yield,Await]: (modified)
            //      BindingElement[?Yield,Await]
            //
            // BindingElement [Yield,Await]: (modified)
            //      SingleNameBinding[?Yield,?Await]
            //      BindingPattern[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
            //
            // SingleNameBinding [Yield,Await]:
            //      BindingIdentifier[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
            if (!parseExpected(20 /* SyntaxKind.OpenParenToken */)) {
                return createMissingList();
            }
            var parameters = parseParametersWorker(flags, /*allowAmbiguity*/ true);
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return parameters;
        }
        function parseTypeMemberSemicolon() {
            // We allow type members to be separated by commas or (possibly ASI) semicolons.
            // First check if it was a comma.  If so, we're done with the member.
            if (parseOptional(27 /* SyntaxKind.CommaToken */)) {
                return;
            }
            // Didn't have a comma.  We must have a (possible ASI) semicolon.
            parseSemicolon();
        }
        function parseSignatureMember(kind) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            if (kind === 175 /* SyntaxKind.ConstructSignature */) {
                parseExpected(103 /* SyntaxKind.NewKeyword */);
            }
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(4 /* SignatureFlags.Type */);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ true);
            parseTypeMemberSemicolon();
            var node = kind === 174 /* SyntaxKind.CallSignature */
                ? factory.createCallSignature(typeParameters, parameters, type)
                : factory.createConstructSignature(typeParameters, parameters, type);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isIndexSignature() {
            return token() === 22 /* SyntaxKind.OpenBracketToken */ && lookAhead(isUnambiguouslyIndexSignature);
        }
        function isUnambiguouslyIndexSignature() {
            // The only allowed sequence is:
            //
            //   [id:
            //
            // However, for error recovery, we also check the following cases:
            //
            //   [...
            //   [id,
            //   [id?,
            //   [id?:
            //   [id?]
            //   [public id
            //   [private id
            //   [protected id
            //   []
            //
            nextToken();
            if (token() === 25 /* SyntaxKind.DotDotDotToken */ || token() === 23 /* SyntaxKind.CloseBracketToken */) {
                return true;
            }
            if (ts.isModifierKind(token())) {
                nextToken();
                if (isIdentifier()) {
                    return true;
                }
            }
            else if (!isIdentifier()) {
                return false;
            }
            else {
                // Skip the identifier
                nextToken();
            }
            // A colon signifies a well formed indexer
            // A comma should be a badly formed indexer because comma expressions are not allowed
            // in computed properties.
            if (token() === 58 /* SyntaxKind.ColonToken */ || token() === 27 /* SyntaxKind.CommaToken */) {
                return true;
            }
            // Question mark could be an indexer with an optional property,
            // or it could be a conditional expression in a computed property.
            if (token() !== 57 /* SyntaxKind.QuestionToken */) {
                return false;
            }
            // If any of the following tokens are after the question mark, it cannot
            // be a conditional expression, so treat it as an indexer.
            nextToken();
            return token() === 58 /* SyntaxKind.ColonToken */ || token() === 27 /* SyntaxKind.CommaToken */ || token() === 23 /* SyntaxKind.CloseBracketToken */;
        }
        function parseIndexSignatureDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var parameters = parseBracketedList(16 /* ParsingContext.Parameters */, function () { return parseParameter(/*inOuterAwaitContext*/ false); }, 22 /* SyntaxKind.OpenBracketToken */, 23 /* SyntaxKind.CloseBracketToken */);
            var type = parseTypeAnnotation();
            parseTypeMemberSemicolon();
            var node = factory.createIndexSignature(decorators, modifiers, parameters, type);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers) {
            var name = parsePropertyName();
            var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
            var node;
            if (token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */) {
                // Method signatures don't exist in expression contexts.  So they have neither
                // [Yield] nor [Await]
                var typeParameters = parseTypeParameters();
                var parameters = parseParameters(4 /* SignatureFlags.Type */);
                var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ true);
                node = factory.createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type);
            }
            else {
                var type = parseTypeAnnotation();
                node = factory.createPropertySignature(modifiers, name, questionToken, type);
                // Although type literal properties cannot not have initializers, we attempt
                // to parse an initializer so we can report in the checker that an interface
                // property or type literal property cannot have an initializer.
                if (token() === 63 /* SyntaxKind.EqualsToken */)
                    node.initializer = parseInitializer();
            }
            parseTypeMemberSemicolon();
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isTypeMemberStart() {
            // Return true if we have the start of a signature member
            if (token() === 20 /* SyntaxKind.OpenParenToken */ ||
                token() === 29 /* SyntaxKind.LessThanToken */ ||
                token() === 136 /* SyntaxKind.GetKeyword */ ||
                token() === 149 /* SyntaxKind.SetKeyword */) {
                return true;
            }
            var idToken = false;
            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier
            while (ts.isModifierKind(token())) {
                idToken = true;
                nextToken();
            }
            // Index signatures and computed property names are type members
            if (token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return true;
            }
            // Try to get the first property-like token following all modifiers
            if (isLiteralPropertyName()) {
                idToken = true;
                nextToken();
            }
            // If we were able to get any potential identifier, check that it is
            // the start of a member declaration
            if (idToken) {
                return token() === 20 /* SyntaxKind.OpenParenToken */ ||
                    token() === 29 /* SyntaxKind.LessThanToken */ ||
                    token() === 57 /* SyntaxKind.QuestionToken */ ||
                    token() === 58 /* SyntaxKind.ColonToken */ ||
                    token() === 27 /* SyntaxKind.CommaToken */ ||
                    canParseSemicolon();
            }
            return false;
        }
        function parseTypeMember() {
            if (token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */) {
                return parseSignatureMember(174 /* SyntaxKind.CallSignature */);
            }
            if (token() === 103 /* SyntaxKind.NewKeyword */ && lookAhead(nextTokenIsOpenParenOrLessThan)) {
                return parseSignatureMember(175 /* SyntaxKind.ConstructSignature */);
            }
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiers();
            if (parseContextualModifier(136 /* SyntaxKind.GetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, /*decorators*/ undefined, modifiers, 172 /* SyntaxKind.GetAccessor */);
            }
            if (parseContextualModifier(149 /* SyntaxKind.SetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, /*decorators*/ undefined, modifiers, 173 /* SyntaxKind.SetAccessor */);
            }
            if (isIndexSignature()) {
                return parseIndexSignatureDeclaration(pos, hasJSDoc, /*decorators*/ undefined, modifiers);
            }
            return parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers);
        }
        function nextTokenIsOpenParenOrLessThan() {
            nextToken();
            return token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */;
        }
        function nextTokenIsDot() {
            return nextToken() === 24 /* SyntaxKind.DotToken */;
        }
        function nextTokenIsOpenParenOrLessThanOrDot() {
            switch (nextToken()) {
                case 20 /* SyntaxKind.OpenParenToken */:
                case 29 /* SyntaxKind.LessThanToken */:
                case 24 /* SyntaxKind.DotToken */:
                    return true;
            }
            return false;
        }
        function parseTypeLiteral() {
            var pos = getNodePos();
            return finishNode(factory.createTypeLiteralNode(parseObjectTypeMembers()), pos);
        }
        function parseObjectTypeMembers() {
            var members;
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                members = parseList(4 /* ParsingContext.TypeMembers */, parseTypeMember);
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                members = createMissingList();
            }
            return members;
        }
        function isStartOfMappedType() {
            nextToken();
            if (token() === 39 /* SyntaxKind.PlusToken */ || token() === 40 /* SyntaxKind.MinusToken */) {
                return nextToken() === 145 /* SyntaxKind.ReadonlyKeyword */;
            }
            if (token() === 145 /* SyntaxKind.ReadonlyKeyword */) {
                nextToken();
            }
            return token() === 22 /* SyntaxKind.OpenBracketToken */ && nextTokenIsIdentifier() && nextToken() === 101 /* SyntaxKind.InKeyword */;
        }
        function parseMappedTypeParameter() {
            var pos = getNodePos();
            var name = parseIdentifierName();
            parseExpected(101 /* SyntaxKind.InKeyword */);
            var type = parseType();
            return finishNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, name, type, /*defaultType*/ undefined), pos);
        }
        function parseMappedType() {
            var pos = getNodePos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var readonlyToken;
            if (token() === 145 /* SyntaxKind.ReadonlyKeyword */ || token() === 39 /* SyntaxKind.PlusToken */ || token() === 40 /* SyntaxKind.MinusToken */) {
                readonlyToken = parseTokenNode();
                if (readonlyToken.kind !== 145 /* SyntaxKind.ReadonlyKeyword */) {
                    parseExpected(145 /* SyntaxKind.ReadonlyKeyword */);
                }
            }
            parseExpected(22 /* SyntaxKind.OpenBracketToken */);
            var typeParameter = parseMappedTypeParameter();
            var nameType = parseOptional(127 /* SyntaxKind.AsKeyword */) ? parseType() : undefined;
            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
            var questionToken;
            if (token() === 57 /* SyntaxKind.QuestionToken */ || token() === 39 /* SyntaxKind.PlusToken */ || token() === 40 /* SyntaxKind.MinusToken */) {
                questionToken = parseTokenNode();
                if (questionToken.kind !== 57 /* SyntaxKind.QuestionToken */) {
                    parseExpected(57 /* SyntaxKind.QuestionToken */);
                }
            }
            var type = parseTypeAnnotation();
            parseSemicolon();
            var members = parseList(4 /* ParsingContext.TypeMembers */, parseTypeMember);
            parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            return finishNode(factory.createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members), pos);
        }
        function parseTupleElementType() {
            var pos = getNodePos();
            if (parseOptional(25 /* SyntaxKind.DotDotDotToken */)) {
                return finishNode(factory.createRestTypeNode(parseType()), pos);
            }
            var type = parseType();
            if (ts.isJSDocNullableType(type) && type.pos === type.type.pos) {
                var node = factory.createOptionalTypeNode(type.type);
                ts.setTextRange(node, type);
                node.flags = type.flags;
                return node;
            }
            return type;
        }
        function isNextTokenColonOrQuestionColon() {
            return nextToken() === 58 /* SyntaxKind.ColonToken */ || (token() === 57 /* SyntaxKind.QuestionToken */ && nextToken() === 58 /* SyntaxKind.ColonToken */);
        }
        function isTupleElementName() {
            if (token() === 25 /* SyntaxKind.DotDotDotToken */) {
                return ts.tokenIsIdentifierOrKeyword(nextToken()) && isNextTokenColonOrQuestionColon();
            }
            return ts.tokenIsIdentifierOrKeyword(token()) && isNextTokenColonOrQuestionColon();
        }
        function parseTupleElementNameOrTupleElementType() {
            if (lookAhead(isTupleElementName)) {
                var pos = getNodePos();
                var hasJSDoc = hasPrecedingJSDocComment();
                var dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
                var name = parseIdentifierName();
                var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
                parseExpected(58 /* SyntaxKind.ColonToken */);
                var type = parseTupleElementType();
                var node = factory.createNamedTupleMember(dotDotDotToken, name, questionToken, type);
                return withJSDoc(finishNode(node, pos), hasJSDoc);
            }
            return parseTupleElementType();
        }
        function parseTupleType() {
            var pos = getNodePos();
            return finishNode(factory.createTupleTypeNode(parseBracketedList(21 /* ParsingContext.TupleElementTypes */, parseTupleElementNameOrTupleElementType, 22 /* SyntaxKind.OpenBracketToken */, 23 /* SyntaxKind.CloseBracketToken */)), pos);
        }
        function parseParenthesizedType() {
            var pos = getNodePos();
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var type = parseType();
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return finishNode(factory.createParenthesizedType(type), pos);
        }
        function parseModifiersForConstructorType() {
            var modifiers;
            if (token() === 126 /* SyntaxKind.AbstractKeyword */) {
                var pos = getNodePos();
                nextToken();
                var modifier = finishNode(factory.createToken(126 /* SyntaxKind.AbstractKeyword */), pos);
                modifiers = createNodeArray([modifier], pos);
            }
            return modifiers;
        }
        function parseFunctionOrConstructorType() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiersForConstructorType();
            var isConstructorType = parseOptional(103 /* SyntaxKind.NewKeyword */);
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(4 /* SignatureFlags.Type */);
            var type = parseReturnType(38 /* SyntaxKind.EqualsGreaterThanToken */, /*isType*/ false);
            var node = isConstructorType
                ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, type)
                : factory.createFunctionTypeNode(typeParameters, parameters, type);
            if (!isConstructorType)
                node.modifiers = modifiers;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseKeywordAndNoDot() {
            var node = parseTokenNode();
            return token() === 24 /* SyntaxKind.DotToken */ ? undefined : node;
        }
        function parseLiteralTypeNode(negative) {
            var pos = getNodePos();
            if (negative) {
                nextToken();
            }
            var expression = token() === 110 /* SyntaxKind.TrueKeyword */ || token() === 95 /* SyntaxKind.FalseKeyword */ || token() === 104 /* SyntaxKind.NullKeyword */ ?
                parseTokenNode() :
                parseLiteralLikeNode(token());
            if (negative) {
                expression = finishNode(factory.createPrefixUnaryExpression(40 /* SyntaxKind.MinusToken */, expression), pos);
            }
            return finishNode(factory.createLiteralTypeNode(expression), pos);
        }
        function isStartOfTypeOfImportType() {
            nextToken();
            return token() === 100 /* SyntaxKind.ImportKeyword */;
        }
        function parseImportTypeAssertions() {
            var pos = getNodePos();
            var openBracePosition = scanner.getTokenPos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var multiLine = scanner.hasPrecedingLineBreak();
            parseExpected(129 /* SyntaxKind.AssertKeyword */);
            parseExpected(58 /* SyntaxKind.ColonToken */);
            var clause = parseAssertClause(/*skipAssertKeyword*/ true);
            if (!parseExpected(19 /* SyntaxKind.CloseBraceToken */)) {
                var lastError = ts.lastOrUndefined(parseDiagnostics);
                if (lastError && lastError.code === ts.Diagnostics._0_expected.code) {
                    ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openBracePosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                }
            }
            return finishNode(factory.createImportTypeAssertionContainer(clause, multiLine), pos);
        }
        function parseImportType() {
            sourceFlags |= 2097152 /* NodeFlags.PossiblyContainsDynamicImport */;
            var pos = getNodePos();
            var isTypeOf = parseOptional(112 /* SyntaxKind.TypeOfKeyword */);
            parseExpected(100 /* SyntaxKind.ImportKeyword */);
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var type = parseType();
            var assertions;
            if (parseOptional(27 /* SyntaxKind.CommaToken */)) {
                assertions = parseImportTypeAssertions();
            }
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            var qualifier = parseOptional(24 /* SyntaxKind.DotToken */) ? parseEntityNameOfTypeReference() : undefined;
            var typeArguments = parseTypeArgumentsOfTypeReference();
            return finishNode(factory.createImportTypeNode(type, assertions, qualifier, typeArguments, isTypeOf), pos);
        }
        function nextTokenIsNumericOrBigIntLiteral() {
            nextToken();
            return token() === 8 /* SyntaxKind.NumericLiteral */ || token() === 9 /* SyntaxKind.BigIntLiteral */;
        }
        function parseNonArrayType() {
            switch (token()) {
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                    // If these are followed by a dot, then parse these out as a dotted type reference instead.
                    return tryParse(parseKeywordAndNoDot) || parseTypeReference();
                case 66 /* SyntaxKind.AsteriskEqualsToken */:
                    // If there is '*=', treat it as * followed by postfix =
                    scanner.reScanAsteriskEqualsToken();
                // falls through
                case 41 /* SyntaxKind.AsteriskToken */:
                    return parseJSDocAllType();
                case 60 /* SyntaxKind.QuestionQuestionToken */:
                    // If there is '??', treat it as prefix-'?' in JSDoc type.
                    scanner.reScanQuestionToken();
                // falls through
                case 57 /* SyntaxKind.QuestionToken */:
                    return parseJSDocUnknownOrNullableType();
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return parseJSDocFunctionType();
                case 53 /* SyntaxKind.ExclamationToken */:
                    return parseJSDocNonNullableType();
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                    return parseLiteralTypeNode();
                case 40 /* SyntaxKind.MinusToken */:
                    return lookAhead(nextTokenIsNumericOrBigIntLiteral) ? parseLiteralTypeNode(/*negative*/ true) : parseTypeReference();
                case 114 /* SyntaxKind.VoidKeyword */:
                    return parseTokenNode();
                case 108 /* SyntaxKind.ThisKeyword */: {
                    var thisKeyword = parseThisTypeNode();
                    if (token() === 139 /* SyntaxKind.IsKeyword */ && !scanner.hasPrecedingLineBreak()) {
                        return parseThisTypePredicate(thisKeyword);
                    }
                    else {
                        return thisKeyword;
                    }
                }
                case 112 /* SyntaxKind.TypeOfKeyword */:
                    return lookAhead(isStartOfTypeOfImportType) ? parseImportType() : parseTypeQuery();
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return lookAhead(isStartOfMappedType) ? parseMappedType() : parseTypeLiteral();
                case 22 /* SyntaxKind.OpenBracketToken */:
                    return parseTupleType();
                case 20 /* SyntaxKind.OpenParenToken */:
                    return parseParenthesizedType();
                case 100 /* SyntaxKind.ImportKeyword */:
                    return parseImportType();
                case 128 /* SyntaxKind.AssertsKeyword */:
                    return lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine) ? parseAssertsTypePredicate() : parseTypeReference();
                case 15 /* SyntaxKind.TemplateHead */:
                    return parseTemplateType();
                default:
                    return parseTypeReference();
            }
        }
        function isStartOfType(inStartOfParameter) {
            switch (token()) {
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 154 /* SyntaxKind.UniqueKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                case 108 /* SyntaxKind.ThisKeyword */:
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 18 /* SyntaxKind.OpenBraceToken */:
                case 22 /* SyntaxKind.OpenBracketToken */:
                case 29 /* SyntaxKind.LessThanToken */:
                case 51 /* SyntaxKind.BarToken */:
                case 50 /* SyntaxKind.AmpersandToken */:
                case 103 /* SyntaxKind.NewKeyword */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                case 41 /* SyntaxKind.AsteriskToken */:
                case 57 /* SyntaxKind.QuestionToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                case 25 /* SyntaxKind.DotDotDotToken */:
                case 137 /* SyntaxKind.InferKeyword */:
                case 100 /* SyntaxKind.ImportKeyword */:
                case 128 /* SyntaxKind.AssertsKeyword */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 15 /* SyntaxKind.TemplateHead */:
                    return true;
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return !inStartOfParameter;
                case 40 /* SyntaxKind.MinusToken */:
                    return !inStartOfParameter && lookAhead(nextTokenIsNumericOrBigIntLiteral);
                case 20 /* SyntaxKind.OpenParenToken */:
                    // Only consider '(' the start of a type if followed by ')', '...', an identifier, a modifier,
                    // or something that starts a type. We don't want to consider things like '(1)' a type.
                    return !inStartOfParameter && lookAhead(isStartOfParenthesizedOrFunctionType);
                default:
                    return isIdentifier();
            }
        }
        function isStartOfParenthesizedOrFunctionType() {
            nextToken();
            return token() === 21 /* SyntaxKind.CloseParenToken */ || isStartOfParameter(/*isJSDocParameter*/ false) || isStartOfType();
        }
        function parsePostfixTypeOrHigher() {
            var pos = getNodePos();
            var type = parseNonArrayType();
            while (!scanner.hasPrecedingLineBreak()) {
                switch (token()) {
                    case 53 /* SyntaxKind.ExclamationToken */:
                        nextToken();
                        type = finishNode(factory.createJSDocNonNullableType(type, /*postfix*/ true), pos);
                        break;
                    case 57 /* SyntaxKind.QuestionToken */:
                        // If next token is start of a type we have a conditional type
                        if (lookAhead(nextTokenIsStartOfType)) {
                            return type;
                        }
                        nextToken();
                        type = finishNode(factory.createJSDocNullableType(type, /*postfix*/ true), pos);
                        break;
                    case 22 /* SyntaxKind.OpenBracketToken */:
                        parseExpected(22 /* SyntaxKind.OpenBracketToken */);
                        if (isStartOfType()) {
                            var indexType = parseType();
                            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                            type = finishNode(factory.createIndexedAccessTypeNode(type, indexType), pos);
                        }
                        else {
                            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                            type = finishNode(factory.createArrayTypeNode(type), pos);
                        }
                        break;
                    default:
                        return type;
                }
            }
            return type;
        }
        function parseTypeOperator(operator) {
            var pos = getNodePos();
            parseExpected(operator);
            return finishNode(factory.createTypeOperatorNode(operator, parseTypeOperatorOrHigher()), pos);
        }
        function tryParseConstraintOfInferType() {
            if (parseOptional(94 /* SyntaxKind.ExtendsKeyword */)) {
                var constraint = disallowConditionalTypesAnd(parseType);
                if (inDisallowConditionalTypesContext() || token() !== 57 /* SyntaxKind.QuestionToken */) {
                    return constraint;
                }
            }
        }
        function parseTypeParameterOfInferType() {
            var pos = getNodePos();
            var name = parseIdentifier();
            var constraint = tryParse(tryParseConstraintOfInferType);
            var node = factory.createTypeParameterDeclaration(/*modifiers*/ undefined, name, constraint);
            return finishNode(node, pos);
        }
        function parseInferType() {
            var pos = getNodePos();
            parseExpected(137 /* SyntaxKind.InferKeyword */);
            return finishNode(factory.createInferTypeNode(parseTypeParameterOfInferType()), pos);
        }
        function parseTypeOperatorOrHigher() {
            var operator = token();
            switch (operator) {
                case 140 /* SyntaxKind.KeyOfKeyword */:
                case 154 /* SyntaxKind.UniqueKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                    return parseTypeOperator(operator);
                case 137 /* SyntaxKind.InferKeyword */:
                    return parseInferType();
            }
            return allowConditionalTypesAnd(parsePostfixTypeOrHigher);
        }
        function parseFunctionOrConstructorTypeToError(isInUnionType) {
            // the function type and constructor type shorthand notation
            // are not allowed directly in unions and intersections, but we'll
            // try to parse them gracefully and issue a helpful message.
            if (isStartOfFunctionTypeOrConstructorType()) {
                var type = parseFunctionOrConstructorType();
                var diagnostic = void 0;
                if (ts.isFunctionTypeNode(type)) {
                    diagnostic = isInUnionType
                        ? ts.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_a_union_type
                        : ts.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
                }
                else {
                    diagnostic = isInUnionType
                        ? ts.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type
                        : ts.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
                }
                parseErrorAtRange(type, diagnostic);
                return type;
            }
            return undefined;
        }
        function parseUnionOrIntersectionType(operator, parseConstituentType, createTypeNode) {
            var pos = getNodePos();
            var isUnionType = operator === 51 /* SyntaxKind.BarToken */;
            var hasLeadingOperator = parseOptional(operator);
            var type = hasLeadingOperator && parseFunctionOrConstructorTypeToError(isUnionType)
                || parseConstituentType();
            if (token() === operator || hasLeadingOperator) {
                var types = [type];
                while (parseOptional(operator)) {
                    types.push(parseFunctionOrConstructorTypeToError(isUnionType) || parseConstituentType());
                }
                type = finishNode(createTypeNode(createNodeArray(types, pos)), pos);
            }
            return type;
        }
        function parseIntersectionTypeOrHigher() {
            return parseUnionOrIntersectionType(50 /* SyntaxKind.AmpersandToken */, parseTypeOperatorOrHigher, factory.createIntersectionTypeNode);
        }
        function parseUnionTypeOrHigher() {
            return parseUnionOrIntersectionType(51 /* SyntaxKind.BarToken */, parseIntersectionTypeOrHigher, factory.createUnionTypeNode);
        }
        function nextTokenIsNewKeyword() {
            nextToken();
            return token() === 103 /* SyntaxKind.NewKeyword */;
        }
        function isStartOfFunctionTypeOrConstructorType() {
            if (token() === 29 /* SyntaxKind.LessThanToken */) {
                return true;
            }
            if (token() === 20 /* SyntaxKind.OpenParenToken */ && lookAhead(isUnambiguouslyStartOfFunctionType)) {
                return true;
            }
            return token() === 103 /* SyntaxKind.NewKeyword */ ||
                token() === 126 /* SyntaxKind.AbstractKeyword */ && lookAhead(nextTokenIsNewKeyword);
        }
        function skipParameterStart() {
            if (ts.isModifierKind(token())) {
                // Skip modifiers
                parseModifiers();
            }
            if (isIdentifier() || token() === 108 /* SyntaxKind.ThisKeyword */) {
                nextToken();
                return true;
            }
            if (token() === 22 /* SyntaxKind.OpenBracketToken */ || token() === 18 /* SyntaxKind.OpenBraceToken */) {
                // Return true if we can parse an array or object binding pattern with no errors
                var previousErrorCount = parseDiagnostics.length;
                parseIdentifierOrPattern();
                return previousErrorCount === parseDiagnostics.length;
            }
            return false;
        }
        function isUnambiguouslyStartOfFunctionType() {
            nextToken();
            if (token() === 21 /* SyntaxKind.CloseParenToken */ || token() === 25 /* SyntaxKind.DotDotDotToken */) {
                // ( )
                // ( ...
                return true;
            }
            if (skipParameterStart()) {
                // We successfully skipped modifiers (if any) and an identifier or binding pattern,
                // now see if we have something that indicates a parameter declaration
                if (token() === 58 /* SyntaxKind.ColonToken */ || token() === 27 /* SyntaxKind.CommaToken */ ||
                    token() === 57 /* SyntaxKind.QuestionToken */ || token() === 63 /* SyntaxKind.EqualsToken */) {
                    // ( xxx :
                    // ( xxx ,
                    // ( xxx ?
                    // ( xxx =
                    return true;
                }
                if (token() === 21 /* SyntaxKind.CloseParenToken */) {
                    nextToken();
                    if (token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                        // ( xxx ) =>
                        return true;
                    }
                }
            }
            return false;
        }
        function parseTypeOrTypePredicate() {
            var pos = getNodePos();
            var typePredicateVariable = isIdentifier() && tryParse(parseTypePredicatePrefix);
            var type = parseType();
            if (typePredicateVariable) {
                return finishNode(factory.createTypePredicateNode(/*assertsModifier*/ undefined, typePredicateVariable, type), pos);
            }
            else {
                return type;
            }
        }
        function parseTypePredicatePrefix() {
            var id = parseIdentifier();
            if (token() === 139 /* SyntaxKind.IsKeyword */ && !scanner.hasPrecedingLineBreak()) {
                nextToken();
                return id;
            }
        }
        function parseAssertsTypePredicate() {
            var pos = getNodePos();
            var assertsModifier = parseExpectedToken(128 /* SyntaxKind.AssertsKeyword */);
            var parameterName = token() === 108 /* SyntaxKind.ThisKeyword */ ? parseThisTypeNode() : parseIdentifier();
            var type = parseOptional(139 /* SyntaxKind.IsKeyword */) ? parseType() : undefined;
            return finishNode(factory.createTypePredicateNode(assertsModifier, parameterName, type), pos);
        }
        function parseType() {
            if (contextFlags & 40960 /* NodeFlags.TypeExcludesFlags */) {
                return doOutsideOfContext(40960 /* NodeFlags.TypeExcludesFlags */, parseType);
            }
            if (isStartOfFunctionTypeOrConstructorType()) {
                return parseFunctionOrConstructorType();
            }
            var pos = getNodePos();
            var type = parseUnionTypeOrHigher();
            if (!inDisallowConditionalTypesContext() && !scanner.hasPrecedingLineBreak() && parseOptional(94 /* SyntaxKind.ExtendsKeyword */)) {
                // The type following 'extends' is not permitted to be another conditional type
                var extendsType = disallowConditionalTypesAnd(parseType);
                parseExpected(57 /* SyntaxKind.QuestionToken */);
                var trueType = allowConditionalTypesAnd(parseType);
                parseExpected(58 /* SyntaxKind.ColonToken */);
                var falseType = allowConditionalTypesAnd(parseType);
                return finishNode(factory.createConditionalTypeNode(type, extendsType, trueType, falseType), pos);
            }
            return type;
        }
        function parseTypeAnnotation() {
            return parseOptional(58 /* SyntaxKind.ColonToken */) ? parseType() : undefined;
        }
        // EXPRESSIONS
        function isStartOfLeftHandSideExpression() {
            switch (token()) {
                case 108 /* SyntaxKind.ThisKeyword */:
                case 106 /* SyntaxKind.SuperKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 15 /* SyntaxKind.TemplateHead */:
                case 20 /* SyntaxKind.OpenParenToken */:
                case 22 /* SyntaxKind.OpenBracketToken */:
                case 18 /* SyntaxKind.OpenBraceToken */:
                case 98 /* SyntaxKind.FunctionKeyword */:
                case 84 /* SyntaxKind.ClassKeyword */:
                case 103 /* SyntaxKind.NewKeyword */:
                case 43 /* SyntaxKind.SlashToken */:
                case 68 /* SyntaxKind.SlashEqualsToken */:
                case 79 /* SyntaxKind.Identifier */:
                    return true;
                case 100 /* SyntaxKind.ImportKeyword */:
                    return lookAhead(nextTokenIsOpenParenOrLessThanOrDot);
                default:
                    return isIdentifier();
            }
        }
        function isStartOfExpression() {
            if (isStartOfLeftHandSideExpression()) {
                return true;
            }
            switch (token()) {
                case 39 /* SyntaxKind.PlusToken */:
                case 40 /* SyntaxKind.MinusToken */:
                case 54 /* SyntaxKind.TildeToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                case 89 /* SyntaxKind.DeleteKeyword */:
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 45 /* SyntaxKind.PlusPlusToken */:
                case 46 /* SyntaxKind.MinusMinusToken */:
                case 29 /* SyntaxKind.LessThanToken */:
                case 132 /* SyntaxKind.AwaitKeyword */:
                case 125 /* SyntaxKind.YieldKeyword */:
                case 80 /* SyntaxKind.PrivateIdentifier */:
                    // Yield/await always starts an expression.  Either it is an identifier (in which case
                    // it is definitely an expression).  Or it's a keyword (either because we're in
                    // a generator or async function, or in strict mode (or both)) and it started a yield or await expression.
                    return true;
                default:
                    // Error tolerance.  If we see the start of some binary operator, we consider
                    // that the start of an expression.  That way we'll parse out a missing identifier,
                    // give a good message about an identifier being missing, and then consume the
                    // rest of the binary expression.
                    if (isBinaryOperator()) {
                        return true;
                    }
                    return isIdentifier();
            }
        }
        function isStartOfExpressionStatement() {
            // As per the grammar, none of '{' or 'function' or 'class' can start an expression statement.
            return token() !== 18 /* SyntaxKind.OpenBraceToken */ &&
                token() !== 98 /* SyntaxKind.FunctionKeyword */ &&
                token() !== 84 /* SyntaxKind.ClassKeyword */ &&
                token() !== 59 /* SyntaxKind.AtToken */ &&
                isStartOfExpression();
        }
        function parseExpression() {
            // Expression[in]:
            //      AssignmentExpression[in]
            //      Expression[in] , AssignmentExpression[in]
            // clear the decorator context when parsing Expression, as it should be unambiguous when parsing a decorator
            var saveDecoratorContext = inDecoratorContext();
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ false);
            }
            var pos = getNodePos();
            var expr = parseAssignmentExpressionOrHigher();
            var operatorToken;
            while ((operatorToken = parseOptionalToken(27 /* SyntaxKind.CommaToken */))) {
                expr = makeBinaryExpression(expr, operatorToken, parseAssignmentExpressionOrHigher(), pos);
            }
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ true);
            }
            return expr;
        }
        function parseInitializer() {
            return parseOptional(63 /* SyntaxKind.EqualsToken */) ? parseAssignmentExpressionOrHigher() : undefined;
        }
        function parseAssignmentExpressionOrHigher() {
            //  AssignmentExpression[in,yield]:
            //      1) ConditionalExpression[?in,?yield]
            //      2) LeftHandSideExpression = AssignmentExpression[?in,?yield]
            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[?in,?yield]
            //      4) ArrowFunctionExpression[?in,?yield]
            //      5) AsyncArrowFunctionExpression[in,yield,await]
            //      6) [+Yield] YieldExpression[?In]
            //
            // Note: for ease of implementation we treat productions '2' and '3' as the same thing.
            // (i.e. they're both BinaryExpressions with an assignment operator in it).
            // First, do the simple check if we have a YieldExpression (production '6').
            if (isYieldExpression()) {
                return parseYieldExpression();
            }
            // Then, check if we have an arrow function (production '4' and '5') that starts with a parenthesized
            // parameter list or is an async arrow function.
            // AsyncArrowFunctionExpression:
            //      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]
            //      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]
            // Production (1) of AsyncArrowFunctionExpression is parsed in "tryParseAsyncSimpleArrowFunctionExpression".
            // And production (2) is parsed in "tryParseParenthesizedArrowFunctionExpression