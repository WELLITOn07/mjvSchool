tionInitializer(declaration, 0 /* CheckMode.Normal */)], 2 /* UnionReduction.Subtype */));
        }
        function getTypeForDeclarationFromJSDocComment(declaration) {
            var jsdocType = ts.getJSDocType(declaration);
            if (jsdocType) {
                return getTypeFromTypeNode(jsdocType);
            }
            return undefined;
        }
        function isNullOrUndefined(node) {
            var expr = ts.skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
            return expr.kind === 104 /* SyntaxKind.NullKeyword */ || expr.kind === 79 /* SyntaxKind.Identifier */ && getResolvedSymbol(expr) === undefinedSymbol;
        }
        function isEmptyArrayLiteral(node) {
            var expr = ts.skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
            return expr.kind === 204 /* SyntaxKind.ArrayLiteralExpression */ && expr.elements.length === 0;
        }
        function addOptionality(type, isProperty, isOptional) {
            if (isProperty === void 0) { isProperty = false; }
            if (isOptional === void 0) { isOptional = true; }
            return strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type;
        }
        // Return the inferred type for a variable, parameter, or property declaration
        function getTypeForVariableLikeDeclaration(declaration, includeOptionality, checkMode) {
            // A variable declared in a for..in statement is of type string, or of type keyof T when the
            // right hand expression is of a type parameter type.
            if (ts.isVariableDeclaration(declaration) && declaration.parent.parent.kind === 243 /* SyntaxKind.ForInStatement */) {
                var indexType = getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression, /*checkMode*/ checkMode)));
                return indexType.flags & (262144 /* TypeFlags.TypeParameter */ | 4194304 /* TypeFlags.Index */) ? getExtractStringType(indexType) : stringType;
            }
            if (ts.isVariableDeclaration(declaration) && declaration.parent.parent.kind === 244 /* SyntaxKind.ForOfStatement */) {
                // checkRightHandSideOfForOf will return undefined if the for-of expression type was
                // missing properties/signatures required to get its iteratedType (like
                // [Symbol.iterator] or next). This may be because we accessed properties from anyType,
                // or it may have led to an error inside getElementTypeOfIterable.
                var forOfStatement = declaration.parent.parent;
                return checkRightHandSideOfForOf(forOfStatement) || anyType;
            }
            if (ts.isBindingPattern(declaration.parent)) {
                return getTypeForBindingElement(declaration);
            }
            var isProperty = ts.isPropertyDeclaration(declaration) || ts.isPropertySignature(declaration);
            var isOptional = includeOptionality && (isProperty && !!declaration.questionToken ||
                ts.isParameter(declaration) && (!!declaration.questionToken || isJSDocOptionalParameter(declaration)) ||
                isOptionalJSDocPropertyLikeTag(declaration));
            // Use type from type annotation if one is present
            var declaredType = tryGetTypeFromEffectiveTypeNode(declaration);
            if (declaredType) {
                return addOptionality(declaredType, isProperty, isOptional);
            }
            if ((noImplicitAny || ts.isInJSFile(declaration)) &&
                ts.isVariableDeclaration(declaration) && !ts.isBindingPattern(declaration.name) &&
                !(ts.getCombinedModifierFlags(declaration) & 1 /* ModifierFlags.Export */) && !(declaration.flags & 16777216 /* NodeFlags.Ambient */)) {
                // If --noImplicitAny is on or the declaration is in a Javascript file,
                // use control flow tracked 'any' type for non-ambient, non-exported var or let variables with no
                // initializer or a 'null' or 'undefined' initializer.
                if (!(ts.getCombinedNodeFlags(declaration) & 2 /* NodeFlags.Const */) && (!declaration.initializer || isNullOrUndefined(declaration.initializer))) {
                    return autoType;
                }
                // Use control flow tracked 'any[]' type for non-ambient, non-exported variables with an empty array
                // literal initializer.
                if (declaration.initializer && isEmptyArrayLiteral(declaration.initializer)) {
                    return autoArrayType;
                }
            }
            if (ts.isParameter(declaration)) {
                var func = declaration.parent;
                // For a parameter of a set accessor, use the type of the get accessor if one is present
                if (func.kind === 173 /* SyntaxKind.SetAccessor */ && hasBindableName(func)) {
                    var getter = ts.getDeclarationOfKind(getSymbolOfNode(declaration.parent), 172 /* SyntaxKind.GetAccessor */);
                    if (getter) {
                        var getterSignature = getSignatureFromDeclaration(getter);
                        var thisParameter = getAccessorThisParameter(func);
                        if (thisParameter && declaration === thisParameter) {
                            // Use the type from the *getter*
                            ts.Debug.assert(!thisParameter.type);
                            return getTypeOfSymbol(getterSignature.thisParameter);
                        }
                        return getReturnTypeOfSignature(getterSignature);
                    }
                }
                if (ts.isInJSFile(declaration)) {
                    var type_1 = getParameterTypeOfTypeTag(func, declaration);
                    if (type_1)
                        return type_1;
                }
                // Use contextual parameter type if one is available
                var type = declaration.symbol.escapedName === "this" /* InternalSymbolName.This */ ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration);
                if (type) {
                    return addOptionality(type, /*isProperty*/ false, isOptional);
                }
            }
            // Use the type of the initializer expression if one is present and the declaration is
            // not a parameter of a contextually typed function
            if (ts.hasOnlyExpressionInitializer(declaration) && !!declaration.initializer) {
                if (ts.isInJSFile(declaration) && !ts.isParameter(declaration)) {
                    var containerObjectType = getJSContainerObjectType(declaration, getSymbolOfNode(declaration), ts.getDeclaredExpandoInitializer(declaration));
                    if (containerObjectType) {
                        return containerObjectType;
                    }
                }
                var type = widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode));
                return addOptionality(type, isProperty, isOptional);
            }
            if (ts.isPropertyDeclaration(declaration) && (noImplicitAny || ts.isInJSFile(declaration))) {
                // We have a property declaration with no type annotation or initializer, in noImplicitAny mode or a .js file.
                // Use control flow analysis of this.xxx assignments in the constructor or static block to determine the type of the property.
                if (!ts.hasStaticModifier(declaration)) {
                    var constructor = findConstructorDeclaration(declaration.parent);
                    var type = constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :
                        ts.getEffectiveModifierFlags(declaration) & 2 /* ModifierFlags.Ambient */ ? getTypeOfPropertyInBaseClass(declaration.symbol) :
                            undefined;
                    return type && addOptionality(type, /*isProperty*/ true, isOptional);
                }
                else {
                    var staticBlocks = ts.filter(declaration.parent.members, ts.isClassStaticBlockDeclaration);
                    var type = staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :
                        ts.getEffectiveModifierFlags(declaration) & 2 /* ModifierFlags.Ambient */ ? getTypeOfPropertyInBaseClass(declaration.symbol) :
                            undefined;
                    return type && addOptionality(type, /*isProperty*/ true, isOptional);
                }
            }
            if (ts.isJsxAttribute(declaration)) {
                // if JSX attribute doesn't have initializer, by default the attribute will have boolean value of true.
                // I.e <Elem attr /> is sugar for <Elem attr={true} />
                return trueType;
            }
            // If the declaration specifies a binding pattern and is not a parameter of a contextually
            // typed function, use the type implied by the binding pattern
            if (ts.isBindingPattern(declaration.name)) {
                return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ false, /*reportErrors*/ true);
            }
            // No type specified and nothing can be inferred
            return undefined;
        }
        function isConstructorDeclaredProperty(symbol) {
            // A property is considered a constructor declared property when all declaration sites are this.xxx assignments,
            // when no declaration sites have JSDoc type annotations, and when at least one declaration site is in the body of
            // a class constructor.
            if (symbol.valueDeclaration && ts.isBinaryExpression(symbol.valueDeclaration)) {
                var links = getSymbolLinks(symbol);
                if (links.isConstructorDeclaredProperty === undefined) {
                    links.isConstructorDeclaredProperty = false;
                    links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && ts.every(symbol.declarations, function (declaration) {
                        return ts.isBinaryExpression(declaration) &&
                            isPossiblyAliasedThisProperty(declaration) &&
                            (declaration.left.kind !== 207 /* SyntaxKind.ElementAccessExpression */ || ts.isStringOrNumericLiteralLike(declaration.left.argumentExpression)) &&
                            !getAnnotatedTypeForAssignmentDeclaration(/*declaredType*/ undefined, declaration, symbol, declaration);
                    });
                }
                return links.isConstructorDeclaredProperty;
            }
            return false;
        }
        function isAutoTypedProperty(symbol) {
            // A property is auto-typed when its declaration has no type annotation or initializer and we're in
            // noImplicitAny mode or a .js file.
            var declaration = symbol.valueDeclaration;
            return declaration && ts.isPropertyDeclaration(declaration) && !ts.getEffectiveTypeAnnotationNode(declaration) &&
                !declaration.initializer && (noImplicitAny || ts.isInJSFile(declaration));
        }
        function getDeclaringConstructor(symbol) {
            if (!symbol.declarations) {
                return;
            }
            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                var declaration = _a[_i];
                var container = ts.getThisContainer(declaration, /*includeArrowFunctions*/ false);
                if (container && (container.kind === 171 /* SyntaxKind.Constructor */ || isJSConstructor(container))) {
                    return container;
                }
            }
            ;
        }
        /** Create a synthetic property access flow node after the last statement of the file */
        function getFlowTypeFromCommonJSExport(symbol) {
            var file = ts.getSourceFileOfNode(symbol.declarations[0]);
            var accessName = ts.unescapeLeadingUnderscores(symbol.escapedName);
            var areAllModuleExports = symbol.declarations.every(function (d) { return ts.isInJSFile(d) && ts.isAccessExpression(d) && ts.isModuleExportsAccessExpression(d.expression); });
            var reference = areAllModuleExports
                ? ts.factory.createPropertyAccessExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier("module"), ts.factory.createIdentifier("exports")), accessName)
                : ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier("exports"), accessName);
            if (areAllModuleExports) {
                ts.setParent(reference.expression.expression, reference.expression);
            }
            ts.setParent(reference.expression, reference);
            ts.setParent(reference, file);
            reference.flowNode = file.endFlowNode;
            return getFlowTypeOfReference(reference, autoType, undefinedType);
        }
        function getFlowTypeInStaticBlocks(symbol, staticBlocks) {
            var accessName = ts.startsWith(symbol.escapedName, "__#")
                ? ts.factory.createPrivateIdentifier(symbol.escapedName.split("@")[1])
                : ts.unescapeLeadingUnderscores(symbol.escapedName);
            for (var _i = 0, staticBlocks_1 = staticBlocks; _i < staticBlocks_1.length; _i++) {
                var staticBlock = staticBlocks_1[_i];
                var reference = ts.factory.createPropertyAccessExpression(ts.factory.createThis(), accessName);
                ts.setParent(reference.expression, reference);
                ts.setParent(reference, staticBlock);
                reference.flowNode = staticBlock.returnFlowNode;
                var flowType = getFlowTypeOfProperty(reference, symbol);
                if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) {
                    error(symbol.valueDeclaration, ts.Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
                }
                // We don't infer a type if assignments are only null or undefined.
                if (everyType(flowType, isNullableType)) {
                    continue;
                }
                return convertAutoToAny(flowType);
            }
        }
        function getFlowTypeInConstructor(symbol, constructor) {
            var accessName = ts.startsWith(symbol.escapedName, "__#")
                ? ts.factory.createPrivateIdentifier(symbol.escapedName.split("@")[1])
                : ts.unescapeLeadingUnderscores(symbol.escapedName);
            var reference = ts.factory.createPropertyAccessExpression(ts.factory.createThis(), accessName);
            ts.setParent(reference.expression, reference);
            ts.setParent(reference, constructor);
            reference.flowNode = constructor.returnFlowNode;
            var flowType = getFlowTypeOfProperty(reference, symbol);
            if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) {
                error(symbol.valueDeclaration, ts.Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
            }
            // We don't infer a type if assignments are only null or undefined.
            return everyType(flowType, isNullableType) ? undefined : convertAutoToAny(flowType);
        }
        function getFlowTypeOfProperty(reference, prop) {
            var initialType = (prop === null || prop === void 0 ? void 0 : prop.valueDeclaration)
                && (!isAutoTypedProperty(prop) || ts.getEffectiveModifierFlags(prop.valueDeclaration) & 2 /* ModifierFlags.Ambient */)
                && getTypeOfPropertyInBaseClass(prop)
                || undefinedType;
            return getFlowTypeOfReference(reference, autoType, initialType);
        }
        function getWidenedTypeForAssignmentDeclaration(symbol, resolvedSymbol) {
            // function/class/{} initializers are themselves containers, so they won't merge in the same way as other initializers
            var container = ts.getAssignedExpandoInitializer(symbol.valueDeclaration);
            if (container) {
                var tag = ts.getJSDocTypeTag(container);
                if (tag && tag.typeExpression) {
                    return getTypeFromTypeNode(tag.typeExpression);
                }
                var containerObjectType = symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container);
                return containerObjectType || getWidenedLiteralType(checkExpressionCached(container));
            }
            var type;
            var definedInConstructor = false;
            var definedInMethod = false;
            // We use control flow analysis to determine the type of the property if the property qualifies as a constructor
            // declared property and the resulting control flow type isn't just undefined or null.
            if (isConstructorDeclaredProperty(symbol)) {
                type = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol));
            }
            if (!type) {
                var types = void 0;
                if (symbol.declarations) {
                    var jsdocType = void 0;
                    for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                        var declaration = _a[_i];
                        var expression = (ts.isBinaryExpression(declaration) || ts.isCallExpression(declaration)) ? declaration :
                            ts.isAccessExpression(declaration) ? ts.isBinaryExpression(declaration.parent) ? declaration.parent : declaration :
                                undefined;
                        if (!expression) {
                            continue; // Non-assignment declaration merged in (eg, an Identifier to mark the thing as a namespace) - skip over it and pull type info from elsewhere
                        }
                        var kind = ts.isAccessExpression(expression)
                            ? ts.getAssignmentDeclarationPropertyAccessKind(expression)
                            : ts.getAssignmentDeclarationKind(expression);
                        if (kind === 4 /* AssignmentDeclarationKind.ThisProperty */ || ts.isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind)) {
                            if (isDeclarationInConstructor(expression)) {
                                definedInConstructor = true;
                            }
                            else {
                                definedInMethod = true;
                            }
                        }
                        if (!ts.isCallExpression(expression)) {
                            jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration);
                        }
                        if (!jsdocType) {
                            (types || (types = [])).push((ts.isBinaryExpression(expression) || ts.isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType);
                        }
                    }
                    type = jsdocType;
                }
                if (!type) {
                    if (!ts.length(types)) {
                        return errorType; // No types from any declarations :(
                    }
                    var constructorTypes = definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types, symbol.declarations) : undefined;
                    // use only the constructor types unless they were only assigned null | undefined (including widening variants)
                    if (definedInMethod) {
                        var propType = getTypeOfPropertyInBaseClass(symbol);
                        if (propType) {
                            (constructorTypes || (constructorTypes = [])).push(propType);
                            definedInConstructor = true;
                        }
                    }
                    var sourceTypes = ts.some(constructorTypes, function (t) { return !!(t.flags & ~98304 /* TypeFlags.Nullable */); }) ? constructorTypes : types; // TODO: GH#18217
                    type = getUnionType(sourceTypes);
                }
            }
            var widened = getWidenedType(addOptionality(type, /*isProperty*/ false, definedInMethod && !definedInConstructor));
            if (symbol.valueDeclaration && filterType(widened, function (t) { return !!(t.flags & ~98304 /* TypeFlags.Nullable */); }) === neverType) {
                reportImplicitAny(symbol.valueDeclaration, anyType);
                return anyType;
            }
            return widened;
        }
        function getJSContainerObjectType(decl, symbol, init) {
            var _a, _b;
            if (!ts.isInJSFile(decl) || !init || !ts.isObjectLiteralExpression(init) || init.properties.length) {
                return undefined;
            }
            var exports = ts.createSymbolTable();
            while (ts.isBinaryExpression(decl) || ts.isPropertyAccessExpression(decl)) {
                var s_2 = getSymbolOfNode(decl);
                if ((_a = s_2 === null || s_2 === void 0 ? void 0 : s_2.exports) === null || _a === void 0 ? void 0 : _a.size) {
                    mergeSymbolTable(exports, s_2.exports);
                }
                decl = ts.isBinaryExpression(decl) ? decl.parent : decl.parent.parent;
            }
            var s = getSymbolOfNode(decl);
            if ((_b = s === null || s === void 0 ? void 0 : s.exports) === null || _b === void 0 ? void 0 : _b.size) {
                mergeSymbolTable(exports, s.exports);
            }
            var type = createAnonymousType(symbol, exports, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            type.objectFlags |= 4096 /* ObjectFlags.JSLiteral */;
            return type;
        }
        function getAnnotatedTypeForAssignmentDeclaration(declaredType, expression, symbol, declaration) {
            var _a;
            var typeNode = ts.getEffectiveTypeAnnotationNode(expression.parent);
            if (typeNode) {
                var type = getWidenedType(getTypeFromTypeNode(typeNode));
                if (!declaredType) {
                    return type;
                }
                else if (!isErrorType(declaredType) && !isErrorType(type) && !isTypeIdenticalTo(declaredType, type)) {
                    errorNextVariableOrPropertyDeclarationMustHaveSameType(/*firstDeclaration*/ undefined, declaredType, declaration, type);
                }
            }
            if ((_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.valueDeclaration) {
                var typeNode_2 = ts.getEffectiveTypeAnnotationNode(symbol.parent.valueDeclaration);
                if (typeNode_2) {
                    var annotationSymbol = getPropertyOfType(getTypeFromTypeNode(typeNode_2), symbol.escapedName);
                    if (annotationSymbol) {
                        return getNonMissingTypeOfSymbol(annotationSymbol);
                    }
                }
            }
            return declaredType;
        }
        /** If we don't have an explicit JSDoc type, get the type from the initializer. */
        function getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) {
            if (ts.isCallExpression(expression)) {
                if (resolvedSymbol) {
                    return getTypeOfSymbol(resolvedSymbol); // This shouldn't happen except under some hopefully forbidden merges of export assignments and object define assignments
                }
                var objectLitType = checkExpressionCached(expression.arguments[2]);
                var valueType = getTypeOfPropertyOfType(objectLitType, "value");
                if (valueType) {
                    return valueType;
                }
                var getFunc = getTypeOfPropertyOfType(objectLitType, "get");
                if (getFunc) {
                    var getSig = getSingleCallSignature(getFunc);
                    if (getSig) {
                        return getReturnTypeOfSignature(getSig);
                    }
                }
                var setFunc = getTypeOfPropertyOfType(objectLitType, "set");
                if (setFunc) {
                    var setSig = getSingleCallSignature(setFunc);
                    if (setSig) {
                        return getTypeOfFirstParameterOfSignature(setSig);
                    }
                }
                return anyType;
            }
            if (containsSameNamedThisProperty(expression.left, expression.right)) {
                return anyType;
            }
            var isDirectExport = kind === 1 /* AssignmentDeclarationKind.ExportsProperty */ && (ts.isPropertyAccessExpression(expression.left) || ts.isElementAccessExpression(expression.left)) && (ts.isModuleExportsAccessExpression(expression.left.expression) || (ts.isIdentifier(expression.left.expression) && ts.isExportsIdentifier(expression.left.expression)));
            var type = resolvedSymbol ? getTypeOfSymbol(resolvedSymbol)
                : isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right))
                    : getWidenedLiteralType(checkExpressionCached(expression.right));
            if (type.flags & 524288 /* TypeFlags.Object */ &&
                kind === 2 /* AssignmentDeclarationKind.ModuleExports */ &&
                symbol.escapedName === "export=" /* InternalSymbolName.ExportEquals */) {
                var exportedType = resolveStructuredTypeMembers(type);
                var members_4 = ts.createSymbolTable();
                ts.copyEntries(exportedType.members, members_4);
                var initialSize = members_4.size;
                if (resolvedSymbol && !resolvedSymbol.exports) {
                    resolvedSymbol.exports = ts.createSymbolTable();
                }
                (resolvedSymbol || symbol).exports.forEach(function (s, name) {
                    var _a;
                    var exportedMember = members_4.get(name);
                    if (exportedMember && exportedMember !== s) {
                        if (s.flags & 111551 /* SymbolFlags.Value */ && exportedMember.flags & 111551 /* SymbolFlags.Value */) {
                            // If the member has an additional value-like declaration, union the types from the two declarations,
                            // but issue an error if they occurred in two different files. The purpose is to support a JS file with
                            // a pattern like:
                            //
                            // module.exports = { a: true };
                            // module.exports.a = 3;
                            //
                            // but we may have a JS file with `module.exports = { a: true }` along with a TypeScript module augmentation
                            // declaring an `export const a: number`. In that case, we issue a duplicate identifier error, because
                            // it's unclear what that's supposed to mean, so it's probably a mistake.
                            if (s.valueDeclaration && exportedMember.valueDeclaration && ts.getSourceFileOfNode(s.valueDeclaration) !== ts.getSourceFileOfNode(exportedMember.valueDeclaration)) {
                                var unescapedName = ts.unescapeLeadingUnderscores(s.escapedName);
                                var exportedMemberName = ((_a = ts.tryCast(exportedMember.valueDeclaration, ts.isNamedDeclaration)) === null || _a === void 0 ? void 0 : _a.name) || exportedMember.valueDeclaration;
                                ts.addRelatedInfo(error(s.valueDeclaration, ts.Diagnostics.Duplicate_identifier_0, unescapedName), ts.createDiagnosticForNode(exportedMemberName, ts.Diagnostics._0_was_also_declared_here, unescapedName));
                                ts.addRelatedInfo(error(exportedMemberName, ts.Diagnostics.Duplicate_identifier_0, unescapedName), ts.createDiagnosticForNode(s.valueDeclaration, ts.Diagnostics._0_was_also_declared_here, unescapedName));
                            }
                            var union = createSymbol(s.flags | exportedMember.flags, name);
                            union.type = getUnionType([getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)]);
                            union.valueDeclaration = exportedMember.valueDeclaration;
                            union.declarations = ts.concatenate(exportedMember.declarations, s.declarations);
                            members_4.set(name, union);
                        }
                        else {
                            members_4.set(name, mergeSymbol(s, exportedMember));
                        }
                    }
                    else {
                        members_4.set(name, s);
                    }
                });
                var result = createAnonymousType(initialSize !== members_4.size ? undefined : exportedType.symbol, // Only set the type's symbol if it looks to be the same as the original type
                members_4, exportedType.callSignatures, exportedType.constructSignatures, exportedType.indexInfos);
                result.objectFlags |= (ts.getObjectFlags(type) & 4096 /* ObjectFlags.JSLiteral */); // Propagate JSLiteral flag
                if (result.symbol && result.symbol.flags & 32 /* SymbolFlags.Class */ && type === getDeclaredTypeOfClassOrInterface(result.symbol)) {
                    result.objectFlags |= 16777216 /* ObjectFlags.IsClassInstanceClone */; // Propagate the knowledge that this type is equivalent to the symbol's class instance type
                }
                return result;
            }
            if (isEmptyArrayLiteralType(type)) {
                reportImplicitAny(expression, anyArrayType);
                return anyArrayType;
            }
            return type;
        }
        function containsSameNamedThisProperty(thisProperty, expression) {
            return ts.isPropertyAccessExpression(thisProperty)
                && thisProperty.expression.kind === 108 /* SyntaxKind.ThisKeyword */
                && ts.forEachChildRecursively(expression, function (n) { return isMatchingReference(thisProperty, n); });
        }
        function isDeclarationInConstructor(expression) {
            var thisContainer = ts.getThisContainer(expression, /*includeArrowFunctions*/ false);
            // Properties defined in a constructor (or base constructor, or javascript constructor function) don't get undefined added.
            // Function expressions that are assigned to the prototype count as methods.
            return thisContainer.kind === 171 /* SyntaxKind.Constructor */ ||
                thisContainer.kind === 256 /* SyntaxKind.FunctionDeclaration */ ||
                (thisContainer.kind === 213 /* SyntaxKind.FunctionExpression */ && !ts.isPrototypePropertyAssignment(thisContainer.parent));
        }
        function getConstructorDefinedThisAssignmentTypes(types, declarations) {
            ts.Debug.assert(types.length === declarations.length);
            return types.filter(function (_, i) {
                var declaration = declarations[i];
                var expression = ts.isBinaryExpression(declaration) ? declaration :
                    ts.isBinaryExpression(declaration.parent) ? declaration.parent : undefined;
                return expression && isDeclarationInConstructor(expression);
            });
        }
        // Return the type implied by a binding pattern element. This is the type of the initializer of the element if
        // one is present. Otherwise, if the element is itself a binding pattern, it is the type implied by the binding
        // pattern. Otherwise, it is the type any.
        function getTypeFromBindingElement(element, includePatternInType, reportErrors) {
            if (element.initializer) {
                // The type implied by a binding pattern is independent of context, so we check the initializer with no
                // contextual type or, if the element itself is a binding pattern, with the type implied by that binding
                // pattern.
                var contextualType = ts.isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, /*includePatternInType*/ true, /*reportErrors*/ false) : unknownType;
                return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, 0 /* CheckMode.Normal */, contextualType)));
            }
            if (ts.isBindingPattern(element.name)) {
                return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors);
            }
            if (reportErrors && !declarationBelongsToPrivateAmbientMember(element)) {
                reportImplicitAny(element, anyType);
            }
            // When we're including the pattern in the type (an indication we're obtaining a contextual type), we
            // use the non-inferrable any type. Inference will never directly infer this type, but it is possible
            // to infer a type that contains it, e.g. for a binding pattern like [foo] or { foo }. In such cases,
            // widening of the binding pattern type substitutes a regular any for the non-inferrable any.
            return includePatternInType ? nonInferrableAnyType : anyType;
        }
        // Return the type implied by an object binding pattern
        function getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors) {
            var members = ts.createSymbolTable();
            var stringIndexInfo;
            var objectFlags = 128 /* ObjectFlags.ObjectLiteral */ | 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
            ts.forEach(pattern.elements, function (e) {
                var name = e.propertyName || e.name;
                if (e.dotDotDotToken) {
                    stringIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly*/ false);
                    return;
                }
                var exprType = getLiteralTypeFromPropertyName(name);
                if (!isTypeUsableAsPropertyName(exprType)) {
                    // do not include computed properties in the implied type
                    objectFlags |= 512 /* ObjectFlags.ObjectLiteralPatternWithComputedProperties */;
                    return;
                }
                var text = getPropertyNameFromType(exprType);
                var flags = 4 /* SymbolFlags.Property */ | (e.initializer ? 16777216 /* SymbolFlags.Optional */ : 0);
                var symbol = createSymbol(flags, text);
                symbol.type = getTypeFromBindingElement(e, includePatternInType, reportErrors);
                symbol.bindingElement = e;
                members.set(symbol.escapedName, symbol);
            });
            var result = createAnonymousType(undefined, members, ts.emptyArray, ts.emptyArray, stringIndexInfo ? [stringIndexInfo] : ts.emptyArray);
            result.objectFlags |= objectFlags;
            if (includePatternInType) {
                result.pattern = pattern;
                result.objectFlags |= 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
            }
            return result;
        }
        // Return the type implied by an array binding pattern
        function getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors) {
            var elements = pattern.elements;
            var lastElement = ts.lastOrUndefined(elements);
            var restElement = lastElement && lastElement.kind === 203 /* SyntaxKind.BindingElement */ && lastElement.dotDotDotToken ? lastElement : undefined;
            if (elements.length === 0 || elements.length === 1 && restElement) {
                return languageVersion >= 2 /* ScriptTarget.ES2015 */ ? createIterableType(anyType) : anyArrayType;
            }
            var elementTypes = ts.map(elements, function (e) { return ts.isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors); });
            var minLength = ts.findLastIndex(elements, function (e) { return !(e === restElement || ts.isOmittedExpression(e) || hasDefaultValue(e)); }, elements.length - 1) + 1;
            var elementFlags = ts.map(elements, function (e, i) { return e === restElement ? 4 /* ElementFlags.Rest */ : i >= minLength ? 2 /* ElementFlags.Optional */ : 1 /* ElementFlags.Required */; });
            var result = createTupleType(elementTypes, elementFlags);
            if (includePatternInType) {
                result = cloneTypeReference(result);
                result.pattern = pattern;
                result.objectFlags |= 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
            }
            return result;
        }
        // Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself
        // and without regard to its context (i.e. without regard any type annotation or initializer associated with the
        // declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any]
        // and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is
        // used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring
        // parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of
        // the parameter.
        function getTypeFromBindingPattern(pattern, includePatternInType, reportErrors) {
            if (includePatternInType === void 0) { includePatternInType = false; }
            if (reportErrors === void 0) { reportErrors = false; }
            return pattern.kind === 201 /* SyntaxKind.ObjectBindingPattern */
                ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)
                : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors);
        }
        // Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
        // specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
        // is a bit more involved. For example:
        //
        //   var [x, s = ""] = [1, "one"];
        //
        // Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
        // binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
        // tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
        function getWidenedTypeForVariableLikeDeclaration(declaration, reportErrors) {
            return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ true, 0 /* CheckMode.Normal */), declaration, reportErrors);
        }
        function isGlobalSymbolConstructor(node) {
            var symbol = getSymbolOfNode(node);
            var globalSymbol = getGlobalESSymbolConstructorTypeSymbol(/*reportErrors*/ false);
            return globalSymbol && symbol && symbol === globalSymbol;
        }
        function widenTypeForVariableLikeDeclaration(type, declaration, reportErrors) {
            if (type) {
                // TODO: If back compat with pre-3.0/4.0 libs isn't required, remove the following SymbolConstructor special case transforming `symbol` into `unique symbol`
                if (type.flags & 4096 /* TypeFlags.ESSymbol */ && isGlobalSymbolConstructor(declaration.parent)) {
                    type = getESSymbolLikeTypeForNode(declaration);
                }
                if (reportErrors) {
                    reportErrorsFromWidening(declaration, type);
                }
                // always widen a 'unique symbol' type if the type was created for a different declaration.
                if (type.flags & 8192 /* TypeFlags.UniqueESSymbol */ && (ts.isBindingElement(declaration) || !declaration.type) && type.symbol !== getSymbolOfNode(declaration)) {
                    type = esSymbolType;
                }
                return getWidenedType(type);
            }
            // Rest parameters default to type any[], other parameters default to type any
            type = ts.isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType;
            // Report implicit any errors unless this is a private property within an ambient declaration
            if (reportErrors) {
                if (!declarationBelongsToPrivateAmbientMember(declaration)) {
                    reportImplicitAny(declaration, type);
                }
            }
            return type;
        }
        function declarationBelongsToPrivateAmbientMember(declaration) {
            var root = ts.getRootDeclaration(declaration);
            var memberDeclaration = root.kind === 164 /* SyntaxKind.Parameter */ ? root.parent : root;
            return isPrivateWithinAmbient(memberDeclaration);
        }
        function tryGetTypeFromEffectiveTypeNode(node) {
            var typeNode = ts.getEffectiveTypeAnnotationNode(node);
            if (typeNode) {
                return getTypeFromTypeNode(typeNode);
            }
        }
        function getTypeOfVariableOrParameterOrProperty(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                var type = getTypeOfVariableOrParameterOrPropertyWorker(symbol);
                // For a contextually typed parameter it is possible that a type has already
                // been assigned (in assignTypeToParameterAndFixTypeParameters), and we want
                // to preserve this type.
                if (!links.type) {
                    links.type = type;
                }
            }
            return links.type;
        }
        function getTypeOfVariableOrParameterOrPropertyWorker(symbol) {
            // Handle prototype property
            if (symbol.flags & 4194304 /* SymbolFlags.Prototype */) {
                return getTypeOfPrototypeProperty(symbol);
            }
            // CommonsJS require and module both have type any.
            if (symbol === requireSymbol) {
                return anyType;
            }
            if (symbol.flags & 134217728 /* SymbolFlags.ModuleExports */ && symbol.valueDeclaration) {
                var fileSymbol = getSymbolOfNode(ts.getSourceFileOfNode(symbol.valueDeclaration));
                var result = createSymbol(fileSymbol.flags, "exports");
                result.declarations = fileSymbol.declarations ? fileSymbol.declarations.slice() : [];
                result.parent = symbol;
                result.target = fileSymbol;
                if (fileSymbol.valueDeclaration)
                    result.valueDeclaration = fileSymbol.valueDeclaration;
                if (fileSymbol.members)
                    result.members = new ts.Map(fileSymbol.members);
                if (fileSymbol.exports)
                    result.exports = new ts.Map(fileSymbol.exports);
                var members = ts.createSymbolTable();
                members.set("exports", result);
                return createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            }
            // Handle catch clause variables
            ts.Debug.assertIsDefined(symbol.valueDeclaration);
            var declaration = symbol.valueDeclaration;
            if (ts.isCatchClauseVariableDeclarationOrBindingElement(declaration)) {
                var typeNode = ts.getEffectiveTypeAnnotationNode(declaration);
                if (typeNode === undefined) {
                    return useUnknownInCatchVariables ? unknownType : anyType;
                }
                var type_2 = getTypeOfNode(typeNode);
                // an errorType will make `checkTryStatement` issue an error
                return isTypeAny(type_2) || type_2 === unknownType ? type_2 : errorType;
            }
            // Handle export default expressions
            if (ts.isSourceFile(declaration) && ts.isJsonSourceFile(declaration)) {
                if (!declaration.statements.length) {
                    return emptyObjectType;
                }
                return getWidenedType(getWidenedLiteralType(checkExpression(declaration.statements[0].expression)));
            }
            if (ts.isAccessor(declaration)) {
                // Binding of certain patterns in JS code will occasionally mark symbols as both properties
                // and accessors. Here we dispatch to accessor resolution if needed.
                return getTypeOfAccessors(symbol);
            }
            // Handle variable, parameter or property
            if (!pushTypeResolution(symbol, 0 /* TypeSystemPropertyName.Type */)) {
                // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
                if (symbol.flags & 512 /* SymbolFlags.ValueModule */ && !(symbol.flags & 67108864 /* SymbolFlags.Assignment */)) {
                    return getTypeOfFuncClassEnumModule(symbol);
                }
                return reportCircularityError(symbol);
            }
            var type;
            if (declaration.kind === 271 /* SyntaxKind.ExportAssignment */) {
                type = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached(declaration.expression), declaration);
            }
            else if (ts.isBinaryExpression(declaration) ||
                (ts.isInJSFile(declaration) &&
                    (ts.isCallExpression(declaration) || (ts.isPropertyAccessExpression(declaration) || ts.isBindableStaticElementAccessExpression(declaration)) && ts.isBinaryExpression(declaration.parent)))) {
                type = getWidenedTypeForAssignmentDeclaration(symbol);
            }
            else if (ts.isPropertyAccessExpression(declaration)
                || ts.isElementAccessExpression(declaration)
                || ts.isIdentifier(declaration)
                || ts.isStringLiteralLike(declaration)
                || ts.isNumericLiteral(declaration)
                || ts.isClassDeclaration(declaration)
                || ts.isFunctionDeclaration(declaration)
                || (ts.isMethodDeclaration(declaration) && !ts.isObjectLiteralMethod(declaration))
                || ts.isMethodSignature(declaration)
                || ts.isSourceFile(declaration)) {
                // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
                if (symbol.flags & (16 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Method */ | 32 /* SymbolFlags.Class */ | 384 /* SymbolFlags.Enum */ | 512 /* SymbolFlags.ValueModule */)) {
                    return getTypeOfFuncClassEnumModule(symbol);
                }
                type = ts.isBinaryExpression(declaration.parent) ?
                    getWidenedTypeForAssignmentDeclaration(symbol) :
                    tryGetTypeFromEffectiveTypeNode(declaration) || anyType;
            }
            else if (ts.isPropertyAssignment(declaration)) {
                type = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration);
            }
            else if (ts.isJsxAttribute(declaration)) {
                type = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration);
            }
            else if (ts.isShorthandPropertyAssignment(declaration)) {
                type = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, 0 /* CheckMode.Normal */);
            }
            else if (ts.isObjectLiteralMethod(declaration)) {
                type = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, 0 /* CheckMode.Normal */);
            }
            else if (ts.isParameter(declaration)
                || ts.isPropertyDeclaration(declaration)
                || ts.isPropertySignature(declaration)
                || ts.isVariableDeclaration(declaration)
                || ts.isBindingElement(declaration)
                || ts.isJSDocPropertyLikeTag(declaration)) {
                type = getWidenedTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ true);
            }
            // getTypeOfSymbol dispatches some JS merges incorrectly because their symbol flags are not mutually exclusive.
            // Re-dispatch based on valueDeclaration.kind instead.
            else if (ts.isEnumDeclaration(declaration)) {
                type = getTypeOfFuncClassEnumModule(symbol);
            }
            else if (ts.isEnumMember(declaration)) {
                type = getTypeOfEnumMember(symbol);
            }
            else {
                return ts.Debug.fail("Unhandled declaration kind! " + ts.Debug.formatSyntaxKind(declaration.kind) + " for " + ts.Debug.formatSymbol(symbol));
            }
            if (!popTypeResolution()) {
                // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
                if (symbol.flags & 512 /* SymbolFlags.ValueModule */ && !(symbol.flags & 67108864 /* SymbolFlags.Assignment */)) {
                    return getTypeOfFuncClassEnumModule(symbol);
                }
                return reportCircularityError(symbol);
            }
            return type;
        }
        function getAnnotatedAccessorTypeNode(accessor) {
            if (accessor) {
                if (accessor.kind === 172 /* SyntaxKind.GetAccessor */) {
                    var getterTypeAnnotation = ts.getEffectiveReturnTypeNode(accessor);
                    return getterTypeAnnotation;
                }
                else {
                    var setterTypeAnnotation = ts.getEffectiveSetAccessorTypeAnnotationNode(accessor);
                    return setterTypeAnnotation;
                }
            }
            return undefined;
        }
        function getAnnotatedAccessorType(accessor) {
            var node = getAnnotatedAccessorTypeNode(accessor);
            return node && getTypeFromTypeNode(node);
        }
        function getAnnotatedAccessorThisParameter(accessor) {
            var parameter = getAccessorThisParameter(accessor);
            return parameter && parameter.symbol;
        }
        function getThisTypeOfDeclaration(declaration) {
            return getThisTypeOfSignature(getSignatureFromDeclaration(declaration));
        }
        function getTypeOfAccessors(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                if (!pushTypeResolution(symbol, 0 /* TypeSystemPropertyName.Type */)) {
                    return errorType;
                }
                var getter = ts.getDeclarationOfKind(symbol, 172 /* SyntaxKind.GetAccessor */);
                var setter = ts.getDeclarationOfKind(symbol, 173 /* SyntaxKind.SetAccessor */);
                // We try to resolve a getter type annotation, a setter type annotation, or a getter function
                // body return type inference, in that order.
                var type = getter && ts.isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) ||
                    getAnnotatedAccessorType(getter) ||
                    getAnnotatedAccessorType(setter) ||
                    getter && getter.body && getReturnTypeFromBody(getter);
                if (!type) {
                    if (setter && !isPrivateWithinAmbient(setter)) {
                        errorOrSuggestion(noImplicitAny, setter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol));
                    }
                    else if (getter && !isPrivateWithinAmbient(getter)) {
                        errorOrSuggestion(noImplicitAny, getter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol));
                    }
                    type = anyType;
                }
                if (!popTypeResolution()) {
                    if (getAnnotatedAccessorTypeNode(getter)) {
                        error(getter, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                    }
                    else if (getAnnotatedAccessorTypeNode(setter)) {
                        error(setter, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                    }
                    else if (getter && noImplicitAny) {
                        error(getter, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol));
                    }
                    type = anyType;
                }
                links.type = type;
            }
            return links.type;
        }
        function getWriteTypeOfAccessors(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.writeType) {
                if (!pushTypeResolution(symbol, 8 /* TypeSystemPropertyName.WriteType */)) {
                    return errorType;
                }
                var setter = ts.getDeclarationOfKind(symbol, 173 /* SyntaxKind.SetAccessor */);
                var writeType = getAnnotatedAccessorType(setter);
                if (!popTypeResolution()) {
                    if (getAnnotatedAccessorTypeNode(setter)) {
                        error(setter, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                    }
                    writeType = anyType;
                }
                // Absent an explicit setter type annotation we use the read type of the accessor.
                links.writeType = writeType || getTypeOfAccessors(symbol);
            }
            return links.writeType;
        }
        function getBaseTypeVariableOfClass(symbol) {
            var baseConstructorType = getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol));
            return baseConstructorType.flags & 8650752 /* TypeFlags.TypeVariable */ ? baseConstructorType :
                baseConstructorType.flags & 2097152 /* TypeFlags.Intersection */ ? ts.find(baseConstructorType.types, function (t) { return !!(t.flags & 8650752 /* TypeFlags.TypeVariable */); }) :
                    undefined;
        }
        function getTypeOfFuncClassEnumModule(symbol) {
            var links = getSymbolLinks(symbol);
            var originalLinks = links;
            if (!links.type) {
                var expando = symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration, /*allowDeclaration*/ false);
                if (expando) {
                    var merged = mergeJSSymbols(symbol, expando);
                    if (merged) {
                        // note:we overwrite links because we just cloned the symbol
                        symbol = links = merged;
                    }
                }
                originalLinks.type = links.type = getTypeOfFuncClassEnumModuleWorker(symbol);
            }
            return links.type;
        }
        function getTypeOfFuncClassEnumModuleWorker(symbol) {
            var declaration = symbol.valueDeclaration;
            if (symbol.flags & 1536 /* SymbolFlags.Module */ && ts.isShorthandAmbientModuleSymbol(symbol)) {
                return anyType;
            }
            else if (declaration && (declaration.kind === 221 /* SyntaxKind.BinaryExpression */ ||
                ts.isAccessExpression(declaration) &&
                    declaration.parent.kind === 221 /* SyntaxKind.BinaryExpression */)) {
                return getWidenedTypeForAssignmentDeclaration(symbol);
            }
            else if (symbol.flags & 512 /* SymbolFlags.ValueModule */ && declaration && ts.isSourceFile(declaration) && declaration.commonJsModuleIndicator) {
                var resolvedModule = resolveExternalModuleSymbol(symbol);
                if (resolvedModule !== symbol) {
                    if (!pushTypeResolution(symbol, 0 /* TypeSystemPropertyName.Type */)) {
                        return errorType;
                    }
                    var exportEquals = getMergedSymbol(symbol.exports.get("export=" /* InternalSymbolName.ExportEquals */));
                    var type_3 = getWidenedTypeForAssignmentDeclaration(exportEquals, exportEquals === resolvedModule ? undefined : resolvedModule);
                    if (!popTypeResolution()) {
                        return reportCircularityError(symbol);
                    }
                    return type_3;
                }
            }
            var type = createObjectType(16 /* ObjectFlags.Anonymous */, symbol);
            if (symbol.flags & 32 /* SymbolFlags.Class */) {
                var baseTypeVariable = getBaseTypeVariableOfClass(symbol);
                return baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type;
            }
            else {
                return strictNullChecks && symbol.flags & 16777216 /* SymbolFlags.Optional */ ? getOptionalType(type) : type;
            }
        }
        function getTypeOfEnumMember(symbol) {
            var links = getSymbolLinks(symbol);
            return links.type || (links.type = getDeclaredTypeOfEnumMember(symbol));
        }
        function getTypeOfAlias(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                var targetSymbol = resolveAlias(symbol);
                var exportSymbol = symbol.declarations && getTargetOfAliasDeclaration(getDeclarationOfAliasSymbol(symbol), /*dontResolveAlias*/ true);
                var declaredType = ts.firstDefined(exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.declarations, function (d) { return ts.isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : undefined; });
                // It only makes sense to get the type of a value symbol. If the result of resolving
                // the alias is not a value, then it has no type. To get the type associated with a
                // type symbol, call getDeclaredTypeOfSymbol.
                // This check is important because without it, a call to getTypeOfSymbol could end
                // up recursively calling getTypeOfAlias, causing a stack overflow.
                links.type = (exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.declarations) && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations.length ? getFlowTypeFromCommonJSExport(exportSymbol)
                    : isDuplicatedCommonJSExport(symbol.declarations) ? autoType
                        : declaredType ? declaredType
                            : targetSymbol.flags & 111551 /* SymbolFlags.Value */ ? getTypeOfSymbol(targetSymbol)
                                : errorType;
            }
            return links.type;
        }
        function getTypeOfInstantiatedSymbol(symbol) {
            var links = getSymbolLinks(symbol);
            return links.type || (links.type = instantiateType(getTypeOfSymbol(links.target), links.mapper));
        }
        function getWriteTypeOfInstantiatedSymbol(symbol) {
            var links = getSymbolLinks(symbol);
            return links.writeType || (links.writeType = instantiateType(getWriteTypeOfSymbol(links.target), links.mapper));
        }
        function reportCircularityError(symbol) {
            var declaration = symbol.valueDeclaration;
            // Check if variable has type annotation that circularly references the variable itself
            if (ts.getEffectiveTypeAnnotationNode(declaration)) {
                error(symbol.valueDeclaration, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                return errorType;
            }
            // Check if variable has initializer that circularly references the variable itself
            if (noImplicitAny && (declaration.kind !== 164 /* SyntaxKind.Parameter */ || declaration.initializer)) {
                error(symbol.valueDeclaration, ts.Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol));
            }
            // Circularities could also result from parameters in function expressions that end up
            // having themselves as contextual types following type argument inference. In those cases
            // we have already reported an implicit any error so we don't report anything here.
            return anyType;
        }
        function getTypeOfSymbolWithDeferredType(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                ts.Debug.assertIsDefined(links.deferralParent);
                ts.Debug.assertIsDefined(links.deferralConstituents);
                links.type = links.deferralParent.flags & 1048576 /* TypeFlags.Union */ ? getUnionType(links.deferralConstituents) : getIntersectionType(links.deferralConstituents);
            }
            return links.type;
        }
        function getWriteTypeOfSymbolWithDeferredType(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.writeType && links.deferralWriteConstituents) {
                ts.Debug.assertIsDefined(links.deferralParent);
                ts.Debug.assertIsDefined(links.deferralConstituents);
                links.writeType = links.deferralParent.flags & 1048576 /* TypeFlags.Union */ ? getUnionType(links.deferralWriteConstituents) : getIntersectionType(links.deferralWriteConstituents);
            }
            return links.writeType;
        }
        /**
         * Distinct write types come only from set accessors, but synthetic union and intersection
         * properties deriving from set accessors will either pre-compute or defer the union or
         * intersection of the writeTypes of their constituents.
         */
        function getWriteTypeOfSymbol(symbol) {
            var checkFlags = ts.getCheckFlags(symbol);
            if (symbol.flags & 4 /* SymbolFlags.Property */) {
                return checkFlags & 2 /* CheckFlags.SyntheticProperty */ ?
                    checkFlags & 65536 /* CheckFlags.DeferredType */ ?
                        getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol) :
                        symbol.writeType || symbol.type :
                    getTypeOfSymbol(symbol);
            }
            if (symbol.flags & 98304 /* SymbolFlags.Accessor */) {
                return checkFlags & 1 /* CheckFlags.Instantiated */ ?
                    getWriteTypeOfInstantiatedSymbol(symbol) :
                    getWriteTypeOfAccessors(symbol);
            }
            return getTypeOfSymbol(symbol);
        }
        function getTypeOfSymbol(symbol) {
            var checkFlags = ts.getCheckFlags(symbol);
            if (checkFlags & 65536 /* CheckFlags.DeferredType */) {
                return getTypeOfSymbolWithDeferredType(symbol);
            }
            if (checkFlags & 1 /* CheckFlags.Instantiated */) {
                return getTypeOfInstantiatedSymbol(symbol);
            }
            if (checkFlags & 262144 /* CheckFlags.Mapped */) {
                return getTypeOfMappedSymbol(symbol);
            }
            if (checkFlags & 8192 /* CheckFlags.ReverseMapped */) {
                return getTypeOfReverseMappedSymbol(symbol);
            }
            if (symbol.flags & (3 /* SymbolFlags.Variable */ | 4 /* SymbolFlags.Property */)) {
                return getTypeOfVariableOrParameterOrProperty(symbol);
            }
            if (symbol.flags & (16 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Method */ | 32 /* SymbolFlags.Class */ | 384 /* SymbolFlags.Enum */ | 512 /* SymbolFlags.ValueModule */)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            if (symbol.flags & 8 /* SymbolFlags.EnumMember */) {
                return getTypeOfEnumMember(symbol);
            }
            if (symbol.flags & 98304 /* SymbolFlags.Accessor */) {
                return getTypeOfAccessors(symbol);
            }
            if (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
                return getTypeOfAlias(symbol);
            }
            return errorType;
        }
        function getNonMissingTypeOfSymbol(symbol) {
            return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & 16777216 /* SymbolFlags.Optional */));
        }
        function isReferenceToType(type, target) {
            return type !== undefined
                && target !== undefined
                && (ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) !== 0
                && type.target === target;
        }
        function getTargetType(type) {
            return ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */ ? type.target : type;
        }
        // TODO: GH#18217 If `checkBase` is undefined, we should not call this because this will always return false.
        function hasBaseType(type, checkBase) {
            return check(type);
            function check(type) {
                if (ts.getObjectFlags(type) & (3 /* ObjectFlags.ClassOrInterface */ | 4 /* ObjectFlags.Reference */)) {
                    var target = getTargetType(type);
                    return target === checkBase || ts.some(getBaseTypes(target), check);
                }
                else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                    return ts.some(type.types, check);
                }
                return false;
            }
        }
        // Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
        // The function allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set
        // in-place and returns the same array.
        function appendTypeParameters(typeParameters, declarations) {
            for (var _i = 0, declarations_2 = declarations; _i < declarations_2.length; _i++) {
                var declaration = declarations_2[_i];
                typeParameters = ts.appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfNode(declaration)));
            }
            return typeParameters;
        }
        // Return the outer type parameters of a node or undefined if the node has no outer type parameters.
        function getOuterTypeParameters(node, includeThisTypes) {
            while (true) {
                node = node.parent; // TODO: GH#18217 Use SourceFile kind check instead
                if (node && ts.isBinaryExpression(node)) {
                    // prototype assignments get the outer type parameters of their constructor function
                    var assignmentKind = ts.getAssignmentDeclarationKind(node);
                    if (assignmentKind === 6 /* AssignmentDeclarationKind.Prototype */ || assignmentKind === 3 /* AssignmentDeclarationKind.PrototypeProperty */) {
                        var symbol = getSymbolOfNode(node.left);
                        if (symbol && symbol.parent && !ts.findAncestor(symbol.parent.valueDeclaration, function (d) { return node === d; })) {
                            node = symbol.parent.valueDeclaration;
                        }
                    }
                }
                if (!node) {
                    return undefined;
                }
                switch (node.kind) {
                    case 257 /* SyntaxKind.ClassDeclaration */:
                    case 226 /* SyntaxKind.ClassExpression */:
                    case 258 /* SyntaxKind.InterfaceDeclaration */:
                    case 174 /* SyntaxKind.CallSignature */:
                    case 175 /* SyntaxKind.ConstructSignature */:
                    case 168 /* SyntaxKind.MethodSignature */:
                    case 179 /* SyntaxKind.FunctionType */:
                    case 180 /* SyntaxKind.ConstructorType */:
                    case 317 /* SyntaxKind.JSDocFunctionType */:
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 213 /* SyntaxKind.FunctionExpression */:
                    case 214 /* SyntaxKind.ArrowFunction */:
                    case 259 /* SyntaxKind.TypeAliasDeclaration */:
                    case 344 /* SyntaxKind.JSDocTemplateTag */:
                    case 345 /* SyntaxKind.JSDocTypedefTag */:
                    case 339 /* SyntaxKind.JSDocEnumTag */:
                    case 338 /* SyntaxKind.JSDocCallbackTag */:
                    case 195 /* SyntaxKind.MappedType */:
                    case 189 /* SyntaxKind.ConditionalType */: {
                        var outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                        if (node.kind === 195 /* SyntaxKind.MappedType */) {
                            return ts.append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfNode(node.typeParameter)));
                        }
                        else if (node.kind === 189 /* SyntaxKind.ConditionalType */) {
                            return ts.concatenate(outerTypeParameters, getInferTypeParameters(node));
                        }
                        var outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, ts.getEffectiveTypeParameterDeclarations(node));
                        var thisType = includeThisTypes &&
                            (node.kind === 257 /* SyntaxKind.ClassDeclaration */ || node.kind === 226 /* SyntaxKind.ClassExpression */ || node.kind === 258 /* SyntaxKind.InterfaceDeclaration */ || isJSConstructor(node)) &&
                            getDeclaredTypeOfClassOrInterface(getSymbolOfNode(node)).thisType;
                        return thisType ? ts.append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;
                    }
                    case 340 /* SyntaxKind.JSDocParameterTag */:
                        var paramSymbol = ts.getParameterSymbolFromJSDoc(node);
                        if (paramSymbol) {
                            node = paramSymbol.valueDeclaration;
                        }
                        break;
                    case 320 /* SyntaxKind.JSDoc */: {
                        var outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                        return node.tags
                            ? appendTypeParameters(outerTypeParameters, ts.flatMap(node.tags, function (t) { return ts.isJSDocTemplateTag(t) ? t.typeParameters : undefined; }))
                            : outerTypeParameters;
                    }
                }
            }
        }
        // The outer type parameters are those defined by enclosing generic classes, methods, or functions.
        function getOuterTypeParametersOfClassOrInterface(symbol) {
            var declaration = symbol.flags & 32 /* SymbolFlags.Class */ ? symbol.valueDeclaration : ts.getDeclarationOfKind(symbol, 258 /* SyntaxKind.InterfaceDeclaration */);
            ts.Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations");
            return getOuterTypeParameters(declaration);
        }
        // The local type parameters are the combined set of type parameters from all declarations of the class,
        // interface, or type alias.
        function getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) {
            if (!symbol.declarations) {
                return;
            }
            var result;
            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                var node = _a[_i];
                if (node.kind === 258 /* SyntaxKind.InterfaceDeclaration */ ||
                    node.kind === 257 /* SyntaxKind.ClassDeclaration */ ||
                    node.kind === 226 /* SyntaxKind.ClassExpression */ ||
                    isJSConstructor(node) ||
                    ts.isTypeAlias(node)) {
                    var declaration = node;
                    result = appendTypeParameters(result, ts.getEffectiveTypeParameterDeclarations(declaration));
                }
            }
            return result;
        }
        // The full set of type parameters for a generic class or interface type consists of its outer type parameters plus
        // its locally declared type parameters.
        function getTypeParametersOfClassOrInterface(symbol) {
            return ts.concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol));
        }
        // A type is a mixin constructor if it has a single construct signature taking no type parameters and a single
        // rest parameter of type any[].
        function isMixinConstructorType(type) {
            var signatures = getSignaturesOfType(type, 1 /* SignatureKind.Construct */);
            if (signatures.length === 1) {
                var s = signatures[0];
                if (!s.typeParameters && s.parameters.length === 1 && signatureHasRestParameter(s)) {
                    var paramType = getTypeOfParameter(s.parameters[0]);
                    return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) === anyType;
                }
            }
            return false;
        }
        function isConstructorType(type) {
            if (getSignaturesOfType(type, 1 /* SignatureKind.Construct */).length > 0) {
                return true;
            }
            if (type.flags & 8650752 /* TypeFlags.TypeVariable */) {
                var constraint = getBaseConstraintOfType(type);
                return !!constraint && isMixinConstructorType(constraint);
            }
            return false;
        }
        function getBaseTypeNodeOfClass(type) {
            var decl = ts.getClassLikeDeclarationOfSymbol(type.symbol);
            return decl && ts.getEffectiveBaseTypeNode(decl);
        }
        function getConstructorsForTypeArguments(type, typeArgumentNodes, location) {
            var typeArgCount = ts.length(typeArgumentNodes);
            var isJavascript = ts.isInJSFile(location);
            return ts.filter(getSignaturesOfType(type, 1 /* SignatureKind.Construct */), function (sig) { return (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= ts.length(sig.typeParameters); });
        }
        function getInstantiatedConstructorsForTypeArguments(type, typeArgumentNodes, location) {
            var signatures = getConstructorsForTypeArguments(type, typeArgumentNodes, location);
            var typeArguments = ts.map(typeArgumentNodes, getTypeFromTypeNode);
            return ts.sameMap(signatures, function (sig) { return ts.some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, ts.isInJSFile(location)) : sig; });
        }
        /**
         * The base constructor of a class can resolve to
         * * undefinedType if the class has no extends clause,
         * * unknownType if an error occurred during resolution of the extends expression,
         * * nullType if the extends expression is the null value,
         * * anyType if the extends expression has type any, or
         * * an object type with at least one construct signature.
         */
        function getBaseConstructorTypeOfClass(type) {
            if (!type.resolvedBaseConstructorType) {
                var decl = ts.getClassLikeDeclarationOfSymbol(type.symbol);
                var extended = decl && ts.getEffectiveBaseTypeNode(decl);
                var baseTypeNode = getBaseTypeNodeOfClass(type);
                if (!baseTypeNode) {
                    return type.resolvedBaseConstructorType = undefinedType;
                }
                if (!pushTypeResolution(type, 1 /* TypeSystemPropertyName.ResolvedBaseConstructorType */)) {
                    return errorType;
                }
                var baseConstructorType = checkExpression(baseTypeNode.expression);
                if (extended && baseTypeNode !== extended) {
                    ts.Debug.assert(!extended.typeArguments); // Because this is in a JS file, and baseTypeNode is in an @extends tag
                    checkExpression(extended.expression);
                }
                if (baseConstructorType.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */)) {
                    // Resolving the members of a class requires us to resolve the base class of that class.
                    // We force resolution here such that we catch circularities now.
                    resolveStructuredTypeMembers(baseConstructorType);
                }
                if (!popTypeResolution()) {
                    error(type.symbol.valueDeclaration, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol));
                    return type.resolvedBaseConstructorType = errorType;
                }
                if (!(baseConstructorType.flags & 1 /* TypeFlags.Any */) && baseConstructorType !== nullWideningType && !isConstructorType(baseConstructorType)) {
                    var err = error(baseTypeNode.expression, ts.Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));
                    if (baseConstructorType.flags & 262144 /* TypeFlags.TypeParameter */) {
                        var constraint = getConstraintFromTypeParameter(baseConstructorType);
                        var ctorReturn = unknownType;
                        if (constraint) {
                            var ctorSig = getSignaturesOfType(constraint, 1 /* SignatureKind.Construct */);
                            if (ctorSig[0]) {
                                ctorReturn = getReturnTypeOfSignature(ctorSig[0]);
                            }
                        }
                        if (baseConstructorType.symbol.declarations) {
                            ts.addRelatedInfo(err, ts.createDiagnosticForNode(baseConstructorType.symbol.declarations[0], ts.Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)));
                        }
                    }
                    return type.resolvedBaseConstructorType = errorType;
                }
                type.resolvedBaseConstructorType = baseConstructorType;
            }
            return type.resolvedBaseConstructorType;
        }
        function getImplementsTypes(type) {
            var resolvedImplementsTypes = ts.emptyArray;
            if (type.symbol.declarations) {
                for (var _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    var implementsTypeNodes = ts.getEffectiveImplementsTypeNodes(declaration);
                    if (!implementsTypeNodes)
                        continue;
                    for (var _b = 0, implementsTypeNodes_1 = implementsTypeNodes; _b < implementsTypeNodes_1.length; _b++) {
                        var node = implementsTypeNodes_1[_b];
                        var implementsType = getTypeFromTypeNode(node);
                        if (!isErrorType(implementsType)) {
                            if (resolvedImplementsTypes === ts.emptyArray) {
                                resolvedImplementsTypes = [implementsType];
                            }
                            else {
                                resolvedImplementsTypes.push(implementsType);
                            }
                        }
                    }
                }
            }
            return resolvedImplementsTypes;
        }
        function reportCircularBaseType(node, type) {
            error(node, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, 2 /* TypeFormatFlags.WriteArrayAsGenericType */));
        }
        function getBaseTypes(type) {
            if (!type.baseTypesResolved) {
                if (pushTypeResolution(type, 7 /* TypeSystemPropertyName.ResolvedBaseTypes */)) {
                    if (type.objectFlags & 8 /* ObjectFlags.Tuple */) {
                        type.resolvedBaseTypes = [getTupleBaseType(type)];
                    }
                    else if (type.symbol.flags & (32 /* SymbolFlags.Class */ | 64 /* SymbolFlags.Interface */)) {
                        if (type.symbol.flags & 32 /* SymbolFlags.Class */) {
                            resolveBaseTypesOfClass(type);
                        }
                        if (type.symbol.flags & 64 /* SymbolFlags.Interface */) {
                            resolveBaseTypesOfInterface(type);
                        }
                    }
                    else {
                        ts.Debug.fail("type must be class or interface");
                    }
                    if (!popTypeResolution() && type.symbol.declarations) {
                        for (var _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
                            var declaration = _a[_i];
                            if (declaration.kind === 257 /* SyntaxKind.ClassDeclaration */ || declaration.kind === 258 /* SyntaxKind.InterfaceDeclaration */) {
                                reportCircularBaseType(declaration, type);
                            }
                        }
                    }
                }
                type.baseTypesResolved = true;
            }
            return type.resolvedBaseTypes;
        }
        function getTupleBaseType(type) {
            var elementTypes = ts.sameMap(type.typeParameters, function (t, i) { return type.elementFlags[i] & 8 /* ElementFlags.Variadic */ ? getIndexedAccessType(t, numberType) : t; });
            return createArrayType(getUnionType(elementTypes || ts.emptyArray), type.readonly);
        }
        function resolveBaseTypesOfClass(type) {
            type.resolvedBaseTypes = ts.resolvingEmptyArray;
            var baseConstructorType = getApparentType(getBaseConstructorTypeOfClass(type));
            if (!(baseConstructorType.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */ | 1 /* TypeFlags.Any */))) {
                return type.resolvedBaseTypes = ts.emptyArray;
            }
            var baseTypeNode = getBaseTypeNodeOfClass(type);
            var baseType;
            var originalBaseType = baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined;
            if (baseConstructorType.symbol && baseConstructorType.symbol.flags & 32 /* SymbolFlags.Class */ &&
                areAllOuterTypeParametersApplied(originalBaseType)) {
                // When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
                // class and all return the instance type of the class. There is no need for further checks and we can apply the
                // type arguments in the same manner as a type reference to get the same error reporting experience.
                baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol);
            }
            else if (baseConstructorType.flags & 1 /* TypeFlags.Any */) {
                baseType = baseConstructorType;
            }
            else {
                // The class derives from a "class-like" constructor function, check that we have at least one construct signature
                // with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
                // we check that all instantiated signatures return the same type.
                var constructors = getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode);
                if (!constructors.length) {
                    error(baseTypeNode.expression, ts.Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments);
                    return type.resolvedBaseTypes = ts.emptyArray;
                }
                baseType = getReturnTypeOfSignature(constructors[0]);
            }
            if (isErrorType(baseType)) {
                return type.resolvedBaseTypes = ts.emptyArray;
            }
            var reducedBaseType = getReducedType(baseType);
            if (!isValidBaseType(reducedBaseType)) {
                var elaboration = elaborateNeverIntersection(/*errorInfo*/ undefined, baseType);
                var diagnostic = ts.chainDiagnosticMessages(elaboration, ts.Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType));
                diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(baseTypeNode.expression, diagnostic));
                return type.resolvedBaseTypes = ts.emptyArray;
            }
            if (type === reducedBaseType || hasBaseType(reducedBaseType, type)) {
                error(type.symbol.valueDeclaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, 2 /* TypeFormatFlags.WriteArrayAsGenericType */));
                return type.resolvedBaseTypes = ts.emptyArray;
            }
            if (type.resolvedBaseTypes === ts.resolvingEmptyArray) {
                // Circular reference, likely through instantiation of default parameters
                // (otherwise there'd be an error from hasBaseType) - this is fine, but `.members` should be reset
                // as `getIndexedAccessType` via `instantiateType` via `getTypeFromClassOrInterfaceReference` forces a
                // partial instantiation of the members without the base types fully resolved
                type.members = undefined;
            }
            return type.resolvedBaseTypes = [reducedBaseType];
        }
        function areAllOuterTypeParametersApplied(type) {
            // An unapplied type parameter has its symbol still the same as the matching argument symbol.
            // Since parameters are applied outer-to-inner, only the last outer parameter needs to be checked.
            var outerTypeParameters = type.outerTypeParameters;
            if (outerTypeParameters) {
                var last_1 = outerTypeParameters.length - 1;
                var typeArguments = getTypeArguments(type);
                return outerTypeParameters[last_1].symbol !== typeArguments[last_1].symbol;
            }
            return true;
        }
        // A valid base type is `any`, an object type or intersection of object types.
        function isValidBaseType(type) {
            if (type.flags & 262144 /* TypeFlags.TypeParameter */) {
                var constraint = getBaseConstraintOfType(type);
                if (constraint) {
                    return isValidBaseType(constraint);
                }
            }
            // TODO: Given that we allow type parmeters here now, is this `!isGenericMappedType(type)` check really needed?
            // There's no reason a `T` should be allowed while a `Readonly<T>` should not.
            return !!(type.flags & (524288 /* TypeFlags.Object */ | 67108864 /* TypeFlags.NonPrimitive */ | 1 /* TypeFlags.Any */) && !isGenericMappedType(type) ||
                type.flags & 2097152 /* TypeFlags.Intersection */ && ts.every(type.types, isValidBaseType));
        }
        function resolveBaseTypesOfInterface(type) {
            type.resolvedBaseTypes = type.resolvedBaseTypes || ts.emptyArray;
            if (type.symbol.declarations) {
                for (var _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    if (declaration.kind === 258 /* SyntaxKind.InterfaceDeclaration */ && ts.getInterfaceBaseTypeNodes(declaration)) {
                        for (var _b = 0, _c = ts.getInterfaceBaseTypeNodes(declaration); _b < _c.length; _b++) {
                            var node = _c[_b];
                            var baseType = getReducedType(getTypeFromTypeNode(node));
                            if (!isErrorType(baseType)) {
                                if (isValidBaseType(baseType)) {
                                    if (type !== baseType && !hasBaseType(baseType, type)) {
                                        if (type.resolvedBaseTypes === ts.emptyArray) {
                                            type.resolvedBaseTypes = [baseType];
                                        }
                                        else {
                                            type.resolvedBaseTypes.push(baseType);
                                        }
                                    }
                                    else {
                                        reportCircularBaseType(declaration, type);
                                    }
                                }
                                else {
                                    error(node, ts.Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members);
                                }
                            }
                        }
                    }
                }
            }
        }
        /**
         * Returns true if the interface given by the symbol is free of "this" references.
         *
         * Specifically, the result is true if the interface itself contains no references
         * to "this" in its body, if all base types are interfaces,
         * and if none of the base interfaces have a "this" type.
         */
        function isThislessInterface(symbol) {
            if (!symbol.declarations) {
                return true;
            }
            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                var declaration = _a[_i];
                if (declaration.kind === 258 /* SyntaxKind.InterfaceDeclaration */) {
                    if (declaration.flags & 128 /* NodeFlags.ContainsThis */) {
                        return false;
                    }
                    var baseTypeNodes = ts.getInterfaceBaseTypeNodes(declaration);
                    if (baseTypeNodes) {
                        for (var _b = 0, baseTypeNodes_1 = baseTypeNodes; _b < baseTypeNodes_1.length; _b++) {
                            var node = baseTypeNodes_1[_b];
                            if (ts.isEntityNameExpression(node.expression)) {
                                var baseSymbol = resolveEntityName(node.expression, 788968 /* SymbolFlags.Type */, /*ignoreErrors*/ true);
                                if (!baseSymbol || !(baseSymbol.flags & 64 /* SymbolFlags.Interface */) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }
        function getDeclaredTypeOfClassOrInterface(symbol) {
            var links = getSymbolLinks(symbol);
            var originalLinks = links;
            if (!links.declaredType) {
                var kind = symbol.flags & 32 /* SymbolFlags.Class */ ? 1 /* ObjectFlags.Class */ : 2 /* ObjectFlags.Interface */;
                var merged = mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration));
                if (merged) {
                    // note:we overwrite links because we just cloned the symbol
                    symbol = links = merged;
                }
                var type = originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol);
                var outerTypeParameters = getOuterTypeParametersOfClassOrInterface(symbol);
                var localTypeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                // A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
                // because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
                // property types inferred from initializers and method return types inferred from return statements are very hard
                // to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
                // "this" references.
                if (outerTypeParameters || localTypeParameters || kind === 1 /* ObjectFlags.Class */ || !isThislessInterface(symbol)) {
                    type.objectFlags |= 4 /* ObjectFlags.Reference */;
                    type.typeParameters = ts.concatenate(outerTypeParameters, localTypeParameters);
                    type.outerTypeParameters = outerTypeParameters;
                    type.localTypeParameters = localTypeParameters;
                    type.instantiations = new ts.Map();
                    type.instantiations.set(getTypeListId(type.typeParameters), type);
                    type.target = type;
                    type.resolvedTypeArguments = type.typeParameters;
                    type.thisType = createTypeParameter(symbol);
                    type.thisType.isThisType = true;
                    type.thisType.constraint = type;
                }
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfTypeAlias(symbol) {
            var _a;
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                // Note that we use the links object as the target here because the symbol object is used as the unique
                // identity for resolution of the 'type' property in SymbolLinks.
                if (!pushTypeResolution(symbol, 2 /* TypeSystemPropertyName.DeclaredType */)) {
                    return errorType;
                }
                var declaration = ts.Debug.checkDefined((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isTypeAlias), "Type alias symbol with no valid declaration found");
                var typeNode = ts.isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type;
                // If typeNode is missing, we will error in checkJSDocTypedefTag.
                var type = typeNode ? getTypeFromTypeNode(typeNode) : errorType;
                if (popTypeResolution()) {
                    var typeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                    if (typeParameters) {
                        // Initialize the instantiation cache for generic type aliases. The declared type corresponds to
                        // an instantiation of the type alias with the type parameters supplied as type arguments.
                        links.typeParameters = typeParameters;
                        links.instantiations = new ts.Map();
                        links.instantiations.set(getTypeListId(typeParameters), type);
                    }
                }
                else {
                    type = errorType;
                    if (declaration.kind === 339 /* SyntaxKind.JSDocEnumTag */) {
                        error(declaration.typeExpression.type, ts.Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                    }
                    else {
                        error(ts.isNamedDeclaration(declaration) ? declaration.name : declaration || declaration, ts.Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                    }
                }
                links.declaredType = type;
            }
            return links.declaredType;
        }
        function isStringConcatExpression(expr) {
            if (ts.isStringLiteralLike(expr)) {
                return true;
            }
            else if (expr.kind === 221 /* SyntaxKind.BinaryExpression */) {
                return isStringConcatExpression(expr.left) && isStringConcatExpression(expr.right);
            }
            return false;
        }
        function isLiteralEnumMember(member) {
            var expr = member.initializer;
            if (!expr) {
                return !(member.flags & 16777216 /* NodeFlags.Ambient */);
            }
            switch (expr.kind) {
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                    return true;
                case 219 /* SyntaxKind.PrefixUnaryExpression */:
                    return expr.operator === 40 /* SyntaxKind.MinusToken */ &&
                        expr.operand.kind === 8 /* SyntaxKind.NumericLiteral */;
                case 79 /* SyntaxKind.Identifier */:
                    return ts.nodeIsMissing(expr) || !!getSymbolOfNode(member.parent).exports.get(expr.escapedText);
                case 221 /* SyntaxKind.BinaryExpression */:
                    return isStringConcatExpression(expr);
                default:
                    return false;
            }
        }
        function getEnumKind(symbol) {
            var links = getSymbolLinks(symbol);
            if (links.enumKind !== undefined) {
                return links.enumKind;
            }
            var hasNonLiteralMember = false;
            if (symbol.declarations) {
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    if (declaration.kind === 260 /* SyntaxKind.EnumDeclaration */) {
                        for (var _b = 0, _c = declaration.members; _b < _c.length; _b++) {
                            var member = _c[_b];
                            if (member.initializer && ts.isStringLiteralLike(member.initializer)) {
                                return links.enumKind = 1 /* EnumKind.Literal */;
                            }
                            if (!isLiteralEnumMember(member)) {
                                hasNonLiteralMember = true;
                            }
                        }
                    }
                }
            }
            return links.enumKind = hasNonLiteralMember ? 0 /* EnumKind.Numeric */ : 1 /* EnumKind.Literal */;
        }
        function getBaseTypeOfEnumLiteralType(type) {
            return type.flags & 1024 /* TypeFlags.EnumLiteral */ && !(type.flags & 1048576 /* TypeFlags.Union */) ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)) : type;
        }
        function getDeclaredTypeOfEnum(symbol) {
            var links = getSymbolLinks(symbol);
            if (links.declaredType) {
                return links.declaredType;
            }
            if (getEnumKind(symbol) === 1 /* EnumKind.Literal */) {
                enumCount++;
                var memberTypeList = [];
                if (symbol.declarations) {
                    for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                        var declaration = _a[_i];
                        if (declaration.kind === 260 /* SyntaxKind.EnumDeclaration */) {
                            for (var _b = 0, _c = declaration.members; _b < _c.length; _b++) {
                                var member = _c[_b];
                                var value = getEnumMemberValue(member);
                                var memberType = getFreshTypeOfLiteralType(getEnumLiteralType(value !== undefined ? value : 0, enumCount, getSymbolOfNode(member)));
                                getSymbolLinks(getSymbolOfNode(member)).declaredType = memberType;
                                memberTypeList.push(getRegularTypeOfLiteralType(memberType));
                            }
                        }
                    }
                }
                if (memberTypeList.length) {
                    var enumType_1 = getUnionType(memberTypeList, 1 /* UnionReduction.Literal */, symbol, /*aliasTypeArguments*/ undefined);
                    if (enumType_1.flags & 1048576 /* TypeFlags.Union */) {
                        enumType_1.flags |= 1024 /* TypeFlags.EnumLiteral */;
                        enumType_1.symbol = symbol;
                    }
                    return links.declaredType = enumType_1;
                }
            }
            var enumType = createType(32 /* TypeFlags.Enum */);
            enumType.symbol = symbol;
            return links.declaredType = enumType;
        }
        function getDeclaredTypeOfEnumMember(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var enumType = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));
                if (!links.declaredType) {
                    links.declaredType = enumType;
                }
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfTypeParameter(symbol) {
            var links = getSymbolLinks(symbol);
            return links.declaredType || (links.declaredType = createTypeParameter(symbol));
        }
        function getDeclaredTypeOfAlias(symbol) {
            var links = getSymbolLinks(symbol);
            return links.declaredType || (links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)));
        }
        function getDeclaredTypeOfSymbol(symbol) {
            return tryGetDeclaredTypeOfSymbol(symbol) || errorType;
        }
        function tryGetDeclaredTypeOfSymbol(symbol) {
            if (symbol.flags & (32 /* SymbolFlags.Class */ | 64 /* SymbolFlags.Interface */)) {
                return getDeclaredTypeOfClassOrInterface(symbol);
            }
            if (symbol.flags & 524288 /* SymbolFlags.TypeAlias */) {
                return getDeclaredTypeOfTypeAlias(symbol);
            }
            if (symbol.flags & 262144 /* SymbolFlags.TypeParameter */) {
                return getDeclaredTypeOfTypeParameter(symbol);
            }
            if (symbol.flags & 384 /* SymbolFlags.Enum */) {
                return getDeclaredTypeOfEnum(symbol);
            }
            if (symbol.flags & 8 /* SymbolFlags.EnumMember */) {
                return getDeclaredTypeOfEnumMember(symbol);
            }
            if (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
                return getDeclaredTypeOfAlias(symbol);
            }
            return undefined;
        }
        /**
         * A type is free of this references if it's the any, string, number, boolean, symbol, or void keyword, a string
         * literal type, an array with an element type that is free of this references, or a type reference that is
         * free of this references.
         */
        function isThislessType(node) {
            switch (node.kind) {
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 196 /* SyntaxKind.LiteralType */:
                    return true;
                case 183 /* SyntaxKind.ArrayType */:
                    return isThislessType(node.elementType);
                case 178 /* SyntaxKind.TypeReference */:
                    return !node.typeArguments || node.typeArguments.every(isThislessType);
            }
            return false;
        }
        /** A type parameter is thisless if its constraint is thisless, or if it has no constraint. */
        function isThislessTypeParameter(node) {
            var constraint = ts.getEffectiveConstraintOfTypeParameter(node);
            return !constraint || isThislessType(constraint);
        }
        /**
         * A variable-like declaration is free of this references if it has a type annotation
         * that is thisless, or if it has no type annotation and no initializer (and is thus of type any).
         */
        function isThislessVariableLikeDeclaration(node) {
            var typeNode = ts.getEffectiveTypeAnnotationNode(node);
            return typeNode ? isThislessType(typeNode) : !ts.hasInitializer(node);
        }
        /**
         * A function-like declaration is considered free of `this` references if it has a return type
         * annotation that is free of this references and if each parameter is thisless and if
         * each type parameter (if present) is thisless.
         */
        function isThislessFunctionLikeDeclaration(node) {
            var returnType = ts.getEffectiveReturnTypeNode(node);
            var typeParameters = ts.getEffectiveTypeParameterDeclarations(node);
            return (node.kind === 171 /* SyntaxKind.Constructor */ || (!!returnType && isThislessType(returnType))) &&
                node.parameters.every(isThislessVariableLikeDeclaration) &&
                typeParameters.every(isThislessTypeParameter);
        }
        /**
         * Returns true if the class or interface member given by the symbol is free of "this" references. The
         * function may return false for symbols that are actually free of "this" references because it is not
         * feasible to perform a complete analysis in all cases. In particular, property members with types
         * inferred from their initializers and function members with inferred return types are conservatively
         * assumed not to be free of "this" references.
         */
        function isThisless(symbol) {
            if (symbol.declarations && symbol.declarations.length === 1) {
                var declaration = symbol.declarations[0];
                if (declaration) {
                    switch (declaration.kind) {
                        case 167 /* SyntaxKind.PropertyDeclaration */:
                        case 166 /* SyntaxKind.PropertySignature */:
                            return isThislessVariableLikeDeclaration(declaration);
                        case 169 /* SyntaxKind.MethodDeclaration */:
                        case 168 /* SyntaxKind.MethodSignature */:
                        case 171 /* SyntaxKind.Constructor */:
                        case 172 /* SyntaxKind.GetAccessor */:
                        case 173 /* SyntaxKind.SetAccessor */:
                            return isThislessFunctionLikeDeclaration(declaration);
                    }
                }
            }
            return false;
        }
        // The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
        // we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
        function createInstantiatedSymbolTable(symbols, mapper, mappingThisOnly) {
            var result = ts.createSymbolTable();
            for (var _i = 0, symbols_2 = symbols; _i < symbols_2.length; _i++) {
                var symbol = symbols_2[_i];
                result.set(symbol.escapedName, mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper));
            }
            return result;
        }
        function addInheritedMembers(symbols, baseSymbols) {
            for (var _i = 0, baseSymbols_1 = baseSymbols; _i < baseSymbols_1.length; _i++) {
                var s = baseSymbols_1[_i];
                if (!symbols.has(s.escapedName) && !isStaticPrivateIdentifierProperty(s)) {
                    symbols.set(s.escapedName, s);
                }
            }
        }
        function isStaticPrivateIdentifierProperty(s) {
            return !!s.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && ts.isStatic(s.valueDeclaration);
        }
        function resolveDeclaredMembers(type) {
            if (!type.declaredProperties) {
                var symbol = type.symbol;
                var members = getMembersOfSymbol(symbol);
                type.declaredProperties = getNamedMembers(members);
                // Start with signatures at empty array in case of recursive types
                type.declaredCallSignatures = ts.emptyArray;
                type.declaredConstructSignatures = ts.emptyArray;
                type.declaredIndexInfos = ts.emptyArray;
                type.declaredCallSignatures = getSignaturesOfSymbol(members.get("__call" /* InternalSymbolName.Call */));
                type.declaredConstructSignatures = getSignaturesOfSymbol(members.get("__new" /* InternalSymbolName.New */));
                type.declaredIndexInfos = getIndexInfosOfSymbol(symbol);
            }
            return type;
        }
        /**
         * Indicates whether a type can be used as a property name.
         */
        function isTypeUsableAsPropertyName(type) {
            return !!(type.flags & 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */);
        }
        /**
         * Indicates whether a declaration name is definitely late-bindable.
         * A declaration name is only late-bindable if:
         * - It is a `ComputedPropertyName`.
         * - Its expression is an `Identifier` or either a `PropertyAccessExpression` an
         * `ElementAccessExpression` consisting only of these same three types of nodes.
         * - The type of its expression is a string or numeric literal type, or is a `unique symbol` type.
         */
        function isLateBindableName(node) {
            if (!ts.isComputedPropertyName(node) && !ts.isElementAccessExpression(node)) {
                return false;
            }
            var expr = ts.isComputedPropertyName(node) ? node.expression : node.argumentExpression;
            return ts.isEntityNameExpression(expr)
                && isTypeUsableAsPropertyName(ts.isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr));
        }
        function isLateBoundName(name) {
            return name.charCodeAt(0) === 95 /* CharacterCodes._ */ &&
                name.charCodeAt(1) === 95 /* CharacterCodes._ */ &&
                name.charCodeAt(2) === 64 /* CharacterCodes.at */;
        }
        /**
         * Indicates whether a declaration has a late-bindable dynamic name.
         */
        function hasLateBindableName(node) {
            var name = ts.getNameOfDeclaration(node);
            return !!name && isLateBindableName(name);
        }
        /**
         * Indicates whether a declaration has an early-bound name or a dynamic name that can be late-bound.
         */
        function hasBindableName(node) {
            return !ts.hasDynamicName(node) || hasLateBindableName(node);
        }
        /**
         * Indicates whether a declaration name is a dynamic name that cannot be late-bound.
         */
        function isNonBindableDynamicName(node) {
            return ts.isDynamicName(node) && !isLateBindableName(node);
        }
        /**
         * Gets the symbolic name for a member from its type.
         */
        function getPropertyNameFromType(type) {
            if (type.flags & 8192 /* TypeFlags.UniqueESSymbol */) {
                return type.escapedName;
            }
            if (type.flags & (128 /* TypeFlags.StringLiteral */ | 256 /* TypeFlags.NumberLiteral */)) {
                return ts.escapeLeadingUnderscores("" + type.value);
            }
            return ts.Debug.fail();
        }
        /**
         * Adds a declaration to a late-bound dynamic member. This performs the same function for
         * late-bound members that `addDeclarationToSymbol` in binder.ts performs for early-bound
         * members.
         */
        function addDeclarationToLateBoundSymbol(symbol, member, symbolFlags) {
            ts.Debug.assert(!!(ts.getCheckFlags(symbol) & 4096 /* CheckFlags.Late */), "Expected a late-bound symbol.");
            symbol.flags |= symbolFlags;
            getSymbolLinks(member.symbol).lateSymbol = symbol;
            if (!symbol.declarations) {
                symbol.declarations = [member];
            }
            else if (!member.symbol.isReplaceableByMethod) {
                symbol.declarations.push(member);
            }
            if (symbolFlags & 111551 /* SymbolFlags.Value */) {
                if (!symbol.valueDeclaration || symbol.valueDeclaration.kind !== member.kind) {
                    symbol.valueDeclaration = member;
                }
            }
        }
        /**
         * Performs late-binding of a dynamic member. This performs the same function for
         * late-bound members that `declareSymbol` in binder.ts performs for early-bound
         * members.
         *
         * If a symbol is a dynamic name from a computed property, we perform an additional "late"
         * binding phase to attempt to resolve the name for the symbol from the type of the computed
         * property's expression. If the type of the expression is a string-literal, numeric-literal,
         * or unique symbol type, we can use that type as the name of the symbol.
         *
         * For example, given:
         *
         *   const x = Symbol();
         *
         *   interface I {
         *     [x]: number;
         *   }
         *
         * The binder gives the property `[x]: number` a special symbol with the name "__computed".
         * In the late-binding phase we can type-check the expression `x` and see that it has a
         * unique symbol type which we can then use as the name of the member. This allows users
         * to define custom symbols that can be used in the members of an object type.
         *
         * @param parent The containing symbol for the member.
         * @param earlySymbols The early-bound symbols of the parent.
         * @param lateSymbols The late-bound symbols of the parent.
         * @param decl The member to bind.
         */
        function lateBindMember(parent, earlySymbols, lateSymbols, decl) {
            ts.Debug.assert(!!decl.symbol, "The member is expected to have a symbol.");
            var links = getNodeLinks(decl);
            if (!links.resolvedSymbol) {
                // In the event we attempt to resolve the late-bound name of this member recursively,
                // fall back to the early-bound name of this member.
                links.resolvedSymbol = decl.symbol;
                var declName = ts.isBinaryExpression(decl) ? decl.left : decl.name;
                var type = ts.isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName);
                if (isTypeUsableAsPropertyName(type)) {
                    var memberName = getPropertyNameFromType(type);
                    var symbolFlags = decl.symbol.flags;
                    // Get or add a late-bound symbol for the member. This allows us to merge late-bound accessor declarations.
                    var lateSymbol = lateSymbols.get(memberName);
                    if (!lateSymbol)
                        lateSymbols.set(memberName, lateSymbol = createSymbol(0 /* SymbolFlags.None */, memberName, 4096 /* CheckFlags.Late */));
                    // Report an error if a late-bound member has the same name as an early-bound member,
                    // or if we have another early-bound symbol declaration with the same name and
                    // conflicting flags.
                    var earlySymbol = earlySymbols && earlySymbols.get(memberName);
                    if (lateSymbol.flags & getExcludedSymbolFlags(symbolFlags) || earlySymbol) {
                        // If we have an existing early-bound member, combine its declarations so that we can
                        // report an error at each declaration.
                        var declarations = earlySymbol ? ts.concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations;
                        var name_5 = !(type.flags & 8192 /* TypeFlags.UniqueESSymbol */) && ts.unescapeLeadingUnderscores(memberName) || ts.declarationNameToString(declName);
                        ts.forEach(declarations, function (declaration) { return error(ts.getNameOfDeclaration(declaration) || declaration, ts.Diagnostics.Property_0_was_also_declared_here, name_5); });
                        error(declName || decl, ts.Diagnostics.Duplicate_property_0, name_5);
                        lateSymbol = createSymbol(0 /* SymbolFlags.None */, memberName, 4096 /* CheckFlags.Late */);
                    }
                    lateSymbol.nameType = type;
                    addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags);
                    if (lateSymbol.parent) {
                        ts.Debug.assert(lateSymbol.parent === parent, "Existing symbol parent should match new one");
                    }
                    else {
                        lateSymbol.parent = parent;
                    }
                    return links.resolvedSymbol = lateSymbol;
                }
            }
            return links.resolvedSymbol;
        }
        function getResolvedMembersOrExportsOfSymbol(symbol, resolutionKind) {
            var links = getSymbolLinks(symbol);
            if (!links[resolutionKind]) {
                var isStatic_1 = resolutionKind === "resolvedExports" /* MembersOrExportsResolutionKind.resolvedExports */;
                var earlySymbols = !isStatic_1 ? symbol.members :
                    symbol.flags & 1536 /* SymbolFlags.Module */ ? getExportsOfModuleWorker(symbol) :
                        symbol.exports;
                // In the event we recursively resolve the members/exports of the symbol, we
                // set the initial value of resolvedMembers/resolvedExports to the early-bound
                // members/exports of the symbol.
                links[resolutionKind] = earlySymbols || emptySymbols;
                // fill in any as-yet-unresolved late-bound members.
                var lateSymbols = ts.createSymbolTable();
                for (var _i = 0, _a = symbol.declarations || ts.emptyArray; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    var members = ts.getMembersOfDeclaration(decl);
                    if (members) {
                        for (var _b = 0, members_5 = members; _b < members_5.length; _b++) {
                            var member = members_5[_b];
                            if (isStatic_1 === ts.hasStaticModifier(member) && hasLateBindableName(member)) {
                                lateBindMember(symbol, earlySymbols, lateSymbols, member);
                            }
                        }
                    }
                }
                var assignments = symbol.assignmentDeclarationMembers;
                if (assignments) {
                    var decls = ts.arrayFrom(assignments.values());
                    for (var _c = 0, decls_1 = decls; _c < decls_1.length; _c++) {
                        var member = decls_1[_c];
                        var assignmentKind = ts.getAssignmentDeclarationKind(member);
                        var isInstanceMember = assignmentKind === 3 /* AssignmentDeclarationKind.PrototypeProperty */
                            || ts.isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind)
                            || assignmentKind === 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */
                            || assignmentKind === 6 /* AssignmentDeclarationKind.Prototype */; // A straight `Prototype` assignment probably can never have a computed name
                        if (isStatic_1 === !isInstanceMember && hasLateBindableName(member)) {
                            lateBindMember(symbol, earlySymbols, lateSymbols, member);
                        }
                    }
                }
                links[resolutionKind] = combineSymbolTables(earlySymbols, lateSymbols) || emptySymbols;
            }
            return links[resolutionKind];
        }
        /**
         * Gets a SymbolTable containing both the early- and late-bound members of a symbol.
         *
         * For a description of late-binding, see `lateBindMember`.
         */
        function getMembersOfSymbol(symbol) {
            return symbol.flags & 6256 /* SymbolFlags.LateBindingContainer */
                ? getResolvedMembersOrExportsOfSymbol(symbol, "resolvedMembers" /* MembersOrExportsResolutionKind.resolvedMembers */)
                : symbol.members || emptySymbols;
        }
        /**
         * If a symbol is the dynamic name of the member of an object type, get the late-bound
         * symbol of the member.
         *
         * For a description of late-binding, see `lateBindMember`.
         */
        function getLateBoundSymbol(symbol) {
            if (symbol.flags & 106500 /* SymbolFlags.ClassMember */ && symbol.escapedName === "__computed" /* InternalSymbolName.Computed */) {
                var links = getSymbolLinks(symbol);
                if (!links.lateSymbol && ts.some(symbol.declarations, hasLateBindableName)) {
                    // force late binding of members/exports. This will set the late-bound symbol
                    var parent = getMergedSymbol(symbol.parent);
                    if (ts.some(symbol.declarations, ts.hasStaticModifier)) {
                        getExportsOfSymbol(parent);
                    }
                    else {
                        getMembersOfSymbol(parent);
                    }
                }
                return links.lateSymbol || (links.lateSymbol = symbol);
            }
            return symbol;
        }
        function getTypeWithThisArgument(type, thisArgument, needApparentType) {
            if (ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) {
                var target = type.target;
                var typeArguments = getTypeArguments(type);
                if (ts.length(target.typeParameters) === ts.length(typeArguments)) {
                    var ref = createTypeReference(target, ts.concatenate(typeArguments, [thisArgument || target.thisType]));
                    return needApparentType ? getApparentType(ref) : ref;
                }
            }
            else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                var types = ts.sameMap(type.types, function (t) { return getTypeWithThisArgument(t, thisArgument, needApparentType); });
                return types !== type.types ? getIntersectionType(types) : type;
            }
            return needApparentType ? getApparentType(type) : type;
        }
        function resolveObjectTypeMembers(type, source, typeParameters, typeArguments) {
            var mapper;
            var members;
            var callSignatures;
            var constructSignatures;
            var indexInfos;
            if (ts.rangeEquals(typeParameters, typeArguments, 0, typeParameters.length)) {
                members = source.symbol ? getMembersOfSymbol(source.symbol) : ts.createSymbolTable(source.declaredProperties);
                callSignatures = source.declaredCallSignatures;
                constructSignatures = source.declaredConstructSignatures;
                indexInfos = source.declaredIndexInfos;
            }
            else {
                mapper = createTypeMapper(typeParameters, typeArguments);
                members = createInstantiatedSymbolTable(source.declaredProperties, mapper, /*mappingThisOnly*/ typeParameters.length === 1);
                callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper);
                constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper);
                indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper);
            }
            var baseTypes = getBaseTypes(source);
            if (baseTypes.length) {
                if (source.symbol && members === getMembersOfSymbol(source.symbol)) {
                    members = ts.createSymbolTable(source.declaredProperties);
                }
                setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
                var thisArgument = ts.lastOrUndefined(typeArguments);
                for (var _i = 0, baseTypes_1 = baseTypes; _i < baseTypes_1.length; _i++) {
                    var baseType = baseTypes_1[_i];
                    var instantiatedBaseType = thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType;
                    addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
                    callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, 0 /* SignatureKind.Call */));
                    constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, 1 /* SignatureKind.Construct */));
                    var inheritedIndexInfos = instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(stringType, anyType, /*isReadonly*/ false)];
                    indexInfos = ts.concatenate(indexInfos, ts.filter(inheritedIndexInfos, function (info) { return !findIndexInfo(indexInfos, info.keyType); }));
                }
            }
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
        }
        function resolveClassOrInterfaceMembers(type) {
            resolveObjectTypeMembers(type, resolveDeclaredMembers(type), ts.emptyArray, ts.emptyArray);
        }
        function resolveTypeReferenceMembers(type) {
            var source = resolveDeclaredMembers(type.target);
            var typeParameters = ts.concatenate(source.typeParameters, [source.thisType]);
            var typeArguments = getTypeArguments(type);
            var paddedTypeArguments = typeArguments.length === typeParameters.length ? typeArguments : ts.concatenate(typeArguments, [type]);
            resolveObjectTypeMembers(type, source, typeParameters, paddedTypeArguments);
        }
        function createSignature(declaration, typeParameters, thisParameter, parameters, resolvedReturnType, resolvedTypePredicate, minArgumentCount, flags) {
            var sig = new Signature(checker, flags);
            sig.declaration = declaration;
            sig.typeParameters = typeParameters;
            sig.parameters = parameters;
            sig.thisParameter = thisParameter;
            sig.resolvedReturnType = resolvedReturnType;
            sig.resolvedTypePredicate = resolvedTypePredicate;
            sig.minArgumentCount = minArgumentCount;
            sig.resolvedMinArgumentCount = undefined;
            sig.target = undefined;
            sig.mapper = undefined;
            sig.compositeSignatures = undefined;
            sig.compositeKind = undefined;
            return sig;
        }
        function cloneSignature(sig) {
            var result = createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, /*resolvedReturnType*/ undefined, 
            /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & 39 /* SignatureFlags.PropagatingFlags */);
            result.target = sig.target;
            result.mapper = sig.mapper;
            result.compositeSignatures = sig.compositeSignatures;
            result.compositeKind = sig.compositeKind;
            return result;
        }
        function createUnionSignature(signature, unionSignatures) {
            var result = cloneSignature(signature);
            result.compositeSignatures = unionSignatures;
            result.compositeKind = 1048576 /* TypeFlags.Union */;
            result.target = undefined;
            result.mapper = undefined;
            return result;
        }
        function getOptionalCallSignature(signature, callChainFlags) {
            if ((signature.flags & 24 /* SignatureFlags.CallChainFlags */) === callChainFlags) {
                return signature;
            }
            if (!signature.optionalCallSignatureCache) {
                signature.optionalCallSignatureCache = {};
            }
            var key = callChainFlags === 8 /* SignatureFlags.IsInnerCallChain */ ? "inner" : "outer";
            return signature.optionalCallSignatureCache[key]
                || (signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags));
        }
        function createOptionalCallSignature(signature, callChainFlags) {
            ts.Debug.assert(callChainFlags === 8 /* SignatureFlags.IsInnerCallChain */ || callChainFlags === 16 /* SignatureFlags.IsOuterCallChain */, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.");
            var result = cloneSignature(signature);
            result.flags |= callChainFlags;
            return result;
        }
        function getExpandedParameters(sig, skipUnionExpanding) {
            if (signatureHasRestParameter(sig)) {
                var restIndex_1 = sig.parameters.length - 1;
                var restType = getTypeOfSymbol(sig.parameters[restIndex_1]);
                if (isTupleType(restType)) {
                    return [expandSignatureParametersWithTupleMembers(restType, restIndex_1)];
                }
                else if (!skipUnionExpanding && restType.flags & 1048576 /* TypeFlags.Union */ && ts.every(restType.types, isTupleType)) {
                    return ts.map(restType.types, function (t) { return expandSignatureParametersWithTupleMembers(t, restIndex_1); });
                }
            }
            return [sig.parameters];
            function expandSignatureParametersWithTupleMembers(restType, restIndex) {
                var elementTypes = getTypeArguments(restType);
                var associatedNames = restType.target.labeledElementDeclarations;
                var restParams = ts.map(elementTypes, function (t, i) {
                    // Lookup the label from the individual tuple passed in before falling back to the signature `rest` parameter name
                    var tupleLabelName = !!associatedNames && getTupleElementLabel(associatedNames[i]);
                    var name = tupleLabelName || getParameterNameAtPosition(sig, restIndex + i, restType);
                    var flags = restType.target.elementFlags[i];
                    var checkFlags = flags & 12 /* ElementFlags.Variable */ ? 32768 /* CheckFlags.RestParameter */ :
                        flags & 2 /* ElementFlags.Optional */ ? 16384 /* CheckFlags.OptionalParameter */ : 0;
                    var symbol = createSymbol(1 /* SymbolFlags.FunctionScopedVariable */, name, checkFlags);
                    symbol.type = flags & 4 /* ElementFlags.Rest */ ? createArrayType(t) : t;
                    return symbol;
                });
                return ts.concatenate(sig.parameters.slice(0, restIndex), restParams);
            }
        }
        function getDefaultConstructSignatures(classType) {
            var baseConstructorType = getBaseConstructorTypeOfClass(classType);
            var baseSignatures = getSignaturesOfType(baseConstructorType, 1 /* SignatureKind.Construct */);
            var declaration = ts.getClassLikeDeclarationOfSymbol(classType.symbol);
            var isAbstract = !!declaration && ts.hasSyntacticModifier(declaration, 128 /* ModifierFlags.Abstract */);
            if (baseSignatures.length === 0) {
                return [createSignature(undefined, classType.localTypeParameters, undefined, ts.emptyArray, classType, /*resolvedTypePredicate*/ undefined, 0, isAbstract ? 4 /* SignatureFlags.Abstract */ : 0 /* SignatureFlags.None */)];
            }
            var baseTypeNode = getBaseTypeNodeOfClass(classType);
            var isJavaScript = ts.isInJSFile(baseTypeNode);
            var typeArguments = typeArgumentsFromTypeReferenceNode(baseTypeNode);
            var typeArgCount = ts.length(typeArguments);
            var result = [];
            for (var _i = 0, baseSignatures_1 = baseSignatures; _i < baseSignatures_1.length; _i++) {
                var baseSig = baseSignatures_1[_i];
                var minTypeArgumentCount = getMinTypeArgumentCount(baseSig.typeParameters);
                var typeParamCount = ts.length(baseSig.typeParameters);
                if (isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount) {
                    var sig = typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig);
                    sig.typeParameters = classType.localTypeParameters;
                    sig.resolvedReturnType = classType;
                    sig.flags = isAbstract ? sig.flags | 4 /* SignatureFlags.Abstract */ : sig.flags & ~4 /* SignatureFlags.Abstract */;
                    result.push(sig);
                }
            }
            return result;
        }
        function findMatchingSignature(signatureList, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes) {
            for (var _i = 0, signatureList_1 = signatureList; _i < signatureList_1.length; _i++) {
                var s = signatureList_1[_i];
                if (compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, partialMatch ? compareTypesSubtypeOf : compareTypesIdentical)) {
                    return s;
                }
            }
        }
        function findMatchingSignatures(signatureLists, signature, listIndex) {
            if (signature.typeParameters) {
                // We require an exact match for generic signatures, so we only return signatures from the first
                // signature list and only if they have exact matches in the other signature lists.
                if (listIndex > 0) {
                    return undefined;
                }
                for (var i = 1; i < signatureLists.length; i++) {
                    if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false)) {
                        return undefined;
                    }
                }
                return [signature];
            }
            var result;
            for (var i = 0; i < signatureLists.length; i++) {
                // Allow matching non-generic signatures to have excess parameters and different return types.
                // Prefer matching this types if possible.
                var match = i === listIndex ? signature : findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ true, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true);
                if (!match) {
                    return undefined;
                }
                result = ts.appendIfUnique(result, match);
            }
            return result;
        }
        // The signatures of a union type are those signatures that are present in each of the constituent types.
        // Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
        // parameters and may differ in return types. When signatures differ in return types, the resulting return
        // type is the union of the constituent return types.
        function getUnionSignatures(signatureLists) {
            var result;
            var indexWithLengthOverOne;
            for (var i = 0; i < signatureLists.length; i++) {
                if (signatureLists[i].length === 0)
                    return ts.emptyArray;
                if (signatureLists[i].length > 1) {
                    indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1; // -1 is a signal there are multiple overload sets
                }
                for (var _i = 0, _a = signatureLists[i]; _i < _a.length; _i++) {
                    var signature = _a[_i];
                    // Only process signatures with parameter lists that aren't already in the result list
                    if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true)) {
                        var unionSignatures = findMatchingSignatures(signatureLists, signature, i);
                        if (unionSignatures) {
                            var s = signature;
                            // Union the result types when more than one signature matches
                            if (unionSignatures.length > 1) {
                                var thisParameter = signature.thisParameter;
                                var firstThisParameterOfUnionSignatures = ts.forEach(unionSignatures, function (sig) { return sig.thisParameter; });
                                if (firstThisParameterOfUnionSignatures) {
                                    var thisType = getIntersectionType(ts.mapDefined(unionSignatures, function (sig) { return sig.thisParameter && getTypeOfSymbol(sig.thisParameter); }));
                                    thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);
                                }
                                s = createUnionSignature(signature, unionSignatures);
                                s.thisParameter = thisParameter;
                            }
                            (result || (result = [])).push(s);
                        }
                    }
                }
            }
            if (!ts.length(result) && indexWithLengthOverOne !== -1) {
                // No sufficiently similar signature existed to subsume all the other signatures in the union - time to see if we can make a single
                // signature that handles all over them. We only do this when there are overloads in only one constituent.
                // (Overloads are conditional in nature and having overloads in multiple constituents would necessitate making a power set of
                // signatures from the type, whose ordering would be non-obvious)
                var masterList = signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0];
                var results = masterList.slice();
                var _loop_10 = function (signatures) {
                    if (signatures !== masterList) {
                        var signature_1 = signatures[0];
                        ts.Debug.assert(!!signature_1, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass");
                        results = !!signature_1.typeParameters && ts.some(results, function (s) { return !!s.typeParameters && !compareTypeParametersIdentical(signature_1.typeParameters, s.typeParameters); }) ? undefined : ts.map(results, function (sig) { return combineSignaturesOfUnionMembers(sig, signature_1); });
                        if (!results) {
                            return "break";
                        }
                    }
                };
                for (var _b = 0, signatureLists_1 = signatureLists; _b < signatureLists_1.length; _b++) {
                    var signatures = signatureLists_1[_b];
                    var state_3 = _loop_10(signatures);
                    if (state_3 === "break")
                        break;
                }
                result = results;
            }
            return result || ts.emptyArray;
        }
        function compareTypeParametersIdentical(sourceParams, targetParams) {
            if (ts.length(sourceParams) !== ts.length(targetParams)) {
                return false;
            }
            if (!sourceParams || !targetParams) {
                return true;
            }
            var mapper = createTypeMapper(targetParams, sourceParams);
            for (var i = 0; i < sourceParams.length; i++) {
                var source = sourceParams[i];
                var target = targetParams[i];
                if (source === target)
                    continue;
                // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`
                if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper)))
                    return false;
                // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.
                // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing
                // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)
                // and, since it's just an inference _default_, just picking one arbitrarily works OK.
            }
            return true;
        }
        function combineUnionThisParam(left, right, mapper) {
            if (!left || !right) {
                return left || right;
            }
            // A signature `this` type might be a read or a write position... It's very possible that it should be invariant
            // and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
            // permissive when calling, for now, we'll intersect the `this` types just like we do for param types in union signatures.
            var thisType = getIntersectionType([getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)]);
            return createSymbolWithType(left, thisType);
        }
        function combineUnionParameters(left, right, mapper) {
            var leftCount = getParameterCount(left);
            var rightCount = getParameterCount(right);
            var longest = leftCount >= rightCount ? left : right;
            var shorter = longest === left ? right : left;
            var longestCount = longest === left ? leftCount : rightCount;
            var eitherHasEffectiveRest = (hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right));
            var needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
            var params = new Array(longestCount + (needsExtraRestElement ? 1 : 0));
            for (var i = 0; i < longestCount; i++) {
                var longestParamType = tryGetTypeAtPosition(longest, i);
                if (longest === right) {
                    longestParamType = instantiateType(longestParamType, mapper);
                }
                var shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
                if (shorter === right) {
                    shorterParamType = instantiateType(shorterParamType, mapper);
                }
                var unionParamType = getIntersectionType([longestParamType, shorterParamType]);
                var isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);
                var isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
                var leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);
                var rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);
                var paramName = leftName === rightName ? leftName :
                    !leftName ? rightName :
                        !rightName ? leftName :
                            undefined;
                var paramSymbol = createSymbol(1 /* SymbolFlags.FunctionScopedVariable */ | (isOptional && !isRestParam ? 16777216 /* SymbolFlags.Optional */ : 0), paramName || "arg".concat(i));
                paramSymbol.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
                params[i] = paramSymbol;
            }
            if (needsExtraRestElement) {
                var restParamSymbol = createSymbol(1 /* SymbolFlags.FunctionScopedVariable */, "args");
                restParamSymbol.type = createArrayType(getTypeAtPosition(shorter, longestCount));
                if (shorter === right) {
                    restParamSymbol.type = instantiateType(restParamSymbol.type, mapper);
                }
                params[longestCount] = restParamSymbol;
            }
            return params;
        }
        function combineSignaturesOfUnionMembers(left, right) {
            var typeParams = left.typeParameters || right.typeParameters;
            var paramMapper;
            if (left.typeParameters && right.typeParameters) {
                paramMapper = createTypeMapper(right.typeParameters, left.typeParameters);
                // We just use the type parameter defaults from the first signature
            }
            var declaration = left.declaration;
            var params = combineUnionParameters(left, right, paramMapper);
            var thisParam = combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper);
            var minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
            var result = createSignature(declaration, typeParams, thisParam, params, 
            /*resolvedReturnType*/ undefined, 
            /*resolvedTypePredicate*/ undefined, minArgCount, (left.flags | right.flags) & 39 /* SignatureFlags.PropagatingFlags */);
            result.compositeKind = 1048576 /* TypeFlags.Union */;
            result.compositeSignatures = ts.concatenate(left.compositeKind !== 2097152 /* TypeFlags.Intersection */ && left.compositeSignatures || [left], [right]);
            if (paramMapper) {
                result.mapper = left.compositeKind !== 2097152 /* TypeFlags.Intersection */ && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper;
            }
            return result;
        }
        function getUnionIndexInfos(types) {
            var sourceInfos = getIndexInfosOfType(types[0]);
            if (sourceInfos) {
                var result = [];
                var _loop_11 = function (info) {
                    var indexType = info.keyType;
                    if (ts.every(types, function (t) { return !!getIndexInfoOfType(t, indexType); })) {
                        result.push(createIndexInfo(indexType, getUnionType(ts.map(types, function (t) { return getIndexTypeOfType(t, indexType); })), ts.some(types, function (t) { return getIndexInfoOfType(t, indexType).isReadonly; })));
                    }
                };
                for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {
                    var info = sourceInfos_1[_i];
                    _loop_11(info);
                }
                return result;
            }
            return ts.emptyArray;
        }
        function resolveUnionTypeMembers(type) {
            // The members and properties collections are empty for union types. To get all properties of a union
            // type use getPropertiesOfType (only the language service uses this).
            var callSignatures = getUnionSignatures(ts.map(type.types, function (t) { return t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, 0 /* SignatureKind.Call */); }));
            var constructSignatures = getUnionSignatures(ts.map(type.types, function (t) { return getSignaturesOfType(t, 1 /* SignatureKind.Construct */); }));
            var indexInfos = getUnionIndexInfos(type.types);
            setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, indexInfos);
        }
        function intersectTypes(type1, type2) {
            return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);
        }
        function findMixins(types) {
            var constructorTypeCount = ts.countWhere(types, function (t) { return getSignaturesOfType(t, 1 /* SignatureKind.Construct */).length > 0; });
            var mixinFlags = ts.map(types, isMixinConstructorType);
            if (constructorTypeCount > 0 && constructorTypeCount === ts.countWhere(mixinFlags, function (b) { return b; })) {
                var firstMixinIndex = mixinFlags.indexOf(/*searchElement*/ true);
                mixinFlags[firstMixinIndex] = false;
            }
            return mixinFlags;
        }
        function includeMixinType(type, types, mixinFlags, index) {
            var mixedTypes = [];
            for (var i = 0; i < types.length; i++) {
                if (i === index) {
                    mixedTypes.push(type);
                }
                else if (mixinFlags[i]) {
                    mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], 1 /* SignatureKind.Construct */)[0]));
                }
            }
            return getIntersectionType(mixedTypes);
        }
        function resolveIntersectionTypeMembers(type) {
            // The members and properties collections are empty for intersection types. To get all properties of an
            // intersection type use getPropertiesOfType (only the language service uses this).
            var callSignatures;
            var constructSignatures;
            var indexInfos;
            var types = type.types;
            var mixinFlags = findMixins(types);
            var mixinCount = ts.countWhere(mixinFlags, function (b) { return b; });
            var _loop_12 = function (i) {
                var t = type.types[i];
                // When an intersection type contains mixin constructor types, the construct signatures from
                // those types are discarded and their return types are mixed into the return types of all
                // other construct signatures in the intersection type. For example, the intersection type
                // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature
                // 'new(s: string) => A & B'.
                if (!mixinFlags[i]) {
                    var signatures = getSignaturesOfType(t, 1 /* SignatureKind.Construct */);
                    if (signatures.length && mixinCount > 0) {
                        signatures = ts.map(signatures, function (s) {
                            var clone = cloneSignature(s);
                            clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);
                            return clone;
                        });
                    }
                    constructSignatures = appendSignatures(constructSignatures, signatures);
                }
                callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, 0 /* SignatureKind.Call */));
                indexInfos = ts.reduceLeft(getIndexInfosOfType(t), function (infos, newInfo) { return appendIndexInfo(infos, newInfo, /*union*/ false); }, indexInfos);
            };
            for (var i = 0; i < types.length; i++) {
                _loop_12(i);
            }
            setStructuredTypeMembers(type, emptySymbols, callSignatures || ts.emptyArray, constructSignatures || ts.emptyArray, indexInfos || ts.emptyArray);
        }
        function appendSignatures(signatures, newSignatures) {
            var _loop_13 = function (sig) {
                if (!signatures || ts.every(signatures, function (s) { return !compareSignaturesIdentical(s, sig, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false, compareTypesIdentical); })) {
                    signatures = ts.append(signatures, sig);
                }
            };
            for (var _i = 0, newSignatures_1 = newSignatures; _i < newSignatures_1.length; _i++) {
                var sig = newSignatures_1[_i];
                _loop_13(sig);
            }
            return signatures;
        }
        function appendIndexInfo(indexInfos, newInfo, union) {
            if (indexInfos) {
                for (var i = 0; i < indexInfos.length; i++) {
                    var info = indexInfos[i];
                    if (info.keyType === newInfo.keyType) {
                        indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);
                        return indexInfos;
                    }
                }
            }
            return ts.append(indexInfos, newInfo);
        }
        /**
         * Converts an AnonymousType to a ResolvedType.
         */
        function resolveAnonymousTypeMembers(type) {
            if (type.target) {
                setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                var members_6 = createInstantiatedSymbolTable(getPropertiesOfObjectType(type.target), type.mapper, /*mappingThisOnly*/ false);
                var callSignatures = instantiateSignatures(getSignaturesOfType(type.target, 0 /* SignatureKind.Call */), type.mapper);
                var constructSignatures = instantiateSignatures(getSignaturesOfType(type.target, 1 /* SignatureKind.Construct */), type.mapper);
                var indexInfos_1 = instantiateIndexInfos(getIndexInfosOfType(type.target), type.mapper);
                setStructuredTypeMembers(type, members_6, callSignatures, constructSignatures, indexInfos_1);
                return;
            }
            var symbol = getMergedSymbol(type.symbol);
            if (symbol.flags & 2048 /* SymbolFlags.TypeLiteral */) {
                setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                var members_7 = getMembersOfSymbol(symbol);
                var callSignatures = getSignaturesOfSymbol(members_7.get("__call" /* InternalSymbolName.Call */));
                var constructSignatures = getSignaturesOfSymbol(members_7.get("__new" /* InternalSymbolName.New */));
                var indexInfos_2 = getIndexInfosOfSymbol(symbol);
                setStructuredTypeMembers(type, members_7, callSignatures, constructSignatures, indexInfos_2);
                return;
            }
            // Combinations of function, class, enum and module
            var members = emptySymbols;
            var indexInfos;
            if (symbol.exports) {
                members = getExportsOfSymbol(symbol);
                if (symbol === globalThisSymbol) {
                    var varsOnly_1 = new ts.Map();
                    members.forEach(function (p) {
                        var _a;
                        if (!(p.flags & 418 /* SymbolFlags.BlockScoped */) && !(p.flags & 512 /* SymbolFlags.ValueModule */ && ((_a = p.declarations) === null || _a === void 0 ? void 0 : _a.length) && ts.every(p.declarations, ts.isAmbientModule))) {
                            varsOnly_1.set(p.escapedName, p);
                        }
                    });
                    members = varsOnly_1;
                }
            }
            var baseConstructorIndexInfo;
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            if (symbol.flags & 32 /* SymbolFlags.Class */) {
                var classType = getDeclaredTypeOfClassOrInterface(symbol);
                var baseConstructorType = getBaseConstructorTypeOfClass(classType);
                if (baseConstructorType.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */ | 8650752 /* TypeFlags.TypeVariable */)) {
                    members = ts.createSymbolTable(getNamedOrIndexSignatureMembers(members));
                    addInheritedMembers(members, getPropertiesOfType(baseConstructorType));
                }
                else if (baseConstructorType === anyType) {
                    baseConstructorIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly*/ false);
                }
            }
            var indexSymbol = getIndexSymbolFromSymbolTable(members);
            if (indexSymbol) {
                indexInfos = getIndexInfosOfIndexSymbol(indexSymbol);
            }
            else {
                if (baseConstructorIndexInfo) {
                    indexInfos = ts.append(indexInfos, baseConstructorIndexInfo);
                }
                if (symbol.flags & 384 /* SymbolFlags.Enum */ && (getDeclaredTypeOfSymbol(symbol).flags & 32 /* TypeFlags.Enum */ ||
                    ts.some(type.properties, function (prop) { return !!(getTypeOfSymbol(prop).flags & 296 /* TypeFlags.NumberLike */); }))) {
                    indexInfos = ts.append(indexInfos, enumNumberIndexInfo);
                }
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos || ts.emptyArray);
            // We resolve the members before computing the signatures because a signature may use
            // typeof with a qualified name expression that circularly references the type we are
            // in the process of resolving (see issue #6072). The temporarily empty signature list
            // will never be observed because a qualified name can't reference signatures.
            if (symbol.flags & (16 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Method */)) {
                type.callSignatures = getSignaturesOfSymbol(symbol);
            }
            // And likewise for construct signatures for classes
            if (symbol.flags & 32 /* SymbolFlags.Class */) {
                var classType_1 = getDeclaredTypeOfClassOrInterface(symbol);
                var constructSignatures = symbol.members ? getSignaturesOfSymbol(symbol.members.get("__constructor" /* InternalSymbolName.Constructor */)) : ts.emptyArray;
                if (symbol.flags & 16 /* SymbolFlags.Function */) {
                    constructSignatures = ts.addRange(constructSignatures.slice(), ts.mapDefined(type.callSignatures, function (sig) { return isJSConstructor(sig.declaration) ?
                        createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType_1, /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & 39 /* SignatureFlags.PropagatingFlags */) :
                        undefined; }));
                }
                if (!constructSignatures.length) {
                    constructSignatures = getDefaultConstructSignatures(classType_1);
                }
                type.constructSignatures = constructSignatures;
            }
        }
        function replaceIndexedAccess(instantiable, type, replacement) {
            // map type.indexType to 0
            // map type.objectType to `[TReplacement]`
            // thus making the indexed access `[TReplacement][0]` or `TReplacement`
            return instantiateType(instantiable, createTypeMapper([type.indexType, type.objectType], [getNumberLiteralType(0), createTupleType([replacement])]));
        }
        function resolveReverseMappedTypeMembers(type) {
            var indexInfo = getIndexInfoOfType(type.source, stringType);
            var modifiers = getMappedTypeModifiers(type.mappedType);
            var readonlyMask = modifiers & 1 /* MappedTypeModifiers.IncludeReadonly */ ? false : true;
            var optionalMask = modifiers & 4 /* MappedTypeModifiers.IncludeOptional */ ? 0 : 16777216 /* SymbolFlags.Optional */;
            var indexInfos = indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType), readonlyMask && indexInfo.isReadonly)] : ts.emptyArray;
            var members = ts.createSymbolTable();
            for (var _i = 0, _a = getPropertiesOfType(type.source); _i < _a.length; _i++) {
                var prop = _a[_i];
                var checkFlags = 8192 /* CheckFlags.ReverseMapped */ | (readonlyMask && isReadonlySymbol(prop) ? 8 /* CheckFlags.Readonly */ : 0);
                var inferredProp = createSymbol(4 /* SymbolFlags.Property */ | prop.flags & optionalMask, prop.escapedName, checkFlags);
                inferredProp.declarations = prop.declarations;
                inferredProp.nameType = getSymbolLinks(prop).nameType;
                inferredProp.propertyType = getTypeOfSymbol(prop);
                if (type.constraintType.type.flags & 8388608 /* TypeFlags.IndexedAccess */
                    && type.constraintType.type.objectType.flags & 262144 /* TypeFlags.TypeParameter */
                    && type.constraintType.type.indexType.flags & 262144 /* TypeFlags.TypeParameter */) {
                    // A reverse mapping of `{[K in keyof T[K_1]]: T[K_1]}` is the same as that of `{[K in keyof T]: T}`, since all we care about is
                    // inferring to the "type parameter" (or indexed access) shared by the constraint and template. So, to reduce the number of
                    // type identities produced, we simplify such indexed access occurences
                    var newTypeParam = type.constraintType.type.objectType;
                    var newMappedType = replaceIndexedAccess(type.mappedType, type.constraintType.type, newTypeParam);
                    inferredProp.mappedType = newMappedType;
                    inferredProp.constraintType = getIndexType(newTypeParam);
                }
                else {
                    inferredProp.mappedType = type.mappedType;
                    inferredProp.constraintType = type.constraintType;
                }
                members.set(prop.escapedName, inferredProp);
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos);
        }
        // Return the lower bound of the key type in a mapped type. Intuitively, the lower
        // bound includes those keys that are known to always be present, for example because
        // because of constraints on type parameters (e.g. 'keyof T' for a constrained T).
        function getLowerBoundOfKeyType(type) {
            if (type.flags & 4194304 /* TypeFlags.Index */) {
                var t = getApparentType(type.type);
                return isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t);
            }
            if (type.flags & 16777216 /* TypeFlags.Conditional */) {
                if (type.root.isDistributive) {
                    var checkType = type.checkType;
                    var constraint = getLowerBoundOfKeyType(checkType);
                    if (constraint !== checkType) {
                        return getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                    }
                }
                return type;
            }
            if (type.flags & 1048576 /* TypeFlags.Union */) {
                return mapType(type, getLowerBoundOfKeyType);
            }
            if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                return getIntersectionType(ts.sameMap(type.types, getLowerBoundOfKeyType));
            }
            return type;
        }
        function getIsLateCheckFlag(s) {
            return ts.getCheckFlags(s) & 4096 /* CheckFlags.Late */;
        }
        function forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(type, include, stringsOnly, cb) {
            for (var _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
                var prop = _a[_i];
                cb(getLiteralTypeFromProperty(prop, include));
            }
            if (type.flags & 1 /* TypeFlags.Any */) {
                cb(stringType);
            }
            else {
                for (var _b = 0, _c = getIndexInfosOfType(type); _b < _c.length; _b++) {
                    var info = _c[_b];
                    if (!stringsOnly || info.keyType.flags & (4 /* TypeFlags.String */ | 134217728 /* TypeFlags.TemplateLiteral */)) {
                        cb(info.keyType);
                    }
                }
            }
        }
        /** Resolve the members of a mapped type { [P in K]: T } */
        function resolveMappedTypeMembers(type) {
            var members = ts.createSymbolTable();
            var indexInfos;
            // Resolve upfront such that recursive references see an empty object type.
            setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            // In { [P in K]: T }, we refer to P as the type parameter type, K as the constraint type,
            // and T as the template type.
            var typeParameter = getTypeParameterFromMappedType(type);
            var constraintType = getConstraintTypeFromMappedType(type);
            var nameType = getNameTypeFromMappedType(type.target || type);
            var templateType = getTemplateTypeFromMappedType(type.target || type);
            var modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
            var templateModifiers = getMappedTypeModifiers(type);
            var include = keyofStringsOnly ? 128 /* TypeFlags.StringLiteral */ : 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */;
            if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                // We have a { [P in keyof T]: X }
                forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include, keyofStringsOnly, addMemberForKeyType);
            }
            else {
                forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos || ts.emptyArray);
            function addMemberForKeyType(keyType) {
                var propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
                forEachType(propNameType, function (t) { return addMemberForKeyTypeWorker(keyType, t); });
            }
            function addMemberForKeyTypeWorker(keyType, propNameType) {
                // If the current iteration type constituent is a string literal type, create a property.
                // Otherwise, for type string create a string index signature.
                if (isTypeUsableAsPropertyName(propNameType)) {
                    var propName = getPropertyNameFromType(propNameType);
                    // String enum members from separate enums with identical values
                    // are distinct types with the same property name. Make the resulting
                    // property symbol's name type be the union of those enum member types.
                    var existingProp = members.get(propName);
                    if (existingProp) {
                        existingProp.nameType = getUnionType([existingProp.nameType, propNameType]);
                        existingProp.keyType = getUnionType([existingProp.keyType, keyType]);
                    }
                    else {
                        var modifiersProp = isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined;
                        var isOptional = !!(templateModifiers & 4 /* MappedTypeModifiers.IncludeOptional */ ||
                            !(templateModifiers & 8 /* MappedTypeModifiers.ExcludeOptional */) && modifiersProp && modifiersProp.flags & 16777216 /* SymbolFlags.Optional */);
                        var isReadonly = !!(templateModifiers & 1 /* MappedTypeModifiers.IncludeReadonly */ ||
                            !(templateModifiers & 2 /* MappedTypeModifiers.ExcludeReadonly */) && modifiersProp && isReadonlySymbol(modifiersProp));
                        var stripOptional = strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags & 16777216 /* SymbolFlags.Optional */;
                        var lateFlag = modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0;
                        var prop = createSymbol(4 /* SymbolFlags.Property */ | (isOptional ? 16777216 /* SymbolFlags.Optional */ : 0), propName, lateFlag | 262144 /* CheckFlags.Mapped */ | (isReadonly ? 8 /* CheckFlags.Readonly */ : 0) | (stripOptional ? 524288 /* CheckFlags.StripOptional */ : 0));
                        prop.mappedType = type;
                        prop.nameType = propNameType;
                        prop.keyType = keyType;
                        if (modifiersProp) {
                            prop.syntheticOrigin = modifiersProp;
                            // If the mapped type has an `as XXX` clause, the property name likely won't match the declaration name and
                            // multiple properties may map to the same name. Thus, we attach no declarations to the symbol.
                            prop.declarations = nameType ? undefined : modifiersProp.declarations;
                        }
                        members.set(propName, prop);
                    }
                }
                else if (isValidIndexKeyType(propNameType) || propNameType.flags & (1 /* TypeFlags.Any */ | 32 /* TypeFlags.Enum */)) {
                    var indexKeyType = propNameType.flags & (1 /* TypeFlags.Any */ | 4 /* TypeFlags.String */) ? stringType :
                        propNameType.flags & (8 /* TypeFlags.Number */ | 32 /* TypeFlags.Enum */) ? numberType :
                            propNameType;
                    var propType = instantiateType(templateType, appendTypeMapping(type.mapper, typeParameter, keyType));
                    var indexInfo = createIndexInfo(indexKeyType, propType, !!(templateModifiers & 1 /* MappedTypeModifiers.IncludeReadonly */));
                    indexInfos = appendIndexInfo(indexInfos, indexInfo, /*union*/ true);
                }
            }
        }
        function getTypeOfMappedSymbol(symbol) {
            if (!symbol.type) {
                var mappedType = symbol.mappedType;
                if (!pushTypeResolution(symbol, 0 /* TypeSystemPropertyName.Type */)) {
                    mappedType.containsError = true;
                    return errorType;
                }
                var templateType = getTemplateTypeFromMappedType(mappedType.target || mappedType);
                var mapper = appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.keyType);
                var propType = instantiateType(templateType, mapper);
                // When creating an optional property in strictNullChecks mode, if 'undefined' isn't assignable to the
                // type, we include 'undefined' in the type. Similarly, when creating a non-optional property in strictNullChecks
                // mode, if the underlying property is optional we remove 'undefined' from the type.
                var type = strictNullChecks && symbol.flags & 16777216 /* SymbolFlags.Optional */ && !maybeTypeOfKind(propType, 32768 /* TypeFlags.Undefined */ | 16384 /* TypeFlags.Void */) ? getOptionalType(propType, /*isProperty*/ true) :
                    symbol.checkFlags & 524288 /* CheckFlags.StripOptional */ ? removeMissingOrUndefinedType(propType) :
                        propType;
                if (!popTypeResolution()) {
                    error(currentNode, ts.Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType));
                    type = errorType;
                }
                symbol.type = type;
            }
            return symbol.type;
        }
        function getTypeParameterFromMappedType(type) {
            return type.typeParameter ||
                (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(type.declaration.typeParameter)));
        }
        function getConstraintTypeFromMappedType(type) {
            return type.constraintType ||
                (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType);
        }
        function getNameTypeFromMappedType(type) {
            return type.declaration.nameType ?
                type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :
                undefined;
        }
        function getTemplateTypeFromMappedType(type) {
            return type.templateType ||
                (type.templateType = type.declaration.type ?
                    instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty*/ true, !!(getMappedTypeModifiers(type) & 4 /* MappedTypeModifiers.IncludeOptional */)), type.mapper) :
                    errorType);
        }
        function getConstraintDeclarationForMappedType(type) {
            return ts.getEffectiveConstraintOfTypeParameter(type.declaration.typeParameter);
        }
        function isMappedTypeWithKeyofConstraintDeclaration(type) {
            var constraintDeclaration = getConstraintDeclarationForMappedType(type); // TODO: GH#18217
            return constraintDeclaration.kind === 193 /* SyntaxKind.TypeOperator */ &&
                constraintDeclaration.operator === 140 /* SyntaxKind.KeyOfKeyword */;
        }
        function getModifiersTypeFromMappedType(type) {
            if (!type.modifiersType) {
                if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                    // If the constraint declaration is a 'keyof T' node, the modifiers type is T. We check
                    // AST nodes here because, when T is a non-generic type, the logic below eagerly resolves
                    // 'keyof T' to a literal union type and we can't recover T from that type.
                    type.modifiersType = instantiateType(getTypeFromTypeNode(getConstraintDeclarationForMappedType(type).type), type.mapper);
                }
                else {
                    // Otherwise, get the declared constraint type, and if the constraint type is a type parameter,
                    // get the constraint of that type parameter. If the resulting type is an indexed type 'keyof T',
                    // the modifiers type is T. Otherwise, the modifiers type is unknown.
                    var declaredType = getTypeFromMappedTypeNode(type.declaration);
                    var constraint = getConstraintTypeFromMappedType(declaredType);
                    var extendedConstraint = constraint && constraint.flags & 262144 /* TypeFlags.TypeParameter */ ? getConstraintOfTypeParameter(constraint) : constraint;
                    type.modifiersType = extendedConstraint && extendedConstraint.flags & 4194304 /* TypeFlags.Index */ ? instantiateType(extendedConstraint.type, type.mapper) : unknownType;
                }
            }
            return type.modifiersType;
        }
        function getMappedTypeModifiers(type) {
            var declaration = type.declaration;
            return (declaration.readonlyToken ? declaration.readonlyToken.kind === 40 /* SyntaxKind.MinusToken */ ? 2 /* MappedTypeModifiers.ExcludeReadonly */ : 1 /* MappedTypeModifiers.IncludeReadonly */ : 0) |
                (declaration.questionToken ? declaration.questionToken.kind === 40 /* SyntaxKind.MinusToken */ ? 8 /* MappedTypeModifiers.ExcludeOptional */ : 4 /* MappedTypeModifiers.IncludeOptional */ : 0);
        }
        function getMappedTypeOptionality(type) {
            var modifiers = getMappedTypeModifiers(type);
            return modifiers & 8 /* MappedTypeModifiers.ExcludeOptional */ ? -1 : modifiers & 4 /* MappedTypeModifiers.IncludeOptional */ ? 1 : 0;
        }
        function getCombinedMappedTypeOptionality(type) {
            var optionality = getMappedTypeOptionality(type);
            var modifiersType = getModifiersTypeFromMappedType(type);
            return optionality || (isGenericMappedType(modifiersType) ? getMappedTypeOptionality(modifiersType) : 0);
        }
        function isPartialMappedType(type) {
            return !!(ts.getObjectFlags(type) & 32 /* ObjectFlags.Mapped */ && getMappedTypeModifiers(type) & 4 /* MappedTypeModifiers.IncludeOptional */);
        }
        function isGenericMappedType(type) {
            return !!(ts.getObjectFlags(type) & 32 /* ObjectFlags.Mapped */) && isGenericIndexType(getConstraintTypeFromMappedType(type));
        }
        function resolveStructuredTypeMembers(type) {
            if (!type.members) {
                if (type.flags & 524288 /* TypeFlags.Object */) {
                    if (type.objectFlags & 4 /* ObjectFlags.Reference */) {
                        resolveTypeReferenceMembers(type);
                    }
                    else if (type.objectFlags & 3 /* ObjectFlags.ClassOrInterface */) {
                        resolveClassOrInterfaceMembers(type);
                    }
                    else if (type.objectFlags & 1024 /* ObjectFlags.ReverseMapped */) {
                        resolveReverseMappedTypeMembers(type);
                    }
                    else if (type.objectFlags & 16 /* ObjectFlags.Anonymous */) {
                        resolveAnonymousTypeMembers(type);
                    }
                    else if (type.objectFlags & 32 /* ObjectFlags.Mapped */) {
                        resolveMappedTypeMembers(type);
                    }
                }
                else if (type.flags & 1048576 /* TypeFlags.Union */) {
                    resolveUnionTypeMembers(type);
                }
                else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                    resolveIntersectionTypeMembers(type);
                }
            }
            return type;
        }
        /** Return properties of an object type or an empty array for other types */
        function getPropertiesOfObjectType(type) {
            if (type.flags & 524288 /* TypeFlags.Object */) {
                return resolveStructuredTypeMembers(type).properties;
            }
            return ts.emptyArray;
        }
        /** If the given type is an object type and that type has a property by the given name,
         * return the symbol for that property. Otherwise return undefined.
         */
        function getPropertyOfObjectType(type, name) {
            if (type.flags & 524288 /* TypeFlags.Object */) {
                var resolved = resolveStructuredTypeMembers(type);
                var symbol = resolved.members.get(name);
                if (symbol && symbolIsValue(symbol)) {
                    return symbol;
                }
            }
        }
        function getPropertiesOfUnionOrIntersectionType(type) {
            if (!type.resolvedProperties) {
                var members = ts.createSymbolTable();
                for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                    var current = _a[_i];
                    for (var _b = 0, _c = getPropertiesOfType(current); _b < _c.length; _b++) {
                        var prop = _c[_b];
                        if (!members.has(prop.escapedName)) {
                            var combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.escapedName);
                            if (combinedProp) {
                                members.set(prop.escapedName, combinedProp);
                            }
                        }
                    }
                    // The properties of a union type are those that are present in all constituent types, so
                    // we only need to check the properties of the first type without index signature
                    if (type.flags & 1048576 /* TypeFlags.Union */ && getIndexInfosOfType(current).length === 0) {
                        break;
                    }
                }
                type.resolvedProperties = getNamedMembers(members);
            }
            return type.resolvedProperties;
        }
        function getPropertiesOfType(type) {
            type = getReducedApparentType(type);
            return type.flags & 3145728 /* TypeFlags.UnionOrIntersection */ ?
                getPropertiesOfUnionOrIntersectionType(type) :
                getPropertiesOfObjectType(type);
        }
        function forEachPropertyOfType(type, action) {
            type = getReducedApparentType(type);
            if (type.flags & 3670016 /* TypeFlags.StructuredType */) {
                resolveStructuredTypeMembers(type).members.forEach(function (symbol, escapedName) {
                    if (isNamedMember(symbol, escapedName)) {
                        action(symbol, escapedName);
                    }
                });
            }
        }
        function isTypeInvalidDueToUnionDiscriminant(contextualType, obj) {
            var list = obj.properties;
            return list.some(function (property) {
                var nameType = property.name && getLiteralTypeFromPropertyName(property.name);
                var name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
                var expected = name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name);
                return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);
            });
        }
        function getAllPossiblePropertiesOfTypes(types) {
            var unionType = getUnionType(types);
            if (!(unionType.flags & 1048576 /* TypeFlags.Union */)) {
                return getAugmentedPropertiesOfType(unionType);
            }
            var props = ts.createSymbolTable();
            for (var _i = 0, types_4 = types; _i < types_4.length; _i++) {
                var memberType = types_4[_i];
                for (var _a = 0, _b = getAugmentedPropertiesOfType(memberType); _a < _b.length; _a++) {
                    var escapedName = _b[_a].escapedName;
                    if (!props.has(escapedName)) {
                        var prop = createUnionOrIntersectionProperty(unionType, escapedName);
                        // May be undefined if the property is private
                        if (prop)
                            props.set(escapedName, prop);
                    }
                }
            }
            return ts.arrayFrom(props.values());
        }
        function getConstraintOfType(type) {
            return type.flags & 262144 /* TypeFlags.TypeParameter */ ? getConstraintOfTypeParameter(type) :
                type.flags & 8388608 /* TypeFlags.IndexedAccess */ ? getConstraintOfIndexedAccess(type) :
                    type.flags & 16777216 /* TypeFlags.Conditional */ ? getConstraintOfConditionalType(type) :
                        getBaseConstraintOfType(type);
        }
        function getConstraintOfTypeParameter(typeParameter) {
            return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined;
        }
        function getConstraintOfIndexedAccess(type) {
            return hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined;
        }
        function getSimplifiedTypeOrConstraint(type) {
            var simplified = getSimplifiedType(type, /*writing*/ false);
            return simplified !== type ? simplified : getConstraintOfType(type);
        }
        function getConstraintFromIndexedAccess(type) {
            if (isMappedTypeGenericIndexedAccess(type)) {
                // For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
                // we substitute an instantiation of E where P is replaced with X.
                return substituteIndexedMappedType(type.objectType, type.indexType);
            }
            var indexConstraint = getSimplifiedTypeOrConstraint(type.indexType);
            if (indexConstraint && indexConstraint !== type.indexType) {
                var indexedAccess = getIndexedAccessTypeOrUndefined(type.objectType, indexConstraint, type.accessFlags);
                if (indexedAccess) {
                    return indexedAccess;
                }
            }
            var objectConstraint = getSimplifiedTypeOrConstraint(type.objectType);
            if (objectConstraint && objectConstraint !== type.objectType) {
                return getIndexedAccessTypeOrUndefined(objectConstraint, type.indexType, type.accessFlags);
            }
            return undefined;
        }
        function getDefaultConstraintOfConditionalType(type) {
            if (!type.resolvedDefaultConstraint) {
                // An `any` branch of a conditional type would normally be viral - specifically, without special handling here,
                // a conditional type with a single branch of type `any` would be assignable to anything, since it's constraint would simplify to
                // just `any`. This result is _usually_ unwanted - so instead here we elide an `any` branch from the constraint type,
                // in effect treating `any` like `never` rather than `unknown` in this location.
                var trueConstraint = getInferredTrueTypeFromConditionalType(type);
                var falseConstraint = getFalseTypeFromConditionalType(type);
                type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]);
            }
            return type.resolvedDefaultConstraint;
        }
        function getConstraintOfDistributiveConditionalType(type) {
            // Check if we have a conditional type of the form 'T extends U ? X : Y', where T is a constrained
            // type parameter. If so, create an instantiation of the conditional type where T is replaced
            // with its constraint. We do this because if the constraint is a union type it will be distributed
            // over the conditional type and possibly reduced. For example, 'T extends undefined ? never : T'
            // removes 'undefined' from T.
            // We skip returning a distributive constraint for a restrictive instantiation of a conditional type
            // as the constraint for all type params (check type included) have been replace with `unknown`, which
            // is going to produce even more false positive/negative results than the distribute constraint already does.
            // Please note: the distributive constraint is a kludge for emulating what a negated type could to do filter
            // a union - once negated types exist and are applied to the conditional false branch, this "constraint"
            // likely doesn't need to exist.
            if (type.root.isDistributive && type.restrictiveInstantiation !== type) {
                var simplified = getSimplifiedType(type.checkType, /*writing*/ false);
                var constraint = simplified === type.checkType ? getConstraintOfType(simplified) : simplified;
                if (constraint && constraint !== type.checkType) {
                    var instantiated = getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                    if (!(instantiated.flags & 131072 /* TypeFlags.Never */)) {
                        return instantiated;
                    }
                }
            }
            return undefined;
        }
        function getConstraintFromConditionalType(type) {
            return getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(type);
        }
        function getConstraintOfConditionalType(type) {
            return hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined;
        }
        function getEffectiveConstraintOfIntersection(types, targetIsUnion) {
            var constraints;
            var hasDisjointDomainType = false;
            for (var _i = 0, types_5 = types; _i < types_5.length; _i++) {
                var t = types_5[_i];
                if (t.flags & 465829888 /* TypeFlags.Instantiable */) {
                    // We keep following constraints as long as we have an instantiable type that is known
                    // not to be circular or infinite (hence we stop on index access types).
                    var constraint = getConstraintOfType(t);
                    while (constraint && constraint.flags & (262144 /* TypeFlags.TypeParameter */ | 4194304 /* TypeFlags.Index */ | 16777216 /* TypeFlags.Conditional */)) {
                        constraint = getConstraintOfType(constraint);
                    }
                    if (constraint) {
                        constraints = ts.append(constraints, constraint);
                        if (targetIsUnion) {
                            constraints = ts.append(constraints, t);
                        }
                    }
                }
                else if (t.flags & 469892092 /* TypeFlags.DisjointDomains */) {
                    hasDisjointDomainType = true;
                }
            }
            // If the target is a union type or if we are intersecting with types belonging to one of the
            // disjoint domains, we may end up producing a constraint that hasn't been examined before.
            if (constraints && (targetIsUnion || hasDisjointDomainType)) {
                if (hasDisjointDomainType) {
                    // We add any types belong to one of the disjoint domains because they might cause the final
                    // intersection operation to reduce the union constraints.
                    for (var _a = 0, types_6 = types; _a < types_6.length; _a++) {
                        var t = types_6[_a];
                        if (t.flags & 469892092 /* TypeFlags.DisjointDomains */) {
                            constraints = ts.append(constraints, t);
                        }
                    }
                }
                return getIntersectionType(constraints);
            }
            return undefined;
        }
        function getBaseConstraintOfType(type) {
            if (type.flags & (58982400 /* TypeFlags.InstantiableNonPrimitive */ | 3145728 /* TypeFlags.UnionOrIntersection */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */)) {
                var constraint = getResolvedBaseConstraint(type);
                return constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined;
            }
            return type.flags & 4194304 /* TypeFlags.Index */ ? keyofConstraintType : undefined;
        }
        /**
         * This is similar to `getBaseConstraintOfType` except it returns the input type if there's no base constraint, instead of `undefined`
         * It also doesn't map indexes to `string`, as where this is used this would be unneeded (and likely undesirable)
         */
        function getBaseConstraintOrType(type) {
            return getBaseConstraintOfType(type) || type;
        }
        function hasNonCircularBaseConstraint(type) {
            return getResolvedBaseConstraint(type) !== circularConstraintType;
        }
        /**
         * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
         * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
         * circularly references the type variable.
         */
        function getResolvedBaseConstraint(type) {
            if (type.resolvedBaseConstraint) {
                return type.resolvedBaseConstraint;
            }
            var stack = [];
            return type.resolvedBaseConstraint = getTypeWithThisArgument(getImmediateBaseConstraint(type), type);
            function getImmediateBaseConstraint(t) {
                if (!t.immediateBaseConstraint) {
                    if (!pushTypeResolution(t, 4 /* TypeSystemPropertyName.ImmediateBaseConstraint */)) {
                        return circularConstraintType;
                    }
                    var result = void 0;
                    // We always explore at least 10 levels of nested constraints. Thereafter, we continue to explore
                    // up to 50 levels of nested constraints provided there are no "deeply nested" types on the stack
                    // (i.e. no types for which five instantiations have been recorded on the stack). If we reach 50
                    // levels of nesting, we are presumably exploring a repeating pattern with a long cycle that hasn't
                    // yet triggered the deeply nested limiter. We have no test cases that actually get to 50 levels of
                    // nesting, so it is effectively just a safety stop.
                    var identity_1 = getRecursionIdentity(t);
                    if (stack.length < 10 || stack.length < 50 && !ts.contains(stack, identity_1)) {
                        stack.push(identity_1);
                        result = computeBaseConstraint(getSimplifiedType(t, /*writing*/ false));
                        stack.pop();
                    }
                    if (!popTypeResolution()) {
                        if (t.flags & 262144 /* TypeFlags.TypeParameter */) {
                            var errorNode = getConstraintDeclaration(t);
                            if (errorNode) {
                                var diagnostic = error(errorNode, ts.Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t));
                                if (currentNode && !ts.isNodeDescendantOf(errorNode, currentNode) && !ts.isNodeDescendantOf(currentNode, errorNode)) {
                                    ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(currentNode, ts.Diagnostics.Circularity_originates_in_type_at_this_location));
                                }
                            }
                        }
                        result = circularConstraintType;
                    }
                    t.immediateBaseConstraint = result || noConstraintType;
                }
                return t.immediateBaseConstraint;
            }
            function getBaseConstraint(t) {
                var c = getImmediateBaseConstraint(t);
                return c !== noConstraintType && c !== circularConstraintType ? c : undefined;
            }
            function computeBaseConstraint(t) {
                if (t.flags & 262144 /* TypeFlags.TypeParameter */) {
                    var constraint = getConstraintFromTypeParameter(t);
                    return t.isThisType || !constraint ?
                        constraint :
                        getBaseConstraint(constraint);
                }
                if (t.flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                    var types = t.types;
                    var baseTypes = [];
                    var different = false;
                    for (var _i = 0, types_7 = types; _i < types_7.length; _i++) {
                        var type_4 = types_7[_i];
                        var baseType = getBaseConstraint(type_4);
                        if (baseType) {
                            if (baseType !== type_4) {
                                different = true;
                            }
                            baseTypes.push(baseType);
                        }
                        else {
                            different = true;
                        }
                    }
                    if (!different) {
                        return t;
                    }
                    return t.flags & 1048576 /* TypeFlags.Union */ && baseTypes.length === types.length ? getUnionType(baseTypes) :
                        t.flags & 2097152 /* TypeFlags.Intersection */ && baseTypes.length ? getIntersectionType(baseTypes) :
                            undefined;
                }
                if (t.flags & 4194304 /* TypeFlags.Index */) {
                    return keyofConstraintType;
                }
                if (t.flags & 134217728 /* TypeFlags.TemplateLiteral */) {
                    var types = t.types;
                    var constraints = ts.mapDefined(types, getBaseConstraint);
                    return constraints.length === types.length ? getTemplateLiteralType(t.texts, constraints) : stringType;
                }
                if (t.flags & 268435456 /* TypeFlags.StringMapping */) {
                    var constraint = getBaseConstraint(t.type);
                    return constraint ? getStringMappingType(t.symbol, constraint) : stringType;
                }
                if (t.flags & 8388608 /* TypeFlags.IndexedAccess */) {
                    if (isMappedTypeGenericIndexedAccess(t)) {
                        // For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
                        // we substitute an instantiation of E where P is replaced with X.
                        return getBaseConstraint(substituteIndexedMappedType(t.objectType, t.indexType));
                    }
                    var baseObjectType = getBaseConstraint(t.objectType);
                    var baseIndexType = getBaseConstraint(t.indexType);
                    var baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, t.accessFlags);
                    return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
                }
                if (t.flags & 16777216 /* TypeFlags.Conditional */) {
                    var constraint = getConstraintFromConditionalType(t);
                    return constraint && getBaseConstraint(constraint);
                }
                if (t.flags & 33554432 /* TypeFlags.Substitution */) {
                    return getBaseConstraint(t.substitute);
                }
                return t;
            }
        }
        function getApparentTypeOfIntersectionType(type) {
            return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, type, /*apparentType*/ true));
        }
        function getResolvedTypeParameterDefault(typeParameter) {
            if (!typeParameter.default) {
                if (typeParameter.target) {
                    var targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
                    typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
                }
                else {
                    // To block recursion, set the initial value to the resolvingDefaultType.
                    typeParameter.default = resolvingDefaultType;
                    var defaultDeclaration = typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; });
                    var defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
                    if (typeParameter.default === resolvingDefaultType) {
                        // If we have not been called recursively, set the correct default type.
                        typeParameter.default = defaultType;
                    }
                }
            }
            else if (typeParameter.default === resolvingDefaultType) {
                // If we are called recursively for this type parameter, mark the default as circular.
                typeParameter.default = circularConstraintType;
            }
            return typeParameter.default;
        }
        /**
         * Gets the default type for a type parameter.
         *
         * If the type parameter is the result of an instantiation, this gets the instantiated
         * default type of its target. If the type parameter has no default type or the default is
         * circular, `undefined` is returned.
         */
        function getDefaultFromTypeParameter(typeParameter) {
            var defaultType = getResolvedTypeParameterDefault(typeParameter);
            return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined;
        }
        function hasNonCircularTypeParameterDefault(typeParameter) {
            return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
        }
        /**
         * Indicates whether the declaration of a typeParameter has a default type.
         */
        function hasTypeParameterDefault(typeParameter) {
            return !!(typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; }));
        }
        function getApparentTypeOfMappedType(type) {
            return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type));
        }
        function getResolvedApparentTypeOfMappedType(type) {
            var typeVariable = getHomomorphicTypeVariable(type);
            if (typeVariable && !type.declaration.nameType) {
                var constraint = getConstraintOfTypeParameter(typeVariable);
                if (constraint && isArrayOrTupleType(constraint)) {
                    return instantiateType(type, prependTypeMapping(typeVariable, constraint, type.mapper));
                }
            }
            return type;
        }
        function isMappedTypeGenericIndexedAccess(type) {
            var objectType;
            return !!(type.flags & 8388608 /* TypeFlags.IndexedAccess */ && ts.getObjectFlags(objectType = type.objectType) & 32 /* ObjectFlags.Mapped */ &&
                !isGenericMappedType(objectType) && isGenericIndexType(type.indexType) &&
                !(getMappedTypeModifiers(objectType) & 8 /* MappedTypeModifiers.ExcludeOptional */) && !objectType.declaration.nameType);
        }
        /**
         * For a type parameter, return the base constraint of the type parameter. For the string, number,
         * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
         * type itself.
         */
        function getApparentType(type) {
            var t = !(type.flags & 465829888 /* TypeFlags.Instantiable */) ? type : getBaseConstraintOfType(type) || unknownType;
            return ts.getObjectFlags(t) & 32 /* ObjectFlags.Mapped */ ? getApparentTypeOfMappedType(t) :
                t.flags & 2097152 /* TypeFlags.Intersection */ ? getApparentTypeOfIntersectionType(t) :
                    t.flags & 402653316 /* TypeFlags.StringLike */ ? globalStringType :
                        t.flags & 296 /* TypeFlags.NumberLike */ ? globalNumberType :
                            t.flags & 2112 /* TypeFlags.BigIntLike */ ? getGlobalBigIntType() :
                                t.flags & 528 /* TypeFlags.BooleanLike */ ? globalBooleanType :
                                    t.flags & 12288 /* TypeFlags.ESSymbolLike */ ? getGlobalESSymbolType() :
                                        t.flags & 67108864 /* TypeFlags.NonPrimitive */ ? emptyObjectType :
                                            t.flags & 4194304 /* TypeFlags.Index */ ? keyofConstraintType :
                                                t.flags & 2 /* TypeFlags.Unknown */ && !strictNullChecks ? emptyObjectType :
                                                    t;
        }
        function getReducedApparentType(type) {
            // Since getApparentType may return a non-reduced union or intersection type, we need to perform
            // type reduction both before and after obtaining the apparent type. For example, given a type parameter
            // 'T extends A | B', the type 'T & X' becomes 'A & X | B & X' after obtaining the apparent type, and
            // that type may need further reduction to remove empty intersections.
            return getReducedType(getApparentType(getReducedType(type)));
        }
        function createUnionOrIntersectionProperty(containingType, name, skipObjectFunctionPropertyAugment) {
            var _a, _b;
            var singleProp;
            var propSet;
            var indexTypes;
            var isUnion = containingType.flags & 1048576 /* TypeFlags.Union */;
            // Flags we want to propagate to the result if they exist in all source symbols
            var optionalFlag = isUnion ? 0 /* SymbolFlags.None */ : 16777216 /* SymbolFlags.Optional */;
            var syntheticFlag = 4 /* CheckFlags.SyntheticMethod */;
            var checkFlags = isUnion ? 0 : 8 /* CheckFlags.Readonly */;
            var mergedInstantiations = false;
            for (var _i = 0, _c = containingType.types; _i < _c.length; _i++) {
                var current = _c[_i];
                var type = getApparentType(current);
                if (!(isErrorType(type) || type.flags & 131072 /* TypeFlags.Never */)) {
                    var prop = getPropertyOfType(type, name, skipObjectFunctionPropertyAugment);
                    var modifiers = prop ? ts.getDeclarationModifierFlagsFromSymbol(prop) : 0;
                    if (prop) {
                        if (isUnion) {
                            optionalFlag |= (prop.flags & 16777216 /* SymbolFlags.Optional */);
                        }
                        else {
                            optionalFlag &= prop.flags;
                        }
                        if (!singleProp) {
                            singleProp = prop;
                        }
                        else if (prop !== singleProp) {
                            var isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(singleProp) || singleProp);
                            // If the symbols are instances of one another with identical types - consider the symbols
                            // equivalent and just use the first one, which thus allows us to avoid eliding private
                            // members when intersecting a (this-)instantiations of a class with it's raw base or another instance
                            if (isInstantiation && compareProperties(singleProp, prop, function (a, b) { return a === b ? -1 /* Ternary.True */ : 0 /* Ternary.False */; }) === -1 /* Ternary.True */) {
                                // If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used
                                // to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed
                                // back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`
                                mergedInstantiations = !!singleProp.parent && !!ts.length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));
                            }
                            else {
                                if (!propSet) {
                                    propSet = new ts.Map();
                                    propSet.set(getSymbolId(singleProp), singleProp);
                                }
                                var id = getSymbolId(prop);
                                if (!propSet.has(id)) {
                                    propSet.set(id, prop);
                                }
                            }
                        }
                        if (isUnion && isReadonlySymbol(prop)) {
                            checkFlags |= 8 /* CheckFlags.Readonly */;
                        }
                        else if (!isUnion && !isReadonlySymbol(prop)) {
                            checkFlags &= ~8 /* CheckFlags.Readonly */;
                        }
                        checkFlags |= (!(modifiers & 24 /* ModifierFlags.NonPublicAccessibilityModifier */) ? 256 /* CheckFlags.ContainsPublic */ : 0) |
                            (modifiers & 16 /* ModifierFlags.Protected */ ? 512 /* CheckFlags.ContainsProtected */ : 0) |
                            (modifiers & 8 /* ModifierFlags.Private */ ? 1024 /* CheckFlags.ContainsPrivate */ : 0) |
                            (modifiers & 32 /* ModifierFlags.Static */ ? 2048 /* CheckFlags.ContainsStatic */ : 0);
                        if (!isPrototypeProperty(prop)) {
                            syntheticFlag = 2 /* CheckFlags.SyntheticProperty */;
                        }
                    }
                    else if (isUnion) {
                        var indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(type, name);
                        if (indexInfo) {
                            checkFlags |= 32 /* CheckFlags.WritePartial */ | (indexInfo.isReadonly ? 8 /* CheckFlags.Readonly */ : 0);
                            indexTypes = ts.append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type);
                        }
                        else if (isObjectLiteralType(type) && !(ts.getObjectFlags(type) & 2097152 /* ObjectFlags.ContainsSpread */)) {
                            checkFlags |= 32 /* CheckFlags.WritePartial */;
                            indexTypes = ts.append(indexTypes, undefinedType);
                        }
                        else {
                            checkFlags |= 16 /* CheckFlags.ReadPartial */;
                        }
                    }
                }
            }
            if (!singleProp || isUnion && (propSet || checkFlags & 48 /* CheckFlags.Partial */) && checkFlags & (1024 /* CheckFlags.ContainsPrivate */ | 512 /* CheckFlags.ContainsProtected */)) {
                // No property was found, or, in a union, a property has a private or protected declaration in one
                // constituent, but is missing or has a different declaration in another constituent.
                return undefined;
            }
            if (!propSet && !(checkFlags & 16 /* CheckFlags.ReadPartial */) && !indexTypes) {
                if (mergedInstantiations) {
                    // No symbol from a union/intersection should have a `.parent` set (since unions/intersections don't act as symbol parents)
                    // Unless that parent is "reconstituted" from the "first value declaration" on the symbol (which is likely different than its instantiated parent!)
                    // They also have a `.containingType` set, which affects some services endpoints behavior, like `getRootSymbol`
                    var clone_1 = createSymbolWithType(singleProp, singleProp.type);
                    clone_1.parent = (_b = (_a = singleProp.valueDeclaration) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.parent;
                    clone_1.containingType = containingType;
                    clone_1.mapper = singleProp.mapper;
                    return clone_1;
                }
                else {
                    return singleProp;
                }
            }
            var props = propSet ? ts.arrayFrom(propSet.values()) : [singleProp];
            var declarations;
            var firstType;
            var nameType;
            var propTypes = [];
            var writeTypes;
            var firstValueDeclaration;
            var hasNonUniformValueDeclaration = false;
            for (var _d = 0, props_1 = props; _d < props_1.length; _d++) {
                var prop = props_1[_d];
                if (!firstValueDeclaration) {
                    firstValueDeclaration = prop.valueDeclaration;
                }
                else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {
                    hasNonUniformValueDeclaration = true;
                }
                declarations = ts.addRange(declarations, prop.declarations);
                var type = getTypeOfSymbol(prop);
                if (!firstType) {
                    firstType = type;
                    nameType = getSymbolLinks(prop).nameType;
                }
                var writeType = getWriteTypeOfSymbol(prop);
                if (writeTypes || writeType !== type) {
                    writeTypes = ts.append(!writeTypes ? propTypes.slice() : writeTypes, writeType);
                }
                else if (type !== firstType) {
                    checkFlags |= 64 /* CheckFlags.HasNonUniformType */;
                }
                if (isLiteralType(type) || isPatternLiteralType(type) || type === uniqueLiteralType) {
                    checkFlags |= 128 /* CheckFlags.HasLiteralType */;
                }
                if (type.flags & 131072 /* TypeFlags.Never */ && type !== uniqueLiteralType) {
                    checkFlags |= 131072 /* CheckFlags.HasNeverType */;
                }
                propTypes.push(type);
            }
            ts.addRange(propTypes, indexTypes);
            var result = createSymbol(4 /* SymbolFlags.Property */ | optionalFlag, name, syntheticFlag | checkFlags);
            result.containingType = containingType;
            if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
                result.valueDeclaration = firstValueDeclaration;
                // Inherit information about parent type.
                if (firstValueDeclaration.symbol.parent) {
                    result.parent = firstValueDeclaration.symbol.parent;
                }
            }
            result.declarations = declarations;
            result.nameType = nameType;
            if (propTypes.length > 2) {
                // When `propTypes` has the potential to explode in size when normalized, defer normalization until absolutely needed
                result.checkFlags |= 65536 /* CheckFlags.DeferredType */;
                result.deferralParent = containingType;
                result.deferralConstituents = propTypes;
                result.deferralWriteConstituents = writeTypes;
            }
            else {
                result.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
                if (writeTypes) {
                    result.writeType = isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes);
                }
            }
            return result;
        }
        // Return the symbol for a given property in a union or intersection type, or undefined if the property
        // does not exist in any constituent type. Note that the returned property may only be present in some
        // constituents, in which case the isPartial flag is set when the containing type is union type. We need
        // these partial properties when identifying discriminant properties, but otherwise they are filtered out
        // and do not appear to be present in the union type.
        function getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment) {
            var _a, _b;
            var property = ((_a = type.propertyCacheWithoutObjectFunctionPropertyAugment) === null || _a === void 0 ? void 0 : _a.get(name)) ||
                !skipObjectFunctionPropertyAugment ? (_b = type.propertyCache) === null || _b === void 0 ? void 0 : _b.get(name) : undefined;
            if (!property) {
                property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
                if (property) {
                    var properties = skipObjectFunctionPropertyAugment ? type.propertyCacheWithoutObjectFunctionPropertyAugment || (type.propertyCacheWithoutObjectFunctionPropertyAugment = ts.createSymbolTable()) : type.propertyCache || (type.propertyCache = ts.createSymbolTable());
                    properties.set(name, property);
                }
            }
            return property;
        }
        function getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment) {
            var property = getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
            // We need to filter out partial properties in union types
            return property && !(ts.getCheckFlags(property) & 16 /* CheckFlags.ReadPartial */) ? property : undefined;
        }
        /**
         * Return the reduced form of the given type. For a union type, it is a union of the normalized constituent types.
         * For an intersection of types containing one or more mututally exclusive discriminant properties, it is 'never'.
         * For all other types, it is simply the type itself. Discriminant properties are considered mutually exclusive when
         * no constituent property has type 'never', but the intersection of the constituent property types is 'never'.
         */
        function getReducedType(type) {
            if (type.flags & 1048576 /* TypeFlags.Union */ && type.objectFlags & 16777216 /* ObjectFlags.ContainsIntersections */) {
                return type.resolvedReducedType || (type.resolvedReducedType = getReducedUnionType(type));
            }
            else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                if (!(type.objectFlags & 16777216 /* ObjectFlags.IsNeverIntersectionComputed */)) {
                    type.objectFlags |= 16777216 /* ObjectFlags.IsNeverIntersectionComputed */ |
                        (ts.some(getPropertiesOfUnionOrIntersectionType(type), isNeverReducedProperty) ? 33554432 /* ObjectFlags.IsNeverIntersection */ : 0);
                }
                return type.objectFlags & 33554432 /* ObjectFlags.IsNeverIntersection */ ? neverType : type;
            }
            return type;
        }
        function getReducedUnionType(unionType) {
            var reducedTypes = ts.sameMap(unionType.types, getReducedType);
            if (reducedTypes === unionType.types) {
                return unionType;
            }
            var reduced = getUnionType(reducedTypes);
            if (reduced.flags & 1048576 /* TypeFlags.Union */) {
                reduced.resolvedReducedType = reduced;
            }
            return reduced;
        }
        function isNeverReducedProperty(prop) {
            return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop);
        }
        function isDiscriminantWithNeverType(prop) {
            // Return true for a synthetic non-optional property with non-uniform types, where at least one is
            // a literal type and none is never, that reduces to never.
            return !(prop.flags & 16777216 /* SymbolFlags.Optional */) &&
                (ts.getCheckFlags(prop) & (192 /* CheckFlags.Discriminant */ | 131072 /* CheckFlags.HasNeverType */)) === 192 /* CheckFlags.Discriminant */ &&
                !!(getTypeOfSymbol(prop).flags & 131072 /* TypeFlags.Never */);
        }
        function isConflictingPrivateProperty(prop) {
            // Return true for a synthetic property with multiple declarations, at least one of which is private.
            return !prop.valueDeclaration && !!(ts.getCheckFlags(prop) & 1024 /* CheckFlags.ContainsPrivate */);
        }
        function elaborateNeverIntersection(errorInfo, type) {
            if (type.flags & 2097152 /* TypeFlags.Intersection */ && ts.getObjectFlags(type) & 33554432 /* ObjectFlags.IsNeverIntersection */) {
                var neverProp = ts.find(getPropertiesOfUnionOrIntersectionType(type), isDiscriminantWithNeverType);
                if (neverProp) {
                    return ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type, /*enclosingDeclaration*/ undefined, 536870912 /* TypeFormatFlags.NoTypeReduction */), symbolToString(neverProp));
                }
                var privateProp = ts.find(getPropertiesOfUnionOrIntersectionType(type), isConflictingPrivateProperty);
                if (privateProp) {
                    return ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type, /*enclosingDeclaration*/ undefined, 536870912 /* TypeFormatFlags.NoTypeReduction */), symbolToString(privateProp));
                }
            }
            return errorInfo;
        }
        /**
         * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
         * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
         * Object and Function as appropriate.
         *
         * @param type a type to look up property from
         * @param name a name of property to look up in a given type
         */
        function getPropertyOfType(type, name, skipObjectFunctionPropertyAugment) {
            type = getReducedApparentType(type);
            if (type.flags & 524288 /* TypeFlags.Object */) {
                var resolved = resolveStructuredTypeMembers(type);
                var symbol = resolved.members.get(name);
                if (symbol && symbolIsValue(symbol)) {
                    return symbol;
                }
                if (skipObjectFunctionPropertyAugment)
                    return undefined;
                var functionType = resolved === anyFunctionType ? globalFunctionType :
                    resolved.callSignatures.length ? globalCallableFunctionType :
                        resolved.constructSignatures.length ? globalNewableFunctionType :
                            undefined;
                if (functionType) {
                    var symbol_1 = getPropertyOfObjectType(functionType, name);
                    if (symbol_1) {
                        return symbol_1;
                    }
                }
                return getPropertyOfObjectType(globalObjectType, name);
            }
            if (type.flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                return getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment);
            }
            return undefined;
        }
        function getSignaturesOfStructuredType(type, kind) {
            if (type.flags & 3670016 /* TypeFlags.StructuredType */) {
                var resolved = resolveStructuredTypeMembers(type);
                return kind === 0 /* SignatureKind.Call */ ? resolved.callSignatures : resolved.constructSignatures;
            }
            return ts.emptyArray;
        }
        /**
         * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
         * maps primitive types and type parameters are to their apparent types.
         */
        function getSignaturesOfType(type, kind) {
            return getSignaturesOfStructuredType(getReducedApparentType(type), kind);
        }
        function findIndexInfo(indexInfos, keyType) {
            return ts.find(indexInfos, function (info) { return info.keyType === keyType; });
        }
        function findApplicableIndexInfo(indexInfos, keyType) {
            // Index signatures for type 'string' are considered only when no other index signatures apply.
            var stringIndexInfo;
            var applicableInfo;
            var applicableInfos;
            for (var _i = 0, indexInfos_3 = indexInfos; _i < indexInfos_3.length; _i++) {
                var info = indexInfos_3[_i];
                if (info.keyType === stringType) {
                    stringIndexInfo = info;
                }
                else if (isApplicableIndexType(keyType, info.keyType)) {
                    if (!applicableInfo) {
                        applicableInfo = info;
                    }
                    else {
                        (applicableInfos || (applicableInfos = [applicableInfo])).push(info);
                    }
                }
            }
            // When more than one index signature is applicable we create a synthetic IndexInfo. Instead of computing
            // the intersected key type, we just use unknownType for the key type as nothing actually depends on the
            // keyType property of the returned IndexInfo.
            return applicableInfos ? createIndexInfo(unknownType, getIntersectionType(ts.map(applicableInfos, function (info) { return info.type; })), ts.reduceLeft(applicableInfos, function (isReadonly, info) { return isReadonly && info.isReadonly; }, /*initial*/ true)) :
                applicableInfo ? applicableInfo :
                    stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :
                        undefined;
        }
        function isApplicableIndexType(source, target) {
            // A 'string' index signature applies to types assignable to 'string' or 'number', and a 'number' index
            // signature applies to types assignable to 'number', `${number}` and numeric string literal types.
            return isTypeAssignableTo(source, target) ||
                target === stringType && isTypeAssignableTo(source, numberType) ||
                target === numberType && (source === numericStringType || !!(source.flags & 128 /* TypeFlags.StringLiteral */) && ts.isNumericLiteralName(source.value));
        }
        function getIndexInfosOfStructuredType(type) {
            if (type.flags & 3670016 /* TypeFlags.StructuredType */) {
                var resolved = resolveStructuredTypeMembers(type);
                return resolved.indexInfos;
            }
            return ts.emptyArray;
        }
        function getIndexInfosOfType(type) {
            return getIndexInfosOfStructuredType(getReducedApparentType(type));
        }
        // Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
        // maps primitive types and type parameters are to their apparent types.
        function getIndexInfoOfType(type, keyType) {
            return findIndexInfo(getIndexInfosOfType(type), keyType);
        }
        // Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
        // maps primitive types and type parameters are to their apparent types.
        function getIndexTypeOfType(type, keyType) {
            var _a;
            return (_a = getIndexInfoOfType(type, keyType)) === null || _a === void 0 ? void 0 : _a.type;
        }
        function getApplicableIndexInfos(type, keyType) {
            return getIndexInfosOfType(type).filter(function (info) { return isApplicableIndexType(keyType, info.keyType); });
        }
        function getApplicableIndexInfo(type, keyType) {
            return findApplicableIndexInfo(getIndexInfosOfType(type), keyType);
        }
        function getApplicableIndexInfoForName(type, name) {
            return getApplicableIndexInfo(type, isLateBoundName(name) ? esSymbolType : getStringLiteralType(ts.unescapeLeadingUnderscores(name)));
        }
        // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
        // type checking functions).
        function getTypeParametersFromDeclaration(declaration) {
            var result;
            for (var _i = 0, _a = ts.getEffectiveTypeParameterDeclarations(declaration); _i < _a.length; _i++) {
                var node = _a[_i];
                result = ts.appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));
            }
            return result;
        }
        function symbolsToArray(symbols) {
            var result = [];
            symbols.forEach(function (symbol, id) {
                if (!isReservedMemberName(id)) {
                    result.push(symbol);
                }
            });
            return result;
        }
        function isJSDocOptionalParameter(node) {
            return ts.isInJSFile(node) && (
            // node.type should only be a JSDocOptionalType when node is a parameter of a JSDocFunctionType
            node.type && node.type.kind === 316 /* SyntaxKind.JSDocOptionalType */
                || ts.getJSDocParameterTags(node).some(function (_a) {
                    var isBracketed = _a.isBracketed, typeExpression = _a.typeExpression;
                    return isBracketed || !!typeExpression && typeExpression.type.kind === 316 /* SyntaxKind.JSDocOptionalType */;
                }));
        }
        function tryFindAmbientModule(moduleName, withAugmentations) {
            if (ts.isExternalModuleNameRelative(moduleName)) {
                return undefined;
            }
            var symbol = getSymbol(globals, '"' + moduleName + '"', 512 /* SymbolFlags.ValueModule */);
            // merged symbol is module declaration symbol combined with all augmentations
            return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
        }
        function isOptionalParameter(node) {
            if (ts.hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isJSDocOptionalParameter(node)) {
                return true;
            }
            if (node.initializer) {
                var signature = getSignatureFromDeclaration(node.parent);
                var parameterIndex = node.parent.parameters.indexOf(node);
                ts.Debug.assert(parameterIndex >= 0);
                // Only consider syntactic or instantiated parameters as optional, not `void` parameters as this function is used
                // in grammar checks and checking for `void` too early results in parameter types widening too early
                // and causes some noImplicitAny errors to be lost.
                return parameterIndex >= getMinArgumentCount(signature, 1 /* MinArgumentCountFlags.StrongArityForUntypedJS */ | 2 /* MinArgumentCountFlags.VoidIsNonOptional */);
            }
            var iife = ts.getImmediatelyInvokedFunctionExpression(node.parent);
            if (iife) {
                return !node.type &&
                    !node.dotDotDotToken &&
                    node.parent.parameters.indexOf(node) >= iife.arguments.length;
            }
            return false;
        }
        function isOptionalPropertyDeclaration(node) {
            return ts.isPropertyDeclaration(node) && node.questionToken;
        }
        function isOptionalJSDocPropertyLikeTag(node) {
            if (!ts.isJSDocPropertyLikeTag(node)) {
                return false;
            }
            var isBracketed = node.isBracketed, typeExpression = node.typeExpression;
            return isBracketed || !!typeExpression && typeExpression.type.kind === 316 /* SyntaxKind.JSDocOptionalType */;
        }
        function createTypePredicate(kind, parameterName, parameterIndex, type) {
            return { kind: kind, parameterName: parameterName, parameterIndex: parameterIndex, type: type };
        }
        /**
         * Gets the minimum number of type arguments needed to satisfy all non-optional type
         * parameters.
         */
        function getMinTypeArgumentCount(typeParameters) {
            var minTypeArgumentCount = 0;
            if (typeParameters) {
                for (var i = 0; i < typeParameters.length; i++) {
                    if (!hasTypeParameterDefault(typeParameters[i])) {
                        minTypeArgumentCount = i + 1;
                    }
                }
            }
            return minTypeArgumentCount;
        }
        function fillMissingTypeArguments(typeArguments, typeParameters, minTypeArgumentCount, isJavaScriptImplicitAny) {
            var numTypeParameters = ts.length(typeParameters);
            if (!numTypeParameters) {
                return [];
            }
            var numTypeArguments = ts.length(typeArguments);
            if (isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters)) {
                var result = typeArguments ? typeArguments.slice() : [];
                // Map invalid forward references in default types to the error type
                for (var i = numTypeArguments; i < numTypeParameters; i++) {
                    result[i] = errorType;
                }
                var baseDefaultType = getDefaultTypeArgumentType(isJavaScriptImplicitAny);
                for (var i = numTypeArguments; i < numTypeParameters; i++) {
                    var defaultType = getDefaultFromTypeParameter(typeParameters[i]);
                    if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {
                        defaultType = anyType;
                    }
                    result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters, result)) : baseDefaultType;
                }
                result.length = typeParameters.length;
                return result;
            }
            return typeArguments && typeArguments.slice();
        }
        function getSignatureFromDeclaration(declaration) {
            var links = getNodeLinks(declaration);
            if (!links.resolvedSignature) {
                var parameters = [];
                var flags = 0 /* SignatureFlags.None */;
                var minArgumentCount = 0;
                var thisParameter = void 0;
                var hasThisParameter = false;
                var iife = ts.getImmediatelyInvokedFunctionExpression(declaration);
                var isJSConstructSignature = ts.isJSDocConstructSignature(declaration);
                var isUntypedSignatureInJSFile = !iife &&
                    ts.isInJSFile(declaration) &&
                    ts.isValueSignatureDeclaration(declaration) &&
                    !ts.hasJSDocParameterTags(declaration) &&
                    !ts.getJSDocType(declaration);
                if (isUntypedSignatureInJSFile) {
                    flags |= 32 /* SignatureFlags.IsUntypedSignatureInJSFile */;
                }
                // If this is a JSDoc construct signature, then skip the first parameter in the
                // parameter list.  The first parameter represents the return type of the construct
                // signature.
                for (var i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {
                    var param = declaration.parameters[i];
                    var paramSymbol = param.symbol;
                    var type = ts.isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;
                    // Include parameter symbol instead of property symbol in the signature
                    if (paramSymbol && !!(paramSymbol.flags & 4 /* SymbolFlags.Property */) && !ts.isBindingPattern(param.name)) {
                        var resolvedSymbol = resolveName(param, paramSymbol.escapedName, 111551 /* SymbolFlags.Value */, undefined, undefined, /*isUse*/ false);
                        paramSymbol = resolvedSymbol;
                    }
                    if (i === 0 && paramSymbol.escapedName === "this" /* InternalSymbolName.This */) {
                        hasThisParameter = true;
                        thisParameter = param.symbol;
                    }
                    else {
                        parameters.push(paramSymbol);
                    }
                    if (type && type.kind === 196 /* SyntaxKind.LiteralType */) {
                        flags |= 2 /* SignatureFlags.HasLiteralTypes */;
                    }
                    // Record a new minimum argument count if this is not an optional parameter
                    var isOptionalParameter_1 = isOptionalJSDocPropertyLikeTag(param) ||
                        param.initializer || param.questionToken || ts.isRestParameter(param) ||
                        iife && parameters.length > iife.arguments.length && !type ||
                        isJSDocOptionalParameter(param);
                    if (!isOptionalParameter_1) {
                        minArgumentCount = parameters.length;
                    }
                }
                // If only one accessor includes a this-type annotation, the other behaves as if it had the same type annotation
                if ((declaration.kind === 172 /* SyntaxKind.GetAccessor */ || declaration.kind === 173 /* SyntaxKind.SetAccessor */) &&
                    hasBindableName(declaration) &&
                    (!hasThisParameter || !thisParameter)) {
                    var otherKind = declaration.kind === 172 /* SyntaxKind.GetAccessor */ ? 173 /* SyntaxKind.SetAccessor */ : 172 /* SyntaxKind.GetAccessor */;
                    var other = ts.getDeclarationOfKind(getSymbolOfNode(declaration), otherKind);
                    if (other) {
                        thisParameter = getAnnotatedAccessorThisParameter(other);
                    }
                }
                var classType = declaration.kind === 171 /* SyntaxKind.Constructor */ ?
                    getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol))
                    : undefined;
                var typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
                if (ts.hasRestParameter(declaration) || ts.isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters)) {
                    flags |= 1 /* SignatureFlags.HasRestParameter */;
                }
                if (ts.isConstructorTypeNode(declaration) && ts.hasSyntacticModifier(declaration, 128 /* ModifierFlags.Abstract */) ||
                    ts.isConstructorDeclaration(declaration) && ts.hasSyntacticModifier(declaration.parent, 128 /* ModifierFlags.Abstract */)) {
                    flags |= 4 /* SignatureFlags.Abstract */;
                }
                links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, 
                /*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/ undefined, minArgumentCount, flags);
            }
            return links.resolvedSignature;
        }
        /**
         * A JS function gets a synthetic rest parameter if it references `arguments` AND:
         * 1. It has no parameters but at least one `@param` with a type that starts with `...`
         * OR
         * 2. It has at least one parameter, and the last parameter has a matching `@param` with a type that starts with `...`
         */
        function maybeAddJsSyntheticRestParameter(declaration, parameters) {
            if (ts.isJSDocSignature(declaration) || !containsArgumentsReference(declaration)) {
                return false;
            }
            var lastParam = ts.lastOrUndefined(declaration.parameters);
            var lastParamTags = lastParam ? ts.getJSDocParameterTags(lastParam) : ts.getJSDocTags(declaration).filter(ts.isJSDocParameterTag);
            var lastParamVariadicType = ts.firstDefined(lastParamTags, function (p) {
                return p.typeExpression && ts.isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined;
            });
            var syntheticArgsSymbol = createSymbol(3 /* SymbolFlags.Variable */, "args", 32768 /* CheckFlags.RestParameter */);
            if (lastParamVariadicType) {
                // Parameter has effective annotation, lock in type
                syntheticArgsSymbol.type = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type));
            }
            else {
                // Parameter has no annotation
                // By using a `DeferredType` symbol, we allow the type of this rest arg to be overriden by contextual type assignment so long as its type hasn't been
                // cached by `getTypeOfSymbol` yet.
                syntheticArgsSymbol.checkFlags |= 65536 /* CheckFlags.DeferredType */;
                syntheticArgsSymbol.deferralParent = neverType;
                syntheticArgsSymbol.deferralConstituents = [anyArrayType];
                syntheticArgsSymbol.deferralWriteConstituents = [anyArrayType];
            }
            if (lastParamVariadicType) {
                // Replace the last parameter with a rest parameter.
                parameters.pop();
            }
            parameters.push(syntheticArgsSymbol);
            return true;
        }
        function getSignatureOfTypeTag(node) {
            // should be attached to a function declaration or expression
            if (!(ts.isInJSFile(node) && ts.isFunctionLikeDeclaration(node)))
                return undefined;
            var typeTag = ts.getJSDocTypeTag(node);
            return (typeTag === null || typeTag === void 0 ? void 0 : typeTag.typeExpression) && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
        }
        function getParameterTypeOfTypeTag(func, parameter) {
            var signature = getSignatureOfTypeTag(func);
            if (!signature)
                return undefined;
            var pos = func.parameters.indexOf(parameter);
            return parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos);
        }
        function getReturnTypeOfTypeTag(node) {
            var signature = getSignatureOfTypeTag(node);
            return signature && getReturnTypeOfSignature(signature);
        }
        function containsArgumentsReference(declaration) {
            var links = getNodeLinks(declaration);
            if (links.containsArgumentsReference === undefined) {
                if (links.flags & 8192 /* NodeCheckFlags.CaptureArguments */) {
                    links.containsArgumentsReference = true;
                }
                else {
                    links.containsArgumentsReference = traverse(declaration.body);
                }
            }
            return links.containsArgumentsReference;
            function traverse(node) {
                if (!node)
                    return false;
                switch (node.kind) {
                    case 79 /* SyntaxKind.Identifier */:
                        return node.escapedText === argumentsSymbol.escapedName && getReferencedValueSymbol(node) === argumentsSymbol;
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                        return node.name.kind === 162 /* SyntaxKind.ComputedPropertyName */
                            && traverse(node.name);
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                        return traverse(node.expression);
                    case 296 /* SyntaxKind.PropertyAssignment */:
                        return traverse(node.initializer);
                    default:
                        return !ts.nodeStartsNewLexicalEnvironment(node) && !ts.isPartOfTypeNode(node) && !!ts.forEachChild(node, traverse);
                }
            }
        }
        function getSignaturesOfSymbol(symbol) {
            if (!symbol || !symbol.declarations)
                return ts.emptyArray;
            var result = [];
            for (var i = 0; i < symbol.declarations.length; i++) {
                var decl = symbol.declarations[i];
                if (!ts.isFunctionLike(decl))
                    continue;
                // Don't include signature if node is the implementation of an overloaded function. A node is considered
                // an implementation node if it has a body and the previous node is of the same kind and immediately
                // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
                if (i > 0 && decl.body) {
                    var previous = symbol.declarations[i - 1];
                    if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {
                        continue;
                    }
                }
                result.push(getSignatureFromDeclaration(decl));
            }
            return result;
        }
        function resolveExternalModuleTypeByLiteral(name) {
            var moduleSym = resolveExternalModuleName(name, name);
            if (moduleSym) {
                var resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                if (resolvedModuleSymbol) {
                    return getTypeOfSymbol(resolvedModuleSymbol);
                }
            }
            return anyType;
        }
        function getThisTypeOfSignature(signature) {
            if (signature.thisParameter) {
                return getTypeOfSymbol(signature.thisParameter);
            }
        }
        function getTypePredicateOfSignature(signature) {
            if (!signature.resolvedTypePredicate) {
                if (signature.target) {
                    var targetTypePredicate = getTypePredicateOfSignature(signature.target);
                    signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper) : noTypePredicate;
                }
                else if (signature.compositeSignatures) {
                    signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate;
                }
                else {
                    var type = signature.declaration && ts.getEffectiveReturnTypeNode(signature.declaration);
                    var jsdocPredicate = void 0;
                    if (!type && ts.isInJSFile(signature.declaration)) {
                        var jsdocSignature = getSignatureOfTypeTag(signature.declaration);
                        if (jsdocSignature && signature !== jsdocSignature) {
                            jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
                        }
                    }
                    signature.resolvedTypePredicate = type && ts.isTypePredicateNode(type) ?
                        createTypePredicateFromTypePredicateNode(type, signature) :
                        jsdocPredicate || noTypePredicate;
                }
                ts.Debug.assert(!!signature.resolvedTypePredicate);
            }
            return signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate;
        }
        function createTypePredicateFromTypePredicateNode(node, signature) {
            var parameterName = node.parameterName;
            var type = node.type && getTypeFromTypeNode(node.type);
            return parameterName.kind === 192 /* SyntaxKind.ThisType */ ?
                createTypePredicate(node.assertsModifier ? 2 /* TypePredicateKind.AssertsThis */ : 0 /* TypePredicateKind.This */, /*parameterName*/ undefined, /*parameterIndex*/ undefined, type) :
                createTypePredicate(node.assertsModifier ? 3 /* TypePredicateKind.AssertsIdentifier */ : 1 /* TypePredicateKind.Identifier */, parameterName.escapedText, ts.findIndex(signature.parameters, function (p) { return p.escapedName === parameterName.escapedText; }), type);
        }
        function getUnionOrIntersectionType(types, kind, unionReduction) {
            return kind !== 2097152 /* TypeFlags.Intersection */ ? getUnionType(types, unionReduction) : getIntersectionType(types);
        }
        function getReturnTypeOfSignature(signature) {
            if (!signature.resolvedReturnType) {
                if (!pushTypeResolution(signature, 3 /* TypeSystemPropertyName.ResolvedReturnType */)) {
                    return errorType;
                }
                var type = signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :
                    signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(ts.map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, 2 /* UnionReduction.Subtype */), signature.mapper) :
                        getReturnTypeFromAnnotation(signature.declaration) ||
                            (ts.nodeIsMissing(signature.declaration.body) ? anyType : getReturnTypeFromBody(signature.declaration));
                if (signature.flags & 8 /* SignatureFlags.IsInnerCallChain */) {
                    type = addOptionalTypeMarker(type);
                }
                else if (signature.flags & 16 /* SignatureFlags.IsOuterCallChain */) {
                    type = getOptionalType(type);
                }
                if (!popTypeResolution()) {
                    if (signature.declaration) {
                        var typeNode = ts.getEffectiveReturnTypeNode(signature.declaration);
                        if (typeNode) {
                            error(typeNode, ts.Diagnostics.Return_type_annotation_circularly_references_itself);
                        }
                        else if (noImplicitAny) {
                            var declaration = signature.declaration;
                            var name = ts.getNameOfDeclaration(declaration);
                            if (name) {
                                error(name, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, ts.declarationNameToString(name));
                            }
                            else {
                                error(declaration, ts.Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                            }
                        }
                    }
                    type = anyType;
                }
                signature.resolvedReturnType = type;
            }
            return signature.resolvedReturnType;
        }
        function getReturnTypeFromAnnotation(declaration) {
            if (declaration.kind === 171 /* SyntaxKind.Constructor */) {
                return getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol));
            }
            if (ts.isJSDocConstructSignature(declaration)) {
                return getTypeFromTypeNode(declaration.parameters[0].type); // TODO: GH#18217
            }
            var typeNode = ts.getEffectiveReturnTypeNode(declaration);
            if (typeNode) {
                return getTypeFromTypeNode(typeNode);
            }
            if (declaration.kind === 172 /* SyntaxKind.GetAccessor */ && hasBindableName(declaration)) {
                var jsDocType = ts.isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration);
                if (jsDocType) {
                    return jsDocType;
                }
                var setter = ts.getDeclarationOfKind(getSymbolOfNode(declaration), 173 /* SyntaxKind.SetAccessor */);
                var setterType = getAnnotatedAccessorType(setter);
                if (setterType) {
                    return setterType;
                }
            }
            return getReturnTypeOfTypeTag(declaration);
        }
        function isResolvingReturnTypeOfSignature(signature) {
            return !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, 3 /* TypeSystemPropertyName.ResolvedReturnType */) >= 0;
        }
        function getRestTypeOfSignature(signature) {
            return tryGetRestTypeOfSignature(signature) || anyType;
        }
        function tryGetRestTypeOfSignature(signature) {
            if (signatureHasRestParameter(signature)) {
                var sigRestType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                var restType = isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType;
                return restType && getIndexTypeOfType(restType, numberType);
            }
            return undefined;
        }
        function getSignatureInstantiation(signature, typeArguments, isJavascript, inferredTypeParameters) {
            var instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript));
            if (inferredTypeParameters) {
                var returnSignature = getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature));
                if (returnSignature) {
                    var newReturnSignature = cloneSignature(returnSignature);
                    newReturnSignature.typeParameters = inferredTypeParameters;
                    var newInstantiatedSignature = cloneSignature(instantiatedSignature);
                    newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature);
                    return newInstantiatedSignature;
                }
            }
            return instantiatedSignature;
        }
        function getSignatureInstantiationWithoutFillingInTypeArguments(signature, typeArguments) {
            var instantiations = signature.instantiations || (signature.instantiations = new ts.Map());
            var id = getTypeListId(typeArguments);
            var instantiation = instantiations.get(id);
            if (!instantiation) {
                instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments));
            }
            return instantiation;
        }
        function createSignatureInstantiation(signature, typeArguments) {
            return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), /*eraseTypeParameters*/ true);
        }
        function createSignatureTypeMapper(signature, typeArguments) {
            return createTypeMapper(signature.typeParameters, typeArguments);
        }
        function getErasedSignature(signature) {
            return signature.typeParameters ?
                signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :
                signature;
        }
        function createErasedSignature(signature) {
            // Create an instantiation of the signature where all type arguments are the any type.
            return instantiateSignature(signature, createTypeEraser(signature.typeParameters), /*eraseTypeParameters*/ true);
        }
        function getCanonicalSignature(signature) {
            return signature.typeParameters ?
                signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :
                signature;
        }
        function createCanonicalSignature(signature) {
            // Create an instantiation of the signature where each unconstrained type parameter is replaced with
            // its original. When a generic class or interface is instantiated, each generic method in the class or
            // interface is instantiated with a fresh set of cloned type parameters (which we need to handle scenarios
            // where different generations of the same type parameter are in scope). This leads to a lot of new type
            // identities, and potentially a lot of work comparing those identities, so here we create an instantiation
            // that uses the original type identities for all unconstrained type parameters.
            return getSignatureInstantiation(signature, ts.map(signature.typeParameters, function (tp) { return tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp; }), ts.isInJSFile(signature.declaration));
        }
        function getBaseSignature(signature) {
            var typeParameters = signature.typeParameters;
            if (typeParameters) {
                if (signature.baseSignatureCache) {
                    return signature.baseSignatureCache;
                }
                var typeEraser = createTypeEraser(typeParameters);
                var baseConstraintMapper_1 = createTypeMapper(typeParameters, ts.map(typeParameters, function (tp) { return getConstraintOfTypeParameter(tp) || unknownType; }));
                var baseConstraints = ts.map(typeParameters, function (tp) { return instantiateType(tp, baseConstraintMapper_1) || unknownType; });
                // Run N type params thru the immediate constraint mapper up to N times
                // This way any noncircular interdependent type parameters are definitely resolved to their external dependencies
                for (var i = 0; i < typeParameters.length - 1; i++) {
                    baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper_1);
                }
                // and then apply a type eraser to remove any remaining circularly dependent type parameters
                baseConstraints = instantiateTypes(baseConstraints, typeEraser);
                return signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters*/ true);
            }
            return signature;
        }
        function getOrCreateTypeFromSignature(signature) {
            var _a;
            // There are two ways to declare a construct signature, one is by declaring a class constructor
            // using the constructor keyword, and the other is declaring a bare construct signature in an
            // object type literal or interface (using the new keyword). Each way of declaring a constructor
            // will result in a different declaration kind.
            if (!signature.isolatedSignatureType) {
                var kind = (_a = signature.declaration) === null || _a === void 0 ? void 0 : _a.kind;
                // If declaration is undefined, it is likely to be the signature of the default constructor.
                var isConstructor = kind === undefined || kind === 171 /* SyntaxKind.Constructor */ || kind === 175 /* SyntaxKind.ConstructSignature */ || kind === 180 /* SyntaxKind.ConstructorType */;
                var type = createObjectType(16 /* ObjectFlags.Anonymous */);
                type.members = emptySymbols;
                type.properties = ts.emptyArray;
                type.callSignatures = !isConstructor ? [signature] : ts.emptyArray;
                type.constructSignatures = isConstructor ? [signature] : ts.emptyArray;
                type.indexInfos = ts.emptyArray;
                signature.isolatedSignatureType = type;
            }
            return signature.isolatedSignatureType;
        }
        function getIndexSymbol(symbol) {
            return symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined;
        }
        function getIndexSymbolFromSymbolTable(symbolTable) {
            return symbolTable.get("__index" /* InternalSymbolName.Index */);
        }
        function createIndexInfo(keyType, type, isReadonly, declaration) {
            return { keyType: keyType, type: type, isReadonly: isReadonly, declaration: declaration };
        }
        function getIndexInfosOfSymbol(symbol) {
            var indexSymbol = getIndexSymbol(symbol);
            return indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : ts.emptyArray;
        }
        function getIndexInfosOfIndexSymbol(indexSymbol) {
            if (indexSymbol.declarations) {
                var indexInfos_4 = [];
                var _loop_14 = function (declaration) {
                    if (declaration.parameters.length === 1) {
                        var parameter = declaration.parameters[0];
                        if (parameter.type) {
                            forEachType(getTypeFromTypeNode(parameter.type), function (keyType) {
                                if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos_4, keyType)) {
                                    indexInfos_4.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, ts.hasEffectiveModifier(declaration, 64 /* ModifierFlags.Readonly */), declaration));
                                }
                            });
                        }
                    }
                };
                for (var _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    _loop_14(declaration);
                }
                return indexInfos_4;
            }
            return ts.emptyArray;
        }
        function isValidIndexKeyType(type) {
            return !!(type.flags & (4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */ | 4096 /* TypeFlags.ESSymbol */)) || isPatternLiteralType(type) ||
                !!(type.flags & 2097152 /* TypeFlags.Intersection */) && !isGenericType(type) && ts.some(type.types, isValidIndexKeyType);
        }
        function getConstraintDeclaration(type) {
            return ts.mapDefined(ts.filter(type.symbol && type.symbol.declarations, ts.isTypeParameterDeclaration), ts.getEffectiveConstraintOfTypeParameter)[0];
        }
        function getInferredTypeParameterConstraint(typeParameter, omitTypeReferences) {
            var _a;
            var inferences;
            if ((_a = typeParameter.symbol) === null || _a === void 0 ? void 0 : _a.declarations) {
                for (var _i = 0, _b = typeParameter.symbol.declarations; _i < _b.length; _i++) {
                    var declaration = _b[_i];
                    if (declaration.parent.kind === 190 /* SyntaxKind.InferType */) {
                        // When an 'infer T' declaration is immediately contained in a type reference node
                        // (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the
                        // corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are
                        // present, we form an intersection of the inferred constraint types.
                        var _c = ts.walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent), _d = _c[0], childTypeParameter = _d === void 0 ? declaration.parent : _d, grandParent = _c[1];
                        if (grandParent.kind === 178 /* SyntaxKind.TypeReference */ && !omitTypeReferences) {
                            var typeReference = grandParent;
                            var typeParameters = getTypeParametersForTypeReference(typeReference);
                            if (typeParameters) {
                                var index = typeReference.typeArguments.indexOf(childTypeParameter);
                                if (index < typeParameters.length) {
                                    var declaredConstraint = getConstraintOfTypeParameter(typeParameters[index]);
                                    if (declaredConstraint) {
                                        // Type parameter constraints can reference other type parameters so
                                        // constraints need to be instantiated. If instantiation produces the
                                        // type parameter itself, we discard that inference. For example, in
                                        //   type Foo<T extends string, U extends T> = [T, U];
                                        //   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;
                                        // the instantiated constraint for U is X, so we discard that inference.
                                        var mapper = createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReference, typeParameters));
                                        var constraint = instantiateType(declaredConstraint, mapper);
                                        if (constraint !== typeParameter) {
                                            inferences = ts.append(inferences, constraint);
                                        }
                                    }
                                }
                            }
                        }
                        // When an 'infer T' declaration is immediately contained in a rest parameter declaration, a rest type
                        // or a named rest tuple element, we infer an 'unknown[]' constraint.
                        else if (grandParent.kind === 164 /* SyntaxKind.Parameter */ && grandParent.dotDotDotToken ||
                            grandParent.kind === 186 /* SyntaxKind.RestType */ ||
                            grandParent.kind === 197 /* SyntaxKind.NamedTupleMember */ && grandParent.dotDotDotToken) {
                            inferences = ts.append(inferences, createArrayType(unknownType));
                        }
                        // When an 'infer T' declaration is immediately contained in a string template type, we infer a 'string'
                        // constraint.
                        else if (grandParent.kind === 199 /* SyntaxKind.TemplateLiteralTypeSpan */) {
                            inferences = ts.append(inferences, stringType);
                        }
                        // When an 'infer T' declaration is in the constraint position of a mapped type, we infer a 'keyof any'
                        // constraint.
                        else if (grandParent.kind === 163 /* SyntaxKind.TypeParameter */ && grandParent.parent.kind === 195 /* SyntaxKind.MappedType */) {
                            inferences = ts.append(inferences, keyofConstraintType);
                        }
                        // When an 'infer T' declaration is the template of a mapped type, and that mapped type is the extends
                        // clause of a conditional whose check type is also a mapped type, give it a constraint equal to the template
                        // of the check type's mapped type
                        else if (grandParent.kind === 195 /* SyntaxKind.MappedType */ && grandParent.type &&
                            ts.skipParentheses(grandParent.type) === declaration.parent && grandParent.parent.kind === 189 /* SyntaxKind.ConditionalType */ &&
                            grandParent.parent.extendsType === grandParent && grandParent.parent.checkType.kind === 195 /* SyntaxKind.MappedType */ &&
                            grandParent.parent.checkType.type) {
                            var checkMappedType_1 = grandParent.parent.checkType;
                            var nodeType = getTypeFromTypeNode(checkMappedType_1.type);
                            inferences = ts.append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfNode(checkMappedType_1.typeParameter)), checkMappedType_1.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType_1.typeParameter.constraint) : keyofConstraintType)));
                        }
                    }
                }
            }
            return inferences && getIntersectionType(inferences);
        }
        /** This is a worker function. Use getConstraintOfTypeParameter which guards against circular constraints. */
        function getConstraintFromTypeParameter(typeParameter) {
            if (!typeParameter.constraint) {
                if (typeParameter.target) {
                    var targetConstraint = getConstraintOfTypeParameter(typeParameter.target);
                    typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType;
                }
                else {
                    var constraintDeclaration = getConstraintDeclaration(typeParameter);
                    if (!constraintDeclaration) {
                        typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType;
                    }
                    else {
                        var type = getTypeFromTypeNode(constraintDeclaration);
                        if (type.flags & 1 /* TypeFlags.Any */ && !isErrorType(type)) { // Allow errorType to propegate to keep downstream errors suppressed
                            // use keyofConstraintType as the base constraint for mapped type key constraints (unknown isn;t assignable to that, but `any` was),
                            // use unknown otherwise
                            type = constraintDeclaration.parent.parent.kind === 195 /* SyntaxKind.MappedType */ ? keyofConstraintType : unknownType;
                        }
                        typeParameter.constraint = type;
                    }
                }
            }
            return typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint;
        }
        function getParentSymbolOfTypeParameter(typeParameter) {
            var tp = ts.getDeclarationOfKind(typeParameter.symbol, 163 /* SyntaxKind.TypeParameter */);
            var host = ts.isJSDocTemplateTag(tp.parent) ? ts.getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent;
            return host && getSymbolOfNode(host);
        }
        function getTypeListId(types) {
            var result = "";
            if (types) {
                var length_4 = types.length;
                var i = 0;
                while (i < length_4) {
                    var startId = types[i].id;
                    var count = 1;
                    while (i + count < length_4 && types[i + count].id === startId + count) {
                        count++;
                    }
                    if (result.length) {
                        result += ",";
                    }
                    result += startId;
                    if (count > 1) {
                        result += ":" + count;
                    }
                    i += count;
                }
            }
            return result;
        }
        function getAliasId(aliasSymbol, aliasTypeArguments) {
            return aliasSymbol ? "@".concat(getSymbolId(aliasSymbol)) + (aliasTypeArguments ? ":".concat(getTypeListId(aliasTypeArguments)) : "") : "";
        }
        // This function is used to propagate certain flags when creating new object type references and union types.
        // It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
        // of an object literal or the anyFunctionType. This is because there are operations in the type checker
        // that care about the presence of such types at arbitrary depth in a containing type.
        function getPropagatingFlagsOfTypes(types, excludeKinds) {
            var result = 0;
            for (var _i = 0, types_8 = types; _i < types_8.length; _i++) {
                var type = types_8[_i];
                if (!(type.flags & excludeKinds)) {
                    result |= ts.getObjectFlags(type);
                }
            }
            return result & 458752 /* ObjectFlags.PropagatingFlags */;
        }
        function createTypeReference(target, typeArguments) {
            var id = getTypeListId(typeArguments);
            var type = target.instantiations.get(id);
            if (!type) {
                type = createObjectType(4 /* ObjectFlags.Reference */, target.symbol);
                target.instantiations.set(id, type);
                type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments, /*excludeKinds*/ 0) : 0;
                type.target = target;
                type.resolvedTypeArguments = typeArguments;
            }
            return type;
        }
        function cloneTypeReference(source) {
            var type = createType(source.flags);
            type.symbol = source.symbol;
            type.objectFlags = source.objectFlags;
            type.target = source.target;
            type.resolvedTypeArguments = source.resolvedTypeArguments;
            return type;
        }
        function createDeferredTypeReference(target, node, mapper, aliasSymbol, aliasTypeArguments) {
            if (!aliasSymbol) {
                aliasSymbol = getAliasSymbolForTypeNode(node);
                var localAliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                aliasTypeArguments = mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments;
            }
            var type = createObjectType(4 /* ObjectFlags.Reference */, target.symbol);
            type.target = target;
            type.node = node;
            type.mapper = mapper;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            return type;
        }
        function getTypeArguments(type) {
            var _a, _b;
            if (!type.resolvedTypeArguments) {
                if (!pushTypeResolution(type, 6 /* TypeSystemPropertyName.ResolvedTypeArguments */)) {
                    return ((_a = type.target.localTypeParameters) === null || _a === void 0 ? void 0 : _a.map(function () { return errorType; })) || ts.emptyArray;
                }
                var node = type.node;
                var typeArguments = !node ? ts.emptyArray :
                    node.kind === 178 /* SyntaxKind.TypeReference */ ? ts.concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters)) :
                        node.kind === 183 /* SyntaxKind.ArrayType */ ? [getTypeFromTypeNode(node.elementType)] :
                            ts.map(node.elements, getTypeFromTypeNode);
                if (popTypeResolution()) {
                    type.resolvedTypeArguments = type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments;
                }
                else {
                    type.resolvedTypeArguments = ((_b = type.target.localTypeParameters) === null || _b === void 0 ? void 0 : _b.map(function () { return errorType; })) || ts.emptyArray;
                    error(type.node || currentNode, type.target.symbol ? ts.Diagnostics.Type_arguments_for_0_circularly_reference_themselves : ts.Diagnostics.Tuple_type_arguments_circularly_reference_themselves, type.target.symbol && symbolToString(type.target.symbol));
                }
            }
            return type.resolvedTypeArguments;
        }
        function getTypeReferenceArity(type) {
            return ts.length(type.target.typeParameters);
        }
        /**
         * Get type from type-reference that reference to class or interface
         */
        function getTypeFromClassOrInterfaceReference(node, symbol) {
            var type = getDeclaredTypeOfSymbol(getMergedSymbol(symbol));
            var typeParameters = type.localTypeParameters;
            if (typeParameters) {
                var numTypeArguments = ts.length(node.typeArguments);
                var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
                var isJs = ts.isInJSFile(node);
                var isJsImplicitAny = !noImplicitAny && isJs;
                if (!isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)) {
                    var missingAugmentsTag = isJs && ts.isExpressionWithTypeArguments(node) && !ts.isJSDocAugmentsTag(node.parent);
                    var diag = minTypeArgumentCount === typeParameters.length ?
                        missingAugmentsTag ?
                            ts.Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :
                            ts.Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        missingAugmentsTag ?
                            ts.Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :
                            ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments;
                    var typeStr = typeToString(type, /*enclosingDeclaration*/ undefined, 2 /* TypeFormatFlags.WriteArrayAsGenericType */);
                    error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length);
                    if (!isJs) {
                        // TODO: Adopt same permissive behavior in TS as in JS to reduce follow-on editing experience failures (requires editing fillMissingTypeArguments)
                        return errorType;
                    }
                }
                if (node.kind === 178 /* SyntaxKind.TypeReference */ && isDeferredTypeReferenceNode(node, ts.length(node.typeArguments) !== typeParameters.length)) {
                    return createDeferredTypeReference(type, node, /*mapper*/ undefined);
                }
                // In a type reference, the outer type parameters of the referenced class or interface are automatically
                // supplied as type arguments and the type reference only specifies arguments for the local type parameters
                // of the class or interface.
                var typeArguments = ts.concatenate(type.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs));
                return createTypeReference(type, typeArguments);
            }
            return checkNoTypeArguments(node, symbol) ? type : errorType;
        }
        function getTypeAliasInstantiation(symbol, typeArguments, aliasSymbol, aliasTypeArguments) {
            var type = getDeclaredTypeOfSymbol(symbol);
            if (type === intrinsicMarkerType && intrinsicTypeKinds.has(symbol.escapedName) && typeArguments && typeArguments.length === 1) {
                return getStringMappingType(symbol, typeArguments[0]);
            }
            var links = getSymbolLinks(symbol);
            var typeParameters = links.typeParameters;
            var id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
            var instantiation = links.instantiations.get(id);
            if (!instantiation) {
                links.instantiations.set(id, instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), ts.isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments));
            }
            return instantiation;
        }
        /**
         * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
         * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
         * declared type. Instantiations are cached using the type identities of the type arguments as the key.
         */
        function getTypeFromTypeAliasReference(node, symbol) {
            if (ts.getCheckFlags(symbol) & 1048576 /* CheckFlags.Unresolved */) {
                var typeArguments = typeArgumentsFromTypeReferenceNode(node);
                var id = getAliasId(symbol, typeArguments);
                var errorType_1 = errorTypes.get(id);
                if (!errorType_1) {
                    errorType_1 = createIntrinsicType(1 /* TypeFlags.Any */, "error");
                    errorType_1.aliasSymbol = symbol;
                    errorType_1.aliasTypeArguments = typeArguments;
                    errorTypes.set(id, errorType_1);
                }
                return errorType_1;
            }
            var type = getDeclaredTypeOfSymbol(symbol);
            var typeParameters = getSymbolLinks(symbol).typeParameters;
            if (typeParameters) {
                var numTypeArguments = ts.length(node.typeArguments);
                var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
                if (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
                    error(node, minTypeArgumentCount === typeParameters.length ?
                        ts.Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments, symbolToString(symbol), minTypeArgumentCount, typeParameters.length);
                    return errorType;
                }
                // We refrain from associating a local type alias with an instantiation of a top-level type alias
                // because the local alias may end up being referenced in an inferred return type where it is not
                // accessible--which in turn may lead to a large structural expansion of the type when generating
                // a .d.ts file. See #43622 for an example.
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                var newAliasSymbol = aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined;
                return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, getTypeArgumentsForAliasSymbol(newAliasSymbol));
            }
            return checkNoTypeArguments(node, symbol) ? type : errorType;
        }
        function isLocalTypeAlias(symbol) {
            var _a;
            var declaration = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isTypeAlias);
            return !!(declaration && ts.getContainingFunction(declaration));
        }
        function getTypeReferenceName(node) {
            switch (node.kind) {
                case 178 /* SyntaxKind.TypeReference */:
                    return node.typeName;
                case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                    // We only support expressions that are simple qualified names. For other
                    // expressions this produces undefined.
                    var expr = node.expression;
                    if (ts.isEntityNameExpression(expr)) {
                        return expr;
                    }
                // fall through;
            }
            return undefined;
        }
        function getSymbolPath(symbol) {
            return symbol.parent ? "".concat(getSymbolPath(symbol.parent), ".").concat(symbol.escapedName) : symbol.escapedName;
        }
        function getUnresolvedSymbolForEntityName(name) {
            var identifier = name.kind === 161 /* SyntaxKind.QualifiedName */ ? name.right :
                name.kind === 206 /* SyntaxKind.PropertyAccessExpression */ ? name.name :
                    name;
            var text = identifier.escapedText;
            if (text) {
                var parentSymbol = name.kind === 161 /* SyntaxKind.QualifiedName */ ? getUnresolvedSymbolForEntityName(name.left) :
                    name.kind === 206 /* SyntaxKind.PropertyAccessExpression */ ? getUnresolvedSymbolForEntityName(name.expression) :
                        undefined;
                var path = parentSymbol ? "".concat(getSymbolPath(parentSymbol), ".").concat(text) : text;
                var result = unresolvedSymbols.get(path);
                if (!result) {
                    unresolvedSymbols.set(path, result = createSymbol(524288 /* SymbolFlags.TypeAlias */, text, 1048576 /* CheckFlags.Unresolved */));
                    result.parent = parentSymbol;
                    result.declaredType = unresolvedType;
                }
                return result;
            }
            return unknownSymbol;
        }
        function resolveTypeReferenceName(typeReference, meaning, ignoreErrors) {
            var name = getTypeReferenceName(typeReference);
            if (!name) {
                return unknownSymbol;
            }
            var symbol = resolveEntityName(name, meaning, ignoreErrors);
            return symbol && symbol !== unknownSymbol ? symbol :
                ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(name);
        }
        function getTypeReferenceType(node, symbol) {
            if (symbol === unknownSymbol) {
                return errorType;
            }
            symbol = getExpandoSymbol(symbol) || symbol;
            if (symbol.flags & (32 /* SymbolFlags.Class */ | 64 /* SymbolFlags.Interface */)) {
                return getTypeFromClassOrInterfaceReference(node, symbol);
            }
            if (symbol.flags & 524288 /* SymbolFlags.TypeAlias */) {
                return getTypeFromTypeAliasReference(node, symbol);
            }
            // Get type from reference to named type that cannot be generic (enum or type parameter)
            var res = tryGetDeclaredTypeOfSymbol(symbol);
            if (res) {
                return checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType;
            }
            if (symbol.flags & 111551 /* SymbolFlags.Value */ && isJSDocTypeReference(node)) {
                var jsdocType = getTypeFromJSDocValueReference(node, symbol);
                if (jsdocType) {
                    return jsdocType;
                }
                else {
                    // Resolve the type reference as a Type for the purpose of reporting errors.
                    resolveTypeReferenceName(node, 788968 /* SymbolFlags.Type */);
                    return getTypeOfSymbol(symbol);
                }
            }
            return errorType;
        }
        /**
         * A JSdoc TypeReference may be to a value, but resolve it as a type anyway.
         * Example: import('./b').ConstructorFunction
         */
        function getTypeFromJSDocValueReference(node, symbol) {
            var links = getNodeLinks(node);
            if (!links.resolvedJSDocType) {
                var valueType = getTypeOfSymbol(symbol);
                var typeType = valueType;
                if (symbol.valueDeclaration) {
                    var isImportTypeWithQualifier = node.kind === 200 /* SyntaxKind.ImportType */ && node.qualifier;
                    // valueType might not have a symbol, eg, {import('./b').STRING_LITERAL}
                    if (valueType.symbol && valueType.symbol !== symbol && isImportTypeWithQualifier) {
                        typeType = getTypeReferenceType(node, valueType.symbol);
                    }
                }
                links.resolvedJSDocType = typeType;
            }
            return links.resolvedJSDocType;
        }
        function getSubstitutionType(baseType, substitute) {
            if (substitute.flags & 3 /* TypeFlags.AnyOrUnknown */ || substitute === baseType) {
                return baseType;
            }
            var id = "".concat(getTypeId(baseType), ">").concat(getTypeId(substitute));
            var cached = substitutionTypes.get(id);
            if (cached) {
                return cached;
            }
            var result = createType(33554432 /* TypeFlags.Substitution */);
            result.baseType = baseType;
            result.substitute = substitute;
            substitutionTypes.set(id, result);
            return result;
        }
        function isUnaryTupleTypeNode(node) {
            return node.kind === 184 /* SyntaxKind.TupleType */ && node.elements.length === 1;
        }
        function getImpliedConstraint(type, checkNode, extendsNode) {
            return isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, checkNode.elements[0], extendsNode.elements[0]) :
                getActualTypeVariable(getTypeFromTypeNode(checkNode)) === getActualTypeVariable(type) ? getTypeFromTypeNode(extendsNode) :
                    undefined;
        }
        function getConditionalFlowTypeOfType(type, node) {
            var constraints;
            var covariant = true;
            while (node && !ts.isStatement(node) && node.kind !== 320 /* SyntaxKind.JSDoc */) {
                var parent = node.parent;
                // only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but
                // often get used in indexed accesses where they behave sortof invariantly, but our checking is lax
                if (parent.kind === 164 /* SyntaxKind.Parameter */) {
                    covariant = !covariant;
                }
                // Always substitute on type parameters, regardless of variance, since even
                // in contravariant positions, they may rely on substituted constraints to be valid
                if ((covariant || type.flags & 8650752 /* TypeFlags.TypeVariable */) && parent.kind === 189 /* SyntaxKind.ConditionalType */ && node === parent.trueType) {
                    var constraint = getImpliedConstraint(type, parent.checkType, parent.extendsType);
                    if (constraint) {
                        constraints = ts.append(constraints, constraint);
                    }
                }
                // Given a homomorphic mapped type { [K in keyof T]: XXX }, where T is constrained to an array or tuple type, in the
                // template type XXX, K has an added constraint of number | `${number}`.
                else if (type.flags & 262144 /* TypeFlags.TypeParameter */ && parent.kind === 195 /* SyntaxKind.MappedType */ && node === parent.type) {
                    var mappedType = getTypeFromTypeNode(parent);
                    if (getTypeParameterFromMappedType(mappedType) === getActualTypeVariable(type)) {
                        var typeParameter = getHomomorphicTypeVariable(mappedType);
                        if (typeParameter) {
                            var constraint = getConstraintOfTypeParameter(typeParameter);
                            if (constraint && everyType(constraint, isArrayOrTupleType)) {
                                constraints = ts.append(constraints, getUnionType([numberType, numericStringType]));
                            }
                        }
                    }
                }
                node = parent;
            }
            return constraints ? getSubstitutionType(type, getIntersectionType(ts.append(constraints, type))) : type;
        }
        function isJSDocTypeReference(node) {
            return !!(node.flags & 8388608 /* NodeFlags.JSDoc */) && (node.kind === 178 /* SyntaxKind.TypeReference */ || node.kind === 200 /* SyntaxKind.ImportType */);
        }
        function checkNoTypeArguments(node, symbol) {
            if (node.typeArguments) {
                error(node, ts.Diagnostics.Type_0_is_not_generic, symbol ? symbolToString(symbol) : node.typeName ? ts.declarationNameToString(node.typeName) : anon);
                return false;
            }
            return true;
        }
        function getIntendedTypeFromJSDocTypeReference(node) {
            if (ts.isIdentifier(node.typeName)) {
                var typeArgs = node.typeArguments;
                switch (node.typeName.escapedText) {
                    case "String":
                        checkNoTypeArguments(node);
                        return stringType;
                    case "Number":
                        checkNoTypeArguments(node);
                        return numberType;
                    case "Boolean":
                        checkNoTypeArguments(node);
                        return booleanType;
                    case "Void":
                        checkNoTypeArguments(node);
                        return voidType;
                    case "Undefined":
                        checkNoTypeArguments(node);
                        return undefinedType;
                    case "Null":
                        checkNoTypeArguments(node);
                        return nullType;
                    case "Function":
                    case "function":
                        checkNoTypeArguments(node);
                        return globalFunctionType;
                    case "array":
                        return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;
                    case "promise":
                        return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;
                    case "Object":
                        if (typeArgs && typeArgs.length === 2) {
                            if (ts.isJSDocIndexSignature(node)) {
                                var indexed = getTypeFromTypeNode(typeArgs[0]);
                                var target = getTypeFromTypeNode(typeArgs[1]);
                                var indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly*/ false)] : ts.emptyArray;
                                return createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, indexInfo);
                            }
                            return anyType;
                        }
                        checkNoTypeArguments(node);
                        return !noImplicitAny ? anyType : undefined;
                }
            }
        }
        function getTypeFromJSDocNullableTypeNode(node) {
            var type = getTypeFromTypeNode(node.type);
            return strictNullChecks ? getNullableType(type, 65536 /* TypeFlags.Null */) : type;
        }
        function getTypeFromTypeReference(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // handle LS queries on the `const` in `x as const` by resolving to the type of `x`
                if (ts.isConstTypeReference(node) && ts.isAssertionExpression(node.parent)) {
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = checkExpressionCached(node.parent.expression);
                }
                var symbol = void 0;
                var type = void 0;
                var meaning = 788968 /* SymbolFlags.Type */;
                if (isJSDocTypeReference(node)) {
                    type = getIntendedTypeFromJSDocTypeReference(node);
                    if (!type) {
                        symbol = resolveTypeReferenceName(node, meaning, /*ignoreErrors*/ true);
                        if (symbol === unknownSymbol) {
                            symbol = resolveTypeReferenceName(node, meaning | 111551 /* SymbolFlags.Value */);
                        }
                        else {
                            resolveTypeReferenceName(node, meaning); // Resolve again to mark errors, if any
                        }
                        type = getTypeReferenceType(node, symbol);
                    }
                }
                if (!type) {
                    symbol = resolveTypeReferenceName(node, meaning);
                    type = getTypeReferenceType(node, symbol);
                }
                // Cache both the resolved symbol and the resolved type. The resolved symbol is needed when we check the
                // type reference in checkTypeReferenceNode.
                links.resolvedSymbol = symbol;
                links.resolvedType = type;
            }
            return links.resolvedType;
        }
        function typeArgumentsFromTypeReferenceNode(node) {
            return ts.map(node.typeArguments, getTypeFromTypeNode);
        }
        function getTypeFromTypeQueryNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // TypeScript 1.0 spec (April 2014): 3.6.3
                // The expression is processed as an identifier expression (section 4.3)
                // or property access expression(section 4.10),
                // the widened type(section 3.9) of which becomes the result.
                var type = checkExpressionWithTypeArguments(node);
                links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type));
            }
            return links.resolvedType;
        }
        function getTypeOfGlobalSymbol(symbol, arity) {
            function getTypeDeclaration(symbol) {
                var declarations = symbol.declarations;
                if (declarations) {
                    for (var _i = 0, declarations_3 = declarations; _i < declarations_3.length; _i++) {
                        var declaration = declarations_3[_i];
                        switch (declaration.kind) {
                            case 257 /* SyntaxKind.ClassDeclaration */:
                            case 258 /* SyntaxKind.InterfaceDeclaration */:
                            case 260 /* SyntaxKind.EnumDeclaration */:
                                return declaration;
                        }
                    }
                }
            }
            if (!symbol) {
                return arity ? emptyGenericType : emptyObjectType;
            }
            var type = getDeclaredTypeOfSymbol(symbol);
            if (!(type.flags & 524288 /* TypeFlags.Object */)) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_be_a_class_or_interface_type, ts.symbolName(symbol));
                return arity ? emptyGenericType : emptyObjectType;
            }
            if (ts.length(type.typeParameters) !== arity) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, ts.symbolName(symbol), arity);
                return arity ? emptyGenericType : emptyObjectType;
            }
            return type;
        }
        function getGlobalValueSymbol(name, reportErrors) {
            return getGlobalSymbol(name, 111551 /* SymbolFlags.Value */, reportErrors ? ts.Diagnostics.Cannot_find_global_value_0 : undefined);
        }
        function getGlobalTypeSymbol(name, reportErrors) {
            return getGlobalSymbol(name, 788968 /* SymbolFlags.Type */, reportErrors ? ts.Diagnostics.Cannot_find_global_type_0 : undefined);
        }
        function getGlobalTypeAliasSymbol(name, arity, reportErrors) {
            var symbol = getGlobalSymbol(name, 788968 /* SymbolFlags.Type */, reportErrors ? ts.Diagnostics.Cannot_find_global_type_0 : undefined);
            if (symbol) {
                // Resolve the declared type of the symbol. This resolves type parameters for the type
                // alias so that we can check arity.
                getDeclaredTypeOfSymbol(symbol);
                if (ts.length(getSymbolLinks(symbol).typeParameters) !== arity) {
                    var decl = symbol.declarations && ts.find(symbol.declarations, ts.isTypeAliasDeclaration);
                    error(decl, ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, ts.symbolName(symbol), arity);
                    return undefined;
                }
            }
            return symbol;
        }
        function getGlobalSymbol(name, meaning, diagnostic) {
            // Don't track references for global symbols anyway, so value if `isReference` is arbitrary
            return resolveName(undefined, name, meaning, diagnostic, name, /*isUse*/ false, /*excludeGlobals*/ false, /*getSpellingSuggestions*/ false);
        }
        function getGlobalType(name, arity, reportErrors) {
            var symbol = getGlobalTypeSymbol(name, reportErrors);
            return symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined;
        }
        function getGlobalTypedPropertyDescriptorType() {
            // We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
            return deferredGlobalTypedPropertyDescriptorType || (deferredGlobalTypedPropertyDescriptorType = getGlobalType("TypedPropertyDescriptor", /*arity*/ 1, /*reportErrors*/ true) || emptyGenericType);
        }
        function getGlobalTemplateStringsArrayType() {
            // We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
            return deferredGlobalTemplateStringsArrayType || (deferredGlobalTemplateStringsArrayType = getGlobalType("TemplateStringsArray", /*arity*/ 0, /*reportErrors*/ true) || emptyObjectType);
        }
        function getGlobalImportMetaType() {
            // We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
            return deferredGlobalImportMetaType || (deferredGlobalImportMetaType = getGlobalType("ImportMeta", /*arity*/ 0, /*reportErrors*/ true) || emptyObjectType);
        }
        function getGlobalImportMetaExpressionType() {
            if (!deferredGlobalImportMetaExpressionType) {
                // Create a synthetic type `ImportMetaExpression { meta: MetaProperty }`
                var symbol = createSymbol(0 /* SymbolFlags.None */, "ImportMetaExpression");
                var importMetaType = getGlobalImportMetaType();
                var metaPropertySymbol = createSymbol(4 /* SymbolFlags.Property */, "meta", 8 /* CheckFlags.Readonly */);
                metaPropertySymbol.parent = symbol;
                metaPropertySymbol.type = importMetaType;
                var members = ts.createSymbolTable([metaPropertySymbol]);
                symbol.members = members;
                deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            }
            return deferredGlobalImportMetaExpressionType;
        }
        function getGlobalImportCallOptionsType(reportErrors) {
            return (deferredGlobalImportCallOptionsType || (deferredGlobalImportCallOptionsType = getGlobalType("ImportCallOptions", /*arity*/ 0, reportErrors))) || emptyObjectType;
        }
        function getGlobalESSymbolConstructorSymbol(reportErrors) {
            return deferredGlobalESSymbolConstructorSymbol || (deferredGlobalESSymbolConstructorSymbol = getGlobalValueSymbol("Symbol", reportErrors));
        }
        function getGlobalESSymbolConstructorTypeSymbol(reportErrors) {
            return deferredGlobalESSymbolConstructorTypeSymbol || (deferredGlobalESSymbolConstructorTypeSymbol = getGlobalTypeSymbol("SymbolConstructor", reportErrors));
        }
        function getGlobalESSymbolType() {
            return (deferredGlobalESSymbolType || (deferredGlobalESSymbolType = getGlobalType("Symbol", /*arity*/ 0, /*reportErrors*/ false))) || emptyObjectType;
        }
        function getGlobalPromiseType(reportErrors) {
            return (deferredGlobalPromiseType || (deferredGlobalPromiseType = getGlobalType("Promise", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalPromiseLikeType(reportErrors) {
            return (deferredGlobalPromiseLikeType || (deferredGlobalPromiseLikeType = getGlobalType("PromiseLike", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalPromiseConstructorSymbol(reportErrors) {
            return deferredGlobalPromiseConstructorSymbol || (deferredGlobalPromiseConstructorSymbol = getGlobalValueSymbol("Promise", reportErrors));
        }
        function getGlobalPromiseConstructorLikeType(reportErrors) {
            return (deferredGlobalPromiseConstructorLikeType || (deferredGlobalPromiseConstructorLikeType = getGlobalType("PromiseConstructorLike", /*arity*/ 0, reportErrors))) || emptyObjectType;
        }
        function getGlobalAsyncIterableType(reportErrors) {
            return (deferredGlobalAsyncIterableType || (deferredGlobalAsyncIterableType = getGlobalType("AsyncIterable", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalAsyncIteratorType(reportErrors) {
            return (deferredGlobalAsyncIteratorType || (deferredGlobalAsyncIteratorType = getGlobalType("AsyncIterator", /*arity*/ 3, reportErrors))) || emptyGenericType;
        }
        function getGlobalAsyncIterableIteratorType(reportErrors) {
            return (deferredGlobalAsyncIterableIteratorType || (deferredGlobalAsyncIterableIteratorType = getGlobalType("AsyncIterableIterator", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalAsyncGeneratorType(reportErrors) {
            return (deferredGlobalAsyncGeneratorType || (deferredGlobalAsyncGeneratorType = getGlobalType("AsyncGenerator", /*arity*/ 3, reportErrors))) || emptyGenericType;
        }
        function getGlobalIterableType(reportErrors) {
            return (deferredGlobalIterableType || (deferredGlobalIterableType = getGlobalType("Iterable", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalIteratorType(reportErrors) {
            return (deferredGlobalIteratorType || (deferredGlobalIteratorType = getGlobalType("Iterator", /*arity*/ 3, reportErrors))) || emptyGenericType;
        }
        function getGlobalIterableIteratorType(reportErrors) {
            return (deferredGlobalIterableIteratorType || (deferredGlobalIterableIteratorType = getGlobalType("IterableIterator", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalGeneratorType(reportErrors) {
            return (deferredGlobalGeneratorType || (deferredGlobalGeneratorType = getGlobalType("Generator", /*arity*/ 3, reportErrors))) || emptyGenericType;
        }
        function getGlobalIteratorYieldResultType(reportErrors) {
            return (deferredGlobalIteratorYieldResultType || (deferredGlobalIteratorYieldResultType = getGlobalType("IteratorYieldResult", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalIteratorReturnResultType(reportErrors) {
            return (deferredGlobalIteratorReturnResultType || (deferredGlobalIteratorReturnResultType = getGlobalType("IteratorReturnResult", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalTypeOrUndefined(name, arity) {
            if (arity === void 0) { arity = 0; }
            var symbol = getGlobalSymbol(name, 788968 /* SymbolFlags.Type */, /*diagnostic*/ undefined);
            return symbol && getTypeOfGlobalSymbol(symbol, arity);
        }
        function getGlobalExtractSymbol() {
            // We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
            deferredGlobalExtractSymbol || (deferredGlobalExtractSymbol = getGlobalTypeAliasSymbol("Extract", /*arity*/ 2, /*reportErrors*/ true) || unknownSymbol);
            return deferredGlobalExtractSymbol === unknownSymbol ? undefined : deferredGlobalExtractSymbol;
        }
        function getGlobalOmitSymbol() {
            // We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
            deferredGlobalOmitSymbol || (deferredGlobalOmitSymbol = getGlobalTypeAliasSymbol("Omit", /*arity*/ 2, /*reportErrors*/ true) || unknownSymbol);
            return deferredGlobalOmitSymbol === unknownSymbol ? undefined : deferredGlobalOmitSymbol;
        }
        function getGlobalAwaitedSymbol(reportErrors) {
            // Only cache `unknownSymbol` if we are reporting errors so that we don't report the error more than once.
            deferredGlobalAwaitedSymbol || (deferredGlobalAwaitedSymbol = getGlobalTypeAliasSymbol("Awaited", /*arity*/ 1, reportErrors) || (reportErrors ? unknownSymbol : undefined));
            return deferredGlobalAwaitedSymbol === unknownSymbol ? undefined : deferredGlobalAwaitedSymbol;
        }
        function getGlobalBigIntType() {
            return (deferredGlobalBigIntType || (deferredGlobalBigIntType = getGlobalType("BigInt", /*arity*/ 0, /*reportErrors*/ false))) || emptyObjectType;
        }
        /**
         * Instantiates a global type that is generic with some element type, and returns that instantiation.
         */
        function createTypeFromGenericGlobalType(genericGlobalType, typeArguments) {
            return genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType;
        }
        function createTypedPropertyDescriptorType(propertyType) {
            return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), [propertyType]);
        }
        function createIterableType(iteratedType) {
            return createTypeFromGenericGlobalType(getGlobalIterableType(/*reportErrors*/ true), [iteratedType]);
        }
        function createArrayType(elementType, readonly) {
            return createTypeFromGenericGlobalType(readonly ? globalReadonlyArrayType : globalArrayType, [elementType]);
        }
        function getTupleElementFlags(node) {
            switch (node.kind) {
                case 185 /* SyntaxKind.OptionalType */:
                    return 2 /* ElementFlags.Optional */;
                case 186 /* SyntaxKind.RestType */:
                    return getRestTypeElementFlags(node);
                case 197 /* SyntaxKind.NamedTupleMember */:
                    return node.questionToken ? 2 /* ElementFlags.Optional */ :
                        node.dotDotDotToken ? getRestTypeElementFlags(node) :
                            1 /* ElementFlags.Required */;
                default:
                    return 1 /* ElementFlags.Required */;
            }
        }
        function getRestTypeElementFlags(node) {
            return getArrayElementTypeNode(node.type) ? 4 /* ElementFlags.Rest */ : 8 /* ElementFlags.Variadic */;
        }
        function getArrayOrTupleTargetType(node) {
            var readonly = isReadonlyTypeOperator(node.parent);
            var elementType = getArrayElementTypeNode(node);
            if (elementType) {
                return readonly ? globalReadonlyArrayType : globalArrayType;
            }
            var elementFlags = ts.map(node.elements, getTupleElementFlags);
            var missingName = ts.some(node.elements, function (e) { return e.kind !== 197 /* SyntaxKind.NamedTupleMember */; });
            return getTupleTargetType(elementFlags, readonly, /*associatedNames*/ missingName ? undefined : node.elements);
        }
        // Return true if the given type reference node is directly aliased or if it needs to be deferred
        // because it is possibly contained in a circular chain of eagerly resolved types.
        function isDeferredTypeReferenceNode(node, hasDefaultTypeArguments) {
            return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (node.kind === 183 /* SyntaxKind.ArrayType */ ? mayResolveTypeAlias(node.elementType) :
                node.kind === 184 /* SyntaxKind.TupleType */ ? ts.some(node.elements, mayResolveTypeAlias) :
                    hasDefaultTypeArguments || ts.some(node.typeArguments, mayResolveTypeAlias));
        }
        // Return true when the given node is transitively contained in type constructs that eagerly
        // resolve their constituent types. We include SyntaxKind.TypeReference because type arguments
        // of type aliases are eagerly resolved.
        function isResolvedByTypeAlias(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 191 /* SyntaxKind.ParenthesizedType */:
                case 197 /* SyntaxKind.NamedTupleMember */:
                case 178 /* SyntaxKind.TypeReference */:
                case 187 /* SyntaxKind.UnionType */:
                case 188 /* SyntaxKind.IntersectionType */:
                case 194 /* SyntaxKind.IndexedAccessType */:
                case 189 /* SyntaxKind.ConditionalType */:
                case 193 /* SyntaxKind.TypeOperator */:
                case 183 /* SyntaxKind.ArrayType */:
                case 184 /* SyntaxKind.TupleType */:
                    return isResolvedByTypeAlias(parent);
                case 259 /* SyntaxKind.TypeAliasDeclaration */:
                    return true;
            }
            return false;
        }
        // Return true if resolving the given node (i.e. getTypeFromTypeNode) possibly causes resolution
        // of a type alias.
        function mayResolveTypeAlias(node) {
            switch (node.kind) {
                case 178 /* SyntaxKind.TypeReference */:
                    return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node, 788968 /* SymbolFlags.Type */).flags & 524288 /* SymbolFlags.TypeAlias */);
                case 181 /* SyntaxKind.TypeQuery */:
                    return true;
                case 193 /* SyntaxKind.TypeOperator */:
                    return node.operator !== 154 /* SyntaxKind.UniqueKeyword */ && mayResolveTypeAlias(node.type);
                case 191 /* SyntaxKind.ParenthesizedType */:
                case 185 /* SyntaxKind.OptionalType */:
                case 197 /* SyntaxKind.NamedTupleMember */:
                case 316 /* SyntaxKind.JSDocOptionalType */:
                case 314 /* SyntaxKind.JSDocNullableType */:
                case 315 /* SyntaxKind.JSDocNonNullableType */:
                case 309 /* SyntaxKind.JSDocTypeExpression */:
                    return mayResolveTypeAlias(node.type);
                case 186 /* SyntaxKind.RestType */:
                    return node.type.kind !== 183 /* SyntaxKind.ArrayType */ || mayResolveTypeAlias(node.type.elementType);
                case 187 /* SyntaxKind.UnionType */:
                case 188 /* SyntaxKind.IntersectionType */:
                    return ts.some(node.types, mayResolveTypeAlias);
                case 194 /* SyntaxKind.IndexedAccessType */:
                    return mayResolveTypeAlias(node.objectType) || mayResolveTypeAlias(node.indexType);
                case 189 /* SyntaxKind.ConditionalType */:
                    return mayResolveTypeAlias(node.checkType) || mayResolveTypeAlias(node.extendsType) ||
                        mayResolveTypeAlias(node.trueType) || mayResolveTypeAlias(node.falseType);
            }
            return false;
        }
        function getTypeFromArrayOrTupleTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var target = getArrayOrTupleTargetType(node);
                if (target === emptyGenericType) {
                    links.resolvedType = emptyObjectType;
                }
                else if (!(node.kind === 184 /* SyntaxKind.TupleType */ && ts.some(node.elements, function (e) { return !!(getTupleElementFlags(e) & 8 /* ElementFlags.Variadic */); })) && isDeferredTypeReferenceNode(node)) {
                    links.resolvedType = node.kind === 184 /* SyntaxKind.TupleType */ && node.elements.length === 0 ? target :
                        createDeferredTypeReference(target, node, /*mapper*/ undefined);
                }
                else {
                    var elementTypes = node.kind === 183 /* SyntaxKind.ArrayType */ ? [getTypeFromTypeNode(node.elementType)] : ts.map(node.elements, getTypeFromTypeNode);
                    links.resolvedType = createNormalizedTypeReference(target, elementTypes);
                }
            }
            return links.resolvedType;
        }
        function isReadonlyTypeOperator(node) {
            return ts.isTypeOperatorNode(node) && node.operator === 145 /* SyntaxKind.ReadonlyKeyword */;
        }
        function createTupleType(elementTypes, elementFlags, readonly, namedMemberDeclarations) {
            if (readonly === void 0) { readonly = false; }
            var tupleTarget = getTupleTargetType(elementFlags || ts.map(elementTypes, function (_) { return 1 /* ElementFlags.Required */; }), readonly, namedMemberDeclarations);
            return tupleTarget === emptyGenericType ? emptyObjectType :
                elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :
                    tupleTarget;
        }
        function getTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
            if (elementFlags.length === 1 && elementFlags[0] & 4 /* ElementFlags.Rest */) {
                // [...X[]] is equivalent to just X[]
                return readonly ? globalReadonlyArrayType : globalArrayType;
            }
            var key = ts.map(elementFlags, function (f) { return f & 1 /* ElementFlags.Required */ ? "#" : f & 2 /* ElementFlags.Optional */ ? "?" : f & 4 /* ElementFlags.Rest */ ? "." : "*"; }).join() +
                (readonly ? "R" : "") +
                (namedMemberDeclarations && namedMemberDeclarations.length ? "," + ts.map(namedMemberDeclarations, getNodeId).join(",") : "");
            var type = tupleTypes.get(key);
            if (!type) {
                tupleTypes.set(key, type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations));
            }
            return type;
        }
        // We represent tuple types as type references to synthesized generic interface types created by
        // this function. The types are of the form:
        //
        //   interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
        //
        // Note that the generic type created by this function has no symbol associated with it. The same
        // is true for each of the synthesized type parameters.
        function createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
            var arity = elementFlags.length;
            var minLength = ts.countWhere(elementFlags, function (f) { return !!(f & (1 /* ElementFlags.Required */ | 8 /* ElementFlags.Variadic */)); });
            var typeParameters;
            var properties = [];
            var combinedFlags = 0;
            if (arity) {
                typeParameters = new Array(arity);
                for (var i = 0; i < arity; i++) {
                    var typeParameter = typeParameters[i] = createTypeParameter();
                    var flags = elementFlags[i];
                    combinedFlags |= flags;
                    if (!(combinedFlags & 12 /* ElementFlags.Variable */)) {
                        var property = createSymbol(4 /* SymbolFlags.Property */ | (flags & 2 /* ElementFlags.Optional */ ? 16777216 /* SymbolFlags.Optional */ : 0), "" + i, readonly ? 8 /* CheckFlags.Readonly */ : 0);
                        property.tupleLabelDeclaration = namedMemberDeclarations === null || namedMemberDeclarations === void 0 ? void 0 : namedMemberDeclarations[i];
                        property.type = typeParameter;
                        properties.push(property);
                    }
                }
            }
            var fixedLength = properties.length;
            var lengthSymbol = createSymbol(4 /* SymbolFlags.Property */, "length", readonly ? 8 /* CheckFlags.Readonly */ : 0);
            if (combinedFlags & 12 /* ElementFlags.Variable */) {
                lengthSymbol.type = numberType;
            }
            else {
                var literalTypes = [];
                for (var i = minLength; i <= arity; i++)
                    literalTypes.push(getNumberLiteralType(i));
                lengthSymbol.type = getUnionType(literalTypes);
            }
            properties.push(lengthSymbol);
            var type = createObjectType(8 /* ObjectFlags.Tuple */ | 4 /* ObjectFlags.Reference */);
            type.typeParameters = typeParameters;
            type.outerTypeParameters = undefined;
            type.localTypeParameters = typeParameters;
            type.instantiations = new ts.Map();
            type.instantiations.set(getTypeListId(type.typeParameters), type);
            type.target = type;
            type.resolvedTypeArguments = type.typeParameters;
            type.thisType = createTypeParameter();
            type.thisType.isThisType = true;
            type.thisType.constraint = type;
            type.declaredProperties = properties;
            type.declaredCallSignatures = ts.emptyArray;
            type.declaredConstructSignatures = ts.emptyArray;
            type.declaredIndexInfos = ts.emptyArray;
            type.elementFlags = elementFlags;
            type.minLength = minLength;
            type.fixedLength = fixedLength;
            type.hasRestElement = !!(combinedFlags & 12 /* ElementFlags.Variable */);
            type.combinedFlags = combinedFlags;
            type.readonly = readonly;
            type.labeledElementDeclarations = namedMemberDeclarations;
            return type;
        }
        function createNormalizedTypeReference(target, typeArguments) {
            return target.objectFlags & 8 /* ObjectFlags.Tuple */ ? createNormalizedTupleType(target, typeArguments) : createTypeReference(target, typeArguments);
        }
        function createNormalizedTupleType(target, elementTypes) {
            var _a, _b, _c;
            if (!(target.combinedFlags & 14 /* ElementFlags.NonRequired */)) {
                // No need to normalize when we only have regular required elements
                return createTypeReference(target, elementTypes);
            }
            if (target.combinedFlags & 8 /* ElementFlags.Variadic */) {
                // Transform [A, ...(X | Y | Z)] into [A, ...X] | [A, ...Y] | [A, ...Z]
                var unionIndex_1 = ts.findIndex(elementTypes, function (t, i) { return !!(target.elementFlags[i] & 8 /* ElementFlags.Variadic */ && t.flags & (131072 /* TypeFlags.Never */ | 1048576 /* TypeFlags.Union */)); });
                if (unionIndex_1 >= 0) {
                    return checkCrossProductUnion(ts.map(elementTypes, function (t, i) { return target.elementFlags[i] & 8 /* ElementFlags.Variadic */ ? t : unknownType; })) ?
                        mapType(elementTypes[unionIndex_1], function (t) { return createNormalizedTupleType(target, ts.replaceElement(elementTypes, unionIndex_1, t)); }) :
                        errorType;
                }
            }
            // We have optional, rest, or variadic elements that may need normalizing. Normalization ensures that all variadic
            // elements are generic and that the tuple type has one of the following layouts, disregarding variadic elements:
            // (1) Zero or more required elements, followed by zero or more optional elements, followed by zero or one rest element.
            // (2) Zero or more required elements, followed by a rest element, followed by zero or more required elements.
            // In either layout, zero or more generic variadic elements may be present at any location.
            var expandedTypes = [];
            var expandedFlags = [];
            var expandedDeclarations = [];
            var lastRequiredIndex = -1;
            var firstRestIndex = -1;
            var lastOptionalOrRestIndex = -1;
            var _loop_15 = function (i) {
                var type = elementTypes[i];
                var flags = target.elementFlags[i];
                if (flags & 8 /* ElementFlags.Variadic */) {
                    if (type.flags & 58982400 /* TypeFlags.InstantiableNonPrimitive */ || isGenericMappedType(type)) {
                        // Generic variadic elements stay as they are.
                        addElement(type, 8 /* ElementFlags.Variadic */, (_a = target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[i]);
                    }
                    else if (isTupleType(type)) {
                        var elements = getTypeArguments(type);
                        if (elements.length + expandedTypes.length >= 10000) {
                            error(currentNode, ts.isPartOfTypeNode(currentNode)
                                ? ts.Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent
                                : ts.Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent);
                            return { value: errorType };
                        }
                        // Spread variadic elements with tuple types into the resulting tuple.
                        ts.forEach(elements, function (t, n) { var _a; return addElement(t, type.target.elementFlags[n], (_a = type.target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[n]); });
                    }
                    else {
                        // Treat everything else as an array type and create a rest element.
                        addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, 4 /* ElementFlags.Rest */, (_b = target.labeledElementDeclarations) === null || _b === void 0 ? void 0 : _b[i]);
                    }
                }
                else {
                    // Copy other element kinds with no change.
                    addElement(type, flags, (_c = target.labeledElementDeclarations) === null || _c === void 0 ? void 0 : _c[i]);
                }
            };
            for (var i = 0; i < elementTypes.length; i++) {
                var state_4 = _loop_15(i);
                if (typeof state_4 === "object")
                    return state_4.value;
            }
            // Turn optional elements preceding the last required element into required elements
            for (var i = 0; i < lastRequiredIndex; i++) {
                if (expandedFlags[i] & 2 /* ElementFlags.Optional */)
                    expandedFlags[i] = 1 /* ElementFlags.Required */;
            }
            if (firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex) {
                // Turn elements between first rest and last optional/rest into a single rest element
                expandedTypes[firstRestIndex] = getUnionType(ts.sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1), function (t, i) { return expandedFlags[firstRestIndex + i] & 8 /* ElementFlags.Variadic */ ? getIndexedAccessType(t, numberType) : t; }));
                expandedTypes.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
                expandedFlags.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
                expandedDeclarations === null || expandedDeclarations === void 0 ? void 0 : expandedDeclarations.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            }
            var tupleTarget = getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations);
            return tupleTarget === emptyGenericType ? emptyObjectType :
                expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :
                    tupleTarget;
            function addElement(type, flags, declaration) {
                if (flags & 1 /* ElementFlags.Required */) {
                    lastRequiredIndex = expandedFlags.length;
                }
                if (flags & 4 /* ElementFlags.Rest */ && firstRestIndex < 0) {
                    firstRestIndex = expandedFlags.length;
                }
                if (flags & (2 /* ElementFlags.Optional */ | 4 /* ElementFlags.Rest */)) {
                    lastOptionalOrRestIndex = expandedFlags.length;
                }
                expandedTypes.push(type);
                expandedFlags.push(flags);
                if (expandedDeclarations && declaration) {
                    expandedDeclarations.push(declaration);
                }
                else {
                    expandedDeclarations = undefined;
                }
            }
        }
        function sliceTupleType(type, index, endSkipCount) {
            if (endSkipCount === void 0) { endSkipCount = 0; }
            var target = type.target;
            var endIndex = getTypeReferenceArity(type) - endSkipCount;
            return index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(ts.emptyArray) :
                createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), 
                /*readonly*/ false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex));
        }
        function getKnownKeysOfTupleType(type) {
            return getUnionType(ts.append(ts.arrayOf(type.target.fixedLength, function (i) { return getStringLiteralType("" + i); }), getIndexType(type.target.readonly ? globalReadonlyArrayType : globalArrayType)));
        }
        // Return count of starting consecutive tuple elements of the given kind(s)
        function getStartElementCount(type, flags) {
            var index = ts.findIndex(type.elementFlags, function (f) { return !(f & flags); });
            return index >= 0 ? index : type.elementFlags.length;
        }
        // Return count of ending consecutive tuple elements of the given kind(s)
        function getEndElementCount(type, flags) {
            return type.elementFlags.length - ts.findLastIndex(type.elementFlags, function (f) { return !(f & flags); }) - 1;
        }
        function getTypeFromOptionalTypeNode(node) {
            return addOptionality(getTypeFromTypeNode(node.type), /*isProperty*/ true);
        }
        function getTypeId(type) {
            return type.id;
        }
        function containsType(types, type) {
            return ts.binarySearch(types, type, getTypeId, ts.compareValues) >= 0;
        }
        function insertType(types, type) {
            var index = ts.binarySearch(types, type, getTypeId, ts.compareValues);
            if (index < 0) {
                types.splice(~index, 0, type);
                return true;
            }
            return false;
        }
        function addTypeToUnion(typeSet, includes, type) {
            var flags = type.flags;
            if (flags & 1048576 /* TypeFlags.Union */) {
                return addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? 1048576 /* TypeFlags.Union */ : 0), type.types);
            }
            // We ignore 'never' types in unions
            if (!(flags & 131072 /* TypeFlags.Never */)) {
                includes |= flags & 205258751 /* TypeFlags.IncludesMask */;
                if (flags & 465829888 /* TypeFlags.Instantiable */)
                    includes |= 33554432 /* TypeFlags.IncludesInstantiable */;
                if (type === wildcardType)
                    includes |= 8388608 /* TypeFlags.IncludesWildcard */;
                if (!strictNullChecks && flags & 98304 /* TypeFlags.Nullable */) {
                    if (!(ts.getObjectFlags(type) & 65536 /* ObjectFlags.ContainsWideningType */))
                        includes |= 4194304 /* TypeFlags.IncludesNonWideningType */;
                }
                else {
                    var len = typeSet.length;
                    var index = len && type.id > typeSet[len - 1].id ? ~len : ts.binarySearch(typeSet, type, getTypeId, ts.compareValues);
                    if (index < 0) {
                        typeSet.splice(~index, 0, type);
                    }
                }
            }
            return includes;
        }
        // Add the given types to the given type set. Order is preserved, duplicates are removed,
        // and nested types of the given kind are flattened into the set.
        function addTypesToUnion(typeSet, includes, types) {
            for (var _i = 0, types_9 = types; _i < types_9.length; _i++) {
                var type = types_9[_i];
                includes = addTypeToUnion(typeSet, includes, type);
            }
            return includes;
        }
        function removeSubtypes(types, hasObjectTypes) {
            // [] and [T] immediately reduce to [] and [T] respectively
            if (types.length < 2) {
                return types;
            }
            var id = getTypeListId(types);
            var match = subtypeReductionCache.get(id);
            if (match) {
                return match;
            }
            // We assume that redundant primitive types have already been removed from the types array and that there
            // are no any and unknown types in the array. Thus, the only possible supertypes for primitive types are empty
            // object types, and if none of those are present we can exclude primitive types from the subtype check.
            var hasEmptyObject = hasObjectTypes && ts.some(types, function (t) { return !!(t.flags & 524288 /* TypeFlags.Object */) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t)); });
            var len = types.length;
            var i = len;
            var count = 0;
            while (i > 0) {
                i--;
                var source = types[i];
                if (hasEmptyObject || source.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */) {
                    // Find the first property with a unit type, if any. When constituents have a property by the same name
                    // but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype
                    // reduction of large discriminated union types.
                    var keyProperty = source.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */ | 58982400 /* TypeFlags.InstantiableNonPrimitive */) ?
                        ts.find(getPropertiesOfType(source), function (p) { return isUnitType(getTypeOfSymbol(p)); }) :
                        undefined;
                    var keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));
                    for (var _i = 0, types_10 = types; _i < types_10.length; _i++) {
                        var target = types_10[_i];
                        if (source !== target) {
                            if (count === 100000) {
                                // After 100000 subtype checks we estimate the remaining amount of work by assuming the
                                // same ratio of checks per element. If the estimated number of remaining type checks is
                                // greater than 1M we deem the union type too complex to represent. This for example
                                // caps union types at 1000 unique object types.
                                var estimatedCount = (count / (len - i)) * len;
                                if (estimatedCount > 1000000) {
                                    ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "removeSubtypes_DepthLimit", { typeIds: types.map(function (t) { return t.id; }) });
                                    error(currentNode, ts.Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                                    return undefined;
                                }
                            }
                            count++;
                            if (keyProperty && target.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */ | 58982400 /* TypeFlags.InstantiableNonPrimitive */)) {
                                var t = getTypeOfPropertyOfType(target, keyProperty.escapedName);
                                if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {
                                    continue;
                                }
                            }
                            if (isTypeRelatedTo(source, target, strictSubtypeRelation) && (!(ts.getObjectFlags(getTargetType(source)) & 1 /* ObjectFlags.Class */) ||
                                !(ts.getObjectFlags(getTargetType(target)) & 1 /* ObjectFlags.Class */) ||
                                isTypeDerivedFrom(source, target))) {
                                ts.orderedRemoveItemAt(types, i);
                                break;
                            }
                        }
                    }
                }
            }
            subtypeReductionCache.set(id, types);
            return types;
        }
        function removeRedundantLiteralTypes(types, includes, reduceVoidUndefined) {
            var i = types.length;
            while (i > 0) {
                i--;
                var t = types[i];
                var flags = t.flags;
                var remove = flags & (128 /* TypeFlags.StringLiteral */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) && includes & 4 /* TypeFlags.String */ ||
                    flags & 256 /* TypeFlags.NumberLiteral */ && includes & 8 /* TypeFlags.Number */ ||
                    flags & 2048 /* TypeFlags.BigIntLiteral */ && includes & 64 /* TypeFlags.BigInt */ ||
                    flags & 8192 /* TypeFlags.UniqueESSymbol */ && includes & 4096 /* TypeFlags.ESSymbol */ ||
                    reduceVoidUndefined && flags & 32768 /* TypeFlags.Undefined */ && includes & 16384 /* TypeFlags.Void */ ||
                    isFreshLiteralType(t) && containsType(types, t.regularType);
                if (remove) {
                    ts.orderedRemoveItemAt(types, i);
                }
            }
        }
        function removeStringLiteralsMatchedByTemplateLiterals(types) {
            var templates = ts.filter(types, isPatternLiteralType);
            if (templates.length) {
                var i = types.length;
                var _loop_16 = function () {
                    i--;
                    var t = types[i];
                    if (t.flags & 128 /* TypeFlags.StringLiteral */ && ts.some(templates, function (template) { return isTypeMatchedByTemplateLiteralType(t, template); })) {
                        ts.orderedRemoveItemAt(types, i);
                    }
                };
                while (i > 0) {
                    _loop_16();
                }
            }
        }
        function isNamedUnionType(type) {
            return !!(type.flags & 1048576 /* TypeFlags.Union */ && (type.aliasSymbol || type.origin));
        }
        function addNamedUnions(namedUnions, types) {
            for (var _i = 0, types_11 = types; _i < types_11.length; _i++) {
                var t = types_11[_i];
                if (t.flags & 1048576 /* TypeFlags.Union */) {
                    var origin = t.origin;
                    if (t.aliasSymbol || origin && !(origin.flags & 1048576 /* TypeFlags.Union */)) {
                        ts.pushIfUnique(namedUnions, t);
                    }
                    else if (origin && origin.flags & 1048576 /* TypeFlags.Union */) {
                        addNamedUnions(namedUnions, origin.types);
                    }
                }
            }
        }
        function createOriginUnionOrIntersectionType(flags, types) {
            var result = createOriginType(flags);
            result.types = types;
            return result;
        }
        // We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
        // flag is specified we also reduce the constituent type set to only include types that aren't subtypes
        // of other types. Subtype reduction is expensive for large union types and is possible only when union
        // types are known not to circularly reference themselves (as is the case with union types created by
        // expression constructs such as array literals and the || and ?: operators). Named types can
        // circularly reference themselves and therefore cannot be subtype reduced during their declaration.
        // For example, "type Item = string | (() => Item" is a named type that circularly references itself.
        function getUnionType(types, unionReduction, aliasSymbol, aliasTypeArguments, origin) {
            if (unionReduction === void 0) { unionReduction = 1 /* UnionReduction.Literal */; }
            if (types.length === 0) {
                return neverType;
            }
            if (types.length === 1) {
                return types[0];
            }
            var typeSet = [];
            var includes = addTypesToUnion(typeSet, 0, types);
            if (unionReduction !== 0 /* UnionReduction.None */) {
                if (includes & 3 /* TypeFlags.AnyOrUnknown */) {
                    return includes & 1 /* TypeFlags.Any */ ?
                        includes & 8388608 /* TypeFlags.IncludesWildcard */ ? wildcardType : anyType :
                        includes & 65536 /* TypeFlags.Null */ || containsType(typeSet, unknownType) ? unknownType : nonNullUnknownType;
                }
                if (exactOptionalPropertyTypes && includes & 32768 /* TypeFlags.Undefined */) {
                    var missingIndex = ts.binarySearch(typeSet, missingType, getTypeId, ts.compareValues);
                    if (missingIndex >= 0 && containsType(typeSet, undefinedType)) {
                        ts.orderedRemoveItemAt(typeSet, missingIndex);
                    }
                }
                if (includes & (2944 /* TypeFlags.Literal */ | 8192 /* TypeFlags.UniqueESSymbol */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) || includes & 16384 /* TypeFlags.Void */ && includes & 32768 /* TypeFlags.Undefined */) {
                    removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & 2 /* UnionReduction.Subtype */));
                }
                if (includes & 128 /* TypeFlags.StringLiteral */ && includes & 134217728 /* TypeFlags.TemplateLiteral */) {
                    removeStringLiteralsMatchedByTemplateLiterals(typeSet);
                }
                if (unionReduction === 2 /* UnionReduction.Subtype */) {
                    typeSet = removeSubtypes(typeSet, !!(includes & 524288 /* TypeFlags.Object */));
                    if (!typeSet) {
                        return errorType;
                    }
                }
                if (typeSet.length === 0) {
                    return includes & 65536 /* TypeFlags.Null */ ? includes & 4194304 /* TypeFlags.IncludesNonWideningType */ ? nullType : nullWideningType :
                        includes & 32768 /* TypeFlags.Undefined */ ? includes & 4194304 /* TypeFlags.IncludesNonWideningType */ ? undefinedType : undefinedWideningType :
                            neverType;
                }
            }
            if (!origin && includes & 1048576 /* TypeFlags.Union */) {
                var namedUnions = [];
                addNamedUnions(namedUnions, types);
                var reducedTypes = [];
                var _loop_17 = function (t) {
                    if (!ts.some(namedUnions, function (union) { return containsType(union.types, t); })) {
                        reducedTypes.push(t);
                    }
                };
                for (var _i = 0, typeSet_1 = typeSet; _i < typeSet_1.length; _i++) {
                    var t = typeSet_1[_i];
                    _loop_17(t);
                }
                if (!aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0) {
                    return namedUnions[0];
                }
                // We create a denormalized origin type only when the union was created from one or more named unions
                // (unions with alias symbols or origins) and when there is no overlap between those named unions.
                var namedTypesCount = ts.reduceLeft(namedUnions, function (sum, union) { return sum + union.types.length; }, 0);
                if (namedTypesCount + reducedTypes.length === typeSet.length) {
                    for (var _a = 0, namedUnions_1 = namedUnions; _a < namedUnions_1.length; _a++) {
                        var t = namedUnions_1[_a];
                        insertType(reducedTypes, t);
                    }
                    origin = createOriginUnionOrIntersectionType(1048576 /* TypeFlags.Union */, reducedTypes);
                }
            }
            var objectFlags = (includes & 36323363 /* TypeFlags.NotPrimitiveUnion */ ? 0 : 32768 /* ObjectFlags.PrimitiveUnion */) |
                (includes & 2097152 /* TypeFlags.Intersection */ ? 16777216 /* ObjectFlags.ContainsIntersections */ : 0);
            return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin);
        }
        function getUnionOrIntersectionTypePredicate(signatures, kind) {
            var first;
            var types = [];
            for (var _i = 0, signatures_6 = signatures; _i < signatures_6.length; _i++) {
                var sig = signatures_6[_i];
                var pred = getTypePredicateOfSignature(sig);
                if (!pred || pred.kind === 2 /* TypePredicateKind.AssertsThis */ || pred.kind === 3 /* TypePredicateKind.AssertsIdentifier */) {
                    if (kind !== 2097152 /* TypeFlags.Intersection */) {
                        continue;
                    }
                    else {
                        return; // intersections demand all members be type predicates for the result to have a predicate
                    }
                }
                if (first) {
                    if (!typePredicateKindsMatch(first, pred)) {
                        // No common type predicate.
                        return undefined;
                    }
                }
                else {
                    first = pred;
                }
                types.push(pred.type);
            }
            if (!first) {
                // No signatures had a type predicate.
                return undefined;
            }
            var compositeType = getUnionOrIntersectionType(types, kind);
            return createTypePredicate(first.kind, first.parameterName, first.parameterIndex, compositeType);
        }
        function typePredicateKindsMatch(a, b) {
            return a.kind === b.kind && a.parameterIndex === b.parameterIndex;
        }
        // This function assumes the constituent type list is sorted and deduplicated.
        function getUnionTypeFromSortedList(types, objectFlags, aliasSymbol, aliasTypeArguments, origin) {
            if (types.length === 0) {
                return neverType;
            }
            if (types.length === 1) {
                return types[0];
            }
            var typeKey = !origin ? getTypeListId(types) :
                origin.flags & 1048576 /* TypeFlags.Union */ ? "|".concat(getTypeListId(origin.types)) :
                    origin.flags & 2097152 /* TypeFlags.Intersection */ ? "&".concat(getTypeListId(origin.types)) :
                        "#".concat(origin.type.id, "|").concat(getTypeListId(types)); // origin type id alone is insufficient, as `keyof x` may resolve to multiple WIP values while `x` is still resolving
            var id = typeKey + getAliasId(aliasSymbol, aliasTypeArguments);
            var type = unionTypes.get(id);
            if (!type) {
                type = createType(1048576 /* TypeFlags.Union */);
                type.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds*/ 98304 /* TypeFlags.Nullable */);
                type.types = types;
                type.origin = origin;
                type.aliasSymbol = aliasSymbol;
                type.aliasTypeArguments = aliasTypeArguments;
                if (types.length === 2 && types[0].flags & 512 /* TypeFlags.BooleanLiteral */ && types[1].flags & 512 /* TypeFlags.BooleanLiteral */) {
                    type.flags |= 16 /* TypeFlags.Boolean */;
                    type.intrinsicName = "boolean";
                }
                unionTypes.set(id, type);
            }
            return type;
        }
        function getTypeFromUnionTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                links.resolvedType = getUnionType(ts.map(node.types, getTypeFromTypeNode), 1 /* UnionReduction.Literal */, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
            }
            return links.resolvedType;
        }
        function addTypeToIntersection(typeSet, includes, type) {
            var flags = type.flags;
            if (flags & 2097152 /* TypeFlags.Intersection */) {
                return addTypesToIntersection(typeSet, includes, type.types);
            }
            if (isEmptyAnonymousObjectType(type)) {
                if (!(includes & 16777216 /* TypeFlags.IncludesEmptyObject */)) {
                    includes |= 16777216 /* TypeFlags.IncludesEmptyObject */;
                    typeSet.set(type.id.toString(), type);
                }
            }
            else {
                if (flags & 3 /* TypeFlags.AnyOrUnknown */) {
                    if (type === wildcardType)
                        includes |= 8388608 /* TypeFlags.IncludesWildcard */;
                }
                else if (strictNullChecks || !(flags & 98304 /* TypeFlags.Nullable */)) {
                    if (exactOptionalPropertyTypes && type === missingType) {
                        includes |= 262144 /* TypeFlags.IncludesMissingType */;
                        type = undefinedType;
                    }
                    if (!typeSet.has(type.id.toString())) {
                        if (type.flags & 109440 /* TypeFlags.Unit */ && includes & 109440 /* TypeFlags.Unit */) {
                            // We have seen two distinct unit types which means we should reduce to an
                            // empty intersection. Adding TypeFlags.NonPrimitive causes that to happen.
                            includes |= 67108864 /* TypeFlags.NonPrimitive */;
                        }
                        typeSet.set(type.id.toString(), type);
                    }
                }
                includes |= flags & 205258751 /* TypeFlags.IncludesMask */;
            }
            return includes;
        }
        // Add the given types to the given type set. Order is preserved, freshness is removed from literal
        // types, duplicates are removed, and nested types of the given kind are flattened into the set.
        function addTypesToIntersection(typeSet, includes, types) {
            for (var _i = 0, types_12 = types; _i < types_12.length; _i++) {
                var type = types_12[_i];
                includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type));
            }
            return includes;
        }
        function removeRedundantPrimitiveTypes(types, includes) {
            var i = types.length;
            while (i > 0) {
                i--;
                var t = types[i];
                var remove = t.flags & 4 /* TypeFlags.String */ && includes & (128 /* TypeFlags.StringLiteral */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) ||
                    t.flags & 8 /* TypeFlags.Number */ && includes & 256 /* TypeFlags.NumberLiteral */ ||
                    t.flags & 64 /* TypeFlags.BigInt */ && includes & 2048 /* TypeFlags.BigIntLiteral */ ||
                    t.flags & 4096 /* TypeFlags.ESSymbol */ && includes & 8192 /* TypeFlags.UniqueESSymbol */;
                if (remove) {
                    ts.orderedRemoveItemAt(types, i);
                }
            }
        }
        // Check that the given type has a match in every union. A given type is matched by
        // an identical type, and a literal type is additionally matched by its corresponding
        // primitive type.
        function eachUnionContains(unionTypes, type) {
            for (var _i = 0, unionTypes_1 = unionTypes; _i < unionTypes_1.length; _i++) {
                var u = unionTypes_1[_i];
                if (!containsType(u.types, type)) {
                    var primitive = type.flags & 128 /* TypeFlags.StringLiteral */ ? stringType :
                        type.flags & 256 /* TypeFlags.NumberLiteral */ ? numberType :
                            type.flags & 2048 /* TypeFlags.BigIntLiteral */ ? bigintType :
                                type.flags & 8192 /* TypeFlags.UniqueESSymbol */ ? esSymbolType :
                                    undefined;
                    if (!primitive || !containsType(u.types, primitive)) {
                        return false;
                    }
                }
            }
            return true;
        }
        /**
         * Returns `true` if the intersection of the template literals and string literals is the empty set, eg `get${string}` & "setX", and should reduce to `never`
         */
        function extractRedundantTemplateLiterals(types) {
            var i = types.length;
            var literals = ts.filter(types, function (t) { return !!(t.flags & 128 /* TypeFlags.StringLiteral */); });
            while (i > 0) {
                i--;
                var t = types[i];
                if (!(t.flags & 134217728 /* TypeFlags.TemplateLiteral */))
                    continue;
                for (var _i = 0, literals_1 = literals; _i < literals_1.length; _i++) {
                    var t2 = literals_1[_i];
                    if (isTypeSubtypeOf(t2, t)) {
                        // eg, ``get${T}` & "getX"` is just `"getX"`
                        ts.orderedRemoveItemAt(types, i);
                        break;
                    }
                    else if (isPatternLiteralType(t)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function eachIsUnionContaining(types, flag) {
            return ts.every(types, function (t) { return !!(t.flags & 1048576 /* TypeFlags.Union */) && ts.some(t.types, function (tt) { return !!(tt.flags & flag); }); });
        }
        function removeFromEach(types, flag) {
            for (var i = 0; i < types.length; i++) {
                types[i] = filterType(types[i], function (t) { return !(t.flags & flag); });
            }
        }
        // If the given list of types contains more than one union of primitive types, replace the
        // first with a union containing an intersection of those primitive types, then remove the
        // other unions and return true. Otherwise, do nothing and return false.
        function intersectUnionsOfPrimitiveTypes(types) {
            var unionTypes;
            var index = ts.findIndex(types, function (t) { return !!(ts.getObjectFlags(t) & 32768 /* ObjectFlags.PrimitiveUnion */); });
            if (index < 0) {
                return false;
            }
            var i = index + 1;
            // Remove all but the first union of primitive types and collect them in
            // the unionTypes array.
            while (i < types.length) {
                var t = types[i];
                if (ts.getObjectFlags(t) & 32768 /* ObjectFlags.PrimitiveUnion */) {
                    (unionTypes || (unionTypes = [types[index]])).push(t);
                    ts.orderedRemoveItemAt(types, i);
                }
                else {
                    i++;
                }
            }
            // Return false if there was only one union of primitive types
            if (!unionTypes) {
                return false;
            }
            // We have more than one union of primitive types, now intersect them. For each
            // type in each union we check if the type is matched in every union and if so
            // we include it in the result.
            var checked = [];
            var result = [];
            for (var _i = 0, unionTypes_2 = unionTypes; _i < unionTypes_2.length; _i++) {
                var u = unionTypes_2[_i];
                for (var _a = 0, _b = u.types; _a < _b.length; _a++) {
                    var t = _b[_a];
                    if (insertType(checked, t)) {
                        if (eachUnionContains(unionTypes, t)) {
                            insertType(result, t);
                        }
                    }
                }
            }
            // Finally replace the first union with the result
            types[index] = getUnionTypeFromSortedList(result, 32768 /* ObjectFlags.PrimitiveUnion */);
            return true;
        }
        function createIntersectionType(types, aliasSymbol, aliasTypeArguments) {
            var result = createType(2097152 /* TypeFlags.Intersection */);
            result.objectFlags = getPropagatingFlagsOfTypes(types, /*excludeKinds*/ 98304 /* TypeFlags.Nullable */);
            result.types = types;
            result.aliasSymbol = aliasSymbol;
            result.aliasTypeArguments = aliasTypeArguments;
            return result;
        }
        // We normalize combinations of intersection and union types based on the distributive property of the '&'
        // operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
        // types with union type constituents into equivalent union types with intersection type constituents and
        // effectively ensure that union types are always at the top level in type representations.
        //
        // We do not perform structural deduplication on intersection types. Intersection types are created only by the &
        // type operator and we can't reduce those because we want to support recursive intersection types. For example,
        // a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
        // Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
        // for intersections of types with signatures can be deterministic.
        function getIntersectionType(types, aliasSymbol, aliasTypeArguments) {
            var typeMembershipMap = new ts.Map();
            var includes = addTypesToIntersection(typeMembershipMap, 0, types);
            var typeSet = ts.arrayFrom(typeMembershipMap.values());
            // An intersection type is considered empty if it contains
            // the type never, or
            // more than one unit type or,
            // an object type and a nullable type (null or undefined), or
            // a string-like type and a type known to be non-string-like, or
            // a number-like type and a type known to be non-number-like, or
            // a symbol-like type and a type known to be non-symbol-like, or
            // a void-like type and a type known to be non-void-like, or
            // a non-primitive type and a type known to be primitive.
            if (includes & 131072 /* TypeFlags.Never */) {
                return ts.contains(typeSet, silentNeverType) ? silentNeverType : neverType;
            }
            if (strictNullChecks && includes & 98304 /* TypeFlags.Nullable */ && includes & (524288 /* TypeFlags.Object */ | 67108864 /* TypeFlags.NonPrimitive */ | 16777216 /* TypeFlags.IncludesEmptyObject */) ||
                includes & 67108864 /* TypeFlags.NonPrimitive */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~67108864 /* TypeFlags.NonPrimitive */) ||
                includes & 402653316 /* TypeFlags.StringLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~402653316 /* TypeFlags.StringLike */) ||
                includes & 296 /* TypeFlags.NumberLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~296 /* TypeFlags.NumberLike */) ||
                includes & 2112 /* TypeFlags.BigIntLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~2112 /* TypeFlags.BigIntLike */) ||
                includes & 12288 /* TypeFlags.ESSymbolLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~12288 /* TypeFlags.ESSymbolLike */) ||
                includes & 49152 /* TypeFlags.VoidLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~49152 /* TypeFlags.VoidLike */)) {
                return neverType;
            }
            if (includes & 134217728 /* TypeFlags.TemplateLiteral */ && includes & 128 /* TypeFlags.StringLiteral */ && extractRedundantTemplateLiterals(typeSet)) {
                return neverType;
            }
            if (includes & 1 /* TypeFlags.Any */) {
                return includes & 8388608 /* TypeFlags.IncludesWildcard */ ? wildcardType : anyType;
            }
            if (!strictNullChecks && includes & 98304 /* TypeFlags.Nullable */) {
                return includes & 32768 /* TypeFlags.Undefined */ ? undefinedType : nullType;
            }
            if (includes & 4 /* TypeFlags.String */ && includes & (128 /* TypeFlags.StringLiteral */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) ||
                includes & 8 /* TypeFlags.Number */ && includes & 256 /* TypeFlags.NumberLiteral */ ||
                includes & 64 /* TypeFlags.BigInt */ && includes & 2048 /* TypeFlags.BigIntLiteral */ ||
                includes & 4096 /* TypeFlags.ESSymbol */ && includes & 8192 /* TypeFlags.UniqueESSymbol */) {
                removeRedundantPrimitiveTypes(typeSet, includes);
            }
            if (includes & 16777216 /* TypeFlags.IncludesEmptyObject */ && includes & 524288 /* TypeFlags.Object */) {
                ts.orderedRemoveItemAt(typeSet, ts.findIndex(typeSet, isEmptyAnonymousObjectType));
            }
            if (includes & 262144 /* TypeFlags.IncludesMissingType */) {
                typeSet[typeSet.indexOf(undefinedType)] = missingType;
            }
            if (typeSet.length === 0) {
                return unknownType;
            }
            if (typeSet.length === 1) {
                return typeSet[0];
            }
            var id = getTypeListId(typeSet) + getAliasId(aliasSymbol, aliasTypeArguments);
            var result = intersectionTypes.get(id);
            if (!result) {
                if (includes & 1048576 /* TypeFlags.Union */) {
                    if (intersectUnionsOfPrimitiveTypes(typeSet)) {
                        // When the intersection creates a reduced set (which might mean that *all* union types have
                        // disappeared), we restart the operation to get a new set of combined flags. Once we have
                        // reduced we'll never reduce again, so this occurs at most once.
                        result = getIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
                    }
                    else if (eachIsUnionContaining(typeSet, 32768 /* TypeFlags.Undefined */)) {
                        var undefinedOrMissingType = exactOptionalPropertyTypes && ts.some(typeSet, function (t) { return containsType(t.types, missingType); }) ? missingType : undefinedType;
                        removeFromEach(typeSet, 32768 /* TypeFlags.Undefined */);
                        result = getUnionType([getIntersectionType(typeSet), undefinedOrMissingType], 1 /* UnionReduction.Literal */, aliasSymbol, aliasTypeArguments);
                    }
                    else if (eachIsUnionContaining(typeSet, 65536 /* TypeFlags.Null */)) {
                        removeFromEach(typeSet, 65536 /* TypeFlags.Null */);
                        result = getUnionType([getIntersectionType(typeSet), nullType], 1 /* UnionReduction.Literal */, aliasSymbol, aliasTypeArguments);
                    }
                    else {
                        // We are attempting to construct a type of the form X & (A | B) & (C | D). Transform this into a type of
                        // the form X & A & C | X & A & D | X & B & C | X & B & D. If the estimated size of the resulting union type
                        // exceeds 100000 constituents, report an error.
                        if (!checkCrossProductUnion(typeSet)) {
                            return errorType;
                        }
                        var constituents = getCrossProductIntersections(typeSet);
                        // We attach a denormalized origin type when at least one constituent of the cross-product union is an
                        // intersection (i.e. when the intersection didn't just reduce one or more unions to smaller unions).
                        var origin = ts.some(constituents, function (t) { return !!(t.flags & 2097152 /* TypeFlags.Intersection */); }) ? createOriginUnionOrIntersectionType(2097152 /* TypeFlags.Intersection */, typeSet) : undefined;
                        result = getUnionType(constituents, 1 /* UnionReduction.Literal */, aliasSymbol, aliasTypeArguments, origin);
                    }
                }
                else {
                    result = createIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
                }
                intersectionTypes.set(id, result);
            }
            return result;
        }
        function getCrossProductUnionSize(types) {
            return ts.reduceLeft(types, function (n, t) { return t.flags & 1048576 /* TypeFlags.Union */ ? n * t.types.length : t.flags & 131072 /* TypeFlags.Never */ ? 0 : n; }, 1);
        }
        function checkCrossProductUnion(types) {
            var size = getCrossProductUnionSize(types);
            if (size >= 100000) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "checkCrossProductUnion_DepthLimit", { typeIds: types.map(function (t) { return t.id; }), size: size });
                error(currentNode, ts.Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                return false;
            }
            return true;
        }
        function getCrossProductIntersections(types) {
            var count = getCrossProductUnionSize(types);
            var intersections = [];
            for (var i = 0; i < count; i++) {
                var constituents = types.slice();
                var n = i;
                for (var j = types.length - 1; j >= 0; j--) {
                    if (types[j].flags & 1048576 /* TypeFlags.Union */) {
                        var sourceTypes = types[j].types;
                        var length_5 = sourceTypes.length;
                        constituents[j] = sourceTypes[n % length_5];
                        n = Math.floor(n / length_5);
                    }
                }
                var t = getIntersectionType(constituents);
                if (!(t.flags & 131072 /* TypeFlags.Never */))
                    intersections.push(t);
            }
            return intersections;
        }
        function getTypeFromIntersectionTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                links.resolvedType = getIntersectionType(ts.map(node.types, getTypeFromTypeNode), aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
            }
            return links.resolvedType;
        }
        function createIndexType(type, stringsOnly) {
            var result = createType(4194304 /* TypeFlags.Index */);
            result.type = type;
            result.stringsOnly = stringsOnly;
            return result;
        }
        function createOriginIndexType(type) {
            var result = createOriginType(4194304 /* TypeFlags.Index */);
            result.type = type;
            return result;
        }
        function getIndexTypeForGenericType(type, stringsOnly) {
            return stringsOnly ?
                type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, /*stringsOnly*/ true)) :
                type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, /*stringsOnly*/ false));
        }
        /**
         * This roughly mirrors `resolveMappedTypeMembers` in the nongeneric case, except only reports a union of the keys calculated,
         * rather than manufacturing the properties. We can't just fetch the `constraintType` since that would ignore mappings
         * and mapping the `constraintType` directly ignores how mapped types map _properties_ and not keys (thus ignoring subtype
         * reduction in the constraintType) when possible.
         * @param noIndexSignatures Indicates if _string_ index signatures should be elided. (other index signatures are always reported)
         */
        function getIndexTypeForMappedType(type, stringsOnly, noIndexSignatures) {
            var typeParameter = getTypeParameterFromMappedType(type);
            var constraintType = getConstraintTypeFromMappedType(type);
            var nameType = getNameTypeFromMappedType(type.target || type);
            if (!nameType && !noIndexSignatures) {
                // no mapping and no filtering required, just quickly bail to returning the constraint in the common case
                return constraintType;
            }
            var keyTypes = [];
            if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                // We have a { [P in keyof T]: X }
                // `getApparentType` on the T in a generic mapped type can trigger a circularity
                // (conditionals and `infer` types create a circular dependency in the constraint resolution)
                // so we only eagerly manifest the keys if the constraint is nongeneric
                if (!isGenericIndexType(constraintType)) {
                    var modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
                    forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */, stringsOnly, addMemberForKeyType);
                }
                else {
                    // we have a generic index and a homomorphic mapping (but a distributive key remapping) - we need to defer the whole `keyof whatever` for later
                    // since it's not safe to resolve the shape of modifier type
                    return getIndexTypeForGenericType(type, stringsOnly);
                }
            }
            else {
                forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
            }
            if (isGenericIndexType(constraintType)) { // include the generic component in the resulting type
                forEachType(constraintType, addMemberForKeyType);
            }
            // we had to pick apart the constraintType to potentially map/filter it - compare the final resulting list with the original constraintType,
            // so we can return the union that preserves aliases/origin data if possible
            var result = noIndexSignatures ? filterType(getUnionType(keyTypes), function (t) { return !(t.flags & (1 /* TypeFlags.Any */ | 4 /* TypeFlags.String */)); }) : getUnionType(keyTypes);
            if (result.flags & 1048576 /* TypeFlags.Union */ && constraintType.flags & 1048576 /* TypeFlags.Union */ && getTypeListId(result.types) === getTypeListId(constraintType.types)) {
                return constraintType;
            }
            return result;
            function addMemberForKeyType(keyType) {
                var propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
                // `keyof` currently always returns `string | number` for concrete `string` index signatures - the below ternary keeps that behavior for mapped types
                // See `getLiteralTypeFromProperties` where there's a similar ternary to cause the same behavior.
                keyTypes.push(propNameType === stringType ? stringOrNumberType : propNameType);
            }
        }
        // Ordinarily we reduce a keyof M, where M is a mapped type { [P in K as N<P>]: X }, to simply N<K>. This however presumes
        // that N distributes over union types, i.e. that N<A | B | C> is equivalent to N<A> | N<B> | N<C>. Specifically, we only
        // want to perform the reduction when the name type of a mapped type is distributive with respect to the type variable
        // introduced by the 'in' clause of the mapped type. Note that non-generic types are considered to be distributive because
        // they're the same type regardless of what's being distributed over.
        function hasDistributiveNameType(mappedType) {
            var typeVariable = getTypeParameterFromMappedType(mappedType);
            return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable);
            function isDistributive(type) {
                return type.flags & (3 /* TypeFlags.AnyOrUnknown */ | 131068 /* TypeFlags.Primitive */ | 131072 /* TypeFlags.Never */ | 262144 /* TypeFlags.TypeParameter */ | 524288 /* TypeFlags.Object */ | 67108864 /* TypeFlags.NonPrimitive */) ? true :
                    type.flags & 16777216 /* TypeFlags.Conditional */ ? type.root.isDistributive && type.checkType === typeVariable :
                        type.flags & (3145728 /* TypeFlags.UnionOrIntersection */ | 134217728 /* TypeFlags.TemplateLiteral */) ? ts.every(type.types, isDistributive) :
                            type.flags & 8388608 /* TypeFlags.IndexedAccess */ ? isDistributive(type.objectType) && isDistributive(type.indexType) :
                                type.flags & 33554432 /* TypeFlags.Substitution */ ? isDistributive(type.substitute) :
                                    type.flags & 268435456 /* TypeFlags.StringMapping */ ? isDistributive(type.type) :
                                        false;
            }
        }
        function getLiteralTypeFromPropertyName(name) {
            if (ts.isPrivateIdentifier(name)) {
                return neverType;
            }
            return ts.isIdentifier(name) ? getStringLiteralType(ts.unescapeLeadingUnderscores(name.escapedText)) :
                getRegularTypeOfLiteralType(ts.isComputedPropertyName(name) ? checkComputedPropertyName(name) : checkExpression(name));
        }
        function getLiteralTypeFromProperty(prop, include, includeNonPublic) {
            if (includeNonPublic || !(ts.getDeclarationModifierFlagsFromSymbol(prop) & 24 /* ModifierFlags.NonPublicAccessibilityModifier */)) {
                var type = getSymbolLinks(getLateBoundSymbol(prop)).nameType;
                if (!type) {
                    var name = ts.getNameOfDeclaration(prop.valueDeclaration);
                    type = prop.escapedName === "default" /* InternalSymbolName.Default */ ? getStringLiteralType("default") :
                        name && getLiteralTypeFromPropertyName(name) || (!ts.isKnownSymbol(prop) ? getStringLiteralType(ts.symbolName(prop)) : undefined);
                }
                if (type && type.flags & include) {
                    return type;
                }
            }
            return neverType;
        }
        function isKeyTypeIncluded(keyType, include) {
            return !!(keyType.flags & include || keyType.flags & 2097152 /* TypeFlags.Intersection */ && ts.some(keyType.types, function (t) { return isKeyTypeIncluded(t, include); }));
        }
        function getLiteralTypeFromProperties(type, include, includeOrigin) {
            var origin = includeOrigin && (ts.getObjectFlags(type) & (3 /* ObjectFlags.ClassOrInterface */ | 4 /* ObjectFlags.Reference */) || type.aliasSymbol) ? createOriginIndexType(type) : undefined;
            var propertyTypes = ts.map(getPropertiesOfType(type), function (prop) { return getLiteralTypeFromProperty(prop, include); });
            var indexKeyTypes = ts.map(getIndexInfosOfType(type), function (info) { return info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) ?
                info.keyType === stringType && include & 8 /* TypeFlags.Number */ ? stringOrNumberType : info.keyType : neverType; });
            return getUnionType(ts.concatenate(propertyTypes, indexKeyTypes), 1 /* UnionReduction.Literal */, 
            /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined, origin);
        }
        /**
         * A union type which is reducible upon instantiation (meaning some members are removed under certain instantiations)
         * must be kept generic, as that instantiation information needs to flow through the type system. By replacing all
         * type parameters in the union with a special never type that is treated as a literal in `getReducedType`, we can cause the `getReducedType` logic
         * to reduce the resulting type if possible (since only intersections with conflicting literal-typed properties are reducible).
         */
        function isPossiblyReducibleByInstantiation(type) {
            return ts.some(type.types, function (t) {
                var uniqueFilled = getUniqueLiteralFilledInstantiation(t);
                return getReducedType(uniqueFilled) !== uniqueFilled;
            });
        }
        function getIndexType(type, stringsOnly, noIndexSignatures) {
            if (stringsOnly === void 0) { stringsOnly = keyofStringsOnly; }
            type = getReducedType(type);
            return type.flags & 1048576 /* TypeFlags.Union */ ? isPossiblyReducibleByInstantiation(type)
                ? getIndexTypeForGenericType(type, stringsOnly)
                : getIntersectionType(ts.map(type.types, function (t) { return getIndexType(t, stringsOnly, noIndexSignatures); })) :
                type.flags & 2097152 /* TypeFlags.Intersection */ ? getUnionType(ts.map(type.types, function (t) { return getIndexType(t, stringsOnly, noIndexSignatures); })) :
                    type.flags & 58982400 /* TypeFlags.InstantiableNonPrimitive */ || isGenericTupleType(type) || isGenericMappedType(type) && !hasDistributiveNameType(type) ? getIndexTypeForGenericType(type, stringsOnly) :
                        ts.getObjectFlags(type) & 32 /* ObjectFlags.Mapped */ ? getIndexTypeForMappedType(type, stringsOnly, noIndexSignatures) :
                            type === wildcardType ? wildcardType :
                                type.flags & 2 /* TypeFlags.Unknown */ ? neverType :
                                    type.flags & (1 /* TypeFlags.Any */ | 131072 /* TypeFlags.Never */) ? keyofConstraintType :
                                        getLiteralTypeFromProperties(type, (noIndexSignatures ? 128 /* TypeFlags.StringLiteral */ : 402653316 /* TypeFlags.StringLike */) | (stringsOnly ? 0 : 296 /* TypeFlags.NumberLike */ | 12288 /* TypeFlags.ESSymbolLike */), stringsOnly === keyofStringsOnly && !noIndexSignatures);
        }
        function getExtractStringType(type) {
            if (keyofStringsOnly) {
                return type;
            }
            var extractTypeAlias = getGlobalExtractSymbol();
            return extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType;
        }
        function getIndexTypeOrString(type) {
            var indexType = getExtractStringType(getIndexType(type));
            return indexType.flags & 131072 /* TypeFlags.Never */ ? stringType : indexType;
        }
        function getTypeFromTypeOperatorNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                switch (node.operator) {
                    case 140 /* SyntaxKind.KeyOfKeyword */:
                        links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));
                        break;
                    case 154 /* SyntaxKind.UniqueKeyword */:
                        links.resolvedType = node.type.kind === 151 /* SyntaxKind.SymbolKeyword */
                            ? getESSymbolLikeTypeForNode(ts.walkUpParenthesizedTypes(node.parent))
                            : errorType;
                        break;
                    case 145 /* SyntaxKind.ReadonlyKeyword */:
                        links.resolvedType = getTypeFromTypeNode(node.type);
                        break;
                    default:
                        throw ts.Debug.assertNever(node.operator);
                }
            }
            return links.resolvedType;
        }
        function getTypeFromTemplateTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getTemplateLiteralType(__spreadArray([node.head.text], ts.map(node.templateSpans, function (span) { return span.literal.text; }), true), ts.map(node.templateSpans, function (span) { return getTypeFromTypeNode(span.type); }));
            }
            return links.resolvedType;
        }
        function getTemplateLiteralType(texts, types) {
            var unionIndex = ts.findIndex(types, function (t) { return !!(t.flags & (131072 /* TypeFlags.Never */ | 1048576 /* TypeFlags.Union */)); });
            if (unionIndex >= 0) {
                return checkCrossProductUnion(types) ?
                    mapType(types[unionIndex], function (t) { return getTemplateLiteralType(texts, ts.replaceElement(types, unionIndex, t)); }) :
                    errorType;
            }
            if (ts.contains(types, wildcardType)) {
                return wildcardType;
            }
            var newTypes = [];
            var newTexts = [];
            var text = texts[0];
            if (!addSpans(texts, types)) {
                return stringType;
            }
            if (newTypes.length === 0) {
                return getStringLiteralType(text);
            }
            newTexts.push(text);
            if (ts.every(newTexts, function (t) { return t === ""; }) && ts.every(newTypes, function (t) { return !!(t.flags & 4 /* TypeFlags.String */); })) {
                return stringType;
            }
            var id = "".concat(getTypeListId(newTypes), "|").concat(ts.map(newTexts, function (t) { return t.length; }).join(","), "|").concat(newTexts.join(""));
            var type = templateLiteralTypes.get(id);
            if (!type) {
                templateLiteralTypes.set(id, type = createTemplateLiteralType(newTexts, newTypes));
            }
            return type;
            function addSpans(texts, types) {
                var isTextsArray = ts.isArray(texts);
                for (var i = 0; i < types.length; i++) {
                    var t = types[i];
                    var addText = isTextsArray ? texts[i + 1] : texts;
                    if (t.flags & (2944 /* TypeFlags.Literal */ | 65536 /* TypeFlags.Null */ | 32768 /* TypeFlags.Undefined */)) {
                        text += getTemplateStringForType(t) || "";
                        text += addText;
                        if (!isTextsArray)
                            return true;
                    }
                    else if (t.flags & 134217728 /* TypeFlags.TemplateLiteral */) {
                        text += t.texts[0];
                        if (!addSpans(t.texts, t.types))
                            return false;
                        text += addText;
                        if (!isTextsArray)
                            return true;
                    }
                    else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {
                        newTypes.push(t);
                        newTexts.push(text);
                        text = addText;
                    }
                    else if (t.flags & 2097152 /* TypeFlags.Intersection */) {
                        var added = addSpans(texts[i + 1], t.types);
                        if (!added)
                            return false;
                    }
                    else if (isTextsArray) {
                        return false;
                    }
                }
                return true;
            }
        }
        function getTemplateStringForType(type) {
            return type.flags & 128 /* TypeFlags.StringLiteral */ ? type.value :
                type.flags & 256 /* TypeFlags.NumberLiteral */ ? "" + type.value :
                    type.flags & 2048 /* TypeFlags.BigIntLiteral */ ? ts.pseudoBigIntToString(type.value) :
                        type.flags & (512 /* TypeFlags.BooleanLiteral */ | 98304 /* TypeFlags.Nullable */) ? type.intrinsicName :
                            undefined;
        }
        function createTemplateLiteralType(texts, types) {
            var type = createType(134217728 /* TypeFlags.TemplateLiteral */);
            type.texts = texts;
            type.types = types;
            return type;
        }
        function getStringMappingType(symbol, type) {
            return type.flags & (1048576 /* TypeFlags.Union */ | 131072 /* TypeFlags.Never */) ? mapType(type, function (t) { return getStringMappingType(symbol, t); }) :
                isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) :
                    type.flags & 128 /* TypeFlags.StringLiteral */ ? getStringLiteralType(applyStringMapping(symbol, type.value)) :
                        type;
        }
        function applyStringMapping(symbol, str) {
            switch (intrinsicTypeKinds.get(symbol.escapedName)) {
                case 0 /* IntrinsicTypeKind.Uppercase */: return str.toUpperCase();
                case 1 /* IntrinsicTypeKind.Lowercase */: return str.toLowerCase();
                case 2 /* IntrinsicTypeKind.Capitalize */: return str.charAt(0).toUpperCase() + str.slice(1);
                case 3 /* IntrinsicTypeKind.Uncapitalize */: return str.charAt(0).toLowerCase() + str.slice(1);
            }
            return str;
        }
        function getStringMappingTypeForGenericType(symbol, type) {
            var id = "".concat(getSymbolId(symbol), ",").concat(getTypeId(type));
            var result = stringMappingTypes.get(id);
            if (!result) {
                stringMappingTypes.set(id, result = createStringMappingType(symbol, type));
            }
            return result;
        }
        function createStringMappingType(symbol, type) {
            var result = createType(268435456 /* TypeFlags.StringMapping */);
            result.symbol = symbol;
            result.type = type;
            return result;
        }
        function createIndexedAccessType(objectType, indexType, accessFlags, aliasSymbol, aliasTypeArguments) {
            var type = createType(8388608 /* TypeFlags.IndexedAccess */);
            type.objectType = objectType;
            type.indexType = indexType;
            type.accessFlags = accessFlags;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            return type;
        }
        /**
         * Returns if a type is or consists of a JSLiteral object type
         * In addition to objects which are directly literals,
         * * unions where every element is a jsliteral
         * * intersections where at least one element is a jsliteral
         * * and instantiable types constrained to a jsliteral
         * Should all count as literals and not print errors on access or assignment of possibly existing properties.
         * This mirrors the behavior of the index signature propagation, to which this behaves similarly (but doesn't affect assignability or inference).
         */
        function isJSLiteralType(type) {
            if (noImplicitAny) {
                return false; // Flag is meaningless under `noImplicitAny` mode
            }
            if (ts.getObjectFlags(type) & 4096 /* ObjectFlags.JSLiteral */) {
                return true;
            }
            if (type.flags & 1048576 /* TypeFlags.Union */) {
                return ts.every(type.types, isJSLiteralType);
            }
            if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                return ts.some(type.types, isJSLiteralType);
            }
            if (type.flags & 465829888 /* TypeFlags.Instantiable */) {
                var constraint = getResolvedBaseConstraint(type);
                return constraint !== type && isJSLiteralType(constraint);
            }
            return false;
        }
        function getPropertyNameFromIndex(indexType, accessNode) {
            return isTypeUsableAsPropertyName(indexType) ?
                getPropertyNameFromType(indexType) :
                accessNode && ts.isPropertyName(accessNode) ?
                    // late bound names are handled in the first branch, so here we only need to handle normal names
                    ts.getPropertyNameForPropertyNameNode(accessNode) :
                    undefined;
        }
        function isUncalledFunctionReference(node, symbol) {
            if (symbol.flags & (16 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Method */)) {
                var parent = ts.findAncestor(node.parent, function (n) { return !ts.isAccessExpression(n); }) || node.parent;
                if (ts.isCallLikeExpression(parent)) {
                    return ts.isCallOrNewExpression(parent) && ts.isIdentifier(node) && hasMatchingArgument(parent, node);
                }
                return ts.every(symbol.declarations, function (d) { return !ts.isFunctionLike(d) || !!(ts.getCombinedNodeFlags(d) & 268435456 /* NodeFlags.Deprecated */); });
            }
            return true;
        }
        function getPropertyTypeForIndexType(originalObjectType, objectType, indexType, fullIndexType, accessNode, accessFlags) {
            var _a;
            var accessExpression = accessNode && accessNode.kind === 207 /* SyntaxKind.ElementAccessExpression */ ? accessNode : undefined;
            var propName = accessNode && ts.isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode);
            if (propName !== undefined) {
                if (accessFlags & 256 /* AccessFlags.Contextual */) {
                    return getTypeOfPropertyOfContextualType(objectType, propName) || anyType;
                }
                var prop = getPropertyOfType(objectType, propName);
                if (prop) {
                    if (accessFlags & 64 /* AccessFlags.ReportDeprecated */ && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop)) {
                        var deprecatedNode = (_a = accessExpression === null || accessExpression === void 0 ? void 0 : accessExpression.argumentExpression) !== null && _a !== void 0 ? _a : (ts.isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode);
                        addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName);
                    }
                    if (accessExpression) {
                        markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol));
                        if (isAssignmentToReadonlyEntity(accessExpression, prop, ts.getAssignmentTargetKind(accessExpression))) {
                            error(accessExpression.argumentExpression, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop));
                            return undefined;
                        }
                        if (accessFlags & 8 /* AccessFlags.CacheSymbol */) {
                            getNodeLinks(accessNode).resolvedSymbol = prop;
                        }
                        if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
                            return autoType;
                        }
                    }
                    var propType = getTypeOfSymbol(prop);
                    return accessExpression && ts.getAssignmentTargetKind(accessExpression) !== 1 /* AssignmentKind.Definite */ ?
                        getFlowTypeOfReference(accessExpression, propType) :
                        propType;
                }
                if (everyType(objectType, isTupleType) && ts.isNumericLiteralName(propName) && +propName >= 0) {
                    if (accessNode && everyType(objectType, function (t) { return !t.target.hasRestElement; }) && !(accessFlags & 16 /* AccessFlags.NoTupleBoundsCheck */)) {
                        var indexNode = getIndexNodeForAccessExpression(accessNode);
                        if (isTupleType(objectType)) {
                            error(indexNode, ts.Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), ts.unescapeLeadingUnderscores(propName));
                        }
                        else {
                            error(indexNode, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.unescapeLeadingUnderscores(propName), typeToString(objectType));
                        }
                    }
                    errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType));
                    return mapType(objectType, function (t) {
                        var restType = getRestTypeOfTupleType(t) || undefinedType;
                        return accessFlags & 1 /* AccessFlags.IncludeUndefined */ ? getUnionType([restType, undefinedType]) : restType;
                    });
                }
            }
            if (!(indexType.flags & 98304 /* TypeFlags.Nullable */) && isTypeAssignableToKind(indexType, 402653316 /* TypeFlags.StringLike */ | 296 /* TypeFlags.NumberLike */ | 12288 /* TypeFlags.ESSymbolLike */)) {
                if (objectType.flags & (1 /* TypeFlags.Any */ | 131072 /* TypeFlags.Never */)) {
                    return objectType;
                }
                // If no index signature is applicable, we default to the string index signature. In effect, this means the string
                // index signature applies even when accessing with a symbol-like type.
                var indexInfo = getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType);
                if (indexInfo) {
                    if (accessFlags & 2 /* AccessFlags.NoIndexSignatures */ && indexInfo.keyType !== numberType) {
                        if (accessExpression) {
                            error(accessExpression, ts.Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType));
                        }
                        return undefined;
                    }
                    if (accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(indexType, 4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */)) {
                        var indexNode = getIndexNodeForAccessExpression(accessNode);
                        error(indexNode, ts.Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                        return accessFlags & 1 /* AccessFlags.IncludeUndefined */ ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
                    }
                    errorIfWritingToReadonlyIndex(indexInfo);
                    return accessFlags & 1 /* AccessFlags.IncludeUndefined */ ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
                }
                if (indexType.flags & 131072 /* TypeFlags.Never */) {
                    return neverType;
                }
                if (isJSLiteralType(objectType)) {
                    return anyType;
                }
                if (accessExpression && !isConstEnumObjectType(objectType)) {
                    if (isObjectLiteralType(objectType)) {
                        if (noImplicitAny && indexType.flags & (128 /* TypeFlags.StringLiteral */ | 256 /* TypeFlags.NumberLiteral */)) {
                            diagnostics.add(ts.createDiagnosticForNode(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType)));
                            return undefinedType;
                        }
                        else if (indexType.flags & (8 /* TypeFlags.Number */ | 4 /* TypeFlags.String */)) {
                            var types = ts.map(objectType.properties, function (property) {
                                return getTypeOfSymbol(property);
                            });
                            return getUnionType(ts.append(types, undefinedType));
                        }
                    }
                    if (objectType.symbol === globalThisSymbol && propName !== undefined && globalThisSymbol.exports.has(propName) && (globalThisSymbol.exports.get(propName).flags & 418 /* SymbolFlags.BlockScoped */)) {
                        error(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.unescapeLeadingUnderscores(propName), typeToString(objectType));
                    }
                    else if (noImplicitAny && !compilerOptions.suppressImplicitAnyIndexErrors && !(accessFlags & 128 /* AccessFlags.SuppressNoImplicitAnyError */)) {
                        if (propName !== undefined && typeHasStaticProperty(propName, objectType)) {
                            var typeName = typeToString(objectType);
                            error(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName + "[" + ts.getTextOfNode(accessExpression.argumentExpression) + "]");
                        }
                        else if (getIndexTypeOfType(objectType, numberType)) {
                            error(accessExpression.argumentExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
                        }
                        else {
                            var suggestion = void 0;
                            if (propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(propName, objectType))) {
                                if (suggestion !== undefined) {
                                    error(accessExpression.argumentExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(objectType), suggestion);
                                }
                            }
                            else {
                                var suggestion_1 = getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType);
                                if (suggestion_1 !== undefined) {
                                    error(accessExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion_1);
                                }
                                else {
                                    var errorInfo = void 0;
                                    if (indexType.flags & 1024 /* TypeFlags.EnumLiteral */) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType));
                                    }
                                    else if (indexType.flags & 8192 /* TypeFlags.UniqueESSymbol */) {
                                        var symbolName_2 = getFullyQualifiedName(indexType.symbol, accessExpression);
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "[" + symbolName_2 + "]", typeToString(objectType));
                                    }
                                    else if (indexType.flags & 128 /* TypeFlags.StringLiteral */) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                    }
                                    else if (indexType.flags & 256 /* TypeFlags.NumberLiteral */) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                    }
                                    else if (indexType.flags & (8 /* TypeFlags.Number */ | 4 /* TypeFlags.String */)) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType));
                                    }
                                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType));
                                    diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(accessExpression, errorInfo));
                                }
                            }
                        }
                    }
                    return undefined;
                }
            }
            if (isJSLiteralType(objectType)) {
                return anyType;
            }
            if (accessNode) {
                var indexNode = getIndexNodeForAccessExpression(accessNode);
                if (indexType.flags & (128 /* TypeFlags.StringLiteral */ | 256 /* TypeFlags.NumberLiteral */)) {
                    error(indexNode, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "" + indexType.value, typeToString(objectType));
                }
                else if (indexType.flags & (4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */)) {
                    error(indexNode, ts.Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
                }
                else {
                    error(indexNode, ts.Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                }
            }
            if (isTypeAny(indexType)) {
                return indexType;
            }
            return undefined;
            function errorIfWritingToReadonlyIndex(indexInfo) {
                if (indexInfo && indexInfo.isReadonly && accessExpression && (ts.isAssignmentTarget(accessExpression) || ts.isDeleteTarget(accessExpression))) {
                    error(accessExpression, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
                }
            }
        }
        function getIndexNodeForAccessExpression(accessNode) {
            return accessNode.kind === 207 /* SyntaxKind.ElementAccessExpression */ ? accessNode.argumentExpression :
                accessNode.kind === 194 /* SyntaxKind.IndexedAccessType */ ? accessNode.indexType :
                    accessNode.kind === 162 /* SyntaxKind.ComputedPropertyName */ ? accessNode.expression :
                        accessNode;
        }
        function isPatternLiteralPlaceholderType(type) {
            return !!(type.flags & (1 /* TypeFlags.Any */ | 4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */ | 64 /* TypeFlags.BigInt */));
        }
        function isPatternLiteralType(type) {
            return !!(type.flags & 134217728 /* TypeFlags.TemplateLiteral */) && ts.every(type.types, isPatternLiteralPlaceholderType);
        }
        function isGenericType(type) {
            return !!getGenericObjectFlags(type);
        }
        function isGenericObjectType(type) {
            return !!(getGenericObjectFlags(type) & 4194304 /* ObjectFlags.IsGenericObjectType */);
        }
        function isGenericIndexType(type) {
            return !!(getGenericObjectFlags(type) & 8388608 /* ObjectFlags.IsGenericIndexType */);
        }
        function getGenericObjectFlags(type) {
            if (type.flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                if (!(type.objectFlags & 2097152 /* ObjectFlags.IsGenericTypeComputed */)) {
                    type.objectFlags |= 2097152 /* ObjectFlags.IsGenericTypeComputed */ |
                        ts.reduceLeft(type.types, function (flags, t) { return flags | getGenericObjectFlags(t); }, 0);
                }
                return type.objectFlags & 12582912 /* ObjectFlags.IsGenericType */;
            }
            if (type.flags & 33554432 /* TypeFlags.Substitution */) {
                if (!(type.objectFlags & 2097152 /* ObjectFlags.IsGenericTypeComputed */)) {
                    type.objectFlags |= 2097152 /* ObjectFlags.IsGenericTypeComputed */ |
                        getGenericObjectFlags(type.substitute) | getGenericObjectFlags(type.baseType);
                }
                return type.objectFlags & 12582912 /* ObjectFlags.IsGenericType */;
            }
            return (type.flags & 58982400 /* TypeFlags.InstantiableNonPrimitive */ || isGenericMappedType(type) || isGenericTupleType(type) ? 4194304 /* ObjectFlags.IsGenericObjectType */ : 0) |
                (type.flags & (58982400 /* TypeFlags.InstantiableNonPrimitive */ | 4194304 /* TypeFlags.Index */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) && !isPatternLiteralType(type) ? 8388608 /* ObjectFlags.IsGenericIndexType */ : 0);
        }
        function getSimplifiedType(type, writing) {
            return type.flags & 8388608 /* TypeFlags.IndexedAccess */ ? getSimplifiedIndexedAccessType(type, writing) :
                type.flags & 16777216 /* TypeFlags.Conditional */ ? getSimplifiedConditionalType(type, writing) :
                    type;
        }
        function distributeIndexOverObjectType(objectType, indexType, writing) {
            // (T | U)[K] -> T[K] | U[K] (reading)
            // (T | U)[K] -> T[K] & U[K] (writing)
            // (T & U)[K] -> T[K] & U[K]
            if (objectType.flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                var types = ts.map(objectType.types, function (t) { return getSimplifiedType(getIndexedAccessType(t, indexType), writing); });
                return objectType.flags & 2097152 /* TypeFlags.Intersection */ || writing ? getIntersectionType(types) : getUnionType(types);
            }
        }
        function distributeObjectOverIndexType(objectType, indexType, writing) {
            // T[A | B] -> T[A] | T[B] (reading)
            // T[A | B] -> T[A] & T[B] (writing)
            if (indexType.flags & 1048576 /* TypeFlags.Union */) {
                var types = ts.map(indexType.types, function (t) { return getSimplifiedType(getIndexedAccessType(objectType, t), writing); });
                return writing ? getIntersectionType(types) : getUnionType(types);
            }
        }
        // Transform an indexed access to a simpler form, if possible. Return the simpler form, or return
        // the type itself if no transformation is possible. The writing flag indicates that the type is
        // the target of an assignment.
        function getSimplifiedIndexedAccessType(type, writing) {
            var cache = writing ? "simplifiedForWriting" : "simplifiedForReading";
            if (type[cache]) {
                return type[cache] === circularConstraintType ? type : type[cache];
            }
            type[cache] = circularConstraintType;
            // We recursively simplify the object type as it may in turn be an indexed access type. For example, with
            // '{ [P in T]: { [Q in U]: number } }[T][U]' we want to first simplify the inner indexed access type.
            var objectType = getSimplifiedType(type.objectType, writing);
            var indexType = getSimplifiedType(type.indexType, writing);
            // T[A | B] -> T[A] | T[B] (reading)
            // T[A | B] -> T[A] & T[B] (writing)
            var distributedOverIndex = distributeObjectOverIndexType(objectType, indexType, writing);
            if (distributedOverIndex) {
                return type[cache] = distributedOverIndex;
            }
            // Only do the inner distributions if the index can no longer be instantiated to cause index distribution again
            if (!(indexType.flags & 465829888 /* TypeFlags.Instantiable */)) {
                // (T | U)[K] -> T[K] | U[K] (reading)
                // (T | U)[K] -> T[K] & U[K] (writing)
                // (T & U)[K] -> T[K] & U[K]
                var distributedOverObject = distributeIndexOverObjectType(objectType, indexType, writing);
                if (distributedOverObject) {
                    return type[cache] = distributedOverObject;
                }
            }
            // So ultimately (reading):
            // ((A & B) | C)[K1 | K2] -> ((A & B) | C)[K1] | ((A & B) | C)[K2] -> (A & B)[K1] | C[K1] | (A & B)[K2] | C[K2] -> (A[K1] & B[K1]) | C[K1] | (A[K2] & B[K2]) | C[K2]
            // A generic tuple type indexed by a number exists only when the index type doesn't select a
            // fixed element. We simplify to either the combined type of all elements (when the index type
            // the actual number type) or to the combined type of all non-fixed elements.
            if (isGenericTupleType(objectType) && indexType.flags & 296 /* TypeFlags.NumberLike */) {
                var elementType = getElementTypeOfSliceOfTupleType(objectType, indexType.flags & 8 /* TypeFlags.Number */ ? 0 : objectType.target.fixedLength, /*endSkipCount*/ 0, writing);
                if (elementType) {
                    return type[cache] = elementType;
                }
            }
            // If the object type is a mapped type { [P in K]: E }, where K is generic, or { [P in K as N]: E }, where
            // K is generic and N is assignable to P, instantiate E using a mapper that substitutes the index type for P.
            // For example, for an index access { [P in K]: Box<T[P]> }[X], we construct the type Box<T[X]>.
            if (isGenericMappedType(objectType)) {
                var nameType = getNameTypeFromMappedType(objectType);
                if (!nameType || isTypeAssignableTo(nameType, getTypeParameterFromMappedType(objectType))) {
                    return type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), function (t) { return getSimplifiedType(t, writing); });
                }
            }
            return type[cache] = type;
        }
        function getSimplifiedConditionalType(type, writing) {
            var checkType = type.checkType;
            var extendsType = type.extendsType;
            var trueType = getTrueTypeFromConditionalType(type);
            var falseType = getFalseTypeFromConditionalType(type);
            // Simplifications for types of the form `T extends U ? T : never` and `T extends U ? never : T`.
            if (falseType.flags & 131072 /* TypeFlags.Never */ && getActualTypeVariable(trueType) === getActualTypeVariable(checkType)) {
                if (checkType.flags & 1 /* TypeFlags.Any */ || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                    return getSimplifiedType(trueType, writing);
                }
                else if (isIntersectionEmpty(checkType, extendsType)) { // Always false
                    return neverType;
                }
            }
            else if (trueType.flags & 131072 /* TypeFlags.Never */ && getActualTypeVariable(falseType) === getActualTypeVariable(checkType)) {
                if (!(checkType.flags & 1 /* TypeFlags.Any */) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                    return neverType;
                }
                else if (checkType.flags & 1 /* TypeFlags.Any */ || isIntersectionEmpty(checkType, extendsType)) { // Always false
                    return getSimplifiedType(falseType, writing);
                }
            }
            return type;
        }
        /**
         * Invokes union simplification logic to determine if an intersection is considered empty as a union constituent
         */
        function isIntersectionEmpty(type1, type2) {
            return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & 131072 /* TypeFlags.Never */);
        }
        function substituteIndexedMappedType(objectType, index) {
            var mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [index]);
            var templateMapper = combineTypeMappers(objectType.mapper, mapper);
            return instantiateType(getTemplateTypeFromMappedType(objectType), templateMapper);
        }
        function getIndexedAccessType(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) {
            if (accessFlags === void 0) { accessFlags = 0 /* AccessFlags.None */; }
            return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (accessNode ? errorType : unknownType);
        }
        function indexTypeLessThan(indexType, limit) {
            return everyType(indexType, function (t) {
                if (t.flags & 384 /* TypeFlags.StringOrNumberLiteral */) {
                    var propName = getPropertyNameFromType(t);
                    if (ts.isNumericLiteralName(propName)) {
                        var index = +propName;
                        return index >= 0 && index < limit;
                    }
                }
                return false;
            });
        }
        function getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) {
            if (accessFlags === void 0) { accessFlags = 0 /* AccessFlags.None */; }
            if (objectType === wildcardType || indexType === wildcardType) {
                return wildcardType;
            }
            // If the object type has a string index signature and no other members we know that the result will
            // always be the type of that index signature and we can simplify accordingly.
            if (isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & 98304 /* TypeFlags.Nullable */) && isTypeAssignableToKind(indexType, 4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */)) {
                indexType = stringType;
            }
            // In noUncheckedIndexedAccess mode, indexed access operations that occur in an expression in a read position and resolve to
            // an index signature have 'undefined' included in their type.
            if (compilerOptions.noUncheckedIndexedAccess && accessFlags & 32 /* AccessFlags.ExpressionPosition */)
                accessFlags |= 1 /* AccessFlags.IncludeUndefined */;
            // If the index type is generic, or if the object type is generic and doesn't originate in an expression and
            // the operation isn't exclusively indexing the fixed (non-variadic) portion of a tuple type, we are performing
            // a higher-order index access where we cannot meaningfully access the properties of the object type. Note that
            // for a generic T and a non-generic K, we eagerly resolve T[K] if it originates in an expression. This is to
            // preserve backwards compatibility. For example, an element access 'this["foo"]' has always been resolved
            // eagerly using the constraint type of 'this' at the given location.
            if (isGenericIndexType(indexType) || (accessNode && accessNode.kind !== 194 /* SyntaxKind.IndexedAccessType */ ?
                isGenericTupleType(objectType) && !indexTypeLessThan(indexType, objectType.target.fixedLength) :
                isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, objectType.target.fixedLength)))) {
                if (objectType.flags & 3 /* TypeFlags.AnyOrUnknown */) {
                    return objectType;
                }
                // Defer the operation by creating an indexed access type.
                var persistentAccessFlags = accessFlags & 1 /* AccessFlags.Persistent */;
                var id = objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments);
                var type = indexedAccessTypes.get(id);
                if (!type) {
                    indexedAccessTypes.set(id, type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments));
                }
                return type;
            }
            // In the following we resolve T[K] to the type of the property in T selected by K.
            // We treat boolean as different from other unions to improve errors;
            // skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
            var apparentObjectType = getReducedApparentType(objectType);
            if (indexType.flags & 1048576 /* TypeFlags.Union */ && !(indexType.flags & 16 /* TypeFlags.Boolean */)) {
                var propTypes = [];
                var wasMissingProp = false;
                for (var _i = 0, _a = indexType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    var propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags | (wasMissingProp ? 128 /* AccessFlags.SuppressNoImplicitAnyError */ : 0));
                    if (propType) {
                        propTypes.push(propType);
                    }
                    else if (!accessNode) {
                        // If there's no error node, we can immeditely stop, since error reporting is off
                        return undefined;
                    }
                    else {
                        // Otherwise we set a flag and return at the end of the loop so we still mark all errors
                        wasMissingProp = true;
                    }
                }
                if (wasMissingProp) {
                    return undefined;
                }
                return accessFlags & 4 /* AccessFlags.Writing */
                    ? getIntersectionType(propTypes, aliasSymbol, aliasTypeArguments)
                    : getUnionType(propTypes, 1 /* UnionReduction.Literal */, aliasSymbol, aliasTypeArguments);
            }
            return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags | 8 /* AccessFlags.CacheSymbol */ | 64 /* AccessFlags.ReportDeprecated */);
        }
        function getTypeFromIndexedAccessTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var objectType = getTypeFromTypeNode(node.objectType);
                var indexType = getTypeFromTypeNode(node.indexType);
                var potentialAlias = getAliasSymbolForTypeNode(node);
                var resolved = getIndexedAccessType(objectType, indexType, 0 /* AccessFlags.None */, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias));
                links.resolvedType = resolved.flags & 8388608 /* TypeFlags.IndexedAccess */ &&
                    resolved.objectType === objectType &&
                    resolved.indexType === indexType ?
                    getConditionalFlowTypeOfType(resolved, node) : resolved;
            }
            return links.resolvedType;
        }
        function getTypeFromMappedTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var type = createObjectType(32 /* ObjectFlags.Mapped */, node.symbol);
                type.declaration = node;
                type.aliasSymbol = getAliasSymbolForTypeNode(node);
                type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol);
                links.resolvedType = type;
                // Eagerly resolve the constraint type which forces an error if the constraint type circularly
                // references itself through one or more type aliases.
                getConstraintTypeFromMappedType(type);
            }
            return links.resolvedType;
        }
        function getActualTypeVariable(type) {
            if (type.flags & 33554432 /* TypeFlags.Substitution */) {
                return type.baseType;
            }
            if (type.flags & 8388608 /* TypeFlags.IndexedAccess */ && (type.objectType.flags & 33554432 /* TypeFlags.Substitution */ ||
                type.indexType.flags & 33554432 /* TypeFlags.Substitution */)) {
                return getIndexedAccessType(getActualTypeVariable(type.objectType), getActualTypeVariable(type.indexType));
            }
            return type;
        }
        function maybeCloneTypeParameter(p) {
            var constraint = getConstraintOfTypeParameter(p);
            return constraint && (isGenericObjectType(constraint) || isGenericIndexType(constraint)) ? cloneTypeParameter(p) : p;
        }
        function isTypicalNondistributiveConditional(root) {
            return !root.isDistributive && isSingletonTupleType(root.node.checkType) && isSingletonTupleType(root.node.extendsType);
        }
        function isSingletonTupleType(node) {
            return ts.isTupleTypeNode(node) &&
                ts.length(node.elements) === 1 &&
                !ts.isOptionalTypeNode(node.elements[0]) &&
                !ts.isRestTypeNode(node.elements[0]) &&
                !(ts.isNamedTupleMember(node.elements[0]) && (node.elements[0].questionToken || node.elements[0].dotDotDotToken));
        }
        /**
         * We syntactually check for common nondistributive conditional shapes and unwrap them into
         * the intended comparison - we do this so we can check if the unwrapped types are generic or
         * not and appropriately defer condition calculation
         */
        function unwrapNondistributiveConditionalTuple(root, type) {
            return isTypicalNondistributiveConditional(root) && isTupleType(type) ? getTypeArguments(type)[0] : type;
        }
        function getConditionalType(root, mapper, aliasSymbol, aliasTypeArguments) {
            var result;
            var extraTypes;
            var tailCount = 0;
            var _loop_18 = function () {
                if (tailCount === 1000) {
                    error(currentNode, ts.Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
                    result = errorType;
                    return "break";
                }
                var isUnwrapped = isTypicalNondistributiveConditional(root);
                var checkType = instantiateType(unwrapNondistributiveConditionalTuple(root, getActualTypeVariable(root.checkType)), mapper);
                var checkTypeInstantiable = isGenericType(checkType);
                var extendsType = instantiateType(unwrapNondistributiveConditionalTuple(root, root.extendsType), mapper);
                if (checkType === wildcardType || extendsType === wildcardType) {
                    return { value: wildcardType };
                }
                var combinedMapper = void 0;
                if (root.inferTypeParameters) {
                    // When we're looking at making an inference for an infer type, when we get its constraint, it'll automagically be
                    // instantiated with the context, so it doesn't need the mapper for the inference contex - however the constraint
                    // may refer to another _root_, _uncloned_ `infer` type parameter [1], or to something mapped by `mapper` [2].
                    // [1] Eg, if we have `Foo<T, U extends T>` and `Foo<number, infer B>` - `B` is constrained to `T`, which, in turn, has been instantiated
                    // as `number`
                    // Conversely, if we have `Foo<infer A, infer B>`, `B` is still constrained to `T` and `T` is instantiated as `A`
                    // [2] Eg, if we have `Foo<T, U extends T>` and `Foo<Q, infer B>` where `Q` is mapped by `mapper` into `number` - `B` is constrained to `T`
                    // which is in turn instantiated as `Q`, which is in turn instantiated as `number`.
                    // So we need to:
                    //    * Clone the type parameters so their constraints can be instantiated in the context of `mapper` (otherwise theyd only get inference context information)
                    //    * Set the clones to both map the conditional's enclosing `mapper` and the original params
                    //    * instantiate the extends type with the clones
                    //    * incorporate all of the component mappers into the combined mapper for the true and false members
                    // This means we have three mappers that need applying:
                    //    * The original `mapper` used to create this conditional
                    //    * The mapper that maps the old root type parameter to the clone (`freshMapper`)
                    //    * The mapper that maps the clone to its inference result (`context.mapper`)
                    var freshParams = ts.sameMap(root.inferTypeParameters, maybeCloneTypeParameter);
                    var freshMapper = freshParams !== root.inferTypeParameters ? createTypeMapper(root.inferTypeParameters, freshParams) : undefined;
                    var context = createInferenceContext(freshParams, /*signature*/ undefined, 0 /* InferenceFlags.None */);
                    if (freshMapper) {
                        var freshCombinedMapper = combineTypeMappers(mapper, freshMapper);
                        for (var _i = 0, freshParams_1 = freshParams; _i < freshParams_1.length; _i++) {
                            var p = freshParams_1[_i];
                            if (root.inferTypeParameters.indexOf(p) === -1) {
                                p.mapper = freshCombinedMapper;
                            }
                        }
                    }
                    // We skip inference of the possible `infer` types unles the `extendsType` _is_ an infer type
                    // if it was, it's trivial to say that extendsType = checkType, however such a pattern is used to
                    // "reset" the type being build up during constraint calculation and avoid making an apparently "infinite" constraint
                    // so in those cases we refain from performing inference and retain the uninfered type parameter
                    if (!checkTypeInstantiable || !ts.some(root.inferTypeParameters, function (t) { return t === extendsType; })) {
                        // We don't want inferences from constraints as they may cause us to eagerly resolve the
                        // conditional type instead of deferring resolution. Also, we always want strict function
                        // types rules (i.e. proper contravariance) for inferences.
                        inferTypes(context.inferences, checkType, instantiateType(extendsType, freshMapper), 512 /* InferencePriority.NoConstraints */ | 1024 /* InferencePriority.AlwaysStrict */);
                    }
                    var innerMapper = combineTypeMappers(freshMapper, context.mapper);
                    // It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the
                    // those type parameters are used in type references (see getInferredTypeParameterConstraint). For
                    // that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.
                    combinedMapper = mapper ? combineTypeMappers(innerMapper, mapper) : innerMapper;
                }
                // Instantiate the extends type including inferences for 'infer T' type parameters
                var inferredExtendsType = combinedMapper ? instantiateType(unwrapNondistributiveConditionalTuple(root, root.extendsType), combinedMapper) : extendsType;
                // We attempt to resolve the conditional type only when the check and extends types are non-generic
                if (!checkTypeInstantiable && !isGenericType(inferredExtendsType)) {
                    // Return falseType for a definitely false extends check. We check an instantiations of the two
                    // types with type parameters mapped to the wildcard type, the most permissive instantiations
                    // possible (the wildcard type is assignable to and from all types). If those are not related,
                    // then no instantiations will be and we can just return the false branch type.
                    if (!(inferredExtendsType.flags & 3 /* TypeFlags.AnyOrUnknown */) && ((checkType.flags & 1 /* TypeFlags.Any */ && !isUnwrapped) || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {
                        // Return union of trueType and falseType for 'any' since it matches anything
                        if (checkType.flags & 1 /* TypeFlags.Any */ && !isUnwrapped) {
                            (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));
                        }
                        // If falseType is an immediately nested conditional type that isn't distributive or has an
                        // identical checkType, switch to that type and loop.
                        var falseType_1 = getTypeFromTypeNode(root.node.falseType);
                        if (falseType_1.flags & 16777216 /* TypeFlags.Conditional */) {
                            var newRoot = falseType_1.root;
                            if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {
                                root = newRoot;
                                return "continue";
                            }
                            if (canTailRecurse(falseType_1, mapper)) {
                                return "continue";
                            }
                        }
                        result = instantiateType(falseType_1, mapper);
                        return "break";
                    }
                    // Return trueType for a definitely true extends check. We check instantiations of the two
                    // types with type parameters mapped to their restrictive form, i.e. a form of the type parameter
                    // that has no constraint. This ensures that, for example, the type
                    //   type Foo<T extends { x: any }> = T extends { x: string } ? string : number
                    // doesn't immediately resolve to 'string' instead of being deferred.
                    if (inferredExtendsType.flags & 3 /* TypeFlags.AnyOrUnknown */ || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {
                        var trueType_1 = getTypeFromTypeNode(root.node.trueType);
                        var trueMapper = combinedMapper || mapper;
                        if (canTailRecurse(trueType_1, trueMapper)) {
                            return "continue";
                        }
                        result = instantiateType(trueType_1, trueMapper);
                        return "break";
                    }
                }
                // Return a deferred type for a check that is neither definitely true nor definitely false
                result = createType(16777216 /* TypeFlags.Conditional */);
                result.root = root;
                result.checkType = instantiateType(root.checkType, mapper);
                result.extendsType = instantiateType(root.extendsType, mapper);
                result.mapper = mapper;
                result.combinedMapper = combinedMapper;
                result.aliasSymbol = aliasSymbol || root.aliasSymbol;
                result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper); // TODO: GH#18217
                return "break";
            };
            // We loop here for an immediately nested conditional type in the false position, effectively treating
            // types of the form 'A extends B ? X : C extends D ? Y : E extends F ? Z : ...' as a single construct for
            // purposes of resolution. We also loop here when resolution of a conditional type ends in resolution of
            // another (or, through recursion, possibly the same) conditional type. In the potentially tail-recursive
            // cases we increment the tail recursion counter and stop after 1000 iterations.
            while (true) {
                var state_5 = _loop_18();
                if (typeof state_5 === "object")
                    return state_5.value;
                if (state_5 === "break")
                    break;
            }
            return extraTypes ? getUnionType(ts.append(extraTypes, result)) : result;
            // We tail-recurse for generic conditional types that (a) have not already been evaluated and cached, and
            // (b) are non distributive, have a check type that is unaffected by instantiation, or have a non-union check
            // type. Note that recursion is possible only through aliased conditional types, so we only increment the tail
            // recursion counter for those.
            function canTailRecurse(newType, newMapper) {
                if (newType.flags & 16777216 /* TypeFlags.Conditional */ && newMapper) {
                    var newRoot = newType.root;
                    if (newRoot.outerTypeParameters) {
                        var typeParamMapper_1 = combineTypeMappers(newType.mapper, newMapper);
                        var typeArguments = ts.map(newRoot.outerTypeParameters, function (t) { return getMappedType(t, typeParamMapper_1); });
                        var newRootMapper = createTypeMapper(newRoot.outerTypeParameters, typeArguments);
                        var newCheckType = newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined;
                        if (!newCheckType || newCheckType === newRoot.checkType || !(newCheckType.flags & (1048576 /* TypeFlags.Union */ | 131072 /* TypeFlags.Never */))) {
                            root = newRoot;
                            mapper = newRootMapper;
                            aliasSymbol = undefined;
                            aliasTypeArguments = undefined;
                            if (newRoot.aliasSymbol) {
                                tailCount++;
                            }
                            return true;
                        }
                    }
                }
                return false;
            }
        }
        function getTrueTypeFromConditionalType(type) {
            return type.resolvedTrueType || (type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper));
        }
        function getFalseTypeFromConditionalType(type) {
            return type.resolvedFalseType || (type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper));
        }
        function getInferredTrueTypeFromConditionalType(type) {
            return type.resolvedInferredTrueType || (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type));
        }
        function getInferTypeParameters(node) {
            var result;
            if (node.locals) {
                node.locals.forEach(function (symbol) {
                    if (symbol.flags & 262144 /* SymbolFlags.TypeParameter */) {
                        result = ts.append(result, getDeclaredTypeOfSymbol(symbol));
                    }
                });
            }
            return result;
        }
        function isDistributionDependent(root) {
            return root.isDistributive && (isTypeParameterPossiblyReferenced(root.checkType, root.node.trueType) ||
                isTypeParameterPossiblyReferenced(root.checkType, root.node.falseType));
        }
        function getTypeFromConditionalTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var checkType = getTypeFromTypeNode(node.checkType);
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                var aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                var allOuterTypeParameters = getOuterTypeParameters(node, /*includeThisTypes*/ true);
                var outerTypeParameters = aliasTypeArguments ? allOuterTypeParameters : ts.filter(allOuterTypeParameters, function (tp) { return isTypeParameterPossiblyReferenced(tp, node); });
                var root = {
                    node: node,
                    checkType: checkType,
                    extendsType: getTypeFromTypeNode(node.extendsType),
                    isDistributive: !!(checkType.flags & 262144 /* TypeFlags.TypeParameter */),
                    inferTypeParameters: getInferTypeParameters(node),
                    outerTypeParameters: outerTypeParameters,
                    instantiations: undefined,
                    aliasSymbol: aliasSymbol,
                    aliasTypeArguments: aliasTypeArguments
                };
                links.resolvedType = getConditionalType(root, /*mapper*/ undefined);
                if (outerTypeParameters) {
                    root.instantiations = new ts.Map();
                    root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType);
                }
            }
            return links.resolvedType;
        }
        function getTypeFromInferTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node.typeParameter));
            }
            return links.resolvedType;
        }
        function getIdentifierChain(node) {
            if (ts.isIdentifier(node)) {
                return [node];
            }
            else {
                return ts.append(getIdentifierChain(node.left), node.right);
            }
        }
        function getTypeFromImportTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                if (node.isTypeOf && node.typeArguments) { // Only the non-typeof form can make use of type arguments
                    error(node, ts.Diagnostics.Type_arguments_cannot_be_used_here);
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = errorType;
                }
                if (!ts.isLiteralImportTypeNode(node)) {
                    error(node.argument, ts.Diagnostics.String_literal_expected);
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = errorType;
                }
                var targetMeaning = node.isTypeOf ? 111551 /* SymbolFlags.Value */ : node.flags & 8388608 /* NodeFlags.JSDoc */ ? 111551 /* SymbolFlags.Value */ | 788968 /* SymbolFlags.Type */ : 788968 /* SymbolFlags.Type */;
                // TODO: Future work: support unions/generics/whatever via a deferred import-type
                var innerModuleSymbol = resolveExternalModuleName(node, node.argument.literal);
                if (!innerModuleSymbol) {
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = errorType;
                }
                var moduleSymbol = resolveExternalModuleSymbol(innerModuleSymbol, /*dontResolveAlias*/ false);
                if (!ts.nodeIsMissing(node.qualifier)) {
                    var nameStack = getIdentifierChain(node.qualifier);
                    var currentNamespace = moduleSymbol;
                    var current = void 0;
                    while (current = nameStack.shift()) {
                        var meaning = nameStack.length ? 1920 /* SymbolFlags.Namespace */ : targetMeaning;
                        // typeof a.b.c is normally resolved using `checkExpression` which in turn defers to `checkQualifiedName`
                        // That, in turn, ultimately uses `getPropertyOfType` on the type of the symbol, which differs slightly from
                        // the `exports` lookup process that only looks up namespace members which is used for most type references
                        var mergedResolvedSymbol = getMergedSymbol(resolveSymbol(currentNamespace));
                        var next = node.isTypeOf
                            ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText)
                            : getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning);
                        if (!next) {
                            error(current, ts.Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), ts.declarationNameToString(current));
                            return links.resolvedType = errorType;
                        }
                        getNodeLinks(current).resolvedSymbol = next;
                        getNodeLinks(current.parent).resolvedSymbol = next;
                        currentNamespace = next;
                    }
                    links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning);
                }
                else {
                    if (moduleSymbol.flags & targetMeaning) {
                        links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning);
                    }
                    else {
                        var errorMessage = targetMeaning === 111551 /* SymbolFlags.Value */
                            ? ts.Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here
                            : ts.Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0;
                        error(node, errorMessage, node.argument.literal.text);
                        links.resolvedSymbol = unknownSymbol;
                        links.resolvedType = errorType;
                    }
                }
            }
            return links.resolvedType;
        }
        function resolveImportSymbolType(node, links, symbol, meaning) {
            var resolvedSymbol = resolveSymbol(symbol);
            links.resolvedSymbol = resolvedSymbol;
            if (meaning === 111551 /* SymbolFlags.Value */) {
                return getTypeOfSymbol(symbol); // intentionally doesn't use resolved symbol so type is cached as expected on the alias
            }
            else {
                return getTypeReferenceType(node, resolvedSymbol); // getTypeReferenceType doesn't handle aliases - it must get the resolved symbol
            }
        }
        function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // Deferred resolution of members is handled by resolveObjectTypeMembers
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                if (getMembersOfSymbol(node.symbol).size === 0 && !aliasSymbol) {
                    links.resolvedType = emptyTypeLiteralType;
                }
                else {
                    var type = createObjectType(16 /* ObjectFlags.Anonymous */, node.symbol);
                    type.aliasSymbol = aliasSymbol;
                    type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                    if (ts.isJSDocTypeLiteral(node) && node.isArrayType) {
                        type = createArrayType(type);
                    }
                    links.resolvedType = type;
                }
            }
            return links.resolvedType;
        }
        function getAliasSymbolForTypeNode(node) {
            var host = node.parent;
            while (ts.isParenthesizedTypeNode(host) || ts.isJSDocTypeExpression(host) || ts.isTypeOperatorNode(host) && host.operator === 145 /* SyntaxKind.ReadonlyKeyword */) {
                host = host.parent;
            }
            return ts.isTypeAlias(host) ? getSymbolOfNode(host) : undefined;
        }
        function getTypeArgumentsForAliasSymbol(symbol) {
            return symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined;
        }
        function isNonGenericObjectType(type) {
            return !!(type.flags & 524288 /* TypeFlags.Object */) && !isGenericMappedType(type);
        }
        function isEmptyObjectTypeOrSpreadsIntoEmptyObject(type) {
            return isEmptyObjectType(type) || !!(type.flags & (65536 /* TypeFlags.Null */ | 32768 /* TypeFlags.Undefined */ | 528 /* TypeFlags.BooleanLike */ | 296 /* TypeFlags.NumberLike */ | 2112 /* TypeFlags.BigIntLike */ | 402653316 /* TypeFlags.StringLike */ | 1056 /* TypeFlags.EnumLike */ | 67108864 /* TypeFlags.NonPrimitive */ | 4194304 /* TypeFlags.Index */));
        }
        function tryMergeUnionOfObjectTypeAndEmptyObject(type, readonly) {
            if (!(type.flags & 1048576 /* TypeFlags.Union */)) {
                return type;
            }
            if (ts.every(type.types, isEmptyObjectTypeOrSpreadsIntoEmptyObject)) {
                return ts.find(type.types, isEmptyObjectType) || emptyObjectType;
            }
            var firstType = ts.find(type.types, function (t) { return !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t); });
            if (!firstType) {
                return type;
            }
            var secondType = ts.find(type.types, function (t) { return t !== firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t); });
            if (secondType) {
                return type;
            }
            return getAnonymousPartialType(firstType);
            function getAnonymousPartialType(type) {
                // gets the type as if it had been spread, but where everything in the spread is made optional
                var members = ts.createSymbolTable();
                for (var _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
                    var prop = _a[_i];
                    if (ts.getDeclarationModifierFlagsFromSymbol(prop) & (8 /* ModifierFlags.Private */ | 16 /* ModifierFlags.Protected */)) {
                        // do nothing, skip privates
                    }
                    else if (isSpreadableProperty(prop)) {
                        var isSetonlyAccessor = prop.flags & 65536 /* SymbolFlags.SetAccessor */ && !(prop.flags & 32768 /* SymbolFlags.GetAccessor */);
                        var flags = 4 /* SymbolFlags.Property */ | 16777216 /* SymbolFlags.Optional */;
                        var result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? 8 /* CheckFlags.Readonly */ : 0));
                        result.type = isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), /*isProperty*/ true);
                        result.declarations = prop.declarations;
                        result.nameType = getSymbolLinks(prop).nameType;
                        result.syntheticOrigin = prop;
                        members.set(prop.escapedName, result);
                    }
                }
                var spread = createAnonymousType(type.symbol, members, ts.emptyArray, ts.emptyArray, getIndexInfosOfType(type));
                spread.objectFlags |= 128 /* ObjectFlags.ObjectLiteral */ | 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
                return spread;
            }
        }
        /**
         * Since the source of spread types are object literals, which are not binary,
         * this function should be called in a left folding style, with left = previous result of getSpreadType
         * and right = the new element to be spread.
         */
        function getSpreadType(left, right, symbol, objectFlags, readonly) {
            if (left.flags & 1 /* TypeFlags.Any */ || right.flags & 1 /* TypeFlags.Any */) {
                return anyType;
            }
            if (left.flags & 2 /* TypeFlags.Unknown */ || right.flags & 2 /* TypeFlags.Unknown */) {
                return unknownType;
            }
            if (left.flags & 131072 /* TypeFlags.Never */) {
                return right;
            }
            if (right.flags & 131072 /* TypeFlags.Never */) {
                return left;
            }
            left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly);
            if (left.flags & 1048576 /* TypeFlags.Union */) {
                return checkCrossProductUnion([left, right])
                    ? mapType(left, function (t) { return getSpreadType(t, right, symbol, objectFlags, readonly); })
                    : errorType;
            }
            right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly);
            if (right.flags & 1048576 /* TypeFlags.Union */) {
                return checkCrossProductUnion([left, right])
                    ? mapType(right, function (t) { return getSpreadType(left, t, symbol, objectFlags, readonly); })
                    : errorType;
            }
            if (right.flags & (528 /* TypeFlags.BooleanLike */ | 296 /* TypeFlags.NumberLike */ | 2112 /* TypeFlags.BigIntLike */ | 402653316 /* TypeFlags.StringLike */ | 1056 /* TypeFlags.EnumLike */ | 67108864 /* TypeFlags.NonPrimitive */ | 4194304 /* TypeFlags.Index */)) {
                return left;
            }
            if (isGenericObjectType(left) || isGenericObjectType(right)) {
                if (isEmptyObjectType(left)) {
                    return right;
                }
                // When the left type is an intersection, we may need to merge the last constituent of the
                // intersection with the right type. For example when the left type is 'T & { a: string }'
                // and the right type is '{ b: string }' we produce 'T & { a: string, b: string }'.
                if (left.flags & 2097152 /* TypeFlags.Intersection */) {
                    var types = left.types;
                    var lastLeft = types[types.length - 1];
                    if (isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right)) {
                        return getIntersectionType(ts.concatenate(types.slice(0, types.length - 1), [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)]));
                    }
                }
                return getIntersectionType([left, right]);
            }
            var members = ts.createSymbolTable();
            var skippedPrivateMembers = new ts.Set();
            var indexInfos = left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]);
            for (var _i = 0, _a = getPropertiesOfType(right); _i < _a.length; _i++) {
                var rightProp = _a[_i];
                if (ts.getDeclarationModifierFlagsFromSymbol(rightProp) & (8 /* ModifierFlags.Private */ | 16 /* ModifierFlags.Protected */)) {
                    skippedPrivateMembers.add(rightProp.escapedName);
                }
                else if (isSpreadableProperty(rightProp)) {
                    members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly));
                }
            }
            for (var _b = 0, _c = getPropertiesOfType(left); _b < _c.length; _b++) {
                var leftProp = _c[_b];
                if (skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp)) {
                    continue;
                }
                if (members.has(leftProp.escapedName)) {
                    var rightProp = members.get(leftProp.escapedName);
                    var rightType = getTypeOfSymbol(rightProp);
                    if (rightProp.flags & 16777216 /* SymbolFlags.Optional */) {
                        var declarations = ts.concatenate(leftProp.declarations, rightProp.declarations);
                        var flags = 4 /* SymbolFlags.Property */ | (leftProp.flags & 16777216 /* SymbolFlags.Optional */);
                        var result = createSymbol(flags, leftProp.escapedName);
                        result.type = getUnionType([getTypeOfSymbol(leftProp), removeMissingOrUndefinedType(rightType)], 2 /* UnionReduction.Subtype */);
                        result.leftSpread = leftProp;
                        result.rightSpread = rightProp;
                        result.declarations = declarations;
                        result.nameType = getSymbolLinks(leftProp).nameType;
                        members.set(leftProp.escapedName, result);
                    }
                }
                else {
                    members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly));
                }
            }
            var spread = createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.sameMap(indexInfos, function (info) { return getIndexInfoWithReadonly(info, readonly); }));
            spread.objectFlags |= 128 /* ObjectFlags.ObjectLiteral */ | 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */ | 2097152 /* ObjectFlags.ContainsSpread */ | objectFlags;
            return spread;
        }
        /** We approximate own properties as non-methods plus methods that are inside the object literal */
        function isSpreadableProperty(prop) {
            var _a;
            return !ts.some(prop.declarations, ts.isPrivateIdentifierClassElementDeclaration) &&
                (!(prop.flags & (8192 /* SymbolFlags.Method */ | 32768 /* SymbolFlags.GetAccessor */ | 65536 /* SymbolFlags.SetAccessor */)) ||
                    !((_a = prop.declarations) === null || _a === void 0 ? void 0 : _a.some(function (decl) { return ts.isClassLike(decl.parent); })));
        }
        function getSpreadSymbol(prop, readonly) {
            var isSetonlyAccessor = prop.flags & 65536 /* SymbolFlags.SetAccessor */ && !(prop.flags & 32768 /* SymbolFlags.GetAccessor */);
            if (!isSetonlyAccessor && readonly === isReadonlySymbol(prop)) {
                return prop;
            }
            var flags = 4 /* SymbolFlags.Property */ | (prop.flags & 16777216 /* SymbolFlags.Optional */);
            var result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? 8 /* CheckFlags.Readonly */ : 0));
            result.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop);
            result.declarations = prop.declarations;
            result.nameType = getSymbolLinks(prop).nameType;
            result.syntheticOrigin = prop;
            return result;
        }
        function getIndexInfoWithReadonly(info, readonly) {
            return info.isReadonly !== readonly ? createIndexInfo(info.keyType, info.type, readonly, info.declaration) : info;
        }
        function createLiteralType(flags, value, symbol, regularType) {
            var type = createType(flags);
            type.symbol = symbol;
            type.value = value;
            type.regularType = regularType || type;
            return type;
        }
        function getFreshTypeOfLiteralType(type) {
            if (type.flags & 2944 /* TypeFlags.Literal */) {
                if (!type.freshType) {
                    var freshType = createLiteralType(type.flags, type.value, type.symbol, type);
                    freshType.freshType = freshType;
                    type.freshType = freshType;
                }
                return type.freshType;
            }
            return type;
        }
        function getRegularTypeOfLiteralType(type) {
            return type.flags & 2944 /* TypeFlags.Literal */ ? type.regularType :
                type.flags & 1048576 /* TypeFlags.Union */ ? (type.regularType || (type.regularType = mapType(type, getRegularTypeOfLiteralType))) :
                    type;
        }
        function isFreshLiteralType(type) {
            return !!(type.flags & 2944 /* TypeFlags.Literal */) && type.freshType === type;
        }
        function getStringLiteralType(value) {
            var type;
            return stringLiteralTypes.get(value) ||
                (stringLiteralTypes.set(value, type = createLiteralType(128 /* TypeFlags.StringLiteral */, value)), type);
        }
        function getNumberLiteralType(value) {
            var type;
            return numberLiteralTypes.get(value) ||
                (numberLiteralTypes.set(value, type = createLiteralType(256 /* TypeFlags.NumberLiteral */, value)), type);
        }
        function getBigIntLiteralType(value) {
            var type;
            var key = ts.pseudoBigIntToString(value);
            return bigIntLiteralTypes.get(key) ||
                (bigIntLiteralTypes.set(key, type = createLiteralType(2048 /* TypeFlags.BigIntLiteral */, value)), type);
        }
        function getEnumLiteralType(value, enumId, symbol) {
            var type;
            var qualifier = typeof value === "string" ? "@" : "#";
            var key = enumId + qualifier + value;
            var flags = 1024 /* TypeFlags.EnumLiteral */ | (typeof value === "string" ? 128 /* TypeFlags.StringLiteral */ : 256 /* TypeFlags.NumberLiteral */);
            return enumLiteralTypes.get(key) ||
                (enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type);
        }
        function getTypeFromLiteralTypeNode(node) {
            if (node.literal.kind === 104 /* SyntaxKind.NullKeyword */) {
                return nullType;
            }
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal));
            }
            return links.resolvedType;
        }
        function createUniqueESSymbolType(symbol) {
            var type = createType(8192 /* TypeFlags.UniqueESSymbol */);
            type.symbol = symbol;
            type.escapedName = "__@".concat(type.symbol.escapedName, "@").concat(getSymbolId(type.symbol));
            return type;
        }
        function getESSymbolLikeTypeForNode(node) {
            if (ts.isValidESSymbolDeclaration(node)) {
                var symbol = ts.isCommonJsExportPropertyAssignment(node) ? getSymbolOfNode(node.left) : getSymbolOfNode(node);
                if (symbol) {
                    var links = getSymbolLinks(symbol);
                    return links.uniqueESSymbolType || (links.uniqueESSymbolType = createUniqueESSymbolType(symbol));
                }
            }
            return esSymbolType;
        }
        function getThisType(node) {
            var container = ts.getThisContainer(node, /*includeArrowFunctions*/ false);
            var parent = container && container.parent;
            if (parent && (ts.isClassLike(parent) || parent.kind === 258 /* SyntaxKind.InterfaceDeclaration */)) {
                if (!ts.isStatic(container) &&
                    (!ts.isConstructorDeclaration(container) || ts.isNodeDescendantOf(node, container.body))) {
                    return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent)).thisType;
                }
            }
            // inside x.prototype = { ... }
            if (parent && ts.isObjectLiteralExpression(parent) && ts.isBinaryExpression(parent.parent) && ts.getAssignmentDeclarationKind(parent.parent) === 6 /* AssignmentDeclarationKind.Prototype */) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left).parent).thisType;
            }
            // /** @return {this} */
            // x.prototype.m = function() { ... }
            var host = node.flags & 8388608 /* NodeFlags.JSDoc */ ? ts.getHostSignatureFromJSDoc(node) : undefined;
            if (host && ts.isFunctionExpression(host) && ts.isBinaryExpression(host.parent) && ts.getAssignmentDeclarationKind(host.parent) === 3 /* AssignmentDeclarationKind.PrototypeProperty */) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left).parent).thisType;
            }
            // inside constructor function C() { ... }
            if (isJSConstructor(container) && ts.isNodeDescendantOf(node, container.body)) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(container)).thisType;
            }
            error(node, ts.Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface);
            return errorType;
        }
        function getTypeFromThisTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getThisType(node);
            }
            return links.resolvedType;
        }
        function getTypeFromRestTypeNode(node) {
            return getTypeFromTypeNode(getArrayElementTypeNode(node.type) || node.type);
        }
        function getArrayElementTypeNode(node) {
            switch (node.kind) {
                case 191 /* SyntaxKind.ParenthesizedType */:
                    return getArrayElementTypeNode(node.type);
                case 184 /* SyntaxKind.TupleType */:
                    if (node.elements.length === 1) {
                        node = node.elements[0];
                        if (node.kind === 186 /* SyntaxKind.RestType */ || node.kind === 197 /* SyntaxKind.NamedTupleMember */ && node.dotDotDotToken) {
                            return getArrayElementTypeNode(node.type);
                        }
                    }
                    break;
                case 183 /* SyntaxKind.ArrayType */:
                    return node.elementType;
            }
            return undefined;
        }
        function getTypeFromNamedTupleTypeNode(node) {
            var links = getNodeLinks(node);
            return links.resolvedType || (links.resolvedType =
                node.dotDotDotToken ? getTypeFromRestTypeNode(node) :
                    addOptionality(getTypeFromTypeNode(node.type), /*isProperty*/ true, !!node.questionToken));
        }
        function getTypeFromTypeNode(node) {
            return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node);
        }
        function getTypeFromTypeNodeWorker(node) {
            switch (node.kind) {
                case 130 /* SyntaxKind.AnyKeyword */:
                case 312 /* SyntaxKind.JSDocAllType */:
                case 313 /* SyntaxKind.JSDocUnknownType */:
                    return anyType;
                case 155 /* SyntaxKind.UnknownKeyword */:
                    return unknownType;
                case 150 /* SyntaxKind.StringKeyword */:
                    return stringType;
                case 147 /* SyntaxKind.NumberKeyword */:
                    return numberType;
                case 158 /* SyntaxKind.BigIntKeyword */:
                    return bigintType;
                case 133 /* SyntaxKind.BooleanKeyword */:
                    return booleanType;
                case 151 /* SyntaxKind.SymbolKeyword */:
                    return esSymbolType;
                case 114 /* SyntaxKind.VoidKeyword */:
                    return voidType;
                case 153 /* SyntaxKind.UndefinedKeyword */:
                    return undefinedType;
                case 104 /* SyntaxKind.NullKeyword */:
                    // TODO(rbuckton): `NullKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service.
                    return nullType;
                case 143 /* SyntaxKind.NeverKeyword */:
                    return neverType;
                case 148 /* SyntaxKind.ObjectKeyword */:
                    return node.flags & 262144 /* NodeFlags.JavaScriptFile */ && !noImplicitAny ? anyType : nonPrimitiveType;
                case 138 /* SyntaxKind.IntrinsicKeyword */:
                    return intrinsicMarkerType;
                case 192 /* SyntaxKind.ThisType */:
                case 108 /* SyntaxKind.ThisKeyword */:
                    // TODO(rbuckton): `ThisKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service and because of `isPartOfTypeNode`.
                    return getTypeFromThisTypeNode(node);
                case 196 /* SyntaxKind.LiteralType */:
                    return getTypeFromLiteralTypeNode(node);
                case 178 /* SyntaxKind.TypeReference */:
                    return getTypeFromTypeReference(node);
                case 177 /* SyntaxKind.TypePredicate */:
                    return node.assertsModifier ? voidType : booleanType;
                case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                    return getTypeFromTypeReference(node);
                case 181 /* SyntaxKind.TypeQuery */:
                    return getTypeFromTypeQueryNode(node);
                case 183 /* SyntaxKind.ArrayType */:
                case 184 /* SyntaxKind.TupleType */:
                    return getTypeFromArrayOrTupleTypeNode(node);
                case 185 /* SyntaxKind.OptionalType */:
                    return getTypeFromOptionalTypeNode(node);
                case 187 /* SyntaxKind.UnionType */:
                    return getTypeFromUnionTypeNode(node);
                case 188 /* SyntaxKind.IntersectionType */:
                    return getTypeFromIntersectionTypeNode(node);
                case 314 /* SyntaxKind.JSDocNullableType */:
                    return getTypeFromJSDocNullableTypeNode(node);
                case 316 /* SyntaxKind.JSDocOptionalType */:
                    return addOptionality(getTypeFromTypeNode(node.type));
                case 197 /* SyntaxKind.NamedTupleMember */:
                    return getTypeFromNamedTupleTypeNode(node);
                case 191 /* SyntaxKind.ParenthesizedType */:
                case 315 /* SyntaxKind.JSDocNonNullableType */:
                case 309 /* SyntaxKind.JSDocTypeExpression */:
                    return getTypeFromTypeNode(node.type);
                case 186 /* SyntaxKind.RestType */:
                    return getTypeFromRestTypeNode(node);
                case 318 /* SyntaxKind.JSDocVariadicType */:
                    return getTypeFromJSDocVariadicType(node);
                case 179 /* SyntaxKind.FunctionType */:
                case 180 /* SyntaxKind.ConstructorType */:
                case 182 /* SyntaxKind.TypeLiteral */:
                case 322 /* SyntaxKind.JSDocTypeLiteral */:
                case 317 /* SyntaxKind.JSDocFunctionType */:
                case 323 /* SyntaxKind.JSDocSignature */:
                    return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
                case 193 /* SyntaxKind.TypeOperator */:
                    return getTypeFromTypeOperatorNode(node);
                case 194 /* SyntaxKind.IndexedAccessType */:
                    return getTypeFromIndexedAccessTypeNode(node);
                case 195 /* SyntaxKind.MappedType */:
                    return getTypeFromMappedTypeNode(node);
                case 189 /* SyntaxKind.ConditionalType */:
                    return getTypeFromConditionalTypeNode(node);
                case 190 /* SyntaxKind.InferType */:
                    return getTypeFromInferTypeNode(node);
                case 198 /* SyntaxKind.TemplateLiteralType */:
                    return getTypeFromTemplateTypeNode(node);
                case 200 /* SyntaxKind.ImportType */:
                    return getTypeFromImportTypeNode(node);
                // This function assumes that an identifier, qualified name, or property access expression is a type expression
                // Callers should first ensure this by calling `isPartOfTypeNode`
                // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.
                case 79 /* SyntaxKind.Identifier */:
                case 161 /* SyntaxKind.QualifiedName */:
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    var symbol = getSymbolAtLocation(node);
                    return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
                default:
                    return errorType;
            }
        }
        function instantiateList(items, mapper, instantiator) {
            if (items && items.length) {
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var mapped = instantiator(item, mapper);
                    if (item !== mapped) {
                        var result = i === 0 ? [] : items.slice(0, i);
                        result.push(mapped);
                        for (i++; i < items.length; i++) {
                            result.push(instantiator(items[i], mapper));
                        }
                        return result;
                    }
                }
            }
            return items;
        }
        function instantiateTypes(types, mapper) {
            return instantiateList(types, mapper, instantiateType);
        }
        function instantiateSignatures(signatures, mapper) {
            return instantiateList(signatures, mapper, instantiateSignature);
        }
        function instantiateIndexInfos(indexInfos, mapper) {
            return instantiateList(indexInfos, mapper, instantiateIndexInfo);
        }
        function createTypeMapper(sources, targets) {
            return sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets);
        }
        function getMappedType(type, mapper) {
            switch (mapper.kind) {
                case 0 /* TypeMapKind.Simple */:
                    return type === mapper.source ? mapper.target : type;
                case 1 /* TypeMapKind.Array */:
                    var sources = mapper.sources;
                    var targets = mapper.targets;
                    for (var i = 0; i < sources.length; i++) {
                        if (type === sources[i]) {
                            return targets ? targets[i] : anyType;
                        }
                    }
                    return type;
                case 2 /* TypeMapKind.Function */:
                    return mapper.func(type);
                case 3 /* TypeMapKind.Composite */:
                case 4 /* TypeMapKind.Merged */:
                    var t1 = getMappedType(type, mapper.mapper1);
                    return t1 !== type && mapper.kind === 3 /* TypeMapKind.Composite */ ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);
            }
        }
        function makeUnaryTypeMapper(source, target) {
            return { kind: 0 /* TypeMapKind.Simple */, source: source, target: target };
        }
        function makeArrayTypeMapper(sources, targets) {
            return { kind: 1 /* TypeMapKind.Array */, sources: sources, targets: targets };
        }
        function makeFunctionTypeMapper(func) {
            return { kind: 2 /* TypeMapKind.Function */, func: func };
        }
        function makeCompositeTypeMapper(kind, mapper1, mapper2) {
            return { kind: kind, mapper1: mapper1, mapper2: mapper2 };
        }
        function createTypeEraser(sources) {
            return createTypeMapper(sources, /*targets*/ undefined);
        }
        /**
         * Maps forward-references to later types parameters to the empty object type.
         * This is used during inference when instantiating type parameter defaults.
         */
        function createBackreferenceMapper(context, index) {
            return makeFunctionTypeMapper(function (t) { return ts.findIndex(context.inferences, function (info) { return info.typeParameter === t; }) >= index ? unknownType : t; });
        }
        function combineTypeMappers(mapper1, mapper2) {
            return mapper1 ? makeCompositeTypeMapper(3 /* TypeMapKind.Composite */, mapper1, mapper2) : mapper2;
        }
        function mergeTypeMappers(mapper1, mapper2) {
            return mapper1 ? makeCompositeTypeMapper(4 /* TypeMapKind.Merged */, mapper1, mapper2) : mapper2;
        }
        function prependTypeMapping(source, target, mapper) {
            return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(4 /* TypeMapKind.Merged */, makeUnaryTypeMapper(source, target), mapper);
        }
        function appendTypeMapping(mapper, source, target) {
            return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(4 /* TypeMapKind.Merged */, mapper, makeUnaryTypeMapper(source, target));
        }
        function getRestrictiveTypeParameter(tp) {
            return tp.constraint === unknownType ? tp : tp.restrictiveInstantiation || (tp.restrictiveInstantiation = createTypeParameter(tp.symbol),
                tp.restrictiveInstantiation.constraint = unknownType,
                tp.restrictiveInstantiation);
        }
        function cloneTypeParameter(typeParameter) {
            var result = createTypeParameter(typeParameter.symbol);
            result.target = typeParameter;
            return result;
        }
        function instantiateTypePredicate(predicate, mapper) {
            return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type, mapper));
        }
        function instantiateSignature(signature, mapper, eraseTypeParameters) {
            var freshTypeParameters;
            if (signature.typeParameters && !eraseTypeParameters) {
                // First create a fresh set of type parameters, then include a mapping from the old to the
                // new type parameters in the mapper function. Finally store this mapper in the new type
                // parameters such that we can use it when instantiating constraints.
                freshTypeParameters = ts.map(signature.typeParameters, cloneTypeParameter);
                mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
                for (var _i = 0, freshTypeParameters_1 = freshTypeParameters; _i < freshTypeParameters_1.length; _i++) {
                    var tp = freshTypeParameters_1[_i];
                    tp.mapper = mapper;
                }
            }
            // Don't compute resolvedReturnType and resolvedTypePredicate now,
            // because using `mapper` now could trigger inferences to become fixed. (See `createInferenceContext`.)
            // See GH#17600.
            var result = createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), 
            /*resolvedReturnType*/ undefined, 
            /*resolvedTypePredicate*/ undefined, signature.minArgumentCount, signature.flags & 39 /* SignatureFlags.PropagatingFlags */);
            result.target = signature;
            result.mapper = mapper;
            return result;
        }
        function instantiateSymbol(symbol, mapper) {
            var links = getSymbolLinks(symbol);
            if (links.type && !couldContainTypeVariables(links.type)) {
                // If the type of the symbol is already resolved, and if that type could not possibly
                // be affected by instantiation, simply return the symbol itself.
                return symbol;
            }
            if (ts.getCheckFlags(symbol) & 1 /* CheckFlags.Instantiated */) {
                // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
                // type mappers. This ensures that original type identities are properly preserved and that aliases
                // always reference a non-aliases.
                symbol = links.target;
                mapper = combineTypeMappers(links.mapper, mapper);
            }
            // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
            // also transient so that we can just store data on it directly.
            var result = createSymbol(symbol.flags, symbol.escapedName, 1 /* CheckFlags.Instantiated */ | ts.getCheckFlags(symbol) & (8 /* CheckFlags.Readonly */ | 4096 /* CheckFlags.Late */ | 16384 /* CheckFlags.OptionalParameter */ | 32768 /* CheckFlags.RestParameter */));
            result.declarations = symbol.declarations;
            result.parent = symbol.parent;
            result.target = symbol;
            result.mapper = mapper;
            if (symbol.valueDeclaration) {
                result.valueDeclaration = symbol.valueDeclaration;
            }
            if (links.nameType) {
                result.nameType = links.nameType;
            }
            return result;
        }
        function getObjectTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments) {
            var declaration = type.objectFlags & 4 /* ObjectFlags.Reference */ ? type.node :
                type.objectFlags & 8388608 /* ObjectFlags.InstantiationExpressionType */ ? type.node :
                    type.symbol.declarations[0];
            var links = getNodeLinks(declaration);
            var target = type.objectFlags & 4 /* ObjectFlags.Reference */ ? links.resolvedType :
                type.objectFlags & 64 /* ObjectFlags.Instantiated */ ? type.target : type;
            var typeParameters = links.outerTypeParameters;
            if (!typeParameters) {
                // The first time an anonymous type is instantiated we compute and store a list of the type
                // parameters that are in scope (and therefore potentially referenced). For type literals that
                // aren't the right hand side of a generic type alias declaration we optimize by reducing the
                // set of type parameters to those that are possibly referenced in the literal.
                var outerTypeParameters = getOuterTypeParameters(declaration, /*includeThisTypes*/ true);
                if (isJSConstructor(declaration)) {
                    var templateTagParameters = getTypeParametersFromDeclaration(declaration);
                    outerTypeParameters = ts.addRange(outerTypeParameters, templateTagParameters);
                }
                typeParameters = outerTypeParameters || ts.emptyArray;
                var allDeclarations_1 = type.objectFlags & (4 /* ObjectFlags.Reference */ | 8388608 /* ObjectFlags.InstantiationExpressionType */) ? [declaration] : type.symbol.declarations;
                typeParameters = (target.objectFlags & (4 /* ObjectFlags.Reference */ | 8388608 /* ObjectFlags.InstantiationExpressionType */) || target.symbol.flags & 8192 /* SymbolFlags.Method */ || target.symbol.flags & 2048 /* SymbolFlags.TypeLiteral */) && !target.aliasTypeArguments ?
                    ts.filter(typeParameters, function (tp) { return ts.some(allDeclarations_1, function (d) { return isTypeParameterPossiblyReferenced(tp, d); }); }) :
                    typeParameters;
                links.outerTypeParameters = typeParameters;
            }
            if (typeParameters.length) {
                // We are instantiating an anonymous type that has one or more type parameters in scope. Apply the
                // mapper to the type parameters to produce the effective list of type arguments, and compute the
                // instantiation cache key from the type IDs of the type arguments.
                var combinedMapper_1 = combineTypeMappers(type.mapper, mapper);
                var typeArguments = ts.map(typeParameters, function (t) { return getMappedType(t, combinedMapper_1); });
                var newAliasSymbol = aliasSymbol || type.aliasSymbol;
                var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
                var id = getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments);
                if (!target.instantiations) {
                    target.instantiations = new ts.Map();
                    target.instantiations.set(getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments), target);
                }
                var result = target.instantiations.get(id);
                if (!result) {
                    var newMapper = createTypeMapper(typeParameters, typeArguments);
                    result = target.objectFlags & 4 /* ObjectFlags.Reference */ ? createDeferredTypeReference(type.target, type.node, newMapper, newAliasSymbol, newAliasTypeArguments) :
                        target.objectFlags & 32 /* ObjectFlags.Mapped */ ? instantiateMappedType(target, newMapper, newAliasSymbol, newAliasTypeArguments) :
                            instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments);
                    target.instantiations.set(id, result);
                }
                return result;
            }
            return type;
        }
        function maybeTypeParameterReference(node) {
            return !(node.parent.kind === 178 /* SyntaxKind.TypeReference */ && node.parent.typeArguments && node === node.parent.typeName ||
                node.parent.kind === 200 /* SyntaxKind.ImportType */ && node.parent.typeArguments && node === node.parent.qualifier);
        }
        function isTypeParameterPossiblyReferenced(tp, node) {
            // If the type parameter doesn't have exactly one declaration, if there are invening statement blocks
            // between the node and the type parameter declaration, if the node contains actual references to the
            // type parameter, or if the node contains type queries, we consider the type parameter possibly referenced.
            if (tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1) {
                var container = tp.symbol.declarations[0].parent;
                for (var n = node; n !== container; n = n.parent) {
                    if (!n || n.kind === 235 /* SyntaxKind.Block */ || n.kind === 189 /* SyntaxKind.ConditionalType */ && ts.forEachChild(n.extendsType, containsReference)) {
                        return true;
                    }
                }
                return containsReference(node);
            }
            return true;
            function containsReference(node) {
                switch (node.kind) {
                    case 192 /* SyntaxKind.ThisType */:
                        return !!tp.isThisType;
                    case 79 /* SyntaxKind.Identifier */:
                        return !tp.isThisType && ts.isPartOfTypeNode(node) && maybeTypeParameterReference(node) &&
                            getTypeFromTypeNodeWorker(node) === tp; // use worker because we're looking for === equality
                    case 181 /* SyntaxKind.TypeQuery */:
                        return true;
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 168 /* SyntaxKind.MethodSignature */:
                        return !node.type && !!node.body ||
                            ts.some(node.typeParameters, containsReference) ||
                            ts.some(node.parameters, containsReference) ||
                            !!node.type && containsReference(node.type);
                }
                return !!ts.forEachChild(node, containsReference);
            }
        }
        function getHomomorphicTypeVariable(type) {
            var constraintType = getConstraintTypeFromMappedType(type);
            if (constraintType.flags & 4194304 /* TypeFlags.Index */) {
                var typeVariable = getActualTypeVariable(constraintType.type);
                if (typeVariable.flags & 262144 /* TypeFlags.TypeParameter */) {
                    return typeVariable;
                }
            }
            return undefined;
        }
        function instantiateMappedType(type, mapper, aliasSymbol, aliasTypeArguments) {
            // For a homomorphic mapped type { [P in keyof T]: X }, where T is some type variable, the mapping
            // operation depends on T as follows:
            // * If T is a primitive type no mapping is performed and the result is simply T.
            // * If T is a union type we distribute the mapped type over the union.
            // * If T is an array we map to an array where the element type has been transformed.
            // * If T is a tuple we map to a tuple where the element types have been transformed.
            // * Otherwise we map to an object type where the type of each property has been transformed.
            // For example, when T is instantiated to a union type A | B, we produce { [P in keyof A]: X } |
            // { [P in keyof B]: X }, and when when T is instantiated to a union type A | undefined, we produce
            // { [P in keyof A]: X } | undefined.
            var typeVariable = getHomomorphicTypeVariable(type);
            if (typeVariable) {
                var mappedTypeVariable = instantiateType(typeVariable, mapper);
                if (typeVariable !== mappedTypeVariable) {
                    return mapTypeWithAlias(getReducedType(mappedTypeVariable), function (t) {
                        if (t.flags & (3 /* TypeFlags.AnyOrUnknown */ | 58982400 /* TypeFlags.InstantiableNonPrimitive */ | 524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */) && t !== wildcardType && !isErrorType(t)) {
                            if (!type.declaration.nameType) {
                                var constraint = void 0;
                                if (isArrayType(t) || t.flags & 1 /* TypeFlags.Any */ && findResolutionCycleStartIndex(typeVariable, 4 /* TypeSystemPropertyName.ImmediateBaseConstraint */) < 0 &&
                                    (constraint = getConstraintOfTypeParameter(typeVariable)) && everyType(constraint, isArrayOrTupleType)) {
                                    return instantiateMappedArrayType(t, type, prependTypeMapping(typeVariable, t, mapper));
                                }
                                if (isGenericTupleType(t)) {
                                    return instantiateMappedGenericTupleType(t, type, typeVariable, mapper);
                                }
                                if (isTupleType(t)) {
                                    return instantiateMappedTupleType(t, type, prependTypeMapping(typeVariable, t, mapper));
                                }
                            }
                            return instantiateAnonymousType(type, prependTypeMapping(typeVariable, t, mapper));
                        }
                        return t;
                    }, aliasSymbol, aliasTypeArguments);
                }
            }
            // If the constraint type of the instantiation is the wildcard type, return the wildcard type.
            return instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments);
        }
        function getModifiedReadonlyState(state, modifiers) {
            return modifiers & 1 /* MappedTypeModifiers.IncludeReadonly */ ? true : modifiers & 2 /* MappedTypeModifiers.ExcludeReadonly */ ? false : state;
        }
        function instantiateMappedGenericTupleType(tupleType, mappedType, typeVariable, mapper) {
            // When a tuple type is generic (i.e. when it contains variadic elements), we want to eagerly map the
            // non-generic elements and defer mapping the generic elements. In order to facilitate this, we transform
            // M<[A, B?, ...T, ...C[]] into [...M<[A]>, ...M<[B?]>, ...M<T>, ...M<C[]>] and then rely on tuple type
            // normalization to resolve the non-generic parts of the resulting tuple.
            var elementFlags = tupleType.target.elementFlags;
            var elementTypes = ts.map(getTypeArguments(tupleType), function (t, i) {
                var singleton = elementFlags[i] & 8 /* ElementFlags.Variadic */ ? t :
                    elementFlags[i] & 4 /* ElementFlags.Rest */ ? createArrayType(t) :
                        createTupleType([t], [elementFlags[i]]);
                // The singleton is never a generic tuple type, so it is safe to recurse here.
                return instantiateMappedType(mappedType, prependTypeMapping(typeVariable, singleton, mapper));
            });
            var newReadonly = getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType));
            return createTupleType(elementTypes, ts.map(elementTypes, function (_) { return 8 /* ElementFlags.Variadic */; }), newReadonly);
        }
        function instantiateMappedArrayType(arrayType, mappedType, mapper) {
            var elementType = instantiateMappedTypeTemplate(mappedType, numberType, /*isOptional*/ true, mapper);
            return isErrorType(elementType) ? errorType :
                createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType)));
        }
        function instantiateMappedTupleType(tupleType, mappedType, mapper) {
            var elementFlags = tupleType.target.elementFlags;
            var elementTypes = ts.map(getTypeArguments(tupleType), function (_, i) {
                return instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(elementFlags[i] & 2 /* ElementFlags.Optional */), mapper);
            });
            var modifiers = getMappedTypeModifiers(mappedType);
            var newTupleModifiers = modifiers & 4 /* MappedTypeModifiers.IncludeOptional */ ? ts.map(elementFlags, function (f) { return f & 1 /* ElementFlags.Required */ ? 2 /* ElementFlags.Optional */ : f; }) :
                modifiers & 8 /* MappedTypeModifiers.ExcludeOptional */ ? ts.map(elementFlags, function (f) { return f & 2 /* ElementFlags.Optional */ ? 1 /* ElementFlags.Required */ : f; }) :
                    elementFlags;
            var newReadonly = getModifiedReadonlyState(tupleType.target.readonly, modifiers);
            return ts.contains(elementTypes, errorType) ? errorType :
                createTupleType(elementTypes, newTupleModifiers, newReadonly, tupleType.target.labeledElementDeclarations);
        }
        function instantiateMappedTypeTemplate(type, key, isOptional, mapper) {
            var templateMapper = appendTypeMapping(mapper, getTypeParameterFromMappedType(type), key);
            var propType = instantiateType(getTemplateTypeFromMappedType(type.target || type), templateMapper);
            var modifiers = getMappedTypeModifiers(type);
            return strictNullChecks && modifiers & 4 /* MappedTypeModifiers.IncludeOptional */ && !maybeTypeOfKind(propType, 32768 /* TypeFlags.Undefined */ | 16384 /* TypeFlags.Void */) ? getOptionalType(propType, /*isProperty*/ true) :
                strictNullChecks && modifiers & 8 /* MappedTypeModifiers.ExcludeOptional */ && isOptional ? getTypeWithFacts(propType, 524288 /* TypeFacts.NEUndefined */) :
                    propType;
        }
        function instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments) {
            var result = createObjectType(type.objectFlags | 64 /* ObjectFlags.Instantiated */, type.symbol);
            if (type.objectFlags & 32 /* ObjectFlags.Mapped */) {
                result.declaration = type.declaration;
                // C.f. instantiateSignature
                var origTypeParameter = getTypeParameterFromMappedType(type);
                var freshTypeParameter = cloneTypeParameter(origTypeParameter);
                result.typeParameter = freshTypeParameter;
                mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper);
                freshTypeParameter.mapper = mapper;
            }
            if (type.objectFlags & 8388608 /* ObjectFlags.InstantiationExpressionType */) {
                result.node = type.node;
            }
            result.target = type;
            result.mapper = mapper;
            result.aliasSymbol = aliasSymbol || type.aliasSymbol;
            result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            return result;
        }
        function getConditionalTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments) {
            var root = type.root;
            if (root.outerTypeParameters) {
                // We are instantiating a conditional type that has one or more type parameters in scope. Apply the
                // mapper to the type parameters to produce the effective list of type arguments, and compute the
                // instantiation cache key from the type IDs of the type arguments.
                var typeArguments = ts.map(root.outerTypeParameters, function (t) { return getMappedType(t, mapper); });
                var id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
                var result = root.instantiations.get(id);
                if (!result) {
                    var newMapper_1 = createTypeMapper(root.outerTypeParameters, typeArguments);
                    var checkType_1 = root.checkType;
                    var distributionType = root.isDistributive ? getMappedType(checkType_1, newMapper_1) : undefined;
                    // Distributive conditional types are distributed over union types. For example, when the
                    // distributive conditional type T extends U ? X : Y is instantiated with A | B for T, the
                    // result is (A extends U ? X : Y) | (B extends U ? X : Y).
                    result = distributionType && checkType_1 !== distributionType && distributionType.flags & (1048576 /* TypeFlags.Union */ | 131072 /* TypeFlags.Never */) ?
                        mapTypeWithAlias(getReducedType(distributionType), function (t) { return getConditionalType(root, prependTypeMapping(checkType_1, t, newMapper_1)); }, aliasSymbol, aliasTypeArguments) :
                        getConditionalType(root, newMapper_1, aliasSymbol, aliasTypeArguments);
                    root.instantiations.set(id, result);
                }
                return result;
            }
            return type;
        }
        function instantiateType(type, mapper) {
            return type && mapper ? instantiateTypeWithAlias(type, mapper, /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined) : type;
        }
        function instantiateTypeWithAlias(type, mapper, aliasSymbol, aliasTypeArguments) {
            if (!couldContainTypeVariables(type)) {
                return type;
            }
            if (instantiationDepth === 100 || instantiationCount >= 5000000) {
                // We have reached 100 recursive type instantiations, or 5M type instantiations caused by the same statement
                // or expression. There is a very high likelyhood we're dealing with a combination of infinite generic types
                // that perpetually generate new type identities, so we stop the recursion here by yielding the error type.
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "instantiateType_DepthLimit", { typeId: type.id, instantiationDepth: instantiationDepth, instantiationCount: instantiationCount });
                error(currentNode, ts.Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
                return errorType;
            }
            totalInstantiationCount++;
            instantiationCount++;
            instantiationDepth++;
            var result = instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments);
            instantiationDepth--;
            return result;
        }
        function instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments) {
            var flags = type.flags;
            if (flags & 262144 /* TypeFlags.TypeParameter */) {
                return getMappedType(type, mapper);
            }
            if (flags & 524288 /* TypeFlags.Object */) {
                var objectFlags = type.objectFlags;
                if (objectFlags & (4 /* ObjectFlags.Reference */ | 16 /* ObjectFlags.Anonymous */ | 32 /* ObjectFlags.Mapped */)) {
                    if (objectFlags & 4 /* ObjectFlags.Reference */ && !type.node) {
                        var resolvedTypeArguments = type.resolvedTypeArguments;
                        var newTypeArguments = instantiateTypes(resolvedTypeArguments, mapper);
                        return newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference(type.target, newTypeArguments) : type;
                    }
                    if (objectFlags & 1024 /* ObjectFlags.ReverseMapped */) {
                        return instantiateReverseMappedType(type, mapper);
                    }
                    return getObjectTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments);
                }
                return type;
            }
            if (flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                var origin = type.flags & 1048576 /* TypeFlags.Union */ ? type.origin : undefined;
                var types = origin && origin.flags & 3145728 /* TypeFlags.UnionOrIntersection */ ? origin.types : type.types;
                var newTypes = instantiateTypes(types, mapper);
                if (newTypes === types && aliasSymbol === type.aliasSymbol) {
                    return type;
                }
                var newAliasSymbol = aliasSymbol || type.aliasSymbol;
                var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
                return flags & 2097152 /* TypeFlags.Intersection */ || origin && origin.flags & 2097152 /* TypeFlags.Intersection */ ?
                    getIntersectionType(newTypes, newAliasSymbol, newAliasTypeArguments) :
                    getUnionType(newTypes, 1 /* UnionReduction.Literal */, newAliasSymbol, newAliasTypeArguments);
            }
            if (flags & 4194304 /* TypeFlags.Index */) {
                return getIndexType(instantiateType(type.type, mapper));
            }
            if (flags & 134217728 /* TypeFlags.TemplateLiteral */) {
                return getTemplateLiteralType(type.texts, instantiateTypes(type.types, mapper));
            }
            if (flags & 268435456 /* TypeFlags.StringMapping */) {
                return getStringMappingType(type.symbol, instantiateType(type.type, mapper));
            }
            if (flags & 8388608 /* TypeFlags.IndexedAccess */) {
                var newAliasSymbol = aliasSymbol || type.aliasSymbol;
                var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
                return getIndexedAccessType(instantiateType(type.objectType, mapper), instantiateType(type.indexType, mapper), type.accessFlags, /*accessNode*/ undefined, newAliasSymbol, newAliasTypeArguments);
            }
            if (flags & 16777216 /* TypeFlags.Conditional */) {
                return getConditionalTypeInstantiation(type, combineTypeMappers(type.mapper, mapper), aliasSymbol, aliasTypeArguments);
            }
            if (flags & 33554432 /* TypeFlags.Substitution */) {
                var maybeVariable = instantiateType(type.baseType, mapper);
                if (maybeVariable.flags & 8650752 /* TypeFlags.TypeVariable */) {
                    return getSubstitutionType(maybeVariable, instantiateType(type.substitute, mapper));
                }
                else {
                    var sub = instantiateType(type.substitute, mapper);
                    if (sub.flags & 3 /* TypeFlags.AnyOrUnknown */ || isTypeAssignableTo(getRestrictiveInstantiation(maybeVariable), getRestrictiveInstantiation(sub))) {
                        return maybeVariable;
                    }
                    return sub;
                }
            }
            return type;
        }
        function instantiateReverseMappedType(type, mapper) {
            var innerMappedType = instantiateType(type.mappedType, mapper);
            if (!(ts.getObjectFlags(innerMappedType) & 32 /* ObjectFlags.Mapped */)) {
                return type;
            }
            var innerIndexType = instantiateType(type.constraintType, mapper);
            if (!(innerIndexType.flags & 4194304 /* TypeFlags.Index */)) {
                return type;
            }
            var instantiated = inferTypeForHomomorphicMappedType(instantiateType(type.source, mapper), innerMappedType, innerIndexType);
            if (instantiated) {
                return instantiated;
            }
            return type; // Nested invocation of `inferTypeForHomomorphicMappedType` or the `source` instantiated into something unmappable
        }
        function getUniqueLiteralFilledInstantiation(type) {
            return type.flags & (131068 /* TypeFlags.Primitive */ | 3 /* TypeFlags.AnyOrUnknown */ | 131072 /* TypeFlags.Never */) ? type :
                type.uniqueLiteralFilledInstantiation || (type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper));
        }
        function getPermissiveInstantiation(type) {
            return type.flags & (131068 /* TypeFlags.Primitive */ | 3 /* TypeFlags.AnyOrUnknown */ | 131072 /* TypeFlags.Never */) ? type :
                type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper));
        }
        function getRestrictiveInstantiation(type) {
            if (type.flags & (131068 /* TypeFlags.Primitive */ | 3 /* TypeFlags.AnyOrUnknown */ | 131072 /* TypeFlags.Never */)) {
                return type;
            }
            if (type.restrictiveInstantiation) {
                return type.restrictiveInstantiation;
            }
            type.restrictiveInstantiation = instantiateType(type, restrictiveMapper);
            // We set the following so we don't attempt to set the restrictive instance of a restrictive instance
            // which is redundant - we'll produce new type identities, but all type params have already been mapped.
            // This also gives us a way to detect restrictive instances upon comparisons and _disable_ the "distributeive constraint"
            // assignability check for them, which is distinctly unsafe, as once you have a restrctive instance, all the type parameters
            // are constrained to `unknown` and produce tons of false positives/negatives!
            type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation;
            return type.restrictiveInstantiation;
        }
        function instantiateIndexInfo(info, mapper) {
            return createIndexInfo(info.keyType, instantiateType(info.type, mapper), info.isReadonly, info.declaration);
        }
        // Returns true if the given expression contains (at any level of nesting) a function or arrow expression
        // that is subject to contextual typing.
        function isContextSensitive(node) {
            ts.Debug.assert(node.kind !== 169 /* SyntaxKind.MethodDeclaration */ || ts.isObjectLiteralMethod(node));
            switch (node.kind) {
                case 213 /* SyntaxKind.FunctionExpression */:
                case 214 /* SyntaxKind.ArrowFunction */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 256 /* SyntaxKind.FunctionDeclaration */: // Function declarations can have context when annotated with a jsdoc @type
                    return isContextSensitiveFunctionLikeDeclaration(node);
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    return ts.some(node.properties, isContextSensitive);
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    return ts.some(node.elements, isContextSensitive);
                case 222 /* SyntaxKind.ConditionalExpression */:
                    return isContextSensitive(node.whenTrue) ||
                        isContextSensitive(node.whenFalse);
                case 221 /* SyntaxKind.BinaryExpression */:
                    return (node.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ || node.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) &&
                        (isContextSensitive(node.left) || isContextSensitive(node.right));
                case 296 /* SyntaxKind.PropertyAssignment */:
                    return isContextSensitive(node.initializer);
                case 212 /* SyntaxKind.ParenthesizedExpression */:
                    return isContextSensitive(node.expression);
                case 286 /* SyntaxKind.JsxAttributes */:
                    return ts.some(node.properties, isContextSensitive) || ts.isJsxOpeningElement(node.parent) && ts.some(node.parent.parent.children, isContextSensitive);
                case 285 /* SyntaxKind.JsxAttribute */: {
                    // If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.
                    var initializer = node.initializer;
                    return !!initializer && isContextSensitive(initializer);
                }
                case 288 /* SyntaxKind.JsxExpression */: {
                    // It is possible to that node.expression is undefined (e.g <div x={} />)
                    var expression = node.expression;
                    return !!expression && isContextSensitive(expression);
                }
            }
            return false;
        }
        function isContextSensitiveFunctionLikeDeclaration(node) {
            return (!ts.isFunctionDeclaration(node) || ts.isInJSFile(node) && !!getTypeForDeclarationFromJSDocComment(node)) &&
                (ts.hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node));
        }
        function hasContextSensitiveReturnExpression(node) {
            // TODO(anhans): A block should be context-sensitive if it has a context-sensitive return value.
            return !node.typeParameters && !ts.getEffectiveReturnTypeNode(node) && !!node.body && node.body.kind !== 235 /* SyntaxKind.Block */ && isContextSensitive(node.body);
        }
        function isContextSensitiveFunctionOrObjectLiteralMethod(func) {
            return (ts.isInJSFile(func) && ts.isFunctionDeclaration(func) || ts.isFunctionExpressionOrArrowFunction(func) || ts.isObjectLiteralMethod(func)) &&
                isContextSensitiveFunctionLikeDeclaration(func);
        }
        function getTypeWithoutSignatures(type) {
            if (type.flags & 524288 /* TypeFlags.Object */) {
                var resolved = resolveStructuredTypeMembers(type);
                if (resolved.constructSignatures.length || resolved.callSignatures.length) {
                    var result = createObjectType(16 /* ObjectFlags.Anonymous */, type.symbol);
                    result.members = resolved.members;
                    result.properties = resolved.properties;
                    result.callSignatures = ts.emptyArray;
                    result.constructSignatures = ts.emptyArray;
                    result.indexInfos = ts.emptyArray;
                    return result;
                }
            }
            else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                return getIntersectionType(ts.map(type.types, getTypeWithoutSignatures));
            }
            return type;
        }
        // TYPE CHECKING
        function isTypeIdenticalTo(source, target) {
            return isTypeRelatedTo(source, target, identityRelation);
        }
        function compareTypesIdentical(source, target) {
            return isTypeRelatedTo(source, target, identityRelation) ? -1 /* Ternary.True */ : 0 /* Ternary.False */;
        }
        function compareTypesAssignable(source, target) {
            return isTypeRelatedTo(source, target, assignableRelation) ? -1 /* Ternary.True */ : 0 /* Ternary.False */;
        }
        function compareTypesSubtypeOf(source, target) {
            return isTypeRelatedTo(source, target, subtypeRelation) ? -1 /* Ternary.True */ : 0 /* Ternary.False */;
        }
        function isTypeSubtypeOf(source, target) {
            return isTypeRelatedTo(source, target, subtypeRelation);
        }
        function isTypeAssignableTo(source, target) {
            return isTypeRelatedTo(source, target, assignableRelation);
        }
        // An object type S is considered to be derived from an object type T if
        // S is a union type and every constituent of S is derived from T,
        // T is a union type and S is derived from at least one constituent of T, or
        // S is a type variable with a base constraint that is derived from T,
        // T is one of the global types Object and Function and S is a subtype of T, or
        // T occurs directly or indirectly in an 'extends' clause of S.
        // Note that this check ignores type parameters and only considers the
        // inheritance hierarchy.
        function isTypeDerivedFrom(source, target) {
            return source.flags & 1048576 /* TypeFlags.Union */ ? ts.every(source.types, function (t) { return isTypeDerivedFrom(t, target); }) :
                target.flags & 1048576 /* TypeFlags.Union */ ? ts.some(target.types, function (t) { return isTypeDerivedFrom(source, t); }) :
                    source.flags & 58982400 /* TypeFlags.InstantiableNonPrimitive */ ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) :
                        target === globalObjectType ? !!(source.flags & (524288 /* TypeFlags.Object */ | 67108864 /* TypeFlags.NonPrimitive */)) :
                            target === globalFunctionType ? !!(source.flags & 524288 /* TypeFlags.Object */) && isFunctionObjectType(source) :
                                hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType));
        }
        /**
         * This is *not* a bi-directional relationship.
         * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.
         *
         * A type S is comparable to a type T if some (but not necessarily all) of the possible values of S are also possible values of T.
         * It is used to check following cases:
         *   - the types of the left and right sides of equality/inequality operators (`===`, `!==`, `==`, `!=`).
         *   - the types of `case` clause expressions and their respective `switch` expressions.
         *   - the type of an expression in a type assertion with the type being asserted.
         */
        function isTypeComparableTo(source, target) {
            return isTypeRelatedTo(source, target, comparableRelation);
        }
        function areTypesComparable(type1, type2) {
            return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1);
        }
        function checkTypeAssignableTo(source, target, errorNode, headMessage, containingMessageChain, errorOutputObject) {
            return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject);
        }
        /**
         * Like `checkTypeAssignableTo`, but if it would issue an error, instead performs structural comparisons of the types using the given expression node to
         * attempt to issue more specific errors on, for example, specific object literal properties or tuple members.
         */
        function checkTypeAssignableToAndOptionallyElaborate(source, target, errorNode, expr, headMessage, containingMessageChain) {
            return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, /*errorOutputContainer*/ undefined);
        }
        function checkTypeRelatedToAndOptionallyElaborate(source, target, relation, errorNode, expr, headMessage, containingMessageChain, errorOutputContainer) {
            if (isTypeRelatedTo(source, target, relation))
                return true;
            if (!errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
                return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer);
            }
            return false;
        }
        function isOrHasGenericConditional(type) {
            return !!(type.flags & 16777216 /* TypeFlags.Conditional */ || (type.flags & 2097152 /* TypeFlags.Intersection */ && ts.some(type.types, isOrHasGenericConditional)));
        }
        function elaborateError(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
            if (!node || isOrHasGenericConditional(target))
                return false;
            if (!checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined)
                && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
                return true;
            }
            switch (node.kind) {
                case 288 /* SyntaxKind.JsxExpression */:
                case 212 /* SyntaxKind.ParenthesizedExpression */:
                    return elaborateError(node.expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
                case 221 /* SyntaxKind.BinaryExpression */:
                    switch (node.operatorToken.kind) {
                        case 63 /* SyntaxKind.EqualsToken */:
                        case 27 /* SyntaxKind.CommaToken */:
                            return elaborateError(node.right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
                    }
                    break;
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    return elaborateObjectLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer);
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    return elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer);
                case 286 /* SyntaxKind.JsxAttributes */:
                    return elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer);
                case 214 /* SyntaxKind.ArrowFunction */:
                    return elaborateArrowFunction(node, source, target, relation, containingMessageChain, errorOutputContainer);
            }
            return false;
        }
        function elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
            var callSignatures = getSignaturesOfType(source, 0 /* SignatureKind.Call */);
            var constructSignatures = getSignaturesOfType(source, 1 /* SignatureKind.Construct */);
            for (var _i = 0, _a = [constructSignatures, callSignatures]; _i < _a.length; _i++) {
                var signatures = _a[_i];
                if (ts.some(signatures, function (s) {
                    var returnType = getReturnTypeOfSignature(s);
                    return !(returnType.flags & (1 /* TypeFlags.Any */ | 131072 /* TypeFlags.Never */)) && checkTypeRelatedTo(returnType, target, relation, /*errorNode*/ undefined);
                })) {
                    var resultObj = errorOutputContainer || {};
                    checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj);
                    var diagnostic = resultObj.errors[resultObj.errors.length - 1];
                    ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(node, signatures === constructSignatures ? ts.Diagnostics.Did_you_mean_to_use_new_with_this_expression : ts.Diagnostics.Did_you_mean_to_call_this_expression));
                    return true;
                }
            }
            return false;
        }
        function elaborateArrowFunction(node, source, target, relation, containingMessageChain, errorOutputContainer) {
            // Don't elaborate blocks
            if (ts.isBlock(node.body)) {
                return false;
            }
            // Or functions with annotated parameter types
            if (ts.some(node.parameters, ts.hasType)) {
                return false;
            }
            var sourceSig = getSingleCallSignature(source);
            if (!sourceSig) {
                return false;
            }
            var targetSignatures = getSignaturesOfType(target, 0 /* SignatureKind.Call */);
            if (!ts.length(targetSignatures)) {
                return false;
            }
            var returnExpression = node.body;
            var sourceReturn = getReturnTypeOfSignature(sourceSig);
            var targetReturn = getUnionType(ts.map(targetSignatures, getReturnTypeOfSignature));
            if (!checkTypeRelatedTo(sourceReturn, targetReturn, relation, /*errorNode*/ undefined)) {
                var elaborated = returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, /*headMessage*/ undefined, containingMessageChain, errorOutputContainer);
                if (elaborated) {
                    return elaborated;
                }
                var resultObj = errorOutputContainer || {};
                checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, /*message*/ undefined, containingMessageChain, resultObj);
                if (resultObj.errors) {
                    if (target.symbol && ts.length(target.symbol.declarations)) {
                        ts.addRelatedInfo(resultObj.errors[resultObj.errors.length - 1], ts.createDiagnosticForNode(target.symbol.declarations[0], ts.Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature));
                    }
                    if ((ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */) === 0
                        // exclude cases where source itself is promisy - this way we don't make a suggestion when relating
                        // an IPromise and a Promise that are slightly different
                        && !getTypeOfPropertyOfType(sourceReturn, "then")
                        && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, /*errorNode*/ undefined)) {
                        ts.addRelatedInfo(resultObj.errors[resultObj.errors.length - 1], ts.createDiagnosticForNode(node, ts.Diagnostics.Did_you_mean_to_mark_this_function_as_async));
                    }
                    return true;
                }
            }
            return false;
        }
        function getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType) {
            var idx = getIndexedAccessTypeOrUndefined(target, nameType);
            if (idx) {
                return idx;
            }
            if (target.flags & 1048576 /* TypeFlags.Union */) {
                var best = getBestMatchingType(source, target);
                if (best) {
                    return getIndexedAccessTypeOrUndefined(best, nameType);
                }
            }
        }
        function checkExpressionForMutableLocationWithContextualType(next, sourcePropType) {
            next.contextualType = sourcePropType;
            try {
                return checkExpressionForMutableLocation(next, 1 /* CheckMode.Contextual */, sourcePropType);
            }
            finally {
                next.contextualType = undefined;
            }
        }
        /**
         * For every element returned from the iterator, checks that element to issue an error on a property of that element's type
         * If that element would issue an error, we first attempt to dive into that element's inner expression and issue a more specific error by recuring into `elaborateError`
         * Otherwise, we issue an error on _every_ element which fail the assignability check
         */
        function elaborateElementwise(iterator, source, target, relation, containingMessageChain, errorOutputContainer) {
            // Assignability failure - check each prop individually, and if that fails, fall back on the bad error span
            var reportedError = false;
            for (var status = iterator.next(); !status.done; status = iterator.next()) {
                var _a = status.value, prop = _a.errorNode, next = _a.innerExpression, nameType = _a.nameType, errorMessage = _a.errorMessage;
                var targetPropType = getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType);
                if (!targetPropType || targetPropType.flags & 8388608 /* TypeFlags.IndexedAccess */)
                    continue; // Don't elaborate on indexes on generic variables
                var sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);
                if (!sourcePropType)
                    continue;
                var propName = getPropertyNameFromIndex(nameType, /*accessNode*/ undefined);
                if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, /*errorNode*/ undefined)) {
                    var elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, /*headMessage*/ undefined, containingMessageChain, errorOutputContainer);
                    reportedError = true;
                    if (!elaborated) {
                        // Issue error on the prop itself, since the prop couldn't elaborate the error
                        var resultObj = errorOutputContainer || {};
                        // Use the expression type, if available
                        var specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;
                        if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {
                            var diag = ts.createDiagnosticForNode(prop, ts.Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));
                            diagnostics.add(diag);
                            resultObj.errors = [diag];
                        }
                        else {
                            var targetIsOptional = !!(propName && (getPropertyOfType(target, propName) || unknownSymbol).flags & 16777216 /* SymbolFlags.Optional */);
                            var sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & 16777216 /* SymbolFlags.Optional */);
                            targetPropType = removeMissingType(targetPropType, targetIsOptional);
                            sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);
                            var result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                            if (result && specificSource !== sourcePropType) {
                                // If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType
                                checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                            }
                        }
                        if (resultObj.errors) {
                            var reportedDiag = resultObj.errors[resultObj.errors.length - 1];
                            var propertyName = isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
                            var targetProp = propertyName !== undefined ? getPropertyOfType(target, propertyName) : undefined;
                            var issuedElaboration = false;
                            if (!targetProp) {
                                var indexInfo = getApplicableIndexInfo(target, nameType);
                                if (indexInfo && indexInfo.declaration && !ts.getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib) {
                                    issuedElaboration = true;
                                    ts.addRelatedInfo(reportedDiag, ts.createDiagnosticForNode(indexInfo.declaration, ts.Diagnostics.The_expected_type_comes_from_this_index_signature));
                                }
                            }
                            if (!issuedElaboration && (targetProp && ts.length(targetProp.declarations) || target.symbol && ts.length(target.symbol.declarations))) {
                                var targetNode = targetProp && ts.length(targetProp.declarations) ? targetProp.declarations[0] : target.symbol.declarations[0];
                                if (!ts.getSourceFileOfNode(targetNode).hasNoDefaultLib) {
                                    ts.addRelatedInfo(reportedDiag, ts.createDiagnosticForNode(targetNode, ts.Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1, propertyName && !(nameType.flags & 8192 /* TypeFlags.UniqueESSymbol */) ? ts.unescapeLeadingUnderscores(propertyName) : typeToString(nameType), typeToString(target)));
                                }
                            }
                        }
                    }
                }
            }
            return reportedError;
        }
        function generateJsxAttributes(node) {
            var _i, _a, prop;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!ts.length(node.properties))
                            return [2 /*return*/];
                        _i = 0, _a = node.properties;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        prop = _a[_i];
                        if (ts.isJsxSpreadAttribute(prop) || isHyphenatedJsxName(ts.idText(prop.name)))
                            return [3 /*break*/, 3];
                        return [4 /*yield*/, { errorNode: prop.name, innerExpression: prop.initializer, nameType: getStringLiteralType(ts.idText(prop.name)) }];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        }
        function generateJsxChildren(node, getInvalidTextDiagnostic) {
            var memberOffset, i, child, nameType, elem;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!ts.length(node.children))
                            return [2 /*return*/];
                        memberOffset = 0;
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < node.children.length)) return [3 /*break*/, 5];
                        child = node.children[i];
                        nameType = getNumberLiteralType(i - memberOffset);
                        elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);
                        if (!elem) return [3 /*break*/, 3];
                        return [4 /*yield*/, elem];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        memberOffset++;
                        _a.label = 4;
                    case 4:
                        i++;
                        return [3 /*break*/, 1];
                    case 5: return [2 /*return*/];
                }
            });
        }
        function getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic) {
            switch (child.kind) {
                case 288 /* SyntaxKind.JsxExpression */:
                    // child is of the type of the expression
                    return { errorNode: child, innerExpression: child.expression, nameType: nameType };
                case 11 /* SyntaxKind.JsxText */:
                    if (child.containsOnlyTriviaWhiteSpaces) {
                        break; // Whitespace only jsx text isn't real jsx text
                    }
                    // child is a string
                    return { errorNode: child, innerExpression: undefined, nameType: nameType, errorMessage: getInvalidTextDiagnostic() };
                case 278 /* SyntaxKind.JsxElement */:
                case 279 /* SyntaxKind.JsxSelfClosingElement */:
                case 282 /* SyntaxKind.JsxFragment */:
                    // child is of type JSX.Element
                    return { errorNode: child, innerExpression: child, nameType: nameType };
                default:
                    return ts.Debug.assertNever(child, "Found invalid jsx child");
            }
        }
        function elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer) {
            var result = elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer);
            var invalidTextDiagnostic;
            if (ts.isJsxOpeningElement(node.parent) && ts.isJsxElement(node.parent.parent)) {
                var containingElement = node.parent.parent;
                var childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
                var childrenPropName = childPropName === undefined ? "children" : ts.unescapeLeadingUnderscores(childPropName);
                var childrenNameType = getStringLiteralType(childrenPropName);
                var childrenTargetType = getIndexedAccessType(target, childrenNameType);
                var validChildren = ts.getSemanticJsxChildren(containingElement.children);
                if (!ts.length(validChildren)) {
                    return result;
                }
                var moreThanOneRealChildren = ts.length(validChildren) > 1;
                var arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType);
                var nonArrayLikeTargetParts = filterType(childrenTargetType, function (t) { return !isArrayOrTupleLikeType(t); });
                if (moreThanOneRealChildren) {
                    if (arrayLikeTargetParts !== neverType) {
                        var realSource = createTupleType(checkJsxChildren(containingElement, 0 /* CheckMode.Normal */));
                        var children = generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic);
                        result = elaborateElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result;
                    }
                    else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
                        // arity mismatch
                        result = true;
                        var diag = error(containingElement.openingElement.tagName, ts.Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided, childrenPropName, typeToString(childrenTargetType));
                        if (errorOutputContainer && errorOutputContainer.skipLogging) {
                            (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                        }
                    }
                }
                else {
                    if (nonArrayLikeTargetParts !== neverType) {
                        var child = validChildren[0];
                        var elem_1 = getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic);
                        if (elem_1) {
                            result = elaborateElementwise((function () { return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, elem_1];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            }); })(), source, target, relation, containingMessageChain, errorOutputContainer) || result;
                        }
                    }
                    else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
                        // arity mismatch
                        result = true;
                        var diag = error(containingElement.openingElement.tagName, ts.Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided, childrenPropName, typeToString(childrenTargetType));
                        if (errorOutputContainer && errorOutputContainer.skipLogging) {
                            (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                        }
                    }
                }
            }
            return result;
            function getInvalidTextualChildDiagnostic() {
                if (!invalidTextDiagnostic) {
                    var tagNameText = ts.getTextOfNode(node.parent.tagName);
                    var childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
                    var childrenPropName = childPropName === undefined ? "children" : ts.unescapeLeadingUnderscores(childPropName);
                    var childrenTargetType = getIndexedAccessType(target, getStringLiteralType(childrenPropName));
                    var diagnostic = ts.Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2;
                    invalidTextDiagnostic = __assign(__assign({}, diagnostic), { key: "!!ALREADY FORMATTED!!", message: ts.formatMessage(/*_dummy*/ undefined, diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)) });
                }
                return invalidTextDiagnostic;
            }
        }
        function generateLimitedTupleElements(node, target) {
            var len, i, elem, nameType;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        len = ts.length(node.elements);
                        if (!len)
                            return [2 /*return*/];
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < len)) return [3 /*break*/, 4];
                        // Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature
                        if (isTupleLikeType(target) && !getPropertyOfType(target, ("" + i)))
                            return [3 /*break*/, 3];
                        elem = node.elements[i];
                        if (ts.isOmittedExpression(elem))
                            return [3 /*break*/, 3];
                        nameType = getNumberLiteralType(i);
                        return [4 /*yield*/, { errorNode: elem, innerExpression: elem, nameType: nameType }];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        }
        function elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer) {
            if (target.flags & 131068 /* TypeFlags.Primitive */)
                return false;
            if (isTupleLikeType(source)) {
                return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer);
            }
            // recreate a tuple from the elements, if possible
            // Since we're re-doing the expression type, we need to reapply the contextual type
            var oldContext = node.contextualType;
            node.contextualType = target;
            try {
                var tupleizedType = checkArrayLiteral(node, 1 /* CheckMode.Contextual */, /*forceTuple*/ true);
                node.contextualType = oldContext;
                if (isTupleLikeType(tupleizedType)) {
                    return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer);
                }
                return false;
            }
            finally {
                node.contextualType = oldContext;
            }
        }
        function generateObjectLiteralElements(node) {
            var _i, _a, prop, type, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!ts.length(node.properties))
                            return [2 /*return*/];
                        _i = 0, _a = node.properties;
                        _c.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 8];
                        prop = _a[_i];
                        if (ts.isSpreadAssignment(prop))
                            return [3 /*break*/, 7];
                        type = getLiteralTypeFromProperty(getSymbolOfNode(prop), 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */);
                        if (!type || (type.flags & 131072 /* TypeFlags.Never */)) {
                            return [3 /*break*/, 7];
                        }
                        _b = prop.kind;
                        switch (_b) {
                            case 173 /* SyntaxKind.SetAccessor */: return [3 /*break*/, 2];
                            case 172 /* SyntaxKind.GetAccessor */: return [3 /*break*/, 2];
                            case 169 /* SyntaxKind.MethodDeclaration */: return [3 /*break*/, 2];
                            case 297 /* SyntaxKind.ShorthandPropertyAssignment */: return [3 /*break*/, 2];
                            case 296 /* SyntaxKind.PropertyAssignment */: return [3 /*break*/, 4];
                        }
                        return [3 /*break*/, 6];
                    case 2: return [4 /*yield*/, { errorNode: prop.name, innerExpression: undefined, nameType: type }];
                    case 3:
                        _c.sent();
                        return [3 /*break*/, 7];
                    case 4: return [4 /*yield*/, { errorNode: prop.name, innerExpression: prop.initializer, nameType: type, errorMessage: ts.isComputedNonLiteralName(prop.name) ? ts.Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined }];
                    case 5:
                        _c.sent();
                        return [3 /*break*/, 7];
                    case 6:
                        ts.Debug.assertNever(prop);
                        _c.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 1];
                    case 8: return [2 /*return*/];
                }
            });
        }
        function elaborateObjectLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer) {
            if (target.flags & 131068 /* TypeFlags.Primitive */)
                return false;
            return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer);
        }
        /**
         * This is *not* a bi-directional relationship.
         * If one needs to check both directions for comparability, use a second call to this function or 'isTypeComparableTo'.
         */
        function checkTypeComparableTo(source, target, errorNode, headMessage, containingMessageChain) {
            return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain);
        }
        function isSignatureAssignableTo(source, target, ignoreReturnTypes) {
            return compareSignaturesRelated(source, target, ignoreReturnTypes ? 4 /* SignatureCheckMode.IgnoreReturnTypes */ : 0, /*reportErrors*/ false, 
            /*errorReporter*/ undefined, /*errorReporter*/ undefined, compareTypesAssignable, /*reportUnreliableMarkers*/ undefined) !== 0 /* Ternary.False */;
        }
        /**
         * Returns true if `s` is `(...args: any[]) => any` or `(this: any, ...args: any[]) => any`
         */
        function isAnySignature(s) {
            return !s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length === 1 &&
                signatureHasRestParameter(s) && (getTypeOfParameter(s.parameters[0]) === anyArrayType || isTypeAny(getTypeOfParameter(s.parameters[0]))) &&
                isTypeAny(getReturnTypeOfSignature(s));
        }
        /**
         * See signatureRelatedTo, compareSignaturesIdentical
         */
        function compareSignaturesRelated(source, target, checkMode, reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) {
            // TODO (drosen): De-duplicate code between related functions.
            if (source === target) {
                return -1 /* Ternary.True */;
            }
            if (isAnySignature(target)) {
                return -1 /* Ternary.True */;
            }
            var targetCount = getParameterCount(target);
            var sourceHasMoreParameters = !hasEffectiveRestParameter(target) &&
                (checkMode & 8 /* SignatureCheckMode.StrictArity */ ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount);
            if (sourceHasMoreParameters) {
                return 0 /* Ternary.False */;
            }
            if (source.typeParameters && source.typeParameters !== target.typeParameters) {
                target = getCanonicalSignature(target);
                source = instantiateSignatureInContextOf(source, target, /*inferenceContext*/ undefined, compareTypes);
            }
            var sourceCount = getParameterCount(source);
            var sourceRestType = getNonArrayRestType(source);
            var targetRestType = getNonArrayRestType(target);
            if (sourceRestType || targetRestType) {
                void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers);
            }
            var kind = target.declaration ? target.declaration.kind : 0 /* SyntaxKind.Unknown */;
            var strictVariance = !(checkMode & 3 /* SignatureCheckMode.Callback */) && strictFunctionTypes && kind !== 169 /* SyntaxKind.MethodDeclaration */ &&
                kind !== 168 /* SyntaxKind.MethodSignature */ && kind !== 171 /* SyntaxKind.Constructor */;
            var result = -1 /* Ternary.True */;
            var sourceThisType = getThisTypeOfSignature(source);
            if (sourceThisType && sourceThisType !== voidType) {
                var targetThisType = getThisTypeOfSignature(target);
                if (targetThisType) {
                    // void sources are assignable to anything.
                    var related = !strictVariance && compareTypes(sourceThisType, targetThisType, /*reportErrors*/ false)
                        || compareTypes(targetThisType, sourceThisType, reportErrors);
                    if (!related) {
                        if (reportErrors) {
                            errorReporter(ts.Diagnostics.The_this_types_of_each_signature_are_incompatible);
                        }
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
            }
            var paramCount = sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount);
            var restIndex = sourceRestType || targetRestType ? paramCount - 1 : -1;
            for (var i = 0; i < paramCount; i++) {
                var sourceType = i === restIndex ? getRestTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i);
                var targetType = i === restIndex ? getRestTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i);
                if (sourceType && targetType) {
                    // In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter
                    // how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,
                    // they naturally relate only contra-variantly). However, if the source and target parameters both have
                    // function types with a single call signature, we know we are relating two callback parameters. In
                    // that case it is sufficient to only relate the parameters of the signatures co-variantly because,
                    // similar to return values, callback parameters are output positions. This means that a Promise<T>,
                    // where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)
                    // with respect to T.
                    var sourceSig = checkMode & 3 /* SignatureCheckMode.Callback */ ? undefined : getSingleCallSignature(getNonNullableType(sourceType));
                    var targetSig = checkMode & 3 /* SignatureCheckMode.Callback */ ? undefined : getSingleCallSignature(getNonNullableType(targetType));
                    var callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) &&
                        (getFalsyFlags(sourceType) & 98304 /* TypeFlags.Nullable */) === (getFalsyFlags(targetType) & 98304 /* TypeFlags.Nullable */);
                    var related = callbacks ?
                        compareSignaturesRelated(targetSig, sourceSig, (checkMode & 8 /* SignatureCheckMode.StrictArity */) | (strictVariance ? 2 /* SignatureCheckMode.StrictCallback */ : 1 /* SignatureCheckMode.BivariantCallback */), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) :
                        !(checkMode & 3 /* SignatureCheckMode.Callback */) && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors*/ false) || compareTypes(targetType, sourceType, reportErrors);
                    // With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void
                    if (related && checkMode & 8 /* SignatureCheckMode.StrictArity */ && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, /*reportErrors*/ false)) {
                        related = 0 /* Ternary.False */;
                    }
                    if (!related) {
                        if (reportErrors) {
                            errorReporter(ts.Diagnostics.Types_of_parameters_0_and_1_are_incompatible, ts.unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), ts.unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)));
                        }
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
            }
            if (!(checkMode & 4 /* SignatureCheckMode.IgnoreReturnTypes */)) {
                // If a signature resolution is already in-flight, skip issuing a circularity error
                // here and just use the `any` type directly
                var targetReturnType = isResolvingReturnTypeOfSignature(target) ? anyType
                    : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))
                        : getReturnTypeOfSignature(target);
                if (targetReturnType === voidType || targetReturnType === anyType) {
                    return result;
                }
                var sourceReturnType = isResolvingReturnTypeOfSignature(source) ? anyType
                    : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))
                        : getReturnTypeOfSignature(source);
                // The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions
                var targetTypePredicate = getTypePredicateOfSignature(target);
                if (targetTypePredicate) {
                    var sourceTypePredicate = getTypePredicateOfSignature(source);
                    if (sourceTypePredicate) {
                        result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes);
                    }
                    else if (ts.isIdentifierTypePredicate(targetTypePredicate)) {
                        if (reportErrors) {
                            errorReporter(ts.Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source));
                        }
                        return 0 /* Ternary.False */;
                    }
                }
                else {
                    // When relating callback signatures, we still need to relate return types bi-variantly as otherwise
                    // the containing type wouldn't be co-variant. For example, interface Foo<T> { add(cb: () => T): void }
                    // wouldn't be co-variant for T without this rule.
                    result &= checkMode & 1 /* SignatureCheckMode.BivariantCallback */ && compareTypes(targetReturnType, sourceReturnType, /*reportErrors*/ false) ||
                        compareTypes(sourceReturnType, targetReturnType, reportErrors);
                    if (!result && reportErrors && incompatibleErrorReporter) {
                        incompatibleErrorReporter(sourceReturnType, targetReturnType);
                    }
                }
            }
            return result;
        }
        function compareTypePredicateRelatedTo(source, target, reportErrors, errorReporter, compareTypes) {
            if (source.kind !== target.kind) {
                if (reportErrors) {
                    errorReporter(ts.Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);
                    errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
                }
                return 0 /* Ternary.False */;
            }
            if (source.kind === 1 /* TypePredicateKind.Identifier */ || source.kind === 3 /* TypePredicateKind.AssertsIdentifier */) {
                if (source.parameterIndex !== target.parameterIndex) {
                    if (reportErrors) {
                        errorReporter(ts.Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, target.parameterName);
                        errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
                    }
                    return 0 /* Ternary.False */;
                }
            }
            var related = source.type === target.type ? -1 /* Ternary.True */ :
                source.type && target.type ? compareTypes(source.type, target.type, reportErrors) :
                    0 /* Ternary.False */;
            if (related === 0 /* Ternary.False */ && reportErrors) {
                errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
            }
            return related;
        }
        function isImplementationCompatibleWithOverload(implementation, overload) {
            var erasedSource = getErasedSignature(implementation);
            var erasedTarget = getErasedSignature(overload);
            // First see if the return types are compatible in either direction.
            var sourceReturnType = getReturnTypeOfSignature(erasedSource);
            var targetReturnType = getReturnTypeOfSignature(erasedTarget);
            if (targetReturnType === voidType
                || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation)
                || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation)) {
                return isSignatureAssignableTo(erasedSource, erasedTarget, /*ignoreReturnTypes*/ true);
            }
            return false;
        }
        function isEmptyResolvedType(t) {
            return t !== anyFunctionType &&
                t.properties.length === 0 &&
                t.callSignatures.length === 0 &&
                t.constructSignatures.length === 0 &&
                t.indexInfos.length === 0;
        }
        function isEmptyObjectType(type) {
            return type.flags & 524288 /* TypeFlags.Object */ ? !isGenericMappedType(type) && isEmptyResolvedType(resolveStructuredTypeMembers(type)) :
                type.flags & 67108864 /* TypeFlags.NonPrimitive */ ? true :
                    type.flags & 1048576 /* TypeFlags.Union */ ? ts.some(type.types, isEmptyObjectType) :
                        type.flags & 2097152 /* TypeFlags.Intersection */ ? ts.every(type.types, isEmptyObjectType) :
                            false;
        }
        function isEmptyAnonymousObjectType(type) {
            return !!(ts.getObjectFlags(type) & 16 /* ObjectFlags.Anonymous */ && (type.members && isEmptyResolvedType(type) ||
                type.symbol && type.symbol.flags & 2048 /* SymbolFlags.TypeLiteral */ && getMembersOfSymbol(type.symbol).size === 0));
        }
        function isStringIndexSignatureOnlyType(type) {
            return type.flags & 524288 /* TypeFlags.Object */ && !isGenericMappedType(type) && getPropertiesOfType(type).length === 0 && getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(type, stringType) ||
                type.flags & 3145728 /* TypeFlags.UnionOrIntersection */ && ts.every(type.types, isStringIndexSignatureOnlyType) ||
                false;
        }
        function isEnumTypeRelatedTo(sourceSymbol, targetSymbol, errorReporter) {
            if (sourceSymbol === targetSymbol) {
                return true;
            }
            var id = getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol);
            var entry = enumRelation.get(id);
            if (entry !== undefined && !(!(entry & 4 /* RelationComparisonResult.Reported */) && entry & 2 /* RelationComparisonResult.Failed */ && errorReporter)) {
                return !!(entry & 1 /* RelationComparisonResult.Succeeded */);
            }
            if (sourceSymbol.escapedName !== targetSymbol.escapedName || !(sourceSymbol.flags & 256 /* SymbolFlags.RegularEnum */) || !(targetSymbol.flags & 256 /* SymbolFlags.RegularEnum */)) {
                enumRelation.set(id, 2 /* RelationComparisonResult.Failed */ | 4 /* RelationComparisonResult.Reported */);
                return false;
            }
            var targetEnumType = getTypeOfSymbol(targetSymbol);
            for (var _i = 0, _a = getPropertiesOfType(getTypeOfSymbol(sourceSymbol)); _i < _a.length; _i++) {
                var property = _a[_i];
                if (property.flags & 8 /* SymbolFlags.EnumMember */) {
                    var targetProperty = getPropertyOfType(targetEnumType, property.escapedName);
                    if (!targetProperty || !(targetProperty.flags & 8 /* SymbolFlags.EnumMember */)) {
                        if (errorReporter) {
                            errorReporter(ts.Diagnostics.Property_0_is_missing_in_type_1, ts.symbolName(property), typeToString(getDeclaredTypeOfSymbol(targetSymbol), /*enclosingDeclaration*/ undefined, 64 /* TypeFormatFlags.UseFullyQualifiedType */));
                            enumRelation.set(id, 2 /* RelationComparisonResult.Failed */ | 4 /* RelationComparisonResult.Reported */);
                        }
                        else {
                            enumRelation.set(id, 2 /* RelationComparisonResult.Failed */);
                        }
                        return false;
                    }
                }
            }
            enumRelation.set(id, 1 /* RelationComparisonResult.Succeeded */);
            return true;
        }
        function isSimpleTypeRelatedTo(source, target, relation, errorReporter) {
            var s = source.flags;
            var t = target.flags;
            if (t & 3 /* TypeFlags.AnyOrUnknown */ || s & 131072 /* TypeFlags.Never */ || source === wildcardType)
                return true;
            if (t & 131072 /* TypeFlags.Never */)
                return false;
            if (s & 402653316 /* TypeFlags.StringLike */ && t & 4 /* TypeFlags.String */)
                return true;
            if (s & 128 /* TypeFlags.StringLiteral */ && s & 1024 /* TypeFlags.EnumLiteral */ &&
                t & 128 /* TypeFlags.StringLiteral */ && !(t & 1024 /* TypeFlags.EnumLiteral */) &&
                source.value === target.value)
                return true;
            if (s & 296 /* TypeFlags.NumberLike */ && t & 8 /* TypeFlags.Number */)
                return true;
            if (s & 256 /* TypeFlags.NumberLiteral */ && s & 1024 /* TypeFlags.EnumLiteral */ &&
                t & 256 /* TypeFlags.NumberLiteral */ && !(t & 1024 /* TypeFlags.EnumLiteral */) &&
                source.value === target.value)
                return true;
            if (s & 2112 /* TypeFlags.BigIntLike */ && t & 64 /* TypeFlags.BigInt */)
                return true;
            if (s & 528 /* TypeFlags.BooleanLike */ && t & 16 /* TypeFlags.Boolean */)
                return true;
            if (s & 12288 /* TypeFlags.ESSymbolLike */ && t & 4096 /* TypeFlags.ESSymbol */)
                return true;
            if (s & 32 /* TypeFlags.Enum */ && t & 32 /* TypeFlags.Enum */ && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter))
                return true;
            if (s & 1024 /* TypeFlags.EnumLiteral */ && t & 1024 /* TypeFlags.EnumLiteral */) {
                if (s & 1048576 /* TypeFlags.Union */ && t & 1048576 /* TypeFlags.Union */ && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter))
                    return true;
                if (s & 2944 /* TypeFlags.Literal */ && t & 2944 /* TypeFlags.Literal */ &&
                    source.value === target.value &&
                    isEnumTypeRelatedTo(getParentOfSymbol(source.symbol), getParentOfSymbol(target.symbol), errorReporter))
                    return true;
            }
            // In non-strictNullChecks mode, `undefined` and `null` are assignable to anything except `never`.
            // Since unions and intersections may reduce to `never`, we exclude them here.
            if (s & 32768 /* TypeFlags.Undefined */ && (!strictNullChecks && !(t & 3145728 /* TypeFlags.UnionOrIntersection */) || t & (32768 /* TypeFlags.Undefined */ | 16384 /* TypeFlags.Void */)))
                return true;
            if (s & 65536 /* TypeFlags.Null */ && (!strictNullChecks && !(t & 3145728 /* TypeFlags.UnionOrIntersection */) || t & 65536 /* TypeFlags.Null */))
                return true;
            if (s & 524288 /* TypeFlags.Object */ && t & 67108864 /* TypeFlags.NonPrimitive */)
                return true;
            if (relation === assignableRelation || relation === comparableRelation) {
                if (s & 1 /* TypeFlags.Any */)
                    return true;
                // Type number or any numeric literal type is assignable to any numeric enum type or any
                // numeric enum literal type. This rule exists for backwards compatibility reasons because
                // bit-flag enum types sometimes look like literal enum types with numeric literal values.
                if (s & (8 /* TypeFlags.Number */ | 256 /* TypeFlags.NumberLiteral */) && !(s & 1024 /* TypeFlags.EnumLiteral */) && (t & 32 /* TypeFlags.Enum */ || relation === assignableRelation && t & 256 /* TypeFlags.NumberLiteral */ && t & 1024 /* TypeFlags.EnumLiteral */))
                    return true;
            }
            return false;
        }
        function isTypeRelatedTo(source, target, relation) {
            if (isFreshLiteralType(source)) {
                source = source.regularType;
            }
            if (isFreshLiteralType(target)) {
                target = target.regularType;
            }
            if (source === target) {
                return true;
            }
            if (relation !== identityRelation) {
                if (relation === comparableRelation && !(target.flags & 131072 /* TypeFlags.Never */) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation)) {
                    return true;
                }
            }
            else if (!((source.flags | target.flags) & (3145728 /* TypeFlags.UnionOrIntersection */ | 8388608 /* TypeFlags.IndexedAccess */ | 16777216 /* TypeFlags.Conditional */ | 33554432 /* TypeFlags.Substitution */))) {
                // We have excluded types that may simplify to other forms, so types must have identical flags
                if (source.flags !== target.flags)
                    return false;
                if (source.flags & 67358815 /* TypeFlags.Singleton */)
                    return true;
            }
            if (source.flags & 524288 /* TypeFlags.Object */ && target.flags & 524288 /* TypeFlags.Object */) {
                var related = relation.get(getRelationKey(source, target, 0 /* IntersectionState.None */, relation, /*ignoreConstraints*/ false));
                if (related !== undefined) {
                    return !!(related & 1 /* RelationComparisonResult.Succeeded */);
                }
            }
            if (source.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */ || target.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */) {
                return checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined);
            }
            return false;
        }
        function isIgnoredJsxProperty(source, sourceProp) {
            return ts.getObjectFlags(source) & 2048 /* ObjectFlags.JsxAttributes */ && isHyphenatedJsxName(sourceProp.escapedName);
        }
        function getNormalizedType(type, writing) {
            while (true) {
                var t = isFreshLiteralType(type) ? type.regularType :
                    ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */ && type.node ? createTypeReference(type.target, getTypeArguments(type)) :
                        type.flags & 3145728 /* TypeFlags.UnionOrIntersection */ ? getReducedType(type) :
                            type.flags & 33554432 /* TypeFlags.Substitution */ ? writing ? type.baseType : type.substitute :
                                type.flags & 25165824 /* TypeFlags.Simplifiable */ ? getSimplifiedType(type, writing) :
                                    type;
                t = getSingleBaseForNonAugmentingSubtype(t) || t;
                if (t === type)
                    break;
                type = t;
            }
            return type;
        }
        /**
         * Checks if 'source' is related to 'target' (e.g.: is a assignable to).
         * @param source The left-hand-side of the relation.
         * @param target The right-hand-side of the relation.
         * @param relation The relation considered. One of 'identityRelation', 'subtypeRelation', 'assignableRelation', or 'comparableRelation'.
         * Used as both to determine which checks are performed and as a cache of previously computed results.
         * @param errorNode The suggested node upon which all errors will be reported, if defined. This may or may not be the actual node used.
         * @param headMessage If the error chain should be prepended by a head message, then headMessage will be used.
         * @param containingMessageChain A chain of errors to prepend any new errors found.
         * @param errorOutputContainer Return the diagnostic. Do not log if 'skipLogging' is truthy.
         */
        function checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) {
            var errorInfo;
            var relatedInfo;
            var maybeKeys;
            var sourceStack;
            var targetStack;
            var maybeCount = 0;
            var sourceDepth = 0;
            var targetDepth = 0;
            var expandingFlags = 0 /* ExpandingFlags.None */;
            var overflow = false;
            var overrideNextErrorInfo = 0; // How many `reportRelationError` calls should be skipped in the elaboration pyramid
            var lastSkippedInfo;
            var incompatibleStack;
            var inPropertyCheck = false;
            ts.Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");
            var result = isRelatedTo(source, target, 3 /* RecursionFlags.Both */, /*reportErrors*/ !!errorNode, headMessage);
            if (incompatibleStack) {
                reportIncompatibleStack();
            }
            if (overflow) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "checkTypeRelatedTo_DepthLimit", { sourceId: source.id, targetId: target.id, depth: sourceDepth, targetDepth: targetDepth });
                var diag = error(errorNode || currentNode, ts.Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));
                if (errorOutputContainer) {
                    (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                }
            }
            else if (errorInfo) {
                if (containingMessageChain) {
                    var chain = containingMessageChain();
                    if (chain) {
                        ts.concatenateDiagnosticMessageChains(chain, errorInfo);
                        errorInfo = chain;
                    }
                }
                var relatedInformation = void 0;
                // Check if we should issue an extra diagnostic to produce a quickfix for a slightly incorrect import statement
                if (headMessage && errorNode && !result && source.symbol) {
                    var links = getSymbolLinks(source.symbol);
                    if (links.originatingImport && !ts.isImportCall(links.originatingImport)) {
                        var helpfulRetry = checkTypeRelatedTo(getTypeOfSymbol(links.target), target, relation, /*errorNode*/ undefined);
                        if (helpfulRetry) {
                            // Likely an incorrect import. Issue a helpful diagnostic to produce a quickfix to change the import
                            var diag_1 = ts.createDiagnosticForNode(links.originatingImport, ts.Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead);
                            relatedInformation = ts.append(relatedInformation, diag_1); // Cause the error to appear with the error that triggered it
                        }
                    }
                }
                var diag = ts.createDiagnosticForNodeFromMessageChain(errorNode, errorInfo, relatedInformation);
                if (relatedInfo) {
                    ts.addRelatedInfo.apply(void 0, __spreadArray([diag], relatedInfo, false));
                }
                if (errorOutputContainer) {
                    (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                }
                if (!errorOutputContainer || !errorOutputContainer.skipLogging) {
                    diagnostics.add(diag);
                }
            }
            if (errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result === 0 /* Ternary.False */) {
                ts.Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error.");
            }
            return result !== 0 /* Ternary.False */;
            function resetErrorInfo(saved) {
                errorInfo = saved.errorInfo;
                lastSkippedInfo = saved.lastSkippedInfo;
                incompatibleStack = saved.incompatibleStack;
                overrideNextErrorInfo = saved.overrideNextErrorInfo;
                relatedInfo = saved.relatedInfo;
            }
            function captureErrorCalculationState() {
                return {
                    errorInfo: errorInfo,
                    lastSkippedInfo: lastSkippedInfo,
                    incompatibleStack: incompatibleStack === null || incompatibleStack === void 0 ? void 0 : incompatibleStack.slice(),
                    overrideNextErrorInfo: overrideNextErrorInfo,
                    relatedInfo: relatedInfo === null || relatedInfo === void 0 ? void 0 : relatedInfo.slice(),
                };
            }
            function reportIncompatibleError(message, arg0, arg1, arg2, arg3) {
                overrideNextErrorInfo++; // Suppress the next relation error
                lastSkippedInfo = undefined; // Reset skipped info cache
                (incompatibleStack || (incompatibleStack = [])).push([message, arg0, arg1, arg2, arg3]);
            }
            function reportIncompatibleStack() {
                var stack = incompatibleStack || [];
                incompatibleStack = undefined;
                var info = lastSkippedInfo;
                lastSkippedInfo = undefined;
                if (stack.length === 1) {
                    reportError.apply(void 0, stack[0]);
                    if (info) {
                        // Actually do the last relation error
                        reportRelationError.apply(void 0, __spreadArray([/*headMessage*/ undefined], info, false));
                    }
                    return;
                }
                // The first error will be the innermost, while the last will be the outermost - so by popping off the end,
                // we can build from left to right
                var path = "";
                var secondaryRootErrors = [];
                while (stack.length) {
                    var _a = stack.pop(), msg = _a[0], args = _a.slice(1);
                    switch (msg.code) {
                        case ts.Diagnostics.Types_of_property_0_are_incompatible.code: {
                            // Parenthesize a `new` if there is one
                            if (path.indexOf("new ") === 0) {
                                path = "(".concat(path, ")");
                            }
                            var str = "" + args[0];
                            // If leading, just print back the arg (irrespective of if it's a valid identifier)
                            if (path.length === 0) {
                                path = "".concat(str);
                            }
                            // Otherwise write a dotted name if possible
                            else if (ts.isIdentifierText(str, ts.getEmitScriptTarget(compilerOptions))) {
                                path = "".concat(path, ".").concat(str);
                            }
                            // Failing that, check if the name is already a computed name
                            else if (str[0] === "[" && str[str.length - 1] === "]") {
                                path = "".concat(path).concat(str);
                            }
                            // And finally write out a computed name as a last resort
                            else {
                                path = "".concat(path, "[").concat(str, "]");
                            }
                            break;
                        }
                        case ts.Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:
                        case ts.Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:
                        case ts.Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
                        case ts.Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code: {
                            if (path.length === 0) {
                                // Don't flatten signature compatability errors at the start of a chain - instead prefer
                                // to unify (the with no arguments bit is excessive for printback) and print them back
                                var mappedMsg = msg;
                                if (msg.code === ts.Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {
                                    mappedMsg = ts.Diagnostics.Call_signature_return_types_0_and_1_are_incompatible;
                                }
                                else if (msg.code === ts.Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {
                                    mappedMsg = ts.Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible;
                                }
                                secondaryRootErrors.unshift([mappedMsg, args[0], args[1]]);
                            }
                            else {
                                var prefix = (msg.code === ts.Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code ||
                                    msg.code === ts.Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)
                                    ? "new "
                                    : "";
                                var params = (msg.code === ts.Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code ||
                                    msg.code === ts.Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)
                                    ? ""
                                    : "...";
                                path = "".concat(prefix).concat(path, "(").concat(params, ")");
                            }
                            break;
                        }
                        case ts.Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code: {
                            secondaryRootErrors.unshift([ts.Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]]);
                            break;
                        }
                        case ts.Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code: {
                            secondaryRootErrors.unshift([ts.Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]]);
                            break;
                        }
                        default:
                            return ts.Debug.fail("Unhandled Diagnostic: ".concat(msg.code));
                    }
                }
                if (path) {
                    reportError(path[path.length - 1] === ")"
                        ? ts.Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types
                        : ts.Diagnostics.The_types_of_0_are_incompatible_between_these_types, path);
                }
                else {
                    // Remove the innermost secondary error as it will duplicate the error already reported by `reportRelationError` on entry
                    secondaryRootErrors.shift();
                }
                for (var _i = 0, secondaryRootErrors_1 = secondaryRootErrors; _i < secondaryRootErrors_1.length; _i++) {
                    var _b = secondaryRootErrors_1[_i], msg = _b[0], args = _b.slice(1);
                    var originalValue = msg.elidedInCompatabilityPyramid;
                    msg.elidedInCompatabilityPyramid = false; // Temporarily override elision to ensure error is reported
                    reportError.apply(void 0, __spreadArray([msg], args, false));
                    msg.elidedInCompatabilityPyramid = originalValue;
                }
                if (info) {
                    // Actually do the last relation error
                    reportRelationError.apply(void 0, __spreadArray([/*headMessage*/ undefined], info, false));
                }
            }
            function reportError(message, arg0, arg1, arg2, arg3) {
                ts.Debug.assert(!!errorNode);
                if (incompatibleStack)
                    reportIncompatibleStack();
                if (message.elidedInCompatabilityPyramid)
                    return;
                errorInfo = ts.chainDiagnosticMessages(errorInfo, message, arg0, arg1, arg2, arg3);
            }
            function associateRelatedInfo(info) {
                ts.Debug.assert(!!errorInfo);
                if (!relatedInfo) {
                    relatedInfo = [info];
                }
                else {
                    relatedInfo.push(info);
                }
            }
            function reportRelationError(message, source, target) {
                if (incompatibleStack)
                    reportIncompatibleStack();
                var _a = getTypeNamesForErrorDisplay(source, target), sourceType = _a[0], targetType = _a[1];
                var generalizedSource = source;
                var generalizedSourceType = sourceType;
                if (isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target)) {
                    generalizedSource = getBaseTypeOfLiteralType(source);
                    ts.Debug.assert(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable");
                    generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource);
                }
                if (target.flags & 262144 /* TypeFlags.TypeParameter */ && target !== markerSuperType && target !== markerSubType) {
                    var constraint = getBaseConstraintOfType(target);
                    var needsOriginalSource = void 0;
                    if (constraint && (isTypeAssignableTo(generalizedSource, constraint) || (needsOriginalSource = isTypeAssignableTo(source, constraint)))) {
                        reportError(ts.Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2, needsOriginalSource ? sourceType : generalizedSourceType, targetType, typeToString(constraint));
                    }
                    else {
                        errorInfo = undefined;
                        reportError(ts.Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1, targetType, generalizedSourceType);
                    }
                }
                if (!message) {
                    if (relation === comparableRelation) {
                        message = ts.Diagnostics.Type_0_is_not_comparable_to_type_1;
                    }
                    else if (sourceType === targetType) {
                        message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated;
                    }
                    else if (exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length) {
                        message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
                    }
                    else {
                        if (source.flags & 128 /* TypeFlags.StringLiteral */ && target.flags & 1048576 /* TypeFlags.Union */) {
                            var suggestedType = getSuggestedTypeForNonexistentStringLiteralType(source, target);
                            if (suggestedType) {
                                reportError(ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, typeToString(suggestedType));
                                return;
                            }
                        }
                        message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1;
                    }
                }
                else if (message === ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1
                    && exactOptionalPropertyTypes
                    && getExactOptionalUnassignableProperties(source, target).length) {
                    message = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
                }
                reportError(message, generalizedSourceType, targetType);
            }
            function tryElaborateErrorsForPrimitivesAndObjects(source, target) {
                var sourceType = symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source);
                var targetType = symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target);
                if ((globalStringType === source && stringType === target) ||
                    (globalNumberType === source && numberType === target) ||
                    (globalBooleanType === source && booleanType === target) ||
                    (getGlobalESSymbolType() === source && esSymbolType === target)) {
                    reportError(ts.Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType);
                }
            }
            /**
             * Try and elaborate array and tuple errors. Returns false
             * if we have found an elaboration, or we should ignore
             * any other elaborations when relating the `source` and
             * `target` types.
             */
            function tryElaborateArrayLikeErrors(source, target, reportErrors) {
                /**
                 * The spec for elaboration is:
                 * - If the source is a readonly tuple and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
                 * - If the source is a tuple then skip property elaborations if the target is an array or tuple.
                 * - If the source is a readonly array and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
                 * - If the source an array then skip property elaborations if the target is a tuple.
                 */
                if (isTupleType(source)) {
                    if (source.target.readonly && isMutableArrayOrTuple(target)) {
                        if (reportErrors) {
                            reportError(ts.Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
                        }
                        return false;
                    }
                    return isArrayOrTupleType(target);
                }
                if (isReadonlyArrayType(source) && isMutableArrayOrTuple(target)) {
                    if (reportErrors) {
                        reportError(ts.Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
                    }
                    return false;
                }
                if (isTupleType(target)) {
                    return isArrayType(source);
                }
                return true;
            }
            function isRelatedToWorker(source, target, reportErrors) {
                return isRelatedTo(source, target, 3 /* RecursionFlags.Both */, reportErrors);
            }
            /**
             * Compare two types and return
             * * Ternary.True if they are related with no assumptions,
             * * Ternary.Maybe if they are related with assumptions of other relationships, or
             * * Ternary.False if they are not related.
             */
            function isRelatedTo(originalSource, originalTarget, recursionFlags, reportErrors, headMessage, intersectionState) {
                if (recursionFlags === void 0) { recursionFlags = 3 /* RecursionFlags.Both */; }
                if (reportErrors === void 0) { reportErrors = false; }
                if (intersectionState === void 0) { intersectionState = 0 /* IntersectionState.None */; }
                // Before normalization: if `source` is type an object type, and `target` is primitive,
                // skip all the checks we don't need and just return `isSimpleTypeRelatedTo` result
                if (originalSource.flags & 524288 /* TypeFlags.Object */ && originalTarget.flags & 131068 /* TypeFlags.Primitive */) {
                    if (isSimpleTypeRelatedTo(originalSource, originalTarget, relation, reportErrors ? reportError : undefined)) {
                        return -1 /* Ternary.True */;
                    }
                    if (reportErrors) {
                        reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage);
                    }
                    return 0 /* Ternary.False */;
                }
                // Normalize the source and target types: Turn fresh literal types into regular literal types,
                // turn deferred type references into regular type references, simplify indexed access and
                // conditional types, and resolve substitution types to either the substitution (on the source
                // side) or the type variable (on the target side).
                var source = getNormalizedType(originalSource, /*writing*/ false);
                var target = getNormalizedType(originalTarget, /*writing*/ true);
                if (source === target)
                    return -1 /* Ternary.True */;
                if (relation === identityRelation) {
                    if (source.flags !== target.flags)
                        return 0 /* Ternary.False */;
                    if (source.flags & 67358815 /* TypeFlags.Singleton */)
                        return -1 /* Ternary.True */;
                    traceUnionsOrIntersectionsTooLarge(source, target);
                    return recursiveTypeRelatedTo(source, target, /*reportErrors*/ false, 0 /* IntersectionState.None */, recursionFlags);
                }
                // We fastpath comparing a type parameter to exactly its constraint, as this is _super_ common,
                // and otherwise, for type parameters in large unions, causes us to need to compare the union to itself,
                // as we break down the _target_ union first, _then_ get the source constraint - so for every
                // member of the target, we attempt to find a match in the source. This avoids that in cases where
                // the target is exactly the constraint.
                if (source.flags & 262144 /* TypeFlags.TypeParameter */ && getConstraintOfType(source) === target) {
                    return -1 /* Ternary.True */;
                }
                // See if we're relating a definitely non-nullable type to a union that includes null and/or undefined
                // plus a single non-nullable type. If so, remove null and/or undefined from the target type.
                if (source.flags & 470302716 /* TypeFlags.DefinitelyNonNullable */ && target.flags & 1048576 /* TypeFlags.Union */) {
                    var types = target.types;
                    var candidate = types.length === 2 && types[0].flags & 98304 /* TypeFlags.Nullable */ ? types[1] :
                        types.length === 3 && types[0].flags & 98304 /* TypeFlags.Nullable */ && types[1].flags & 98304 /* TypeFlags.Nullable */ ? types[2] :
                            undefined;
                    if (candidate && !(candidate.flags & 98304 /* TypeFlags.Nullable */)) {
                        target = getNormalizedType(candidate, /*writing*/ true);
                        if (source === target)
                            return -1 /* Ternary.True */;
                    }
                }
                if (relation === comparableRelation && !(target.flags & 131072 /* TypeFlags.Never */) && isSimpleTypeRelatedTo(target, source, relation) ||
                    isSimpleTypeRelatedTo(source, target, relation, reportErrors ? reportError : undefined))
                    return -1 /* Ternary.True */;
                if (source.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */ || target.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */) {
                    var isPerformingExcessPropertyChecks = !(intersectionState & 2 /* IntersectionState.Target */) && (isObjectLiteralType(source) && ts.getObjectFlags(source) & 8192 /* ObjectFlags.FreshLiteral */);
                    if (isPerformingExcessPropertyChecks) {
                        if (hasExcessProperties(source, target, reportErrors)) {
                            if (reportErrors) {
                                reportRelationError(headMessage, source, originalTarget.aliasSymbol ? originalTarget : target);
                            }
                            return 0 /* Ternary.False */;
                        }
                    }
                    var isPerformingCommonPropertyChecks = relation !== comparableRelation && !(intersectionState & 2 /* IntersectionState.Target */) &&
                        source.flags & (131068 /* TypeFlags.Primitive */ | 524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */) && source !== globalObjectType &&
                        target.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */) && isWeakType(target) &&
                        (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source));
                    var isComparingJsxAttributes = !!(ts.getObjectFlags(source) & 2048 /* ObjectFlags.JsxAttributes */);
                    if (isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes)) {
                        if (reportErrors) {
                            var sourceString = typeToString(originalSource.aliasSymbol ? originalSource : source);
                            var targetString = typeToString(originalTarget.aliasSymbol ? originalTarget : target);
                            var calls = getSignaturesOfType(source, 0 /* SignatureKind.Call */);
                            var constructs = getSignaturesOfType(source, 1 /* SignatureKind.Construct */);
                            if (calls.length > 0 && isRelatedTo(getReturnTypeOfSignature(calls[0]), target, 1 /* RecursionFlags.Source */, /*reportErrors*/ false) ||
                                constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature(constructs[0]), target, 1 /* RecursionFlags.Source */, /*reportErrors*/ false)) {
                                reportError(ts.Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString);
                            }
                            else {
                                reportError(ts.Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString);
                            }
                        }
                        return 0 /* Ternary.False */;
                    }
                    traceUnionsOrIntersectionsTooLarge(source, target);
                    var skipCaching = source.flags & 1048576 /* TypeFlags.Union */ && source.types.length < 4 && !(target.flags & 1048576 /* TypeFlags.Union */) ||
                        target.flags & 1048576 /* TypeFlags.Union */ && target.types.length < 4 && !(source.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */);
                    var result_7 = skipCaching ?
                        unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) :
                        recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags);
                    // For certain combinations involving intersections and optional, excess, or mismatched properties we need
                    // an extra property check where the intersection is viewed as a single object. The following are motivating
                    // examples that all should be errors, but aren't without this extra property check:
                    //
                    //   let obj: { a: { x: string } } & { c: number } = { a: { x: 'hello', y: 2 }, c: 5 };  // Nested excess property
                    //
                    //   declare let wrong: { a: { y: string } };
                    //   let weak: { a?: { x?: number } } & { c?: string } = wrong;  // Nested weak object type
                    //
                    //   function foo<T extends object>(x: { a?: string }, y: T & { a: boolean }) {
                    //     x = y;  // Mismatched property in source intersection
                    //   }
                    //
                    // We suppress recursive intersection property checks because they can generate lots of work when relating
                    // recursive intersections that are structurally similar but not exactly identical. See #37854.
                    if (result_7 && !inPropertyCheck && (target.flags & 2097152 /* TypeFlags.Intersection */ && (isPerformingExcessPropertyChecks || isPerformingCommonPropertyChecks) ||
                        isNonGenericObjectType(target) && !isArrayOrTupleType(target) && source.flags & 2097152 /* TypeFlags.Intersection */ && getApparentType(source).flags & 3670016 /* TypeFlags.StructuredType */ && !ts.some(source.types, function (t) { return !!(ts.getObjectFlags(t) & 262144 /* ObjectFlags.NonInferrableType */); }))) {
                        inPropertyCheck = true;
                        result_7 &= recursiveTypeRelatedTo(source, target, reportErrors, 4 /* IntersectionState.PropertyCheck */, recursionFlags);
                        inPropertyCheck = false;
                    }
                    if (result_7) {
                        return result_7;
                    }
                }
                if (reportErrors) {
                    reportErrorResults(originalSource, originalTarget, source, target, headMessage);
                }
                return 0 /* Ternary.False */;
            }
            function reportErrorResults(originalSource, originalTarget, source, target, headMessage) {
                var sourceHasBase = !!getSingleBaseForNonAugmentingSubtype(originalSource);
                var targetHasBase = !!getSingleBaseForNonAugmentingSubtype(originalTarget);
                source = (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source;
                target = (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target;
                var maybeSuppress = overrideNextErrorInfo > 0;
                if (maybeSuppress) {
                    overrideNextErrorInfo--;
                }
                if (source.flags & 524288 /* TypeFlags.Object */ && target.flags & 524288 /* TypeFlags.Object */) {
                    var currentError = errorInfo;
                    tryElaborateArrayLikeErrors(source, target, /*reportErrors*/ true);
                    if (errorInfo !== currentError) {
                        maybeSuppress = !!errorInfo;
                    }
                }
                if (source.flags & 524288 /* TypeFlags.Object */ && target.flags & 131068 /* TypeFlags.Primitive */) {
                    tryElaborateErrorsForPrimitivesAndObjects(source, target);
                }
                else if (source.symbol && source.flags & 524288 /* TypeFlags.Object */ && globalObjectType === source) {
                    reportError(ts.Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead);
                }
                else if (ts.getObjectFlags(source) & 2048 /* ObjectFlags.JsxAttributes */ && target.flags & 2097152 /* TypeFlags.Intersection */) {
                    var targetTypes = target.types;
                    var intrinsicAttributes = getJsxType(JsxNames.IntrinsicAttributes, errorNode);
                    var intrinsicClassAttributes = getJsxType(JsxNames.IntrinsicClassAttributes, errorNode);
                    if (!isErrorType(intrinsicAttributes) && !isErrorType(intrinsicClassAttributes) &&
                        (ts.contains(targetTypes, intrinsicAttributes) || ts.contains(targetTypes, intrinsicClassAttributes))) {
                        // do not report top error
                        return;
                    }
                }
                else {
                    errorInfo = elaborateNeverIntersection(errorInfo, originalTarget);
                }
                if (!headMessage && maybeSuppress) {
                    lastSkippedInfo = [source, target];
                    // Used by, eg, missing property checking to replace the top-level message with a more informative one
                    return;
                }
                reportRelationError(headMessage, source, target);
            }
            function traceUnionsOrIntersectionsTooLarge(source, target) {
                if (!ts.tracing) {
                    return;
                }
                if ((source.flags & 3145728 /* TypeFlags.UnionOrIntersection */) && (target.flags & 3145728 /* TypeFlags.UnionOrIntersection */)) {
                    var sourceUnionOrIntersection = source;
                    var targetUnionOrIntersection = target;
                    if (sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & 32768 /* ObjectFlags.PrimitiveUnion */) {
                        // There's a fast path for comparing primitive unions
                        return;
                    }
                    var sourceSize = sourceUnionOrIntersection.types.length;
                    var targetSize = targetUnionOrIntersection.types.length;
                    if (sourceSize * targetSize > 1E6) {
                        ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "traceUnionsOrIntersectionsTooLarge_DepthLimit", {
                            sourceId: source.id,
                            sourceSize: sourceSize,
                            targetId: target.id,
                            targetSize: targetSize,
                            pos: errorNode === null || errorNode === void 0 ? void 0 : errorNode.pos,
                            end: errorNode === null || errorNode === void 0 ? void 0 : errorNode.end
                        });
                    }
                }
            }
            function getTypeOfPropertyInTypes(types, name) {
                var appendPropType = function (propTypes, type) {
                    var _a;
                    type = getApparentType(type);
                    var prop = type.flags & 3145728 /* TypeFlags.UnionOrIntersection */ ? getPropertyOfUnionOrIntersectionType(type, name) : getPropertyOfObjectType(type, name);
                    var propType = prop && getTypeOfSymbol(prop) || ((_a = getApplicableIndexInfoForName(type, name)) === null || _a === void 0 ? void 0 : _a.type) || undefinedType;
                    return ts.append(propTypes, propType);
                };
                return getUnionType(ts.reduceLeft(types, appendPropType, /*initial*/ undefined) || ts.emptyArray);
            }
            function hasExcessProperties(source, target, reportErrors) {
                var _a;
                if (!isExcessPropertyCheckTarget(target) || !noImplicitAny && ts.getObjectFlags(target) & 4096 /* ObjectFlags.JSLiteral */) {
                    return false; // Disable excess property checks on JS literals to simulate having an implicit "index signature" - but only outside of noImplicitAny
                }
                var isComparingJsxAttributes = !!(ts.getObjectFlags(source) & 2048 /* ObjectFlags.JsxAttributes */);
                if ((relation === assignableRelation || relation === comparableRelation) &&
                    (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target)))) {
                    return false;
                }
                var reducedTarget = target;
                var checkTypes;
                if (target.flags & 1048576 /* TypeFlags.Union */) {
                    reducedTarget = findMatchingDiscriminantType(source, target, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target);
                    checkTypes = reducedTarget.flags & 1048576 /* TypeFlags.Union */ ? reducedTarget.types : [reducedTarget];
                }
                var _loop_19 = function (prop) {
                    if (shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(source, prop)) {
                        if (!isKnownProperty(reducedTarget, prop.escapedName, isComparingJsxAttributes)) {
                            if (reportErrors) {
                                // Report error in terms of object types in the target as those are the only ones
                                // we check in isKnownProperty.
                                var errorTarget = filterType(reducedTarget, isExcessPropertyCheckTarget);
                                // We know *exactly* where things went wrong when comparing the types.
                                // Use this property as the error node as this will be more helpful in
                                // reasoning about what went wrong.
                                if (!errorNode)
                                    return { value: ts.Debug.fail() };
                                if (ts.isJsxAttributes(errorNode) || ts.isJsxOpeningLikeElement(errorNode) || ts.isJsxOpeningLikeElement(errorNode.parent)) {
                                    // JsxAttributes has an object-literal flag and undergo same type-assignablity check as normal object-literal.
                                    // However, using an object-literal error message will be very confusing to the users so we give different a message.
                                    if (prop.valueDeclaration && ts.isJsxAttribute(prop.valueDeclaration) && ts.getSourceFileOfNode(errorNode) === ts.getSourceFileOfNode(prop.valueDeclaration.name)) {
                                        // Note that extraneous children (as in `<NoChild>extra</NoChild>`) don't pass this check,
                                        // since `children` is a SyntaxKind.PropertySignature instead of a SyntaxKind.JsxAttribute.
                                        errorNode = prop.valueDeclaration.name;
                                    }
                                    var propName = symbolToString(prop);
                                    var suggestionSymbol = getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget);
                                    var suggestion = suggestionSymbol ? symbolToString(suggestionSymbol) : undefined;
                                    if (suggestion) {
                                        reportError(ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(errorTarget), suggestion);
                                    }
                                    else {
                                        reportError(ts.Diagnostics.Property_0_does_not_exist_on_type_1, propName, typeToString(errorTarget));
                                    }
                                }
                                else {
                                    // use the property's value declaration if the property is assigned inside the literal itself
                                    var objectLiteralDeclaration_1 = ((_a = source.symbol) === null || _a === void 0 ? void 0 : _a.declarations) && ts.firstOrUndefined(source.symbol.declarations);
                                    var suggestion = void 0;
                                    if (prop.valueDeclaration && ts.findAncestor(prop.valueDeclaration, function (d) { return d === objectLiteralDeclaration_1; }) && ts.getSourceFileOfNode(objectLiteralDeclaration_1) === ts.getSourceFileOfNode(errorNode)) {
                                        var propDeclaration = prop.valueDeclaration;
                                        ts.Debug.assertNode(propDeclaration, ts.isObjectLiteralElementLike);
                                        errorNode = propDeclaration;
                                        var name = propDeclaration.name;
                                        if (ts.isIdentifier(name)) {
                                            suggestion = getSuggestionForNonexistentProperty(name, errorTarget);
                                        }
                                    }
                                    if (suggestion !== undefined) {
                                        reportError(ts.Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(errorTarget), suggestion);
                                    }
                                    else {
                                        reportError(ts.Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(errorTarget));
                                    }
                                }
                            }
                            return { value: true };
                        }
                        if (checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escapedName), 3 /* RecursionFlags.Both */, reportErrors)) {
                            if (reportErrors) {
                                reportIncompatibleError(ts.Diagnostics.Types_of_property_0_are_incompatible, symbolToString(prop));
                            }
                            return { value: true };
                        }
                    }
                };
                for (var _i = 0, _b = getPropertiesOfType(source); _i < _b.length; _i++) {
                    var prop = _b[_i];
                    var state_6 = _loop_19(prop);
                    if (typeof state_6 === "object")
                        return state_6.value;
                }
                return false;
            }
            function shouldCheckAsExcessProperty(prop, container) {
                return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent === container.valueDeclaration;
            }
            function unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) {
                // Note that these checks are specifically ordered to produce correct results. In particular,
                // we need to deconstruct unions before intersections (because unions are always at the top),
                // and we need to handle "each" relations before "some" relations for the same kind of type.
                if (source.flags & 1048576 /* TypeFlags.Union */) {
                    return relation === comparableRelation ?
                        someTypeRelatedToType(source, target, reportErrors && !(source.flags & 131068 /* TypeFlags.Primitive */), intersectionState) :
                        eachTypeRelatedToType(source, target, reportErrors && !(source.flags & 131068 /* TypeFlags.Primitive */), intersectionState);
                }
                if (target.flags & 1048576 /* TypeFlags.Union */) {
                    return typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target, reportErrors && !(source.flags & 131068 /* TypeFlags.Primitive */) && !(target.flags & 131068 /* TypeFlags.Primitive */));
                }
                if (target.flags & 2097152 /* TypeFlags.Intersection */) {
                    return typeRelatedToEachType(getRegularTypeOfObjectLiteral(source), target, reportErrors, 2 /* IntersectionState.Target */);
                }
                // Source is an intersection. For the comparable relation, if the target is a primitive type we hoist the
                // constraints of all non-primitive types in the source into a new intersection. We do this because the
                // intersection may further constrain the constraints of the non-primitive types. For example, given a type
                // parameter 'T extends 1 | 2', the intersection 'T & 1' should be reduced to '1' such that it doesn't
                // appear to be comparable to '2'.
                if (relation === comparableRelation && target.flags & 131068 /* TypeFlags.Primitive */) {
                    var constraints = ts.sameMap(source.types, getBaseConstraintOrType);
                    if (constraints !== source.types) {
                        source = getIntersectionType(constraints);
                        if (!(source.flags & 2097152 /* TypeFlags.Intersection */)) {
                            return isRelatedTo(source, target, 1 /* RecursionFlags.Source */, /*reportErrors*/ false);
                        }
                    }
                }
                // Check to see if any constituents of the intersection are immediately related to the target.
                // Don't report errors though. Elaborating on whether a source constituent is related to the target is
                // not actually useful and leads to some confusing error messages. Instead, we rely on the caller
                // checking whether the full intersection viewed as an object is related to the target.
                return someTypeRelatedToType(source, target, /*reportErrors*/ false, 1 /* IntersectionState.Source */);
            }
            function eachTypeRelatedToSomeType(source, target) {
                var result = -1 /* Ternary.True */;
                var sourceTypes = source.types;
                for (var _i = 0, sourceTypes_1 = sourceTypes; _i < sourceTypes_1.length; _i++) {
                    var sourceType = sourceTypes_1[_i];
                    var related = typeRelatedToSomeType(sourceType, target, /*reportErrors*/ false);
                    if (!related) {
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
                return result;
            }
            function typeRelatedToSomeType(source, target, reportErrors) {
                var targetTypes = target.types;
                if (target.flags & 1048576 /* TypeFlags.Union */) {
                    if (containsType(targetTypes, source)) {
                        return -1 /* Ternary.True */;
                    }
                    var match = getMatchingUnionConstituentForType(target, source);
                    if (match) {
                        var related = isRelatedTo(source, match, 2 /* RecursionFlags.Target */, /*reportErrors*/ false);
                        if (related) {
                            return related;
                        }
                    }
                }
                for (var _i = 0, targetTypes_1 = targetTypes; _i < targetTypes_1.length; _i++) {
                    var type = targetTypes_1[_i];
                    var related = isRelatedTo(source, type, 2 /* RecursionFlags.Target */, /*reportErrors*/ false);
                    if (related) {
                        return related;
                    }
                }
                if (reportErrors) {
                    // Elaborate only if we can find a best matching type in the target union
                    var bestMatchingType = getBestMatchingType(source, target, isRelatedTo);
                    if (bestMatchingType) {
                        isRelatedTo(source, bestMatchingType, 2 /* RecursionFlags.Target */, /*reportErrors*/ true);
                    }
                }
                return 0 /* Ternary.False */;
            }
            function typeRelatedToEachType(source, target, reportErrors, intersectionState) {
                var result = -1 /* Ternary.True */;
                var targetTypes = target.types;
                for (var _i = 0, targetTypes_2 = targetTypes; _i < targetTypes_2.length; _i++) {
                    var targetType = targetTypes_2[_i];
                    var related = isRelatedTo(source, targetType, 2 /* RecursionFlags.Target */, reportErrors, /*headMessage*/ undefined, intersectionState);
                    if (!related) {
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
                return result;
            }
            function someTypeRelatedToType(source, target, reportErrors, intersectionState) {
                var sourceTypes = source.types;
                if (source.flags & 1048576 /* TypeFlags.Union */ && containsType(sourceTypes, target)) {
                    return -1 /* Ternary.True */;
                }
                var len = sourceTypes.length;
                for (var i = 0; i < len; i++) {
                    var related = isRelatedTo(sourceTypes[i], target, 1 /* RecursionFlags.Source */, reportErrors && i === len - 1, /*headMessage*/ undefined, intersectionState);
                    if (related) {
                        return related;
                    }
                }
                return 0 /* Ternary.False */;
            }
            function getUndefinedStrippedTargetIfNeeded(source, target) {
                // As a builtin type, `undefined` is a very low type ID - making it almsot always first, making this a very fast check to see
                // if we need to strip `undefined` from the target
                if (source.flags & 1048576 /* TypeFlags.Union */ && target.flags & 1048576 /* TypeFlags.Union */ &&
                    !(source.types[0].flags & 32768 /* TypeFlags.Undefined */) && target.types[0].flags & 32768 /* TypeFlags.Undefined */) {
                    return extractTypesOfKind(target, ~32768 /* TypeFlags.Undefined */);
                }
                return target;
            }
            function eachTypeRelatedToType(source, target, reportErrors, intersectionState) {
                var result = -1 /* Ternary.True */;
                var sourceTypes = source.types;
                // We strip `undefined` from the target if the `source` trivially doesn't contain it for our correspondence-checking fastpath
                // since `undefined` is frequently added by optionality and would otherwise spoil a potentially useful correspondence
                var undefinedStrippedTarget = getUndefinedStrippedTargetIfNeeded(source, target);
                for (var i = 0; i < sourceTypes.length; i++) {
                    var sourceType = sourceTypes[i];
                    if (undefinedStrippedTarget.flags & 1048576 /* TypeFlags.Union */ && sourceTypes.length >= undefinedStrippedTarget.types.length && sourceTypes.length % undefinedStrippedTarget.types.length === 0) {
                        // many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison
                        // such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large
                        // union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,
                        // the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`
                        // - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union
                        var related_1 = isRelatedTo(sourceType, undefinedStrippedTarget.types[i % undefinedStrippedTarget.types.length], 3 /* RecursionFlags.Both */, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                        if (related_1) {
                            result &= related_1;
                            continue;
                        }
                    }
                    var related = isRelatedTo(sourceType, target, 1 /* RecursionFlags.Source */, reportErrors, /*headMessage*/ undefined, intersectionState);
                    if (!related) {
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
                return result;
            }
            function typeArgumentsRelatedTo(sources, targets, variances, reportErrors, intersectionState) {
                if (sources === void 0) { sources = ts.emptyArray; }
                if (targets === void 0) { targets = ts.emptyArray; }
                if (variances === void 0) { variances = ts.emptyArray; }
                if (sources.length !== targets.length && relation === identityRelation) {
                    return 0 /* Ternary.False */;
                }
                var length = sources.length <= targets.length ? sources.length : targets.length;
                var result = -1 /* Ternary.True */;
                for (var i = 0; i < length; i++) {
                    // When variance information isn't available we default to covariance. This happens
                    // in the process of computing variance information for recursive types and when
                    // comparing 'this' type arguments.
                    var varianceFlags = i < variances.length ? variances[i] : 1 /* VarianceFlags.Covariant */;
                    var variance = varianceFlags & 7 /* VarianceFlags.VarianceMask */;
                    // We ignore arguments for independent type parameters (because they're never witnessed).
                    if (variance !== 4 /* VarianceFlags.Independent */) {
                        var s = sources[i];
                        var t = targets[i];
                        var related = -1 /* Ternary.True */;
                        if (varianceFlags & 8 /* VarianceFlags.Unmeasurable */) {
                            // Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.
                            // We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by
                            // the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)
                            related = relation === identityRelation ? isRelatedTo(s, t, 3 /* RecursionFlags.Both */, /*reportErrors*/ false) : compareTypesIdentical(s, t);
                        }
                        else if (variance === 1 /* VarianceFlags.Covariant */) {
                            related = isRelatedTo(s, t, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                        }
                        else if (variance === 2 /* VarianceFlags.Contravariant */) {
                            related = isRelatedTo(t, s, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                        }
                        else if (variance === 3 /* VarianceFlags.Bivariant */) {
                            // In the bivariant case we first compare contravariantly without reporting
                            // errors. Then, if that doesn't succeed, we compare covariantly with error
                            // reporting. Thus, error elaboration will be based on the the covariant check,
                            // which is generally easier to reason about.
                            related = isRelatedTo(t, s, 3 /* RecursionFlags.Both */, /*reportErrors*/ false);
                            if (!related) {
                                related = isRelatedTo(s, t, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                            }
                        }
                        else {
                            // In the invariant case we first compare covariantly, and only when that
                            // succeeds do we proceed to compare contravariantly. Thus, error elaboration
                            // will typically be based on the covariant check.
                            related = isRelatedTo(s, t, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                            if (related) {
                                related &= isRelatedTo(t, s, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                            }
                        }
                        if (!related) {
                            return 0 /* Ternary.False */;
                        }
                        result &= related;
                    }
                }
                return result;
            }
            // Determine if possibly recursive types are related. First, check if the result is already available in the global cache.
            // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
            // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
            // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
            // and issue an error. Otherwise, actually compare the structure of the two types.
            function recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags) {
                if (overflow) {
                    return 0 /* Ternary.False */;
                }
                var keyIntersectionState = intersectionState | (inPropertyCheck ? 8 /* IntersectionState.InPropertyCheck */ : 0);
                var id = getRelationKey(source, target, keyInte