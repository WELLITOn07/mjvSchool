               addOutput("".concat(dts, ".map"));
            }
        }
    }
    /*@internal*/
    function getCommonSourceDirectory(options, emittedFiles, currentDirectory, getCanonicalFileName, checkSourceFilesBelongToPath) {
        var commonSourceDirectory;
        if (options.rootDir) {
            // If a rootDir is specified use it as the commonSourceDirectory
            commonSourceDirectory = ts.getNormalizedAbsolutePath(options.rootDir, currentDirectory);
            checkSourceFilesBelongToPath === null || checkSourceFilesBelongToPath === void 0 ? void 0 : checkSourceFilesBelongToPath(options.rootDir);
        }
        else if (options.composite && options.configFilePath) {
            // Project compilations never infer their root from the input source paths
            commonSourceDirectory = ts.getDirectoryPath(ts.normalizeSlashes(options.configFilePath));
            checkSourceFilesBelongToPath === null || checkSourceFilesBelongToPath === void 0 ? void 0 : checkSourceFilesBelongToPath(commonSourceDirectory);
        }
        else {
            commonSourceDirectory = ts.computeCommonSourceDirectoryOfFilenames(emittedFiles(), currentDirectory, getCanonicalFileName);
        }
        if (commonSourceDirectory && commonSourceDirectory[commonSourceDirectory.length - 1] !== ts.directorySeparator) {
            // Make sure directory path ends with directory separator so this string can directly
            // used to replace with "" to get the relative path of the source file and the relative path doesn't
            // start with / making it rooted path
            commonSourceDirectory += ts.directorySeparator;
        }
        return commonSourceDirectory;
    }
    ts.getCommonSourceDirectory = getCommonSourceDirectory;
    /*@internal*/
    function getCommonSourceDirectoryOfConfig(_a, ignoreCase) {
        var options = _a.options, fileNames = _a.fileNames;
        return getCommonSourceDirectory(options, function () { return ts.filter(fileNames, function (file) { return !(options.noEmitForJsFiles && ts.fileExtensionIsOneOf(file, ts.supportedJSExtensionsFlat)) && !ts.isDeclarationFileName(file); }); }, ts.getDirectoryPath(ts.normalizeSlashes(ts.Debug.checkDefined(options.configFilePath))), ts.createGetCanonicalFileName(!ignoreCase));
    }
    ts.getCommonSourceDirectoryOfConfig = getCommonSourceDirectoryOfConfig;
    /*@internal*/
    function getAllProjectOutputs(configFile, ignoreCase) {
        var _a = createAddOutput(), addOutput = _a.addOutput, getOutputs = _a.getOutputs;
        if (ts.outFile(configFile.options)) {
            getSingleOutputFileNames(configFile, addOutput);
        }
        else {
            var getCommonSourceDirectory_1 = ts.memoize(function () { return getCommonSourceDirectoryOfConfig(configFile, ignoreCase); });
            for (var _b = 0, _c = configFile.fileNames; _b < _c.length; _b++) {
                var inputFileName = _c[_b];
                getOwnOutputFileNames(configFile, inputFileName, ignoreCase, addOutput, getCommonSourceDirectory_1);
            }
            addOutput(getTsBuildInfoEmitOutputFilePath(configFile.options));
        }
        return getOutputs();
    }
    ts.getAllProjectOutputs = getAllProjectOutputs;
    function getOutputFileNames(commandLine, inputFileName, ignoreCase) {
        inputFileName = ts.normalizePath(inputFileName);
        ts.Debug.assert(ts.contains(commandLine.fileNames, inputFileName), "Expected fileName to be present in command line");
        var _a = createAddOutput(), addOutput = _a.addOutput, getOutputs = _a.getOutputs;
        if (ts.outFile(commandLine.options)) {
            getSingleOutputFileNames(commandLine, addOutput);
        }
        else {
            getOwnOutputFileNames(commandLine, inputFileName, ignoreCase, addOutput);
        }
        return getOutputs();
    }
    ts.getOutputFileNames = getOutputFileNames;
    /*@internal*/
    function getFirstProjectOutput(configFile, ignoreCase) {
        if (ts.outFile(configFile.options)) {
            var jsFilePath = getOutputPathsForBundle(configFile.options, /*forceDtsPaths*/ false).jsFilePath;
            return ts.Debug.checkDefined(jsFilePath, "project ".concat(configFile.options.configFilePath, " expected to have at least one output"));
        }
        var getCommonSourceDirectory = ts.memoize(function () { return getCommonSourceDirectoryOfConfig(configFile, ignoreCase); });
        for (var _a = 0, _b = configFile.fileNames; _a < _b.length; _a++) {
            var inputFileName = _b[_a];
            if (ts.isDeclarationFileName(inputFileName))
                continue;
            var jsFilePath = getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory);
            if (jsFilePath)
                return jsFilePath;
            if (ts.fileExtensionIs(inputFileName, ".json" /* Extension.Json */))
                continue;
            if (ts.getEmitDeclarations(configFile.options)) {
                return getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory);
            }
        }
        var buildInfoPath = getTsBuildInfoEmitOutputFilePath(configFile.options);
        if (buildInfoPath)
            return buildInfoPath;
        return ts.Debug.fail("project ".concat(configFile.options.configFilePath, " expected to have at least one output"));
    }
    ts.getFirstProjectOutput = getFirstProjectOutput;
    /*@internal*/
    // targetSourceFile is when users only want one file in entire project to be emitted. This is used in compileOnSave feature
    function emitFiles(resolver, host, targetSourceFile, _a, emitOnlyDtsFiles, onlyBuildInfo, forceDtsEmit) {
        var scriptTransformers = _a.scriptTransformers, declarationTransformers = _a.declarationTransformers;
        var compilerOptions = host.getCompilerOptions();
        var sourceMapDataList = (compilerOptions.sourceMap || compilerOptions.inlineSourceMap || ts.getAreDeclarationMapsEnabled(compilerOptions)) ? [] : undefined;
        var emittedFilesList = compilerOptions.listEmittedFiles ? [] : undefined;
        var emitterDiagnostics = ts.createDiagnosticCollection();
        var newLine = ts.getNewLineCharacter(compilerOptions, function () { return host.getNewLine(); });
        var writer = ts.createTextWriter(newLine);
        var _b = ts.performance.createTimer("printTime", "beforePrint", "afterPrint"), enter = _b.enter, exit = _b.exit;
        var bundleBuildInfo;
        var emitSkipped = false;
        var exportedModulesFromDeclarationEmit;
        // Emit each output file
        enter();
        forEachEmittedFile(host, emitSourceFileOrBundle, ts.getSourceFilesToEmit(host, targetSourceFile, forceDtsEmit), forceDtsEmit, onlyBuildInfo, !targetSourceFile);
        exit();
        return {
            emitSkipped: emitSkipped,
            diagnostics: emitterDiagnostics.getDiagnostics(),
            emittedFiles: emittedFilesList,
            sourceMaps: sourceMapDataList,
            exportedModulesFromDeclarationEmit: exportedModulesFromDeclarationEmit
        };
        function emitSourceFileOrBundle(_a, sourceFileOrBundle) {
            var jsFilePath = _a.jsFilePath, sourceMapFilePath = _a.sourceMapFilePath, declarationFilePath = _a.declarationFilePath, declarationMapPath = _a.declarationMapPath, buildInfoPath = _a.buildInfoPath;
            var buildInfoDirectory;
            if (buildInfoPath && sourceFileOrBundle && ts.isBundle(sourceFileOrBundle)) {
                buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(buildInfoPath, host.getCurrentDirectory()));
                bundleBuildInfo = {
                    commonSourceDirectory: relativeToBuildInfo(host.getCommonSourceDirectory()),
                    sourceFiles: sourceFileOrBundle.sourceFiles.map(function (file) { return relativeToBuildInfo(ts.getNormalizedAbsolutePath(file.fileName, host.getCurrentDirectory())); })
                };
            }
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("emit" /* tracing.Phase.Emit */, "emitJsFileOrBundle", { jsFilePath: jsFilePath });
            emitJsFileOrBundle(sourceFileOrBundle, jsFilePath, sourceMapFilePath, relativeToBuildInfo);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("emit" /* tracing.Phase.Emit */, "emitDeclarationFileOrBundle", { declarationFilePath: declarationFilePath });
            emitDeclarationFileOrBundle(sourceFileOrBundle, declarationFilePath, declarationMapPath, relativeToBuildInfo);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("emit" /* tracing.Phase.Emit */, "emitBuildInfo", { buildInfoPath: buildInfoPath });
            emitBuildInfo(bundleBuildInfo, buildInfoPath);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            if (!emitSkipped && emittedFilesList) {
                if (!emitOnlyDtsFiles) {
                    if (jsFilePath) {
                        emittedFilesList.push(jsFilePath);
                    }
                    if (sourceMapFilePath) {
                        emittedFilesList.push(sourceMapFilePath);
                    }
                    if (buildInfoPath) {
                        emittedFilesList.push(buildInfoPath);
                    }
                }
                if (declarationFilePath) {
                    emittedFilesList.push(declarationFilePath);
                }
                if (declarationMapPath) {
                    emittedFilesList.push(declarationMapPath);
                }
            }
            function relativeToBuildInfo(path) {
                return ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(buildInfoDirectory, path, host.getCanonicalFileName));
            }
        }
        function emitBuildInfo(bundle, buildInfoPath) {
            // Write build information if applicable
            if (!buildInfoPath || targetSourceFile || emitSkipped)
                return;
            var program = host.getProgramBuildInfo();
            if (host.isEmitBlocked(buildInfoPath)) {
                emitSkipped = true;
                return;
            }
            var version = ts.version; // Extracted into a const so the form is stable between namespace and module
            ts.writeFile(host, emitterDiagnostics, buildInfoPath, getBuildInfoText({ bundle: bundle, program: program, version: version }), /*writeByteOrderMark*/ false);
        }
        function emitJsFileOrBundle(sourceFileOrBundle, jsFilePath, sourceMapFilePath, relativeToBuildInfo) {
            if (!sourceFileOrBundle || emitOnlyDtsFiles || !jsFilePath) {
                return;
            }
            // Make sure not to write js file and source map file if any of them cannot be written
            if ((jsFilePath && host.isEmitBlocked(jsFilePath)) || compilerOptions.noEmit) {
                emitSkipped = true;
                return;
            }
            // Transform the source files
            var transform = ts.transformNodes(resolver, host, ts.factory, compilerOptions, [sourceFileOrBundle], scriptTransformers, /*allowDtsFiles*/ false);
            var printerOptions = {
                removeComments: compilerOptions.removeComments,
                newLine: compilerOptions.newLine,
                noEmitHelpers: compilerOptions.noEmitHelpers,
                module: compilerOptions.module,
                target: compilerOptions.target,
                sourceMap: compilerOptions.sourceMap,
                inlineSourceMap: compilerOptions.inlineSourceMap,
                inlineSources: compilerOptions.inlineSources,
                extendedDiagnostics: compilerOptions.extendedDiagnostics,
                writeBundleFileInfo: !!bundleBuildInfo,
                relativeToBuildInfo: relativeToBuildInfo
            };
            // Create a printer to print the nodes
            var printer = createPrinter(printerOptions, {
                // resolver hooks
                hasGlobalName: resolver.hasGlobalName,
                // transform hooks
                onEmitNode: transform.emitNodeWithNotification,
                isEmitNotificationEnabled: transform.isEmitNotificationEnabled,
                substituteNode: transform.substituteNode,
            });
            ts.Debug.assert(transform.transformed.length === 1, "Should only see one output from the transform");
            printSourceFileOrBundle(jsFilePath, sourceMapFilePath, transform.transformed[0], printer, compilerOptions);
            // Clean up emit nodes on parse tree
            transform.dispose();
            if (bundleBuildInfo)
                bundleBuildInfo.js = printer.bundleFileInfo;
        }
        function emitDeclarationFileOrBundle(sourceFileOrBundle, declarationFilePath, declarationMapPath, relativeToBuildInfo) {
            if (!sourceFileOrBundle)
                return;
            if (!declarationFilePath) {
                if (emitOnlyDtsFiles || compilerOptions.emitDeclarationOnly)
                    emitSkipped = true;
                return;
            }
            var sourceFiles = ts.isSourceFile(sourceFileOrBundle) ? [sourceFileOrBundle] : sourceFileOrBundle.sourceFiles;
            var filesForEmit = forceDtsEmit ? sourceFiles : ts.filter(sourceFiles, ts.isSourceFileNotJson);
            // Setup and perform the transformation to retrieve declarations from the input files
            var inputListOrBundle = ts.outFile(compilerOptions) ? [ts.factory.createBundle(filesForEmit, !ts.isSourceFile(sourceFileOrBundle) ? sourceFileOrBundle.prepends : undefined)] : filesForEmit;
            if (emitOnlyDtsFiles && !ts.getEmitDeclarations(compilerOptions)) {
                // Checker wont collect the linked aliases since thats only done when declaration is enabled.
                // Do that here when emitting only dts files
                filesForEmit.forEach(collectLinkedAliases);
            }
            var declarationTransform = ts.transformNodes(resolver, host, ts.factory, compilerOptions, inputListOrBundle, declarationTransformers, /*allowDtsFiles*/ false);
            if (ts.length(declarationTransform.diagnostics)) {
                for (var _a = 0, _b = declarationTransform.diagnostics; _a < _b.length; _a++) {
                    var diagnostic = _b[_a];
                    emitterDiagnostics.add(diagnostic);
                }
            }
            var printerOptions = {
                removeComments: compilerOptions.removeComments,
                newLine: compilerOptions.newLine,
                noEmitHelpers: true,
                module: compilerOptions.module,
                target: compilerOptions.target,
                sourceMap: compilerOptions.sourceMap,
                inlineSourceMap: compilerOptions.inlineSourceMap,
                extendedDiagnostics: compilerOptions.extendedDiagnostics,
                onlyPrintJsDocStyle: true,
                writeBundleFileInfo: !!bundleBuildInfo,
                recordInternalSection: !!bundleBuildInfo,
                relativeToBuildInfo: relativeToBuildInfo
            };
            var declarationPrinter = createPrinter(printerOptions, {
                // resolver hooks
                hasGlobalName: resolver.hasGlobalName,
                // transform hooks
                onEmitNode: declarationTransform.emitNodeWithNotification,
                isEmitNotificationEnabled: declarationTransform.isEmitNotificationEnabled,
                substituteNode: declarationTransform.substituteNode,
            });
            var declBlocked = (!!declarationTransform.diagnostics && !!declarationTransform.diagnostics.length) || !!host.isEmitBlocked(declarationFilePath) || !!compilerOptions.noEmit;
            emitSkipped = emitSkipped || declBlocked;
            if (!declBlocked || forceDtsEmit) {
                ts.Debug.assert(declarationTransform.transformed.length === 1, "Should only see one output from the decl transform");
                printSourceFileOrBundle(declarationFilePath, declarationMapPath, declarationTransform.transformed[0], declarationPrinter, {
                    sourceMap: !forceDtsEmit && compilerOptions.declarationMap,
                    sourceRoot: compilerOptions.sourceRoot,
                    mapRoot: compilerOptions.mapRoot,
                    extendedDiagnostics: compilerOptions.extendedDiagnostics,
                    // Explicitly do not passthru either `inline` option
                });
                if (forceDtsEmit && declarationTransform.transformed[0].kind === 305 /* SyntaxKind.SourceFile */) {
                    var sourceFile = declarationTransform.transformed[0];
                    exportedModulesFromDeclarationEmit = sourceFile.exportedModulesFromDeclarationEmit;
                }
            }
            declarationTransform.dispose();
            if (bundleBuildInfo)
                bundleBuildInfo.dts = declarationPrinter.bundleFileInfo;
        }
        function collectLinkedAliases(node) {
            if (ts.isExportAssignment(node)) {
                if (node.expression.kind === 79 /* SyntaxKind.Identifier */) {
                    resolver.collectLinkedAliases(node.expression, /*setVisibility*/ true);
                }
                return;
            }
            else if (ts.isExportSpecifier(node)) {
                resolver.collectLinkedAliases(node.propertyName || node.name, /*setVisibility*/ true);
                return;
            }
            ts.forEachChild(node, collectLinkedAliases);
        }
        function printSourceFileOrBundle(jsFilePath, sourceMapFilePath, sourceFileOrBundle, printer, mapOptions) {
            var bundle = sourceFileOrBundle.kind === 306 /* SyntaxKind.Bundle */ ? sourceFileOrBundle : undefined;
            var sourceFile = sourceFileOrBundle.kind === 305 /* SyntaxKind.SourceFile */ ? sourceFileOrBundle : undefined;
            var sourceFiles = bundle ? bundle.sourceFiles : [sourceFile];
            var sourceMapGenerator;
            if (shouldEmitSourceMaps(mapOptions, sourceFileOrBundle)) {
                sourceMapGenerator = ts.createSourceMapGenerator(host, ts.getBaseFileName(ts.normalizeSlashes(jsFilePath)), getSourceRoot(mapOptions), getSourceMapDirectory(mapOptions, jsFilePath, sourceFile), mapOptions);
            }
            if (bundle) {
                printer.writeBundle(bundle, writer, sourceMapGenerator);
            }
            else {
                printer.writeFile(sourceFile, writer, sourceMapGenerator);
            }
            var sourceMapUrlPos;
            if (sourceMapGenerator) {
                if (sourceMapDataList) {
                    sourceMapDataList.push({
                        inputSourceFileNames: sourceMapGenerator.getSources(),
                        sourceMap: sourceMapGenerator.toJSON()
                    });
                }
                var sourceMappingURL = getSourceMappingURL(mapOptions, sourceMapGenerator, jsFilePath, sourceMapFilePath, sourceFile);
                if (sourceMappingURL) {
                    if (!writer.isAtStartOfLine())
                        writer.rawWrite(newLine);
                    sourceMapUrlPos = writer.getTextPos();
                    writer.writeComment("//# ".concat("sourceMappingURL", "=").concat(sourceMappingURL)); // Tools can sometimes see this line as a source mapping url comment
                }
                // Write the source map
                if (sourceMapFilePath) {
                    var sourceMap = sourceMapGenerator.toString();
                    ts.writeFile(host, emitterDiagnostics, sourceMapFilePath, sourceMap, /*writeByteOrderMark*/ false, sourceFiles);
                }
            }
            else {
                writer.writeLine();
            }
            // Write the output file
            ts.writeFile(host, emitterDiagnostics, jsFilePath, writer.getText(), !!compilerOptions.emitBOM, sourceFiles, { sourceMapUrlPos: sourceMapUrlPos });
            // Reset state
            writer.clear();
        }
        function shouldEmitSourceMaps(mapOptions, sourceFileOrBundle) {
            return (mapOptions.sourceMap || mapOptions.inlineSourceMap)
                && (sourceFileOrBundle.kind !== 305 /* SyntaxKind.SourceFile */ || !ts.fileExtensionIs(sourceFileOrBundle.fileName, ".json" /* Extension.Json */));
        }
        function getSourceRoot(mapOptions) {
            // Normalize source root and make sure it has trailing "/" so that it can be used to combine paths with the
            // relative paths of the sources list in the sourcemap
            var sourceRoot = ts.normalizeSlashes(mapOptions.sourceRoot || "");
            return sourceRoot ? ts.ensureTrailingDirectorySeparator(sourceRoot) : sourceRoot;
        }
        function getSourceMapDirectory(mapOptions, filePath, sourceFile) {
            if (mapOptions.sourceRoot)
                return host.getCommonSourceDirectory();
            if (mapOptions.mapRoot) {
                var sourceMapDir = ts.normalizeSlashes(mapOptions.mapRoot);
                if (sourceFile) {
                    // For modules or multiple emit files the mapRoot will have directory structure like the sources
                    // So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
                    sourceMapDir = ts.getDirectoryPath(ts.getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir));
                }
                if (ts.getRootLength(sourceMapDir) === 0) {
                    // The relative paths are relative to the common directory
                    sourceMapDir = ts.combinePaths(host.getCommonSourceDirectory(), sourceMapDir);
                }
                return sourceMapDir;
            }
            return ts.getDirectoryPath(ts.normalizePath(filePath));
        }
        function getSourceMappingURL(mapOptions, sourceMapGenerator, filePath, sourceMapFilePath, sourceFile) {
            if (mapOptions.inlineSourceMap) {
                // Encode the sourceMap into the sourceMap url
                var sourceMapText = sourceMapGenerator.toString();
                var base64SourceMapText = ts.base64encode(ts.sys, sourceMapText);
                return "data:application/json;base64,".concat(base64SourceMapText);
            }
            var sourceMapFile = ts.getBaseFileName(ts.normalizeSlashes(ts.Debug.checkDefined(sourceMapFilePath)));
            if (mapOptions.mapRoot) {
                var sourceMapDir = ts.normalizeSlashes(mapOptions.mapRoot);
                if (sourceFile) {
                    // For modules or multiple emit files the mapRoot will have directory structure like the sources
                    // So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
                    sourceMapDir = ts.getDirectoryPath(ts.getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir));
                }
                if (ts.getRootLength(sourceMapDir) === 0) {
                    // The relative paths are relative to the common directory
                    sourceMapDir = ts.combinePaths(host.getCommonSourceDirectory(), sourceMapDir);
                    return encodeURI(ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizePath(filePath)), // get the relative sourceMapDir path based on jsFilePath
                    ts.combinePaths(sourceMapDir, sourceMapFile), // this is where user expects to see sourceMap
                    host.getCurrentDirectory(), host.getCanonicalFileName, 
                    /*isAbsolutePathAnUrl*/ true));
                }
                else {
                    return encodeURI(ts.combinePaths(sourceMapDir, sourceMapFile));
                }
            }
            return encodeURI(sourceMapFile);
        }
    }
    ts.emitFiles = emitFiles;
    /*@internal*/
    function getBuildInfoText(buildInfo) {
        return JSON.stringify(buildInfo);
    }
    ts.getBuildInfoText = getBuildInfoText;
    /*@internal*/
    function getBuildInfo(buildInfoText) {
        return JSON.parse(buildInfoText);
    }
    ts.getBuildInfo = getBuildInfo;
    /*@internal*/
    ts.notImplementedResolver = {
        hasGlobalName: ts.notImplemented,
        getReferencedExportContainer: ts.notImplemented,
        getReferencedImportDeclaration: ts.notImplemented,
        getReferencedDeclarationWithCollidingName: ts.notImplemented,
        isDeclarationWithCollidingName: ts.notImplemented,
        isValueAliasDeclaration: ts.notImplemented,
        isReferencedAliasDeclaration: ts.notImplemented,
        isTopLevelValueImportEqualsWithEntityName: ts.notImplemented,
        getNodeCheckFlags: ts.notImplemented,
        isDeclarationVisible: ts.notImplemented,
        isLateBound: function (_node) { return false; },
        collectLinkedAliases: ts.notImplemented,
        isImplementationOfOverload: ts.notImplemented,
        isRequiredInitializedParameter: ts.notImplemented,
        isOptionalUninitializedParameterProperty: ts.notImplemented,
        isExpandoFunctionDeclaration: ts.notImplemented,
        getPropertiesOfContainerFunction: ts.notImplemented,
        createTypeOfDeclaration: ts.notImplemented,
        createReturnTypeOfSignatureDeclaration: ts.notImplemented,
        createTypeOfExpression: ts.notImplemented,
        createLiteralConstValue: ts.notImplemented,
        isSymbolAccessible: ts.notImplemented,
        isEntityNameVisible: ts.notImplemented,
        // Returns the constant value this property access resolves to: notImplemented, or 'undefined' for a non-constant
        getConstantValue: ts.notImplemented,
        getReferencedValueDeclaration: ts.notImplemented,
        getTypeReferenceSerializationKind: ts.notImplemented,
        isOptionalParameter: ts.notImplemented,
        moduleExportsSomeValue: ts.notImplemented,
        isArgumentsLocalBinding: ts.notImplemented,
        getExternalModuleFileFromDeclaration: ts.notImplemented,
        getTypeReferenceDirectivesForEntityName: ts.notImplemented,
        getTypeReferenceDirectivesForSymbol: ts.notImplemented,
        isLiteralConstDeclaration: ts.notImplemented,
        getJsxFactoryEntity: ts.notImplemented,
        getJsxFragmentFactoryEntity: ts.notImplemented,
        getAllAccessorDeclarations: ts.notImplemented,
        getSymbolOfExternalModuleSpecifier: ts.notImplemented,
        isBindingCapturedByNode: ts.notImplemented,
        getDeclarationStatementsForSourceFile: ts.notImplemented,
        isImportRequiredByAugmentation: ts.notImplemented,
    };
    function createSourceFilesFromBundleBuildInfo(bundle, buildInfoDirectory, host) {
        var _a;
        var jsBundle = ts.Debug.checkDefined(bundle.js);
        var prologueMap = ((_a = jsBundle.sources) === null || _a === void 0 ? void 0 : _a.prologues) && ts.arrayToMap(jsBundle.sources.prologues, function (prologueInfo) { return prologueInfo.file; });
        return bundle.sourceFiles.map(function (fileName, index) {
            var _a, _b;
            var prologueInfo = prologueMap === null || prologueMap === void 0 ? void 0 : prologueMap.get(index);
            var statements = prologueInfo === null || prologueInfo === void 0 ? void 0 : prologueInfo.directives.map(function (directive) {
                var literal = ts.setTextRange(ts.factory.createStringLiteral(directive.expression.text), directive.expression);
                var statement = ts.setTextRange(ts.factory.createExpressionStatement(literal), directive);
                ts.setParent(literal, statement);
                return statement;
            });
            var eofToken = ts.factory.createToken(1 /* SyntaxKind.EndOfFileToken */);
            var sourceFile = ts.factory.createSourceFile(statements !== null && statements !== void 0 ? statements : [], eofToken, 0 /* NodeFlags.None */);
            sourceFile.fileName = ts.getRelativePathFromDirectory(host.getCurrentDirectory(), ts.getNormalizedAbsolutePath(fileName, buildInfoDirectory), !host.useCaseSensitiveFileNames());
            sourceFile.text = (_a = prologueInfo === null || prologueInfo === void 0 ? void 0 : prologueInfo.text) !== null && _a !== void 0 ? _a : "";
            ts.setTextRangePosWidth(sourceFile, 0, (_b = prologueInfo === null || prologueInfo === void 0 ? void 0 : prologueInfo.text.length) !== null && _b !== void 0 ? _b : 0);
            ts.setEachParent(sourceFile.statements, sourceFile);
            ts.setTextRangePosWidth(eofToken, sourceFile.end, 0);
            ts.setParent(eofToken, sourceFile);
            return sourceFile;
        });
    }
    /*@internal*/
    function emitUsingBuildInfo(config, host, getCommandLine, customTransformers) {
        var _a = getOutputPathsForBundle(config.options, /*forceDtsPaths*/ false), buildInfoPath = _a.buildInfoPath, jsFilePath = _a.jsFilePath, sourceMapFilePath = _a.sourceMapFilePath, declarationFilePath = _a.declarationFilePath, declarationMapPath = _a.declarationMapPath;
        var buildInfoText = host.readFile(ts.Debug.checkDefined(buildInfoPath));
        if (!buildInfoText)
            return buildInfoPath;
        var jsFileText = host.readFile(ts.Debug.checkDefined(jsFilePath));
        if (!jsFileText)
            return jsFilePath;
        var sourceMapText = sourceMapFilePath && host.readFile(sourceMapFilePath);
        // error if no source map or for now if inline sourcemap
        if ((sourceMapFilePath && !sourceMapText) || config.options.inlineSourceMap)
            return sourceMapFilePath || "inline sourcemap decoding";
        // read declaration text
        var declarationText = declarationFilePath && host.readFile(declarationFilePath);
        if (declarationFilePath && !declarationText)
            return declarationFilePath;
        var declarationMapText = declarationMapPath && host.readFile(declarationMapPath);
        // error if no source map or for now if inline sourcemap
        if ((declarationMapPath && !declarationMapText) || config.options.inlineSourceMap)
            return declarationMapPath || "inline sourcemap decoding";
        var buildInfo = getBuildInfo(buildInfoText);
        if (!buildInfo.bundle || !buildInfo.bundle.js || (declarationText && !buildInfo.bundle.dts))
            return buildInfoPath;
        var buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(buildInfoPath, host.getCurrentDirectory()));
        var ownPrependInput = ts.createInputFiles(jsFileText, declarationText, sourceMapFilePath, sourceMapText, declarationMapPath, declarationMapText, jsFilePath, declarationFilePath, buildInfoPath, buildInfo, 
        /*onlyOwnText*/ true);
        var outputFiles = [];
        var prependNodes = ts.createPrependNodes(config.projectReferences, getCommandLine, function (f) { return host.readFile(f); });
        var sourceFilesForJsEmit = createSourceFilesFromBundleBuildInfo(buildInfo.bundle, buildInfoDirectory, host);
        var emitHost = {
            getPrependNodes: ts.memoize(function () { return __spreadArray(__spreadArray([], prependNodes, true), [ownPrependInput], false); }),
            getCanonicalFileName: host.getCanonicalFileName,
            getCommonSourceDirectory: function () { return ts.getNormalizedAbsolutePath(buildInfo.bundle.commonSourceDirectory, buildInfoDirectory); },
            getCompilerOptions: function () { return config.options; },
            getCurrentDirectory: function () { return host.getCurrentDirectory(); },
            getNewLine: function () { return host.getNewLine(); },
            getSourceFile: ts.returnUndefined,
            getSourceFileByPath: ts.returnUndefined,
            getSourceFiles: function () { return sourceFilesForJsEmit; },
            getLibFileFromReference: ts.notImplemented,
            isSourceFileFromExternalLibrary: ts.returnFalse,
            getResolvedProjectReferenceToRedirect: ts.returnUndefined,
            getProjectReferenceRedirect: ts.returnUndefined,
            isSourceOfProjectReferenceRedirect: ts.returnFalse,
            writeFile: function (name, text, writeByteOrderMark) {
                switch (name) {
                    case jsFilePath:
                        if (jsFileText === text)
                            return;
                        break;
                    case sourceMapFilePath:
                        if (sourceMapText === text)
                            return;
                        break;
                    case buildInfoPath:
                        var newBuildInfo = getBuildInfo(text);
                        newBuildInfo.program = buildInfo.program;
                        // Update sourceFileInfo
                        var _a = buildInfo.bundle, js = _a.js, dts = _a.dts, sourceFiles = _a.sourceFiles;
                        newBuildInfo.bundle.js.sources = js.sources;
                        if (dts) {
                            newBuildInfo.bundle.dts.sources = dts.sources;
                        }
                        newBuildInfo.bundle.sourceFiles = sourceFiles;
                        outputFiles.push({ name: name, text: getBuildInfoText(newBuildInfo), writeByteOrderMark: writeByteOrderMark });
                        return;
                    case declarationFilePath:
                        if (declarationText === text)
                            return;
                        break;
                    case declarationMapPath:
                        if (declarationMapText === text)
                            return;
                        break;
                    default:
                        ts.Debug.fail("Unexpected path: ".concat(name));
                }
                outputFiles.push({ name: name, text: text, writeByteOrderMark: writeByteOrderMark });
            },
            isEmitBlocked: ts.returnFalse,
            readFile: function (f) { return host.readFile(f); },
            fileExists: function (f) { return host.fileExists(f); },
            useCaseSensitiveFileNames: function () { return host.useCaseSensitiveFileNames(); },
            getProgramBuildInfo: ts.returnUndefined,
            getSourceFileFromReference: ts.returnUndefined,
            redirectTargetsMap: ts.createMultiMap(),
            getFileIncludeReasons: ts.notImplemented,
        };
        emitFiles(ts.notImplementedResolver, emitHost, 
        /*targetSourceFile*/ undefined, ts.getTransformers(config.options, customTransformers));
        return outputFiles;
    }
    ts.emitUsingBuildInfo = emitUsingBuildInfo;
    var PipelinePhase;
    (function (PipelinePhase) {
        PipelinePhase[PipelinePhase["Notification"] = 0] = "Notification";
        PipelinePhase[PipelinePhase["Substitution"] = 1] = "Substitution";
        PipelinePhase[PipelinePhase["Comments"] = 2] = "Comments";
        PipelinePhase[PipelinePhase["SourceMaps"] = 3] = "SourceMaps";
        PipelinePhase[PipelinePhase["Emit"] = 4] = "Emit";
    })(PipelinePhase || (PipelinePhase = {}));
    function createPrinter(printerOptions, handlers) {
        if (printerOptions === void 0) { printerOptions = {}; }
        if (handlers === void 0) { handlers = {}; }
        var hasGlobalName = handlers.hasGlobalName, _a = handlers.onEmitNode, onEmitNode = _a === void 0 ? ts.noEmitNotification : _a, isEmitNotificationEnabled = handlers.isEmitNotificationEnabled, _b = handlers.substituteNode, substituteNode = _b === void 0 ? ts.noEmitSubstitution : _b, onBeforeEmitNode = handlers.onBeforeEmitNode, onAfterEmitNode = handlers.onAfterEmitNode, onBeforeEmitNodeArray = handlers.onBeforeEmitNodeArray, onAfterEmitNodeArray = handlers.onAfterEmitNodeArray, onBeforeEmitToken = handlers.onBeforeEmitToken, onAfterEmitToken = handlers.onAfterEmitToken;
        var extendedDiagnostics = !!printerOptions.extendedDiagnostics;
        var newLine = ts.getNewLineCharacter(printerOptions);
        var moduleKind = ts.getEmitModuleKind(printerOptions);
        var bundledHelpers = new ts.Map();
        var currentSourceFile;
        var nodeIdToGeneratedName; // Map of generated names for specific nodes.
        var autoGeneratedIdToGeneratedName; // Map of generated names for temp and loop variables.
        var generatedNames; // Set of names generated by the NameGenerator.
        var tempFlagsStack; // Stack of enclosing name generation scopes.
        var tempFlags; // TempFlags for the current name generation scope.
        var reservedNamesStack; // Stack of TempFlags reserved in enclosing name generation scopes.
        var reservedNames; // TempFlags to reserve in nested name generation scopes.
        var preserveSourceNewlines = printerOptions.preserveSourceNewlines; // Can be overridden inside nodes with the `IgnoreSourceNewlines` emit flag.
        var nextListElementPos; // See comment in `getLeadingLineTerminatorCount`.
        var writer;
        var ownWriter; // Reusable `EmitTextWriter` for basic printing.
        var write = writeBase;
        var isOwnFileEmit;
        var bundleFileInfo = printerOptions.writeBundleFileInfo ? { sections: [] } : undefined;
        var relativeToBuildInfo = bundleFileInfo ? ts.Debug.checkDefined(printerOptions.relativeToBuildInfo) : undefined;
        var recordInternalSection = printerOptions.recordInternalSection;
        var sourceFileTextPos = 0;
        var sourceFileTextKind = "text" /* BundleFileSectionKind.Text */;
        // Source Maps
        var sourceMapsDisabled = true;
        var sourceMapGenerator;
        var sourceMapSource;
        var sourceMapSourceIndex = -1;
        var mostRecentlyAddedSourceMapSource;
        var mostRecentlyAddedSourceMapSourceIndex = -1;
        // Comments
        var containerPos = -1;
        var containerEnd = -1;
        var declarationListContainerEnd = -1;
        var currentLineMap;
        var detachedCommentsInfo;
        var hasWrittenComment = false;
        var commentsDisabled = !!printerOptions.removeComments;
        var lastSubstitution;
        var currentParenthesizerRule;
        var _c = ts.performance.createTimerIf(extendedDiagnostics, "commentTime", "beforeComment", "afterComment"), enterComment = _c.enter, exitComment = _c.exit;
        var parenthesizer = ts.factory.parenthesizer;
        var typeArgumentParenthesizerRuleSelector = {
            select: function (index) { return index === 0 ? parenthesizer.parenthesizeLeadingTypeArgument : undefined; }
        };
        var emitBinaryExpression = createEmitBinaryExpression();
        reset();
        return {
            // public API
            printNode: printNode,
            printList: printList,
            printFile: printFile,
            printBundle: printBundle,
            // internal API
            writeNode: writeNode,
            writeList: writeList,
            writeFile: writeFile,
            writeBundle: writeBundle,
            bundleFileInfo: bundleFileInfo
        };
        function printNode(hint, node, sourceFile) {
            switch (hint) {
                case 0 /* EmitHint.SourceFile */:
                    ts.Debug.assert(ts.isSourceFile(node), "Expected a SourceFile node.");
                    break;
                case 2 /* EmitHint.IdentifierName */:
                    ts.Debug.assert(ts.isIdentifier(node), "Expected an Identifier node.");
                    break;
                case 1 /* EmitHint.Expression */:
                    ts.Debug.assert(ts.isExpression(node), "Expected an Expression node.");
                    break;
            }
            switch (node.kind) {
                case 305 /* SyntaxKind.SourceFile */: return printFile(node);
                case 306 /* SyntaxKind.Bundle */: return printBundle(node);
                case 307 /* SyntaxKind.UnparsedSource */: return printUnparsedSource(node);
            }
            writeNode(hint, node, sourceFile, beginPrint());
            return endPrint();
        }
        function printList(format, nodes, sourceFile) {
            writeList(format, nodes, sourceFile, beginPrint());
            return endPrint();
        }
        function printBundle(bundle) {
            writeBundle(bundle, beginPrint(), /*sourceMapEmitter*/ undefined);
            return endPrint();
        }
        function printFile(sourceFile) {
            writeFile(sourceFile, beginPrint(), /*sourceMapEmitter*/ undefined);
            return endPrint();
        }
        function printUnparsedSource(unparsed) {
            writeUnparsedSource(unparsed, beginPrint());
            return endPrint();
        }
        function writeNode(hint, node, sourceFile, output) {
            var previousWriter = writer;
            setWriter(output, /*_sourceMapGenerator*/ undefined);
            print(hint, node, sourceFile);
            reset();
            writer = previousWriter;
        }
        function writeList(format, nodes, sourceFile, output) {
            var previousWriter = writer;
            setWriter(output, /*_sourceMapGenerator*/ undefined);
            if (sourceFile) {
                setSourceFile(sourceFile);
            }
            emitList(/*parentNode*/ undefined, nodes, format);
            reset();
            writer = previousWriter;
        }
        function getTextPosWithWriteLine() {
            return writer.getTextPosWithWriteLine ? writer.getTextPosWithWriteLine() : writer.getTextPos();
        }
        function updateOrPushBundleFileTextLike(pos, end, kind) {
            var last = ts.lastOrUndefined(bundleFileInfo.sections);
            if (last && last.kind === kind) {
                last.end = end;
            }
            else {
                bundleFileInfo.sections.push({ pos: pos, end: end, kind: kind });
            }
        }
        function recordBundleFileInternalSectionStart(node) {
            if (recordInternalSection &&
                bundleFileInfo &&
                currentSourceFile &&
                (ts.isDeclaration(node) || ts.isVariableStatement(node)) &&
                ts.isInternalDeclaration(node, currentSourceFile) &&
                sourceFileTextKind !== "internal" /* BundleFileSectionKind.Internal */) {
                var prevSourceFileTextKind = sourceFileTextKind;
                recordBundleFileTextLikeSection(writer.getTextPos());
                sourceFileTextPos = getTextPosWithWriteLine();
                sourceFileTextKind = "internal" /* BundleFileSectionKind.Internal */;
                return prevSourceFileTextKind;
            }
            return undefined;
        }
        function recordBundleFileInternalSectionEnd(prevSourceFileTextKind) {
            if (prevSourceFileTextKind) {
                recordBundleFileTextLikeSection(writer.getTextPos());
                sourceFileTextPos = getTextPosWithWriteLine();
                sourceFileTextKind = prevSourceFileTextKind;
            }
        }
        function recordBundleFileTextLikeSection(end) {
            if (sourceFileTextPos < end) {
                updateOrPushBundleFileTextLike(sourceFileTextPos, end, sourceFileTextKind);
                return true;
            }
            return false;
        }
        function writeBundle(bundle, output, sourceMapGenerator) {
            var _a;
            isOwnFileEmit = false;
            var previousWriter = writer;
            setWriter(output, sourceMapGenerator);
            emitShebangIfNeeded(bundle);
            emitPrologueDirectivesIfNeeded(bundle);
            emitHelpers(bundle);
            emitSyntheticTripleSlashReferencesIfNeeded(bundle);
            for (var _b = 0, _c = bundle.prepends; _b < _c.length; _b++) {
                var prepend = _c[_b];
                writeLine();
                var pos = writer.getTextPos();
                var savedSections = bundleFileInfo && bundleFileInfo.sections;
                if (savedSections)
                    bundleFileInfo.sections = [];
                print(4 /* EmitHint.Unspecified */, prepend, /*sourceFile*/ undefined);
                if (bundleFileInfo) {
                    var newSections = bundleFileInfo.sections;
                    bundleFileInfo.sections = savedSections;
                    if (prepend.oldFileOfCurrentEmit)
                        (_a = bundleFileInfo.sections).push.apply(_a, newSections);
                    else {
                        newSections.forEach(function (section) { return ts.Debug.assert(ts.isBundleFileTextLike(section)); });
                        bundleFileInfo.sections.push({
                            pos: pos,
                            end: writer.getTextPos(),
                            kind: "prepend" /* BundleFileSectionKind.Prepend */,
                            data: relativeToBuildInfo(prepend.fileName),
                            texts: newSections
                        });
                    }
                }
            }
            sourceFileTextPos = getTextPosWithWriteLine();
            for (var _d = 0, _e = bundle.sourceFiles; _d < _e.length; _d++) {
                var sourceFile = _e[_d];
                print(0 /* EmitHint.SourceFile */, sourceFile, sourceFile);
            }
            if (bundleFileInfo && bundle.sourceFiles.length) {
                var end = writer.getTextPos();
                if (recordBundleFileTextLikeSection(end)) {
                    // Store prologues
                    var prologues = getPrologueDirectivesFromBundledSourceFiles(bundle);
                    if (prologues) {
                        if (!bundleFileInfo.sources)
                            bundleFileInfo.sources = {};
                        bundleFileInfo.sources.prologues = prologues;
                    }
                    // Store helpes
                    var helpers = getHelpersFromBundledSourceFiles(bundle);
                    if (helpers) {
                        if (!bundleFileInfo.sources)
                            bundleFileInfo.sources = {};
                        bundleFileInfo.sources.helpers = helpers;
                    }
                }
            }
            reset();
            writer = previousWriter;
        }
        function writeUnparsedSource(unparsed, output) {
            var previousWriter = writer;
            setWriter(output, /*_sourceMapGenerator*/ undefined);
            print(4 /* EmitHint.Unspecified */, unparsed, /*sourceFile*/ undefined);
            reset();
            writer = previousWriter;
        }
        function writeFile(sourceFile, output, sourceMapGenerator) {
            isOwnFileEmit = true;
            var previousWriter = writer;
            setWriter(output, sourceMapGenerator);
            emitShebangIfNeeded(sourceFile);
            emitPrologueDirectivesIfNeeded(sourceFile);
            print(0 /* EmitHint.SourceFile */, sourceFile, sourceFile);
            reset();
            writer = previousWriter;
        }
        function beginPrint() {
            return ownWriter || (ownWriter = ts.createTextWriter(newLine));
        }
        function endPrint() {
            var text = ownWriter.getText();
            ownWriter.clear();
            return text;
        }
        function print(hint, node, sourceFile) {
            if (sourceFile) {
                setSourceFile(sourceFile);
            }
            pipelineEmit(hint, node, /*parenthesizerRule*/ undefined);
        }
        function setSourceFile(sourceFile) {
            currentSourceFile = sourceFile;
            currentLineMap = undefined;
            detachedCommentsInfo = undefined;
            if (sourceFile) {
                setSourceMapSource(sourceFile);
            }
        }
        function setWriter(_writer, _sourceMapGenerator) {
            if (_writer && printerOptions.omitTrailingSemicolon) {
                _writer = ts.getTrailingSemicolonDeferringWriter(_writer);
            }
            writer = _writer; // TODO: GH#18217
            sourceMapGenerator = _sourceMapGenerator;
            sourceMapsDisabled = !writer || !sourceMapGenerator;
        }
        function reset() {
            nodeIdToGeneratedName = [];
            autoGeneratedIdToGeneratedName = [];
            generatedNames = new ts.Set();
            tempFlagsStack = [];
            tempFlags = 0 /* TempFlags.Auto */;
            reservedNamesStack = [];
            currentSourceFile = undefined;
            currentLineMap = undefined;
            detachedCommentsInfo = undefined;
            setWriter(/*output*/ undefined, /*_sourceMapGenerator*/ undefined);
        }
        function getCurrentLineMap() {
            return currentLineMap || (currentLineMap = ts.getLineStarts(ts.Debug.checkDefined(currentSourceFile)));
        }
        function emit(node, parenthesizerRule) {
            if (node === undefined)
                return;
            var prevSourceFileTextKind = recordBundleFileInternalSectionStart(node);
            pipelineEmit(4 /* EmitHint.Unspecified */, node, parenthesizerRule);
            recordBundleFileInternalSectionEnd(prevSourceFileTextKind);
        }
        function emitIdentifierName(node) {
            if (node === undefined)
                return;
            pipelineEmit(2 /* EmitHint.IdentifierName */, node, /*parenthesizerRule*/ undefined);
        }
        function emitExpression(node, parenthesizerRule) {
            if (node === undefined)
                return;
            pipelineEmit(1 /* EmitHint.Expression */, node, parenthesizerRule);
        }
        function emitJsxAttributeValue(node) {
            pipelineEmit(ts.isStringLiteral(node) ? 6 /* EmitHint.JsxAttributeValue */ : 4 /* EmitHint.Unspecified */, node);
        }
        function beforeEmitNode(node) {
            if (preserveSourceNewlines && (ts.getEmitFlags(node) & 134217728 /* EmitFlags.IgnoreSourceNewlines */)) {
                preserveSourceNewlines = false;
            }
        }
        function afterEmitNode(savedPreserveSourceNewlines) {
            preserveSourceNewlines = savedPreserveSourceNewlines;
        }
        function pipelineEmit(emitHint, node, parenthesizerRule) {
            currentParenthesizerRule = parenthesizerRule;
            var pipelinePhase = getPipelinePhase(0 /* PipelinePhase.Notification */, emitHint, node);
            pipelinePhase(emitHint, node);
            currentParenthesizerRule = undefined;
        }
        function shouldEmitComments(node) {
            return !commentsDisabled && !ts.isSourceFile(node);
        }
        function shouldEmitSourceMaps(node) {
            return !sourceMapsDisabled &&
                !ts.isSourceFile(node) &&
                !ts.isInJsonFile(node) &&
                !ts.isUnparsedSource(node) &&
                !ts.isUnparsedPrepend(node);
        }
        function getPipelinePhase(phase, emitHint, node) {
            switch (phase) {
                case 0 /* PipelinePhase.Notification */:
                    if (onEmitNode !== ts.noEmitNotification && (!isEmitNotificationEnabled || isEmitNotificationEnabled(node))) {
                        return pipelineEmitWithNotification;
                    }
                // falls through
                case 1 /* PipelinePhase.Substitution */:
                    if (substituteNode !== ts.noEmitSubstitution && (lastSubstitution = substituteNode(emitHint, node) || node) !== node) {
                        if (currentParenthesizerRule) {
                            lastSubstitution = currentParenthesizerRule(lastSubstitution);
                        }
                        return pipelineEmitWithSubstitution;
                    }
                // falls through
                case 2 /* PipelinePhase.Comments */:
                    if (shouldEmitComments(node)) {
                        return pipelineEmitWithComments;
                    }
                // falls through
                case 3 /* PipelinePhase.SourceMaps */:
                    if (shouldEmitSourceMaps(node)) {
                        return pipelineEmitWithSourceMaps;
                    }
                // falls through
                case 4 /* PipelinePhase.Emit */:
                    return pipelineEmitWithHint;
                default:
                    return ts.Debug.assertNever(phase);
            }
        }
        function getNextPipelinePhase(currentPhase, emitHint, node) {
            return getPipelinePhase(currentPhase + 1, emitHint, node);
        }
        function pipelineEmitWithNotification(hint, node) {
            var pipelinePhase = getNextPipelinePhase(0 /* PipelinePhase.Notification */, hint, node);
            onEmitNode(hint, node, pipelinePhase);
        }
        function pipelineEmitWithHint(hint, node) {
            onBeforeEmitNode === null || onBeforeEmitNode === void 0 ? void 0 : onBeforeEmitNode(node);
            if (preserveSourceNewlines) {
                var savedPreserveSourceNewlines = preserveSourceNewlines;
                beforeEmitNode(node);
                pipelineEmitWithHintWorker(hint, node);
                afterEmitNode(savedPreserveSourceNewlines);
            }
            else {
                pipelineEmitWithHintWorker(hint, node);
            }
            onAfterEmitNode === null || onAfterEmitNode === void 0 ? void 0 : onAfterEmitNode(node);
            // clear the parenthesizer rule as we ascend
            currentParenthesizerRule = undefined;
        }
        function pipelineEmitWithHintWorker(hint, node, allowSnippets) {
            if (allowSnippets === void 0) { allowSnippets = true; }
            if (allowSnippets) {
                var snippet = ts.getSnippetElement(node);
                if (snippet) {
                    return emitSnippetNode(hint, node, snippet);
                }
            }
            if (hint === 0 /* EmitHint.SourceFile */)
                return emitSourceFile(ts.cast(node, ts.isSourceFile));
            if (hint === 2 /* EmitHint.IdentifierName */)
                return emitIdentifier(ts.cast(node, ts.isIdentifier));
            if (hint === 6 /* EmitHint.JsxAttributeValue */)
                return emitLiteral(ts.cast(node, ts.isStringLiteral), /*jsxAttributeEscape*/ true);
            if (hint === 3 /* EmitHint.MappedTypeParameter */)
                return emitMappedTypeParameter(ts.cast(node, ts.isTypeParameterDeclaration));
            if (hint === 5 /* EmitHint.EmbeddedStatement */) {
                ts.Debug.assertNode(node, ts.isEmptyStatement);
                return emitEmptyStatement(/*isEmbeddedStatement*/ true);
            }
            if (hint === 4 /* EmitHint.Unspecified */) {
                switch (node.kind) {
                    // Pseudo-literals
                    case 15 /* SyntaxKind.TemplateHead */:
                    case 16 /* SyntaxKind.TemplateMiddle */:
                    case 17 /* SyntaxKind.TemplateTail */:
                        return emitLiteral(node, /*jsxAttributeEscape*/ false);
                    // Identifiers
                    case 79 /* SyntaxKind.Identifier */:
                        return emitIdentifier(node);
                    // PrivateIdentifiers
                    case 80 /* SyntaxKind.PrivateIdentifier */:
                        return emitPrivateIdentifier(node);
                    // Parse tree nodes
                    // Names
                    case 161 /* SyntaxKind.QualifiedName */:
                        return emitQualifiedName(node);
                    case 162 /* SyntaxKind.ComputedPropertyName */:
                        return emitComputedPropertyName(node);
                    // Signature elements
                    case 163 /* SyntaxKind.TypeParameter */:
                        return emitTypeParameter(node);
                    case 164 /* SyntaxKind.Parameter */:
                        return emitParameter(node);
                    case 165 /* SyntaxKind.Decorator */:
                        return emitDecorator(node);
                    // Type members
                    case 166 /* SyntaxKind.PropertySignature */:
                        return emitPropertySignature(node);
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                        return emitPropertyDeclaration(node);
                    case 168 /* SyntaxKind.MethodSignature */:
                        return emitMethodSignature(node);
                    case 169 /* SyntaxKind.MethodDeclaration */:
                        return emitMethodDeclaration(node);
                    case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                        return emitClassStaticBlockDeclaration(node);
                    case 171 /* SyntaxKind.Constructor */:
                        return emitConstructor(node);
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                        return emitAccessorDeclaration(node);
                    case 174 /* SyntaxKind.CallSignature */:
                        return emitCallSignature(node);
                    case 175 /* SyntaxKind.ConstructSignature */:
                        return emitConstructSignature(node);
                    case 176 /* SyntaxKind.IndexSignature */:
                        return emitIndexSignature(node);
                    // Types
                    case 177 /* SyntaxKind.TypePredicate */:
                        return emitTypePredicate(node);
                    case 178 /* SyntaxKind.TypeReference */:
                        return emitTypeReference(node);
                    case 179 /* SyntaxKind.FunctionType */:
                        return emitFunctionType(node);
                    case 180 /* SyntaxKind.ConstructorType */:
                        return emitConstructorType(node);
                    case 181 /* SyntaxKind.TypeQuery */:
                        return emitTypeQuery(node);
                    case 182 /* SyntaxKind.TypeLiteral */:
                        return emitTypeLiteral(node);
                    case 183 /* SyntaxKind.ArrayType */:
                        return emitArrayType(node);
                    case 184 /* SyntaxKind.TupleType */:
                        return emitTupleType(node);
                    case 185 /* SyntaxKind.OptionalType */:
                        return emitOptionalType(node);
                    // SyntaxKind.RestType is handled below
                    case 187 /* SyntaxKind.UnionType */:
                        return emitUnionType(node);
                    case 188 /* SyntaxKind.IntersectionType */:
                        return emitIntersectionType(node);
                    case 189 /* SyntaxKind.ConditionalType */:
                        return emitConditionalType(node);
                    case 190 /* SyntaxKind.InferType */:
                        return emitInferType(node);
                    case 191 /* SyntaxKind.ParenthesizedType */:
                        return emitParenthesizedType(node);
                    case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                        return emitExpressionWithTypeArguments(node);
                    case 192 /* SyntaxKind.ThisType */:
                        return emitThisType();
                    case 193 /* SyntaxKind.TypeOperator */:
                        return emitTypeOperator(node);
                    case 194 /* SyntaxKind.IndexedAccessType */:
                        return emitIndexedAccessType(node);
                    case 195 /* SyntaxKind.MappedType */:
                        return emitMappedType(node);
                    case 196 /* SyntaxKind.LiteralType */:
                        return emitLiteralType(node);
                    case 197 /* SyntaxKind.NamedTupleMember */:
                        return emitNamedTupleMember(node);
                    case 198 /* SyntaxKind.TemplateLiteralType */:
                        return emitTemplateType(node);
                    case 199 /* SyntaxKind.TemplateLiteralTypeSpan */:
                        return emitTemplateTypeSpan(node);
                    case 200 /* SyntaxKind.ImportType */:
                        return emitImportTypeNode(node);
                    // Binding patterns
                    case 201 /* SyntaxKind.ObjectBindingPattern */:
                        return emitObjectBindingPattern(node);
                    case 202 /* SyntaxKind.ArrayBindingPattern */:
                        return emitArrayBindingPattern(node);
                    case 203 /* SyntaxKind.BindingElement */:
                        return emitBindingElement(node);
                    // Misc
                    case 233 /* SyntaxKind.TemplateSpan */:
                        return emitTemplateSpan(node);
                    case 234 /* SyntaxKind.SemicolonClassElement */:
                        return emitSemicolonClassElement();
                    // Statements
                    case 235 /* SyntaxKind.Block */:
                        return emitBlock(node);
                    case 237 /* SyntaxKind.VariableStatement */:
                        return emitVariableStatement(node);
                    case 236 /* SyntaxKind.EmptyStatement */:
                        return emitEmptyStatement(/*isEmbeddedStatement*/ false);
                    case 238 /* SyntaxKind.ExpressionStatement */:
                        return emitExpressionStatement(node);
                    case 239 /* SyntaxKind.IfStatement */:
                        return emitIfStatement(node);
                    case 240 /* SyntaxKind.DoStatement */:
                        return emitDoStatement(node);
                    case 241 /* SyntaxKind.WhileStatement */:
                        return emitWhileStatement(node);
                    case 242 /* SyntaxKind.ForStatement */:
                        return emitForStatement(node);
                    case 243 /* SyntaxKind.ForInStatement */:
                        return emitForInStatement(node);
                    case 244 /* SyntaxKind.ForOfStatement */:
                        return emitForOfStatement(node);
                    case 245 /* SyntaxKind.ContinueStatement */:
                        return emitContinueStatement(node);
                    case 246 /* SyntaxKind.BreakStatement */:
                        return emitBreakStatement(node);
                    case 247 /* SyntaxKind.ReturnStatement */:
                        return emitReturnStatement(node);
                    case 248 /* SyntaxKind.WithStatement */:
                        return emitWithStatement(node);
                    case 249 /* SyntaxKind.SwitchStatement */:
                        return emitSwitchStatement(node);
                    case 250 /* SyntaxKind.LabeledStatement */:
                        return emitLabeledStatement(node);
                    case 251 /* SyntaxKind.ThrowStatement */:
                        return emitThrowStatement(node);
                    case 252 /* SyntaxKind.TryStatement */:
                        return emitTryStatement(node);
                    case 253 /* SyntaxKind.DebuggerStatement */:
                        return emitDebuggerStatement(node);
                    // Declarations
                    case 254 /* SyntaxKind.VariableDeclaration */:
                        return emitVariableDeclaration(node);
                    case 255 /* SyntaxKind.VariableDeclarationList */:
                        return emitVariableDeclarationList(node);
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                        return emitFunctionDeclaration(node);
                    case 257 /* SyntaxKind.ClassDeclaration */:
                        return emitClassDeclaration(node);
                    case 258 /* SyntaxKind.InterfaceDeclaration */:
                        return emitInterfaceDeclaration(node);
                    case 259 /* SyntaxKind.TypeAliasDeclaration */:
                        return emitTypeAliasDeclaration(node);
                    case 260 /* SyntaxKind.EnumDeclaration */:
                        return emitEnumDeclaration(node);
                    case 261 /* SyntaxKind.ModuleDeclaration */:
                        return emitModuleDeclaration(node);
                    case 262 /* SyntaxKind.ModuleBlock */:
                        return emitModuleBlock(node);
                    case 263 /* SyntaxKind.CaseBlock */:
                        return emitCaseBlock(node);
                    case 264 /* SyntaxKind.NamespaceExportDeclaration */:
                        return emitNamespaceExportDeclaration(node);
                    case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                        return emitImportEqualsDeclaration(node);
                    case 266 /* SyntaxKind.ImportDeclaration */:
                        return emitImportDeclaration(node);
                    case 267 /* SyntaxKind.ImportClause */:
                        return emitImportClause(node);
                    case 268 /* SyntaxKind.NamespaceImport */:
                        return emitNamespaceImport(node);
                    case 274 /* SyntaxKind.NamespaceExport */:
                        return emitNamespaceExport(node);
                    case 269 /* SyntaxKind.NamedImports */:
                        return emitNamedImports(node);
                    case 270 /* SyntaxKind.ImportSpecifier */:
                        return emitImportSpecifier(node);
                    case 271 /* SyntaxKind.ExportAssignment */:
                        return emitExportAssignment(node);
                    case 272 /* SyntaxKind.ExportDeclaration */:
                        return emitExportDeclaration(node);
                    case 273 /* SyntaxKind.NamedExports */:
                        return emitNamedExports(node);
                    case 275 /* SyntaxKind.ExportSpecifier */:
                        return emitExportSpecifier(node);
                    case 293 /* SyntaxKind.AssertClause */:
                        return emitAssertClause(node);
                    case 294 /* SyntaxKind.AssertEntry */:
                        return emitAssertEntry(node);
                    case 276 /* SyntaxKind.MissingDeclaration */:
                        return;
                    // Module references
                    case 277 /* SyntaxKind.ExternalModuleReference */:
                        return emitExternalModuleReference(node);
                    // JSX (non-expression)
                    case 11 /* SyntaxKind.JsxText */:
                        return emitJsxText(node);
                    case 280 /* SyntaxKind.JsxOpeningElement */:
                    case 283 /* SyntaxKind.JsxOpeningFragment */:
                        return emitJsxOpeningElementOrFragment(node);
                    case 281 /* SyntaxKind.JsxClosingElement */:
                    case 284 /* SyntaxKind.JsxClosingFragment */:
                        return emitJsxClosingElementOrFragment(node);
                    case 285 /* SyntaxKind.JsxAttribute */:
                        return emitJsxAttribute(node);
                    case 286 /* SyntaxKind.JsxAttributes */:
                        return emitJsxAttributes(node);
                    case 287 /* SyntaxKind.JsxSpreadAttribute */:
                        return emitJsxSpreadAttribute(node);
                    case 288 /* SyntaxKind.JsxExpression */:
                        return emitJsxExpression(node);
                    // Clauses
                    case 289 /* SyntaxKind.CaseClause */:
                        return emitCaseClause(node);
                    case 290 /* SyntaxKind.DefaultClause */:
                        return emitDefaultClause(node);
                    case 291 /* SyntaxKind.HeritageClause */:
                        return emitHeritageClause(node);
                    case 292 /* SyntaxKind.CatchClause */:
                        return emitCatchClause(node);
                    // Property assignments
                    case 296 /* SyntaxKind.PropertyAssignment */:
                        return emitPropertyAssignment(node);
                    case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                        return emitShorthandPropertyAssignment(node);
                    case 298 /* SyntaxKind.SpreadAssignment */:
                        return emitSpreadAssignment(node);
                    // Enum
                    case 299 /* SyntaxKind.EnumMember */:
                        return emitEnumMember(node);
                    // Unparsed
                    case 300 /* SyntaxKind.UnparsedPrologue */:
                        return writeUnparsedNode(node);
                    case 307 /* SyntaxKind.UnparsedSource */:
                    case 301 /* SyntaxKind.UnparsedPrepend */:
                        return emitUnparsedSourceOrPrepend(node);
                    case 302 /* SyntaxKind.UnparsedText */:
                    case 303 /* SyntaxKind.UnparsedInternalText */:
                        return emitUnparsedTextLike(node);
                    case 304 /* SyntaxKind.UnparsedSyntheticReference */:
                        return emitUnparsedSyntheticReference(node);
                    // Top-level nodes
                    case 305 /* SyntaxKind.SourceFile */:
                        return emitSourceFile(node);
                    case 306 /* SyntaxKind.Bundle */:
                        return ts.Debug.fail("Bundles should be printed using printBundle");
                    // SyntaxKind.UnparsedSource (handled above)
                    case 308 /* SyntaxKind.InputFiles */:
                        return ts.Debug.fail("InputFiles should not be printed");
                    // JSDoc nodes (only used in codefixes currently)
                    case 309 /* SyntaxKind.JSDocTypeExpression */:
                        return emitJSDocTypeExpression(node);
                    case 310 /* SyntaxKind.JSDocNameReference */:
                        return emitJSDocNameReference(node);
                    case 312 /* SyntaxKind.JSDocAllType */:
                        return writePunctuation("*");
                    case 313 /* SyntaxKind.JSDocUnknownType */:
                        return writePunctuation("?");
                    case 314 /* SyntaxKind.JSDocNullableType */:
                        return emitJSDocNullableType(node);
                    case 315 /* SyntaxKind.JSDocNonNullableType */:
                        return emitJSDocNonNullableType(node);
                    case 316 /* SyntaxKind.JSDocOptionalType */:
                        return emitJSDocOptionalType(node);
                    case 317 /* SyntaxKind.JSDocFunctionType */:
                        return emitJSDocFunctionType(node);
                    case 186 /* SyntaxKind.RestType */:
                    case 318 /* SyntaxKind.JSDocVariadicType */:
                        return emitRestOrJSDocVariadicType(node);
                    case 319 /* SyntaxKind.JSDocNamepathType */:
                        return;
                    case 320 /* SyntaxKind.JSDoc */:
                        return emitJSDoc(node);
                    case 322 /* SyntaxKind.JSDocTypeLiteral */:
                        return emitJSDocTypeLiteral(node);
                    case 323 /* SyntaxKind.JSDocSignature */:
                        return emitJSDocSignature(node);
                    case 327 /* SyntaxKind.JSDocTag */:
                    case 332 /* SyntaxKind.JSDocClassTag */:
                    case 337 /* SyntaxKind.JSDocOverrideTag */:
                        return emitJSDocSimpleTag(node);
                    case 328 /* SyntaxKind.JSDocAugmentsTag */:
                    case 329 /* SyntaxKind.JSDocImplementsTag */:
                        return emitJSDocHeritageTag(node);
                    case 330 /* SyntaxKind.JSDocAuthorTag */:
                    case 331 /* SyntaxKind.JSDocDeprecatedTag */:
                        return;
                    // SyntaxKind.JSDocClassTag (see JSDocTag, above)
                    case 333 /* SyntaxKind.JSDocPublicTag */:
                    case 334 /* SyntaxKind.JSDocPrivateTag */:
                    case 335 /* SyntaxKind.JSDocProtectedTag */:
                    case 336 /* SyntaxKind.JSDocReadonlyTag */:
                        return;
                    case 338 /* SyntaxKind.JSDocCallbackTag */:
                        return emitJSDocCallbackTag(node);
                    // SyntaxKind.JSDocEnumTag (see below)
                    case 340 /* SyntaxKind.JSDocParameterTag */:
                    case 347 /* SyntaxKind.JSDocPropertyTag */:
                        return emitJSDocPropertyLikeTag(node);
                    case 339 /* SyntaxKind.JSDocEnumTag */:
                    case 341 /* SyntaxKind.JSDocReturnTag */:
                    case 342 /* SyntaxKind.JSDocThisTag */:
                    case 343 /* SyntaxKind.JSDocTypeTag */:
                        return emitJSDocSimpleTypedTag(node);
                    case 344 /* SyntaxKind.JSDocTemplateTag */:
                        return emitJSDocTemplateTag(node);
                    case 345 /* SyntaxKind.JSDocTypedefTag */:
                        return emitJSDocTypedefTag(node);
                    case 346 /* SyntaxKind.JSDocSeeTag */:
                        return emitJSDocSeeTag(node);
                    // SyntaxKind.JSDocPropertyTag (see JSDocParameterTag, above)
                    // Transformation nodes
                    case 349 /* SyntaxKind.NotEmittedStatement */:
                    case 353 /* SyntaxKind.EndOfDeclarationMarker */:
                    case 352 /* SyntaxKind.MergeDeclarationMarker */:
                        return;
                }
                if (ts.isExpression(node)) {
                    hint = 1 /* EmitHint.Expression */;
                    if (substituteNode !== ts.noEmitSubstitution) {
                        var substitute = substituteNode(hint, node) || node;
                        if (substitute !== node) {
                            node = substitute;
                            if (currentParenthesizerRule) {
                                node = currentParenthesizerRule(node);
                            }
                        }
                    }
                }
            }
            if (hint === 1 /* EmitHint.Expression */) {
                switch (node.kind) {
                    // Literals
                    case 8 /* SyntaxKind.NumericLiteral */:
                    case 9 /* SyntaxKind.BigIntLiteral */:
                        return emitNumericOrBigIntLiteral(node);
                    case 10 /* SyntaxKind.StringLiteral */:
                    case 13 /* SyntaxKind.RegularExpressionLiteral */:
                    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                        return emitLiteral(node, /*jsxAttributeEscape*/ false);
                    // Identifiers
                    case 79 /* SyntaxKind.Identifier */:
                        return emitIdentifier(node);
                    case 80 /* SyntaxKind.PrivateIdentifier */:
                        return emitPrivateIdentifier(node);
                    // Expressions
                    case 204 /* SyntaxKind.ArrayLiteralExpression */:
                        return emitArrayLiteralExpression(node);
                    case 205 /* SyntaxKind.ObjectLiteralExpression */:
                        return emitObjectLiteralExpression(node);
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                        return emitPropertyAccessExpression(node);
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                        return emitElementAccessExpression(node);
                    case 208 /* SyntaxKind.CallExpression */:
                        return emitCallExpression(node);
                    case 209 /* SyntaxKind.NewExpression */:
                        return emitNewExpression(node);
                    case 210 /* SyntaxKind.TaggedTemplateExpression */:
                        return emitTaggedTemplateExpression(node);
                    case 211 /* SyntaxKind.TypeAssertionExpression */:
                        return emitTypeAssertionExpression(node);
                    case 212 /* SyntaxKind.ParenthesizedExpression */:
                        return emitParenthesizedExpression(node);
                    case 213 /* SyntaxKind.FunctionExpression */:
                        return emitFunctionExpression(node);
                    case 214 /* SyntaxKind.ArrowFunction */:
                        return emitArrowFunction(node);
                    case 215 /* SyntaxKind.DeleteExpression */:
                        return emitDeleteExpression(node);
                    case 216 /* SyntaxKind.TypeOfExpression */:
                        return emitTypeOfExpression(node);
                    case 217 /* SyntaxKind.VoidExpression */:
                        return emitVoidExpression(node);
                    case 218 /* SyntaxKind.AwaitExpression */:
                        return emitAwaitExpression(node);
                    case 219 /* SyntaxKind.PrefixUnaryExpression */:
                        return emitPrefixUnaryExpression(node);
                    case 220 /* SyntaxKind.PostfixUnaryExpression */:
                        return emitPostfixUnaryExpression(node);
                    case 221 /* SyntaxKind.BinaryExpression */:
                        return emitBinaryExpression(node);
                    case 222 /* SyntaxKind.ConditionalExpression */:
                        return emitConditionalExpression(node);
                    case 223 /* SyntaxKind.TemplateExpression */:
                        return emitTemplateExpression(node);
                    case 224 /* SyntaxKind.YieldExpression */:
                        return emitYieldExpression(node);
                    case 225 /* SyntaxKind.SpreadElement */:
                        return emitSpreadElement(node);
                    case 226 /* SyntaxKind.ClassExpression */:
                        return emitClassExpression(node);
                    case 227 /* SyntaxKind.OmittedExpression */:
                        return;
                    case 229 /* SyntaxKind.AsExpression */:
                        return emitAsExpression(node);
                    case 230 /* SyntaxKind.NonNullExpression */:
                        return emitNonNullExpression(node);
                    case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                        return emitExpressionWithTypeArguments(node);
                    case 231 /* SyntaxKind.MetaProperty */:
                        return emitMetaProperty(node);
                    case 232 /* SyntaxKind.SyntheticExpression */:
                        return ts.Debug.fail("SyntheticExpression should never be printed.");
                    // JSX
                    case 278 /* SyntaxKind.JsxElement */:
                        return emitJsxElement(node);
                    case 279 /* SyntaxKind.JsxSelfClosingElement */:
                        return emitJsxSelfClosingElement(node);
                    case 282 /* SyntaxKind.JsxFragment */:
                        return emitJsxFragment(node);
                    // Synthesized list
                    case 348 /* SyntaxKind.SyntaxList */:
                        return ts.Debug.fail("SyntaxList should not be printed");
                    // Transformation nodes
                    case 349 /* SyntaxKind.NotEmittedStatement */:
                        return;
                    case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                        return emitPartiallyEmittedExpression(node);
                    case 351 /* SyntaxKind.CommaListExpression */:
                        return emitCommaList(node);
                    case 352 /* SyntaxKind.MergeDeclarationMarker */:
                    case 353 /* SyntaxKind.EndOfDeclarationMarker */:
                        return;
                    case 354 /* SyntaxKind.SyntheticReferenceExpression */:
                        return ts.Debug.fail("SyntheticReferenceExpression should not be printed");
                }
            }
            if (ts.isKeyword(node.kind))
                return writeTokenNode(node, writeKeyword);
            if (ts.isTokenKind(node.kind))
                return writeTokenNode(node, writePunctuation);
            ts.Debug.fail("Unhandled SyntaxKind: ".concat(ts.Debug.formatSyntaxKind(node.kind), "."));
        }
        function emitMappedTypeParameter(node) {
            emit(node.name);
            writeSpace();
            writeKeyword("in");
            writeSpace();
            emit(node.constraint);
        }
        function pipelineEmitWithSubstitution(hint, node) {
            var pipelinePhase = getNextPipelinePhase(1 /* PipelinePhase.Substitution */, hint, node);
            ts.Debug.assertIsDefined(lastSubstitution);
            node = lastSubstitution;
            lastSubstitution = undefined;
            pipelinePhase(hint, node);
        }
        function getHelpersFromBundledSourceFiles(bundle) {
            var result;
            if (moduleKind === ts.ModuleKind.None || printerOptions.noEmitHelpers) {
                return undefined;
            }
            var bundledHelpers = new ts.Map();
            for (var _a = 0, _b = bundle.sourceFiles; _a < _b.length; _a++) {
                var sourceFile = _b[_a];
                var shouldSkip = ts.getExternalHelpersModuleName(sourceFile) !== undefined;
                var helpers = getSortedEmitHelpers(sourceFile);
                if (!helpers)
                    continue;
                for (var _c = 0, helpers_5 = helpers; _c < helpers_5.length; _c++) {
                    var helper = helpers_5[_c];
                    if (!helper.scoped && !shouldSkip && !bundledHelpers.get(helper.name)) {
                        bundledHelpers.set(helper.name, true);
                        (result || (result = [])).push(helper.name);
                    }
                }
            }
            return result;
        }
        function emitHelpers(node) {
            var helpersEmitted = false;
            var bundle = node.kind === 306 /* SyntaxKind.Bundle */ ? node : undefined;
            if (bundle && moduleKind === ts.ModuleKind.None) {
                return;
            }
            var numPrepends = bundle ? bundle.prepends.length : 0;
            var numNodes = bundle ? bundle.sourceFiles.length + numPrepends : 1;
            for (var i = 0; i < numNodes; i++) {
                var currentNode = bundle ? i < numPrepends ? bundle.prepends[i] : bundle.sourceFiles[i - numPrepends] : node;
                var sourceFile = ts.isSourceFile(currentNode) ? currentNode : ts.isUnparsedSource(currentNode) ? undefined : currentSourceFile;
                var shouldSkip = printerOptions.noEmitHelpers || (!!sourceFile && ts.hasRecordedExternalHelpers(sourceFile));
                var shouldBundle = (ts.isSourceFile(currentNode) || ts.isUnparsedSource(currentNode)) && !isOwnFileEmit;
                var helpers = ts.isUnparsedSource(currentNode) ? currentNode.helpers : getSortedEmitHelpers(currentNode);
                if (helpers) {
                    for (var _a = 0, helpers_6 = helpers; _a < helpers_6.length; _a++) {
                        var helper = helpers_6[_a];
                        if (!helper.scoped) {
                            // Skip the helper if it can be skipped and the noEmitHelpers compiler
                            // option is set, or if it can be imported and the importHelpers compiler
                            // option is set.
                            if (shouldSkip)
                                continue;
                            // Skip the helper if it can be bundled but hasn't already been emitted and we
                            // are emitting a bundled module.
                            if (shouldBundle) {
                                if (bundledHelpers.get(helper.name)) {
                                    continue;
                                }
                                bundledHelpers.set(helper.name, true);
                            }
                        }
                        else if (bundle) {
                            // Skip the helper if it is scoped and we are emitting bundled helpers
                            continue;
                        }
                        var pos = getTextPosWithWriteLine();
                        if (typeof helper.text === "string") {
                            writeLines(helper.text);
                        }
                        else {
                            writeLines(helper.text(makeFileLevelOptimisticUniqueName));
                        }
                        if (bundleFileInfo)
                            bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "emitHelpers" /* BundleFileSectionKind.EmitHelpers */, data: helper.name });
                        helpersEmitted = true;
                    }
                }
            }
            return helpersEmitted;
        }
        function getSortedEmitHelpers(node) {
            var helpers = ts.getEmitHelpers(node);
            return helpers && ts.stableSort(helpers, ts.compareEmitHelpers);
        }
        //
        // Literals/Pseudo-literals
        //
        // SyntaxKind.NumericLiteral
        // SyntaxKind.BigIntLiteral
        function emitNumericOrBigIntLiteral(node) {
            emitLiteral(node, /*jsxAttributeEscape*/ false);
        }
        // SyntaxKind.StringLiteral
        // SyntaxKind.RegularExpressionLiteral
        // SyntaxKind.NoSubstitutionTemplateLiteral
        // SyntaxKind.TemplateHead
        // SyntaxKind.TemplateMiddle
        // SyntaxKind.TemplateTail
        function emitLiteral(node, jsxAttributeEscape) {
            var text = getLiteralTextOfNode(node, printerOptions.neverAsciiEscape, jsxAttributeEscape);
            if ((printerOptions.sourceMap || printerOptions.inlineSourceMap)
                && (node.kind === 10 /* SyntaxKind.StringLiteral */ || ts.isTemplateLiteralKind(node.kind))) {
                writeLiteral(text);
            }
            else {
                // Quick info expects all literals to be called with writeStringLiteral, as there's no specific type for numberLiterals
                writeStringLiteral(text);
            }
        }
        // SyntaxKind.UnparsedSource
        // SyntaxKind.UnparsedPrepend
        function emitUnparsedSourceOrPrepend(unparsed) {
            for (var _a = 0, _b = unparsed.texts; _a < _b.length; _a++) {
                var text = _b[_a];
                writeLine();
                emit(text);
            }
        }
        // SyntaxKind.UnparsedPrologue
        // SyntaxKind.UnparsedText
        // SyntaxKind.UnparsedInternal
        // SyntaxKind.UnparsedSyntheticReference
        function writeUnparsedNode(unparsed) {
            writer.rawWrite(unparsed.parent.text.substring(unparsed.pos, unparsed.end));
        }
        // SyntaxKind.UnparsedText
        // SyntaxKind.UnparsedInternal
        function emitUnparsedTextLike(unparsed) {
            var pos = getTextPosWithWriteLine();
            writeUnparsedNode(unparsed);
            if (bundleFileInfo) {
                updateOrPushBundleFileTextLike(pos, writer.getTextPos(), unparsed.kind === 302 /* SyntaxKind.UnparsedText */ ?
                    "text" /* BundleFileSectionKind.Text */ :
                    "internal" /* BundleFileSectionKind.Internal */);
            }
        }
        // SyntaxKind.UnparsedSyntheticReference
        function emitUnparsedSyntheticReference(unparsed) {
            var pos = getTextPosWithWriteLine();
            writeUnparsedNode(unparsed);
            if (bundleFileInfo) {
                var section = ts.clone(unparsed.section);
                section.pos = pos;
                section.end = writer.getTextPos();
                bundleFileInfo.sections.push(section);
            }
        }
        //
        // Snippet Elements
        //
        function emitSnippetNode(hint, node, snippet) {
            switch (snippet.kind) {
                case 1 /* SnippetKind.Placeholder */:
                    emitPlaceholder(hint, node, snippet);
                    break;
                case 0 /* SnippetKind.TabStop */:
                    emitTabStop(hint, node, snippet);
                    break;
            }
        }
        function emitPlaceholder(hint, node, snippet) {
            nonEscapingWrite("${".concat(snippet.order, ":")); // `${2:`
            pipelineEmitWithHintWorker(hint, node, /*allowSnippets*/ false); // `...`
            nonEscapingWrite("}"); // `}`
            // `${2:...}`
        }
        function emitTabStop(hint, node, snippet) {
            // A tab stop should only be attached to an empty node, i.e. a node that doesn't emit any text.
            ts.Debug.assert(node.kind === 236 /* SyntaxKind.EmptyStatement */, "A tab stop cannot be attached to a node of kind ".concat(ts.Debug.formatSyntaxKind(node.kind), "."));
            ts.Debug.assert(hint !== 5 /* EmitHint.EmbeddedStatement */, "A tab stop cannot be attached to an embedded statement.");
            nonEscapingWrite("$".concat(snippet.order));
        }
        //
        // Identifiers
        //
        function emitIdentifier(node) {
            var writeText = node.symbol ? writeSymbol : write;
            writeText(getTextOfNode(node, /*includeTrivia*/ false), node.symbol);
            emitList(node, node.typeArguments, 53776 /* ListFormat.TypeParameters */); // Call emitList directly since it could be an array of TypeParameterDeclarations _or_ type arguments
        }
        //
        // Names
        //
        function emitPrivateIdentifier(node) {
            var writeText = node.symbol ? writeSymbol : write;
            writeText(getTextOfNode(node, /*includeTrivia*/ false), node.symbol);
        }
        function emitQualifiedName(node) {
            emitEntityName(node.left);
            writePunctuation(".");
            emit(node.right);
        }
        function emitEntityName(node) {
            if (node.kind === 79 /* SyntaxKind.Identifier */) {
                emitExpression(node);
            }
            else {
                emit(node);
            }
        }
        function emitComputedPropertyName(node) {
            writePunctuation("[");
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfComputedPropertyName);
            writePunctuation("]");
        }
        //
        // Signature elements
        //
        function emitTypeParameter(node) {
            emitModifiers(node, node.modifiers);
            emit(node.name);
            if (node.constraint) {
                writeSpace();
                writeKeyword("extends");
                writeSpace();
                emit(node.constraint);
            }
            if (node.default) {
                writeSpace();
                writeOperator("=");
                writeSpace();
                emit(node.default);
            }
        }
        function emitParameter(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emit(node.dotDotDotToken);
            emitNodeWithWriter(node.name, writeParameter);
            emit(node.questionToken);
            if (node.parent && node.parent.kind === 317 /* SyntaxKind.JSDocFunctionType */ && !node.name) {
                emit(node.type);
            }
            else {
                emitTypeAnnotation(node.type);
            }
            // The comment position has to fallback to any present node within the parameterdeclaration because as it turns out, the parser can make parameter declarations with _just_ an initializer.
            emitInitializer(node.initializer, node.type ? node.type.end : node.questionToken ? node.questionToken.end : node.name ? node.name.end : node.modifiers ? node.modifiers.end : node.decorators ? node.decorators.end : node.pos, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitDecorator(decorator) {
            writePunctuation("@");
            emitExpression(decorator.expression, parenthesizer.parenthesizeLeftSideOfAccess);
        }
        //
        // Type members
        //
        function emitPropertySignature(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emitNodeWithWriter(node.name, writeProperty);
            emit(node.questionToken);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
        }
        function emitPropertyDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emit(node.name);
            emit(node.questionToken);
            emit(node.exclamationToken);
            emitTypeAnnotation(node.type);
            emitInitializer(node.initializer, node.type ? node.type.end : node.questionToken ? node.questionToken.end : node.name.end, node);
            writeTrailingSemicolon();
        }
        function emitMethodSignature(node) {
            pushNameGenerationScope(node);
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emit(node.name);
            emit(node.questionToken);
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
            popNameGenerationScope(node);
        }
        function emitMethodDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emit(node.asteriskToken);
            emit(node.name);
            emit(node.questionToken);
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitClassStaticBlockDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword("static");
            emitBlockFunctionBody(node.body);
        }
        function emitConstructor(node) {
            emitModifiers(node, node.modifiers);
            writeKeyword("constructor");
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitAccessorDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword(node.kind === 172 /* SyntaxKind.GetAccessor */ ? "get" : "set");
            writeSpace();
            emit(node.name);
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitCallSignature(node) {
            pushNameGenerationScope(node);
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
            popNameGenerationScope(node);
        }
        function emitConstructSignature(node) {
            pushNameGenerationScope(node);
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword("new");
            writeSpace();
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
            popNameGenerationScope(node);
        }
        function emitIndexSignature(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emitParametersForIndexSignature(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
        }
        function emitTemplateTypeSpan(node) {
            emit(node.type);
            emit(node.literal);
        }
        function emitSemicolonClassElement() {
            writeTrailingSemicolon();
        }
        //
        // Types
        //
        function emitTypePredicate(node) {
            if (node.assertsModifier) {
                emit(node.assertsModifier);
                writeSpace();
            }
            emit(node.parameterName);
            if (node.type) {
                writeSpace();
                writeKeyword("is");
                writeSpace();
                emit(node.type);
            }
        }
        function emitTypeReference(node) {
            emit(node.typeName);
            emitTypeArguments(node, node.typeArguments);
        }
        function emitFunctionType(node) {
            pushNameGenerationScope(node);
            emitTypeParameters(node, node.typeParameters);
            emitParametersForArrow(node, node.parameters);
            writeSpace();
            writePunctuation("=>");
            writeSpace();
            emit(node.type);
            popNameGenerationScope(node);
        }
        function emitJSDocFunctionType(node) {
            writeKeyword("function");
            emitParameters(node, node.parameters);
            writePunctuation(":");
            emit(node.type);
        }
        function emitJSDocNullableType(node) {
            writePunctuation("?");
            emit(node.type);
        }
        function emitJSDocNonNullableType(node) {
            writePunctuation("!");
            emit(node.type);
        }
        function emitJSDocOptionalType(node) {
            emit(node.type);
            writePunctuation("=");
        }
        function emitConstructorType(node) {
            pushNameGenerationScope(node);
            emitModifiers(node, node.modifiers);
            writeKeyword("new");
            writeSpace();
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            writeSpace();
            writePunctuation("=>");
            writeSpace();
            emit(node.type);
            popNameGenerationScope(node);
        }
        function emitTypeQuery(node) {
            writeKeyword("typeof");
            writeSpace();
            emit(node.exprName);
            emitTypeArguments(node, node.typeArguments);
        }
        function emitTypeLiteral(node) {
            writePunctuation("{");
            var flags = ts.getEmitFlags(node) & 1 /* EmitFlags.SingleLine */ ? 768 /* ListFormat.SingleLineTypeLiteralMembers */ : 32897 /* ListFormat.MultiLineTypeLiteralMembers */;
            emitList(node, node.members, flags | 524288 /* ListFormat.NoSpaceIfEmpty */);
            writePunctuation("}");
        }
        function emitArrayType(node) {
            emit(node.elementType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType);
            writePunctuation("[");
            writePunctuation("]");
        }
        function emitRestOrJSDocVariadicType(node) {
            writePunctuation("...");
            emit(node.type);
        }
        function emitTupleType(node) {
            emitTokenWithComment(22 /* SyntaxKind.OpenBracketToken */, node.pos, writePunctuation, node);
            var flags = ts.getEmitFlags(node) & 1 /* EmitFlags.SingleLine */ ? 528 /* ListFormat.SingleLineTupleTypeElements */ : 657 /* ListFormat.MultiLineTupleTypeElements */;
            emitList(node, node.elements, flags | 524288 /* ListFormat.NoSpaceIfEmpty */, parenthesizer.parenthesizeElementTypeOfTupleType);
            emitTokenWithComment(23 /* SyntaxKind.CloseBracketToken */, node.elements.end, writePunctuation, node);
        }
        function emitNamedTupleMember(node) {
            emit(node.dotDotDotToken);
            emit(node.name);
            emit(node.questionToken);
            emitTokenWithComment(58 /* SyntaxKind.ColonToken */, node.name.end, writePunctuation, node);
            writeSpace();
            emit(node.type);
        }
        function emitOptionalType(node) {
            emit(node.type, parenthesizer.parenthesizeTypeOfOptionalType);
            writePunctuation("?");
        }
        function emitUnionType(node) {
            emitList(node, node.types, 516 /* ListFormat.UnionTypeConstituents */, parenthesizer.parenthesizeConstituentTypeOfUnionType);
        }
        function emitIntersectionType(node) {
            emitList(node, node.types, 520 /* ListFormat.IntersectionTypeConstituents */, parenthesizer.parenthesizeConstituentTypeOfIntersectionType);
        }
        function emitConditionalType(node) {
            emit(node.checkType, parenthesizer.parenthesizeCheckTypeOfConditionalType);
            writeSpace();
            writeKeyword("extends");
            writeSpace();
            emit(node.extendsType, parenthesizer.parenthesizeExtendsTypeOfConditionalType);
            writeSpace();
            writePunctuation("?");
            writeSpace();
            emit(node.trueType);
            writeSpace();
            writePunctuation(":");
            writeSpace();
            emit(node.falseType);
        }
        function emitInferType(node) {
            writeKeyword("infer");
            writeSpace();
            emit(node.typeParameter);
        }
        function emitParenthesizedType(node) {
            writePunctuation("(");
            emit(node.type);
            writePunctuation(")");
        }
        function emitThisType() {
            writeKeyword("this");
        }
        function emitTypeOperator(node) {
            writeTokenText(node.operator, writeKeyword);
            writeSpace();
            var parenthesizerRule = node.operator === 145 /* SyntaxKind.ReadonlyKeyword */ ?
                parenthesizer.parenthesizeOperandOfReadonlyTypeOperator :
                parenthesizer.parenthesizeOperandOfTypeOperator;
            emit(node.type, parenthesizerRule);
        }
        function emitIndexedAccessType(node) {
            emit(node.objectType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType);
            writePunctuation("[");
            emit(node.indexType);
            writePunctuation("]");
        }
        function emitMappedType(node) {
            var emitFlags = ts.getEmitFlags(node);
            writePunctuation("{");
            if (emitFlags & 1 /* EmitFlags.SingleLine */) {
                writeSpace();
            }
            else {
                writeLine();
                increaseIndent();
            }
            if (node.readonlyToken) {
                emit(node.readonlyToken);
                if (node.readonlyToken.kind !== 145 /* SyntaxKind.ReadonlyKeyword */) {
                    writeKeyword("readonly");
                }
                writeSpace();
            }
            writePunctuation("[");
            pipelineEmit(3 /* EmitHint.MappedTypeParameter */, node.typeParameter);
            if (node.nameType) {
                writeSpace();
                writeKeyword("as");
                writeSpace();
                emit(node.nameType);
            }
            writePunctuation("]");
            if (node.questionToken) {
                emit(node.questionToken);
                if (node.questionToken.kind !== 57 /* SyntaxKind.QuestionToken */) {
                    writePunctuation("?");
                }
            }
            writePunctuation(":");
            writeSpace();
            emit(node.type);
            writeTrailingSemicolon();
            if (emitFlags & 1 /* EmitFlags.SingleLine */) {
                writeSpace();
            }
            else {
                writeLine();
                decreaseIndent();
            }
            emitList(node, node.members, 2 /* ListFormat.PreserveLines */);
            writePunctuation("}");
        }
        function emitLiteralType(node) {
            emitExpression(node.literal);
        }
        function emitTemplateType(node) {
            emit(node.head);
            emitList(node, node.templateSpans, 262144 /* ListFormat.TemplateExpressionSpans */);
        }
        function emitImportTypeNode(node) {
            if (node.isTypeOf) {
                writeKeyword("typeof");
                writeSpace();
            }
            writeKeyword("import");
            writePunctuation("(");
            emit(node.argument);
            if (node.assertions) {
                writePunctuation(",");
                writeSpace();
                writePunctuation("{");
                writeSpace();
                writeKeyword("assert");
                writePunctuation(":");
                writeSpace();
                var elements = node.assertions.assertClause.elements;
                emitList(node.assertions.assertClause, elements, 526226 /* ListFormat.ImportClauseEntries */);
                writeSpace();
                writePunctuation("}");
            }
            writePunctuation(")");
            if (node.qualifier) {
                writePunctuation(".");
                emit(node.qualifier);
            }
            emitTypeArguments(node, node.typeArguments);
        }
        //
        // Binding patterns
        //
        function emitObjectBindingPattern(node) {
            writePunctuation("{");
            emitList(node, node.elements, 525136 /* ListFormat.ObjectBindingPatternElements */);
            writePunctuation("}");
        }
        function emitArrayBindingPattern(node) {
            writePunctuation("[");
            emitList(node, node.elements, 524880 /* ListFormat.ArrayBindingPatternElements */);
            writePunctuation("]");
        }
        function emitBindingElement(node) {
            emit(node.dotDotDotToken);
            if (node.propertyName) {
                emit(node.propertyName);
                writePunctuation(":");
                writeSpace();
            }
            emit(node.name);
            emitInitializer(node.initializer, node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        //
        // Expressions
        //
        function emitArrayLiteralExpression(node) {
            var elements = node.elements;
            var preferNewLine = node.multiLine ? 65536 /* ListFormat.PreferNewLine */ : 0 /* ListFormat.None */;
            emitExpressionList(node, elements, 8914 /* ListFormat.ArrayLiteralExpressionElements */ | preferNewLine, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitObjectLiteralExpression(node) {
            ts.forEach(node.properties, generateMemberNames);
            var indentedFlag = ts.getEmitFlags(node) & 65536 /* EmitFlags.Indented */;
            if (indentedFlag) {
                increaseIndent();
            }
            var preferNewLine = node.multiLine ? 65536 /* ListFormat.PreferNewLine */ : 0 /* ListFormat.None */;
            var allowTrailingComma = currentSourceFile && currentSourceFile.languageVersion >= 1 /* ScriptTarget.ES5 */ && !ts.isJsonSourceFile(currentSourceFile) ? 64 /* ListFormat.AllowTrailingComma */ : 0 /* ListFormat.None */;
            emitList(node, node.properties, 526226 /* ListFormat.ObjectLiteralExpressionProperties */ | allowTrailingComma | preferNewLine);
            if (indentedFlag) {
                decreaseIndent();
            }
        }
        function emitPropertyAccessExpression(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            var token = node.questionDotToken || ts.setTextRangePosEnd(ts.factory.createToken(24 /* SyntaxKind.DotToken */), node.expression.end, node.name.pos);
            var linesBeforeDot = getLinesBetweenNodes(node, node.expression, token);
            var linesAfterDot = getLinesBetweenNodes(node, token, node.name);
            writeLinesAndIndent(linesBeforeDot, /*writeSpaceIfNotIndenting*/ false);
            var shouldEmitDotDot = token.kind !== 28 /* SyntaxKind.QuestionDotToken */ &&
                mayNeedDotDotForPropertyAccess(node.expression) &&
                !writer.hasTrailingComment() &&
                !writer.hasTrailingWhitespace();
            if (shouldEmitDotDot) {
                writePunctuation(".");
            }
            if (node.questionDotToken) {
                emit(token);
            }
            else {
                emitTokenWithComment(token.kind, node.expression.end, writePunctuation, node);
            }
            writeLinesAndIndent(linesAfterDot, /*writeSpaceIfNotIndenting*/ false);
            emit(node.name);
            decreaseIndentIf(linesBeforeDot, linesAfterDot);
        }
        // 1..toString is a valid property access, emit a dot after the literal
        // Also emit a dot if expression is a integer const enum value - it will appear in generated code as numeric literal
        function mayNeedDotDotForPropertyAccess(expression) {
            expression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isNumericLiteral(expression)) {
                // check if numeric literal is a decimal literal that was originally written with a dot
                var text = getLiteralTextOfNode(expression, /*neverAsciiEscape*/ true, /*jsxAttributeEscape*/ false);
                // If he number will be printed verbatim and it doesn't already contain a dot, add one
                // if the expression doesn't have any comments that will be emitted.
                return !expression.numericLiteralFlags && !ts.stringContains(text, ts.tokenToString(24 /* SyntaxKind.DotToken */));
            }
            else if (ts.isAccessExpression(expression)) {
                // check if constant enum value is integer
                var constantValue = ts.getConstantValue(expression);
                // isFinite handles cases when constantValue is undefined
                return typeof constantValue === "number" && isFinite(constantValue)
                    && Math.floor(constantValue) === constantValue;
            }
        }
        function emitElementAccessExpression(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            emit(node.questionDotToken);
            emitTokenWithComment(22 /* SyntaxKind.OpenBracketToken */, node.expression.end, writePunctuation, node);
            emitExpression(node.argumentExpression);
            emitTokenWithComment(23 /* SyntaxKind.CloseBracketToken */, node.argumentExpression.end, writePunctuation, node);
        }
        function emitCallExpression(node) {
            var indirectCall = ts.getEmitFlags(node) & 536870912 /* EmitFlags.IndirectCall */;
            if (indirectCall) {
                writePunctuation("(");
                writeLiteral("0");
                writePunctuation(",");
                writeSpace();
            }
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            if (indirectCall) {
                writePunctuation(")");
            }
            emit(node.questionDotToken);
            emitTypeArguments(node, node.typeArguments);
            emitExpressionList(node, node.arguments, 2576 /* ListFormat.CallExpressionArguments */, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitNewExpression(node) {
            emitTokenWithComment(103 /* SyntaxKind.NewKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfNew);
            emitTypeArguments(node, node.typeArguments);
            emitExpressionList(node, node.arguments, 18960 /* ListFormat.NewExpressionArguments */, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitTaggedTemplateExpression(node) {
            var indirectCall = ts.getEmitFlags(node) & 536870912 /* EmitFlags.IndirectCall */;
            if (indirectCall) {
                writePunctuation("(");
                writeLiteral("0");
                writePunctuation(",");
                writeSpace();
            }
            emitExpression(node.tag, parenthesizer.parenthesizeLeftSideOfAccess);
            if (indirectCall) {
                writePunctuation(")");
            }
            emitTypeArguments(node, node.typeArguments);
            writeSpace();
            emitExpression(node.template);
        }
        function emitTypeAssertionExpression(node) {
            writePunctuation("<");
            emit(node.type);
            writePunctuation(">");
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitParenthesizedExpression(node) {
            var openParenPos = emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, node.pos, writePunctuation, node);
            var indented = writeLineSeparatorsAndIndentBefore(node.expression, node);
            emitExpression(node.expression, /*parenthesizerRules*/ undefined);
            writeLineSeparatorsAfter(node.expression, node);
            decreaseIndentIf(indented);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression ? node.expression.end : openParenPos, writePunctuation, node);
        }
        function emitFunctionExpression(node) {
            generateNameIfNeeded(node.name);
            emitFunctionDeclarationOrExpression(node);
        }
        function emitArrowFunction(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emitSignatureAndBody(node, emitArrowFunctionHead);
        }
        function emitArrowFunctionHead(node) {
            emitTypeParameters(node, node.typeParameters);
            emitParametersForArrow(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeSpace();
            emit(node.equalsGreaterThanToken);
        }
        function emitDeleteExpression(node) {
            emitTokenWithComment(89 /* SyntaxKind.DeleteKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitTypeOfExpression(node) {
            emitTokenWithComment(112 /* SyntaxKind.TypeOfKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitVoidExpression(node) {
            emitTokenWithComment(114 /* SyntaxKind.VoidKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitAwaitExpression(node) {
            emitTokenWithComment(132 /* SyntaxKind.AwaitKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitPrefixUnaryExpression(node) {
            writeTokenText(node.operator, writeOperator);
            if (shouldEmitWhitespaceBeforeOperand(node)) {
                writeSpace();
            }
            emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function shouldEmitWhitespaceBeforeOperand(node) {
            // In some cases, we need to emit a space between the operator and the operand. One obvious case
            // is when the operator is an identifier, like delete or typeof. We also need to do this for plus
            // and minus expressions in certain cases. Specifically, consider the following two cases (parens
            // are just for clarity of exposition, and not part of the source code):
            //
            //  (+(+1))
            //  (+(++1))
            //
            // We need to emit a space in both cases. In the first case, the absence of a space will make
            // the resulting expression a prefix increment operation. And in the second, it will make the resulting
            // expression a prefix increment whose operand is a plus expression - (++(+x))
            // The same is true of minus of course.
            var operand = node.operand;
            return operand.kind === 219 /* SyntaxKind.PrefixUnaryExpression */
                && ((node.operator === 39 /* SyntaxKind.PlusToken */ && (operand.operator === 39 /* SyntaxKind.PlusToken */ || operand.operator === 45 /* SyntaxKind.PlusPlusToken */))
                    || (node.operator === 40 /* SyntaxKind.MinusToken */ && (operand.operator === 40 /* SyntaxKind.MinusToken */ || operand.operator === 46 /* SyntaxKind.MinusMinusToken */)));
        }
        function emitPostfixUnaryExpression(node) {
            emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPostfixUnary);
            writeTokenText(node.operator, writeOperator);
        }
        function createEmitBinaryExpression() {
            return ts.createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, /*foldState*/ undefined);
            function onEnter(node, state) {
                if (state) {
                    state.stackIndex++;
                    state.preserveSourceNewlinesStack[state.stackIndex] = preserveSourceNewlines;
                    state.containerPosStack[state.stackIndex] = containerPos;
                    state.containerEndStack[state.stackIndex] = containerEnd;
                    state.declarationListContainerEndStack[state.stackIndex] = declarationListContainerEnd;
                    var emitComments_1 = state.shouldEmitCommentsStack[state.stackIndex] = shouldEmitComments(node);
                    var emitSourceMaps = state.shouldEmitSourceMapsStack[state.stackIndex] = shouldEmitSourceMaps(node);
                    onBeforeEmitNode === null || onBeforeEmitNode === void 0 ? void 0 : onBeforeEmitNode(node);
                    if (emitComments_1)
                        emitCommentsBeforeNode(node);
                    if (emitSourceMaps)
                        emitSourceMapsBeforeNode(node);
                    beforeEmitNode(node);
                }
                else {
                    state = {
                        stackIndex: 0,
                        preserveSourceNewlinesStack: [undefined],
                        containerPosStack: [-1],
                        containerEndStack: [-1],
                        declarationListContainerEndStack: [-1],
                        shouldEmitCommentsStack: [false],
                        shouldEmitSourceMapsStack: [false],
                    };
                }
                return state;
            }
            function onLeft(next, _workArea, parent) {
                return maybeEmitExpression(next, parent, "left");
            }
            function onOperator(operatorToken, _state, node) {
                var isCommaOperator = operatorToken.kind !== 27 /* SyntaxKind.CommaToken */;
                var linesBeforeOperator = getLinesBetweenNodes(node, node.left, operatorToken);
                var linesAfterOperator = getLinesBetweenNodes(node, operatorToken, node.right);
                writeLinesAndIndent(linesBeforeOperator, isCommaOperator);
                emitLeadingCommentsOfPosition(operatorToken.pos);
                writeTokenNode(operatorToken, operatorToken.kind === 101 /* SyntaxKind.InKeyword */ ? writeKeyword : writeOperator);
                emitTrailingCommentsOfPosition(operatorToken.end, /*prefixSpace*/ true); // Binary operators should have a space before the comment starts
                writeLinesAndIndent(linesAfterOperator, /*writeSpaceIfNotIndenting*/ true);
            }
            function onRight(next, _workArea, parent) {
                return maybeEmitExpression(next, parent, "right");
            }
            function onExit(node, state) {
                var linesBeforeOperator = getLinesBetweenNodes(node, node.left, node.operatorToken);
                var linesAfterOperator = getLinesBetweenNodes(node, node.operatorToken, node.right);
                decreaseIndentIf(linesBeforeOperator, linesAfterOperator);
                if (state.stackIndex > 0) {
                    var savedPreserveSourceNewlines = state.preserveSourceNewlinesStack[state.stackIndex];
                    var savedContainerPos = state.containerPosStack[state.stackIndex];
                    var savedContainerEnd = state.containerEndStack[state.stackIndex];
                    var savedDeclarationListContainerEnd = state.declarationListContainerEndStack[state.stackIndex];
                    var shouldEmitComments_1 = state.shouldEmitCommentsStack[state.stackIndex];
                    var shouldEmitSourceMaps_1 = state.shouldEmitSourceMapsStack[state.stackIndex];
                    afterEmitNode(savedPreserveSourceNewlines);
                    if (shouldEmitSourceMaps_1)
                        emitSourceMapsAfterNode(node);
                    if (shouldEmitComments_1)
                        emitCommentsAfterNode(node, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd);
                    onAfterEmitNode === null || onAfterEmitNode === void 0 ? void 0 : onAfterEmitNode(node);
                    state.stackIndex--;
                }
            }
            function maybeEmitExpression(next, parent, side) {
                var parenthesizerRule = side === "left" ?
                    parenthesizer.getParenthesizeLeftSideOfBinaryForOperator(parent.operatorToken.kind) :
                    parenthesizer.getParenthesizeRightSideOfBinaryForOperator(parent.operatorToken.kind);
                var pipelinePhase = getPipelinePhase(0 /* PipelinePhase.Notification */, 1 /* EmitHint.Expression */, next);
                if (pipelinePhase === pipelineEmitWithSubstitution) {
                    ts.Debug.assertIsDefined(lastSubstitution);
                    next = parenthesizerRule(ts.cast(lastSubstitution, ts.isExpression));
                    pipelinePhase = getNextPipelinePhase(1 /* PipelinePhase.Substitution */, 1 /* EmitHint.Expression */, next);
                    lastSubstitution = undefined;
                }
                if (pipelinePhase === pipelineEmitWithComments ||
                    pipelinePhase === pipelineEmitWithSourceMaps ||
                    pipelinePhase === pipelineEmitWithHint) {
                    if (ts.isBinaryExpression(next)) {
                        return next;
                    }
                }
                currentParenthesizerRule = parenthesizerRule;
                pipelinePhase(1 /* EmitHint.Expression */, next);
            }
        }
        function emitConditionalExpression(node) {
            var linesBeforeQuestion = getLinesBetweenNodes(node, node.condition, node.questionToken);
            var linesAfterQuestion = getLinesBetweenNodes(node, node.questionToken, node.whenTrue);
            var linesBeforeColon = getLinesBetweenNodes(node, node.whenTrue, node.colonToken);
            var linesAfterColon = getLinesBetweenNodes(node, node.colonToken, node.whenFalse);
            emitExpression(node.condition, parenthesizer.parenthesizeConditionOfConditionalExpression);
            writeLinesAndIndent(linesBeforeQuestion, /*writeSpaceIfNotIndenting*/ true);
            emit(node.questionToken);
            writeLinesAndIndent(linesAfterQuestion, /*writeSpaceIfNotIndenting*/ true);
            emitExpression(node.whenTrue, parenthesizer.parenthesizeBranchOfConditionalExpression);
            decreaseIndentIf(linesBeforeQuestion, linesAfterQuestion);
            writeLinesAndIndent(linesBeforeColon, /*writeSpaceIfNotIndenting*/ true);
            emit(node.colonToken);
            writeLinesAndIndent(linesAfterColon, /*writeSpaceIfNotIndenting*/ true);
            emitExpression(node.whenFalse, parenthesizer.parenthesizeBranchOfConditionalExpression);
            decreaseIndentIf(linesBeforeColon, linesAfterColon);
        }
        function emitTemplateExpression(node) {
            emit(node.head);
            emitList(node, node.templateSpans, 262144 /* ListFormat.TemplateExpressionSpans */);
        }
        function emitYieldExpression(node) {
            emitTokenWithComment(125 /* SyntaxKind.YieldKeyword */, node.pos, writeKeyword, node);
            emit(node.asteriskToken);
            emitExpressionWithLeadingSpace(node.expression && parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsiAndDisallowedComma);
        }
        function emitSpreadElement(node) {
            emitTokenWithComment(25 /* SyntaxKind.DotDotDotToken */, node.pos, writePunctuation, node);
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitClassExpression(node) {
            generateNameIfNeeded(node.name);
            emitClassDeclarationOrExpression(node);
        }
        function emitExpressionWithTypeArguments(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            emitTypeArguments(node, node.typeArguments);
        }
        function emitAsExpression(node) {
            emitExpression(node.expression, /*parenthesizerRules*/ undefined);
            if (node.type) {
                writeSpace();
                writeKeyword("as");
                writeSpace();
                emit(node.type);
            }
        }
        function emitNonNullExpression(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            writeOperator("!");
        }
        function emitMetaProperty(node) {
            writeToken(node.keywordToken, node.pos, writePunctuation);
            writePunctuation(".");
            emit(node.name);
        }
        //
        // Misc
        //
        function emitTemplateSpan(node) {
            emitExpression(node.expression);
            emit(node.literal);
        }
        //
        // Statements
        //
        function emitBlock(node) {
            emitBlockStatements(node, /*forceSingleLine*/ !node.multiLine && isEmptyBlock(node));
        }
        function emitBlockStatements(node, forceSingleLine) {
            emitTokenWithComment(18 /* SyntaxKind.OpenBraceToken */, node.pos, writePunctuation, /*contextNode*/ node);
            var format = forceSingleLine || ts.getEmitFlags(node) & 1 /* EmitFlags.SingleLine */ ? 768 /* ListFormat.SingleLineBlockStatements */ : 129 /* ListFormat.MultiLineBlockStatements */;
            emitList(node, node.statements, format);
            emitTokenWithComment(19 /* SyntaxKind.CloseBraceToken */, node.statements.end, writePunctuation, /*contextNode*/ node, /*indentLeading*/ !!(format & 1 /* ListFormat.MultiLine */));
        }
        function emitVariableStatement(node) {
            emitModifiers(node, node.modifiers);
            emit(node.declarationList);
            writeTrailingSemicolon();
        }
        function emitEmptyStatement(isEmbeddedStatement) {
            // While most trailing semicolons are possibly insignificant, an embedded "empty"
            // statement is significant and cannot be elided by a trailing-semicolon-omitting writer.
            if (isEmbeddedStatement) {
                writePunctuation(";");
            }
            else {
                writeTrailingSemicolon();
            }
        }
        function emitExpressionStatement(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfExpressionStatement);
            // Emit semicolon in non json files
            // or if json file that created synthesized expression(eg.define expression statement when --out and amd code generation)
            if (!currentSourceFile || !ts.isJsonSourceFile(currentSourceFile) || ts.nodeIsSynthesized(node.expression)) {
                writeTrailingSemicolon();
            }
        }
        function emitIfStatement(node) {
            var openParenPos = emitTokenWithComment(99 /* SyntaxKind.IfKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.thenStatement);
            if (node.elseStatement) {
                writeLineOrSpace(node, node.thenStatement, node.elseStatement);
                emitTokenWithComment(91 /* SyntaxKind.ElseKeyword */, node.thenStatement.end, writeKeyword, node);
                if (node.elseStatement.kind === 239 /* SyntaxKind.IfStatement */) {
                    writeSpace();
                    emit(node.elseStatement);
                }
                else {
                    emitEmbeddedStatement(node, node.elseStatement);
                }
            }
        }
        function emitWhileClause(node, startPos) {
            var openParenPos = emitTokenWithComment(115 /* SyntaxKind.WhileKeyword */, startPos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
        }
        function emitDoStatement(node) {
            emitTokenWithComment(90 /* SyntaxKind.DoKeyword */, node.pos, writeKeyword, node);
            emitEmbeddedStatement(node, node.statement);
            if (ts.isBlock(node.statement) && !preserveSourceNewlines) {
                writeSpace();
            }
            else {
                writeLineOrSpace(node, node.statement, node.expression);
            }
            emitWhileClause(node, node.statement.end);
            writeTrailingSemicolon();
        }
        function emitWhileStatement(node) {
            emitWhileClause(node, node.pos);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForStatement(node) {
            var openParenPos = emitTokenWithComment(97 /* SyntaxKind.ForKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            var pos = emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, /*contextNode*/ node);
            emitForBinding(node.initializer);
            pos = emitTokenWithComment(26 /* SyntaxKind.SemicolonToken */, node.initializer ? node.initializer.end : pos, writePunctuation, node);
            emitExpressionWithLeadingSpace(node.condition);
            pos = emitTokenWithComment(26 /* SyntaxKind.SemicolonToken */, node.condition ? node.condition.end : pos, writePunctuation, node);
            emitExpressionWithLeadingSpace(node.incrementor);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.incrementor ? node.incrementor.end : pos, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForInStatement(node) {
            var openParenPos = emitTokenWithComment(97 /* SyntaxKind.ForKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitForBinding(node.initializer);
            writeSpace();
            emitTokenWithComment(101 /* SyntaxKind.InKeyword */, node.initializer.end, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForOfStatement(node) {
            var openParenPos = emitTokenWithComment(97 /* SyntaxKind.ForKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitWithTrailingSpace(node.awaitModifier);
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitForBinding(node.initializer);
            writeSpace();
            emitTokenWithComment(160 /* SyntaxKind.OfKeyword */, node.initializer.end, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForBinding(node) {
            if (node !== undefined) {
                if (node.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
                    emit(node);
                }
                else {
                    emitExpression(node);
                }
            }
        }
        function emitContinueStatement(node) {
            emitTokenWithComment(86 /* SyntaxKind.ContinueKeyword */, node.pos, writeKeyword, node);
            emitWithLeadingSpace(node.label);
            writeTrailingSemicolon();
        }
        function emitBreakStatement(node) {
            emitTokenWithComment(81 /* SyntaxKind.BreakKeyword */, node.pos, writeKeyword, node);
            emitWithLeadingSpace(node.label);
            writeTrailingSemicolon();
        }
        function emitTokenWithComment(token, pos, writer, contextNode, indentLeading) {
            var node = ts.getParseTreeNode(contextNode);
            var isSimilarNode = node && node.kind === contextNode.kind;
            var startPos = pos;
            if (isSimilarNode && currentSourceFile) {
                pos = ts.skipTrivia(currentSourceFile.text, pos);
            }
            if (isSimilarNode && contextNode.pos !== startPos) {
                var needsIndent = indentLeading && currentSourceFile && !ts.positionsAreOnSameLine(startPos, pos, currentSourceFile);
                if (needsIndent) {
                    increaseIndent();
                }
                emitLeadingCommentsOfPosition(startPos);
                if (needsIndent) {
                    decreaseIndent();
                }
            }
            pos = writeTokenText(token, writer, pos);
            if (isSimilarNode && contextNode.end !== pos) {
                var isJsxExprContext = contextNode.kind === 288 /* SyntaxKind.JsxExpression */;
                emitTrailingCommentsOfPosition(pos, /*prefixSpace*/ !isJsxExprContext, /*forceNoNewline*/ isJsxExprContext);
            }
            return pos;
        }
        function commentWillEmitNewLine(node) {
            return node.kind === 2 /* SyntaxKind.SingleLineCommentTrivia */ || !!node.hasTrailingNewLine;
        }
        function willEmitLeadingNewLine(node) {
            if (!currentSourceFile)
                return false;
            if (ts.some(ts.getLeadingCommentRanges(currentSourceFile.text, node.pos), commentWillEmitNewLine))
                return true;
            if (ts.some(ts.getSyntheticLeadingComments(node), commentWillEmitNewLine))
                return true;
            if (ts.isPartiallyEmittedExpression(node)) {
                if (node.pos !== node.expression.pos) {
                    if (ts.some(ts.getTrailingCommentRanges(currentSourceFile.text, node.expression.pos), commentWillEmitNewLine))
                        return true;
                }
                return willEmitLeadingNewLine(node.expression);
            }
            return false;
        }
        /**
         * Wraps an expression in parens if we would emit a leading comment that would introduce a line separator
         * between the node and its parent.
         */
        function parenthesizeExpressionForNoAsi(node) {
            if (!commentsDisabled && ts.isPartiallyEmittedExpression(node) && willEmitLeadingNewLine(node)) {
                var parseNode = ts.getParseTreeNode(node);
                if (parseNode && ts.isParenthesizedExpression(parseNode)) {
                    // If the original node was a parenthesized expression, restore it to preserve comment and source map emit
                    var parens = ts.factory.createParenthesizedExpression(node.expression);
                    ts.setOriginalNode(parens, node);
                    ts.setTextRange(parens, parseNode);
                    return parens;
                }
                return ts.factory.createParenthesizedExpression(node);
            }
            return node;
        }
        function parenthesizeExpressionForNoAsiAndDisallowedComma(node) {
            return parenthesizeExpressionForNoAsi(parenthesizer.parenthesizeExpressionForDisallowedComma(node));
        }
        function emitReturnStatement(node) {
            emitTokenWithComment(105 /* SyntaxKind.ReturnKeyword */, node.pos, writeKeyword, /*contextNode*/ node);
            emitExpressionWithLeadingSpace(node.expression && parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsi);
            writeTrailingSemicolon();
        }
        function emitWithStatement(node) {
            var openParenPos = emitTokenWithComment(116 /* SyntaxKind.WithKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitSwitchStatement(node) {
            var openParenPos = emitTokenWithComment(107 /* SyntaxKind.SwitchKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            writeSpace();
            emit(node.caseBlock);
        }
        function emitLabeledStatement(node) {
            emit(node.label);
            emitTokenWithComment(58 /* SyntaxKind.ColonToken */, node.label.end, writePunctuation, node);
            writeSpace();
            emit(node.statement);
        }
        function emitThrowStatement(node) {
            emitTokenWithComment(109 /* SyntaxKind.ThrowKeyword */, node.pos, writeKeyword, node);
            emitExpressionWithLeadingSpace(parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsi);
            writeTrailingSemicolon();
        }
        function emitTryStatement(node) {
            emitTokenWithComment(111 /* SyntaxKind.TryKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emit(node.tryBlock);
            if (node.catchClause) {
                writeLineOrSpace(node, node.tryBlock, node.catchClause);
                emit(node.catchClause);
            }
            if (node.finallyBlock) {
                writeLineOrSpace(node, node.catchClause || node.tryBlock, node.finallyBlock);
                emitTokenWithComment(96 /* SyntaxKind.FinallyKeyword */, (node.catchClause || node.tryBlock).end, writeKeyword, node);
                writeSpace();
                emit(node.finallyBlock);
            }
        }
        function emitDebuggerStatement(node) {
            writeToken(87 /* SyntaxKind.DebuggerKeyword */, node.pos, writeKeyword);
            writeTrailingSemicolon();
        }
        //
        // Declarations
        //
        function emitVariableDeclaration(node) {
            var _a, _b, _c, _d, _e;
            emit(node.name);
            emit(node.exclamationToken);
            emitTypeAnnotation(node.type);
            emitInitializer(node.initializer, (_e = (_b = (_a = node.type) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : (_d = (_c = node.name.emitNode) === null || _c === void 0 ? void 0 : _c.typeNode) === null || _d === void 0 ? void 0 : _d.end) !== null && _e !== void 0 ? _e : node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitVariableDeclarationList(node) {
            writeKeyword(ts.isLet(node) ? "let" : ts.isVarConst(node) ? "const" : "var");
            writeSpace();
            emitList(node, node.declarations, 528 /* ListFormat.VariableDeclarationList */);
        }
        function emitFunctionDeclaration(node) {
            emitFunctionDeclarationOrExpression(node);
        }
        function emitFunctionDeclarationOrExpression(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword("function");
            emit(node.asteriskToken);
            writeSpace();
            emitIdentifierName(node.name);
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitSignatureAndBody(node, emitSignatureHead) {
            var body = node.body;
            if (body) {
                if (ts.isBlock(body)) {
                    var indentedFlag = ts.getEmitFlags(node) & 65536 /* EmitFlags.Indented */;
                    if (indentedFlag) {
                        increaseIndent();
                    }
                    pushNameGenerationScope(node);
                    ts.forEach(node.parameters, generateNames);
                    generateNames(node.body);
                    emitSignatureHead(node);
                    emitBlockFunctionBody(body);
                    popNameGenerationScope(node);
                    if (indentedFlag) {
                        decreaseIndent();
                    }
                }
                else {
                    emitSignatureHead(node);
                    writeSpace();
                    emitExpression(body, parenthesizer.parenthesizeConciseBodyOfArrowFunction);
                }
            }
            else {
                emitSignatureHead(node);
                writeTrailingSemicolon();
            }
        }
        function emitSignatureHead(node) {
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
        }
        function shouldEmitBlockFunctionBodyOnSingleLine(body) {
            // We must emit a function body as a single-line body in the following case:
            // * The body has NodeEmitFlags.SingleLine specified.
            // We must emit a function body as a multi-line body in the following cases:
            // * The body is explicitly marked as multi-line.
            // * A non-synthesized body's start and end position are on different lines.
            // * Any statement in the body starts on a new line.
            if (ts.getEmitFlags(body) & 1 /* EmitFlags.SingleLine */) {
                return true;
            }
            if (body.multiLine) {
                return false;
            }
            if (!ts.nodeIsSynthesized(body) && currentSourceFile && !ts.rangeIsOnSingleLine(body, currentSourceFile)) {
                return false;
            }
            if (getLeadingLineTerminatorCount(body, body.statements, 2 /* ListFormat.PreserveLines */)
                || getClosingLineTerminatorCount(body, body.statements, 2 /* ListFormat.PreserveLines */)) {
                return false;
            }
            var previousStatement;
            for (var _a = 0, _b = body.statements; _a < _b.length; _a++) {
                var statement = _b[_a];
                if (getSeparatingLineTerminatorCount(previousStatement, statement, 2 /* ListFormat.PreserveLines */) > 0) {
                    return false;
                }
                previousStatement = statement;
            }
            return true;
        }
        function emitBlockFunctionBody(body) {
            onBeforeEmitNode === null || onBeforeEmitNode === void 0 ? void 0 : onBeforeEmitNode(body);
            writeSpace();
            writePunctuation("{");
            increaseIndent();
            var emitBlockFunctionBody = shouldEmitBlockFunctionBodyOnSingleLine(body)
                ? emitBlockFunctionBodyOnSingleLine
                : emitBlockFunctionBodyWorker;
            emitBodyWithDetachedComments(body, body.statements, emitBlockFunctionBody);
            decreaseIndent();
            writeToken(19 /* SyntaxKind.CloseBraceToken */, body.statements.end, writePunctuation, body);
            onAfterEmitNode === null || onAfterEmitNode === void 0 ? void 0 : onAfterEmitNode(body);
        }
        function emitBlockFunctionBodyOnSingleLine(body) {
            emitBlockFunctionBodyWorker(body, /*emitBlockFunctionBodyOnSingleLine*/ true);
        }
        function emitBlockFunctionBodyWorker(body, emitBlockFunctionBodyOnSingleLine) {
            // Emit all the prologue directives (like "use strict").
            var statementOffset = emitPrologueDirectives(body.statements);
            var pos = writer.getTextPos();
            emitHelpers(body);
            if (statementOffset === 0 && pos === writer.getTextPos() && emitBlockFunctionBodyOnSingleLine) {
                decreaseIndent();
                emitList(body, body.statements, 768 /* ListFormat.SingleLineFunctionBodyStatements */);
                increaseIndent();
            }
            else {
                emitList(body, body.statements, 1 /* ListFormat.MultiLineFunctionBodyStatements */, /*parenthesizerRule*/ undefined, statementOffset);
            }
        }
        function emitClassDeclaration(node) {
            emitClassDeclarationOrExpression(node);
        }
        function emitClassDeclarationOrExpression(node) {
            ts.forEach(node.members, generateMemberNames);
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword("class");
            if (node.name) {
                writeSpace();
                emitIdentifierName(node.name);
            }
            var indentedFlag = ts.getEmitFlags(node) & 65536 /* EmitFlags.Indented */;
            if (indentedFlag) {
                increaseIndent();
            }
            emitTypeParameters(node, node.typeParameters);
            emitList(node, node.heritageClauses, 0 /* ListFormat.ClassHeritageClauses */);
            writeSpace();
            writePunctuation("{");
            emitList(node, node.members, 129 /* ListFormat.ClassMembers */);
            writePunctuation("}");
            if (indentedFlag) {
                decreaseIndent();
            }
        }
        function emitInterfaceDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword("interface");
            writeSpace();
            emit(node.name);
            emitTypeParameters(node, node.typeParameters);
            emitList(node, node.heritageClauses, 512 /* ListFormat.HeritageClauses */);
            writeSpace();
            writePunctuation("{");
            emitList(node, node.members, 129 /* ListFormat.InterfaceMembers */);
            writePunctuation("}");
        }
        function emitTypeAliasDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword("type");
            writeSpace();
            emit(node.name);
            emitTypeParameters(node, node.typeParameters);
            writeSpace();
            writePunctuation("=");
            writeSpace();
            emit(node.type);
            writeTrailingSemicolon();
        }
        function emitEnumDeclaration(node) {
            emitModifiers(node, node.modifiers);
            writeKeyword("enum");
            writeSpace();
            emit(node.name);
            writeSpace();
            writePunctuation("{");
            emitList(node, node.members, 145 /* ListFormat.EnumMembers */);
            writePunctuation("}");
        }
        function emitModuleDeclaration(node) {
            emitModifiers(node, node.modifiers);
            if (~node.flags & 1024 /* NodeFlags.GlobalAugmentation */) {
                writeKeyword(node.flags & 16 /* NodeFlags.Namespace */ ? "namespace" : "module");
                writeSpace();
            }
            emit(node.name);
            var body = node.body;
            if (!body)
                return writeTrailingSemicolon();
            while (body && ts.isModuleDeclaration(body)) {
                writePunctuation(".");
                emit(body.name);
                body = body.body;
            }
            writeSpace();
            emit(body);
        }
        function emitModuleBlock(node) {
            pushNameGenerationScope(node);
            ts.forEach(node.statements, generateNames);
            emitBlockStatements(node, /*forceSingleLine*/ isEmptyBlock(node));
            popNameGenerationScope(node);
        }
        function emitCaseBlock(node) {
            emitTokenWithComment(18 /* SyntaxKind.OpenBraceToken */, node.pos, writePunctuation, node);
            emitList(node, node.clauses, 129 /* ListFormat.CaseBlockClauses */);
            emitTokenWithComment(19 /* SyntaxKind.CloseBraceToken */, node.clauses.end, writePunctuation, node, /*indentLeading*/ true);
        }
        function emitImportEqualsDeclaration(node) {
            emitModifiers(node, node.modifiers);
            emitTokenWithComment(100 /* SyntaxKind.ImportKeyword */, node.modifiers ? node.modifiers.end : node.pos, writeKeyword, node);
            writeSpace();
            if (node.isTypeOnly) {
                emitTokenWithComment(152 /* SyntaxKind.TypeKeyword */, node.pos, writeKeyword, node);
                writeSpace();
            }
            emit(node.name);
            writeSpace();
            emitTokenWithComment(63 /* SyntaxKind.EqualsToken */, node.name.end, writePunctuation, node);
            writeSpace();
            emitModuleReference(node.moduleReference);
            writeTrailingSemicolon();
        }
        function emitModuleReference(node) {
            if (node.kind === 79 /* SyntaxKind.Identifier */) {
                emitExpression(node);
            }
            else {
                emit(node);
            }
        }
        function emitImportDeclaration(node) {
            emitModifiers(node, node.modifiers);
            emitTokenWithComment(100 /* SyntaxKind.ImportKeyword */, node.modifiers ? node.modifiers.end : node.pos, writeKeyword, node);
            writeSpace();
            if (node.importClause) {
                emit(node.importClause);
                writeSpace();
                emitTokenWithComment(156 /* SyntaxKind.FromKeyword */, node.importClause.end, writeKeyword, node);
                writeSpace();
            }
            emitExpression(node.moduleSpecifier);
            if (node.assertClause) {
                emitWithLeadingSpace(node.assertClause);
            }
            writeTrailingSemicolon();
        }
        function emitImportClause(node) {
            if (node.isTypeOnly) {
                emitTokenWithComment(152 /* SyntaxKind.TypeKeyword */, node.pos, writeKeyword, node);
                writeSpace();
            }
            emit(node.name);
            if (node.name && node.namedBindings) {
                emitTokenWithComment(27 /* SyntaxKind.CommaToken */, node.name.end, writePunctuation, node);
                writeSpace();
            }
            emit(node.namedBindings);
        }
        function emitNamespaceImport(node) {
            var asPos = emitTokenWithComment(41 /* SyntaxKind.AsteriskToken */, node.pos, writePunctuation, node);
            writeSpace();
            emitTokenWithComment(127 /* SyntaxKind.AsKeyword */, asPos, writeKeyword, node);
            writeSpace();
            emit(node.name);
        }
        function emitNamedImports(node) {
            emitNamedImportsOrExports(node);
        }
        function emitImportSpecifier(node) {
            emitImportOrExportSpecifier(node);
        }
        function emitExportAssignment(node) {
            var nextPos = emitTokenWithComment(93 /* SyntaxKind.ExportKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            if (node.isExportEquals) {
                emitTokenWithComment(63 /* SyntaxKind.EqualsToken */, nextPos, writeOperator, node);
            }
            else {
                emitTokenWithComment(88 /* SyntaxKind.DefaultKeyword */, nextPos, writeKeyword, node);
            }
            writeSpace();
            emitExpression(node.expression, node.isExportEquals ?
                parenthesizer.getParenthesizeRightSideOfBinaryForOperator(63 /* SyntaxKind.EqualsToken */) :
                parenthesizer.parenthesizeExpressionOfExportDefault);
            writeTrailingSemicolon();
        }
        function emitExportDeclaration(node) {
            var nextPos = emitTokenWithComment(93 /* SyntaxKind.ExportKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            if (node.isTypeOnly) {
                nextPos = emitTokenWithComment(152 /* SyntaxKind.TypeKeyword */, nextPos, writeKeyword, node);
                writeSpace();
            }
            if (node.exportClause) {
                emit(node.exportClause);
            }
            else {
                nextPos = emitTokenWithComment(41 /* SyntaxKind.AsteriskToken */, nextPos, writePunctuation, node);
            }
            if (node.moduleSpecifier) {
                writeSpace();
                var fromPos = node.exportClause ? node.exportClause.end : nextPos;
                emitTokenWithComment(156 /* SyntaxKind.FromKeyword */, fromPos, writeKeyword, node);
                writeSpace();
                emitExpression(node.moduleSpecifier);
            }
            if (node.assertClause) {
                emitWithLeadingSpace(node.assertClause);
            }
            writeTrailingSemicolon();
        }
        function emitAssertClause(node) {
            emitTokenWithComment(129 /* SyntaxKind.AssertKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            var elements = node.elements;
            emitList(node, elements, 526226 /* ListFormat.ImportClauseEntries */);
        }
        function emitAssertEntry(node) {
            emit(node.name);
            writePunctuation(":");
            writeSpace();
            var value = node.value;
            /** @see {emitPropertyAssignment} */
            if ((ts.getEmitFlags(value) & 512 /* EmitFlags.NoLeadingComments */) === 0) {
                var commentRange = ts.getCommentRange(value);
                emitTrailingCommentsOfPosition(commentRange.pos);
            }
            emit(value);
        }
        function emitNamespaceExportDeclaration(node) {
            var nextPos = emitTokenWithComment(93 /* SyntaxKind.ExportKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            nextPos = emitTokenWithComment(127 /* SyntaxKind.AsKeyword */, nextPos, writeKeyword, node);
            writeSpace();
            nextPos = emitTokenWithComment(142 /* SyntaxKind.NamespaceKeyword */, nextPos, writeKeyword, node);
            writeSpace();
            emit(node.name);
            writeTrailingSemicolon();
        }
        function emitNamespaceExport(node) {
            var asPos = emitTokenWithComment(41 /* SyntaxKind.AsteriskToken */, node.pos, writePunctuation, node);
            writeSpace();
            emitTokenWithComment(127 /* SyntaxKind.AsKeyword */, asPos, writeKeyword, node);
            writeSpace();
            emit(node.name);
        }
        function emitNamedExports(node) {
            emitNamedImportsOrExports(node);
        }
        function emitExportSpecifier(node) {
            emitImportOrExportSpecifier(node);
        }
        function emitNamedImportsOrExports(node) {
            writePunctuation("{");
            emitList(node, node.elements, 525136 /* ListFormat.NamedImportsOrExportsElements */);
            writePunctuation("}");
        }
        function emitImportOrExportSpecifier(node) {
            if (node.isTypeOnly) {
                writeKeyword("type");
                writeSpace();
            }
            if (node.propertyName) {
                emit(node.propertyName);
                writeSpace();
                emitTokenWithComment(127 /* SyntaxKind.AsKeyword */, node.propertyName.end, writeKeyword, node);
                writeSpace();
            }
            emit(node.name);
        }
        //
        // Module references
        //
        function emitExternalModuleReference(node) {
            writeKeyword("require");
            writePunctuation("(");
            emitExpression(node.expression);
            writePunctuation(")");
        }
        //
        // JSX
        //
        function emitJsxElement(node) {
            emit(node.openingElement);
            emitList(node, node.children, 262144 /* ListFormat.JsxElementOrFragmentChildren */);
            emit(node.closingElement);
        }
        function emitJsxSelfClosingElement(node) {
            writePunctuation("<");
            emitJsxTagName(node.tagName);
            emitTypeArguments(node, node.typeArguments);
            writeSpace();
            emit(node.attributes);
            writePunctuation("/>");
        }
        function emitJsxFragment(node) {
            emit(node.openingFragment);
            emitList(node, node.children, 262144 /* ListFormat.JsxElementOrFragmentChildren */);
            emit(node.closingFragment);
        }
        function emitJsxOpeningElementOrFragment(node) {
            writePunctuation("<");
            if (ts.isJsxOpeningElement(node)) {
                var indented = writeLineSeparatorsAndIndentBefore(node.tagName, node);
                emitJsxTagName(node.tagName);
                emitTypeArguments(node, node.typeArguments);
                if (node.attributes.properties && node.attributes.properties.length > 0) {
                    writeSpace();
                }
                emit(node.attributes);
                writeLineSeparatorsAfter(node.attributes, node);
                decreaseIndentIf(indented);
            }
            writePunctuation(">");
        }
        function emitJsxText(node) {
            writer.writeLiteral(node.text);
        }
        function emitJsxClosingElementOrFragment(node) {
            writePunctuation("</");
            if (ts.isJsxClosingElement(node)) {
                emitJsxTagName(node.tagName);
            }
            writePunctuation(">");
        }
        function emitJsxAttributes(node) {
            emitList(node, node.properties, 262656 /* ListFormat.JsxElementAttributes */);
        }
        function emitJsxAttribute(node) {
            emit(node.name);
            emitNodeWithPrefix("=", writePunctuation, node.initializer, emitJsxAttributeValue);
        }
        function emitJsxSpreadAttribute(node) {
            writePunctuation("{...");
            emitExpression(node.expression);
            writePunctuation("}");
        }
        function hasTrailingCommentsAtPosition(pos) {
            var result = false;
            ts.forEachTrailingCommentRange((currentSourceFile === null || currentSourceFile === void 0 ? void 0 : currentSourceFile.text) || "", pos + 1, function () { return result = true; });
            return result;
        }
        function hasLeadingCommentsAtPosition(pos) {
            var result = false;
            ts.forEachLeadingCommentRange((currentSourceFile === null || currentSourceFile === void 0 ? void 0 : currentSourceFile.text) || "", pos + 1, function () { return result = true; });
            return result;
        }
        function hasCommentsAtPosition(pos) {
            return hasTrailingCommentsAtPosition(pos) || hasLeadingCommentsAtPosition(pos);
        }
        function emitJsxExpression(node) {
            var _a;
            if (node.expression || (!commentsDisabled && !ts.nodeIsSynthesized(node) && hasCommentsAtPosition(node.pos))) { // preserve empty expressions if they contain comments!
                var isMultiline = currentSourceFile && !ts.nodeIsSynthesized(node) && ts.getLineAndCharacterOfPosition(currentSourceFile, node.pos).line !== ts.getLineAndCharacterOfPosition(currentSourceFile, node.end).line;
                if (isMultiline) {
                    writer.increaseIndent();
                }
                var end = emitTokenWithComment(18 /* SyntaxKind.OpenBraceToken */, node.pos, writePunctuation, node);
                emit(node.dotDotDotToken);
                emitExpression(node.expression);
                emitTokenWithComment(19 /* SyntaxKind.CloseBraceToken */, ((_a = node.expression) === null || _a === void 0 ? void 0 : _a.end) || end, writePunctuation, node);
                if (isMultiline) {
                    writer.decreaseIndent();
                }
            }
        }
        function emitJsxTagName(node) {
            if (node.kind === 79 /* SyntaxKind.Identifier */) {
                emitExpression(node);
            }
            else {
                emit(node);
            }
        }
        //
        // Clauses
        //
        function emitCaseClause(node) {
            emitTokenWithComment(82 /* SyntaxKind.CaseKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma);
            emitCaseOrDefaultClauseRest(node, node.statements, node.expression.end);
        }
        function emitDefaultClause(node) {
            var pos = emitTokenWithComment(88 /* SyntaxKind.DefaultKeyword */, node.pos, writeKeyword, node);
            emitCaseOrDefaultClauseRest(node, node.statements, pos);
        }
        function emitCaseOrDefaultClauseRest(parentNode, statements, colonPos) {
            var emitAsSingleStatement = statements.length === 1 &&
                (
                // treat synthesized nodes as located on the same line for emit purposes
                !currentSourceFile ||
                    ts.nodeIsSynthesized(parentNode) ||
                    ts.nodeIsSynthesized(statements[0]) ||
                    ts.rangeStartPositionsAreOnSameLine(parentNode, statements[0], currentSourceFile));
            var format = 163969 /* ListFormat.CaseOrDefaultClauseStatements */;
            if (emitAsSingleStatement) {
                writeToken(58 /* SyntaxKind.ColonToken */, colonPos, writePunctuation, parentNode);
                writeSpace();
                format &= ~(1 /* ListFormat.MultiLine */ | 128 /* ListFormat.Indented */);
            }
            else {
                emitTokenWithComment(58 /* SyntaxKind.ColonToken */, colonPos, writePunctuation, parentNode);
            }
            emitList(parentNode, statements, format);
        }
        function emitHeritageClause(node) {
            writeSpace();
            writeTokenText(node.token, writeKeyword);
            writeSpace();
            emitList(node, node.types, 528 /* ListFormat.HeritageClauseTypes */);
        }
        function emitCatchClause(node) {
            var openParenPos = emitTokenWithComment(83 /* SyntaxKind.CatchKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            if (node.variableDeclaration) {
                emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
                emit(node.variableDeclaration);
                emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.variableDeclaration.end, writePunctuation, node);
                writeSpace();
            }
            emit(node.block);
        }
        //
        // Property assignments
        //
        function emitPropertyAssignment(node) {
            emit(node.name);
            writePunctuation(":");
            writeSpace();
            // This is to ensure that we emit comment in the following case:
            //      For example:
            //          obj = {
            //              id: /*comment1*/ ()=>void
            //          }
            // "comment1" is not considered to be leading comment for node.initializer
            // but rather a trailing comment on the previous node.
            var initializer = node.initializer;
            if ((ts.getEmitFlags(initializer) & 512 /* EmitFlags.NoLeadingComments */) === 0) {
                var commentRange = ts.getCommentRange(initializer);
                emitTrailingCommentsOfPosition(commentRange.pos);
            }
            emitExpression(initializer, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitShorthandPropertyAssignment(node) {
            emit(node.name);
            if (node.objectAssignmentInitializer) {
                writeSpace();
                writePunctuation("=");
                writeSpace();
                emitExpression(node.objectAssignmentInitializer, parenthesizer.parenthesizeExpressionForDisallowedComma);
            }
        }
        function emitSpreadAssignment(node) {
            if (node.expression) {
                emitTokenWithComment(25 /* SyntaxKind.DotDotDotToken */, node.pos, writePunctuation, node);
                emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma);
            }
        }
        //
        // Enum
        //
        function emitEnumMember(node) {
            emit(node.name);
            emitInitializer(node.initializer, node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        //
        // JSDoc
        //
        function emitJSDoc(node) {
            write("/**");
            if (node.comment) {
                var text = ts.getTextOfJSDocComment(node.comment);
                if (text) {
                    var lines = text.split(/\r\n?|\n/g);
                    for (var _a = 0, lines_2 = lines; _a < lines_2.length; _a++) {
                        var line = lines_2[_a];
                        writeLine();
                        writeSpace();
                        writePunctuation("*");
                        writeSpace();
                        write(line);
                    }
                }
            }
            if (node.tags) {
                if (node.tags.length === 1 && node.tags[0].kind === 343 /* SyntaxKind.JSDocTypeTag */ && !node.comment) {
                    writeSpace();
                    emit(node.tags[0]);
                }
                else {
                    emitList(node, node.tags, 33 /* ListFormat.JSDocComment */);
                }
            }
            writeSpace();
            write("*/");
        }
        function emitJSDocSimpleTypedTag(tag) {
            emitJSDocTagName(tag.tagName);
            emitJSDocTypeExpression(tag.typeExpression);
            emitJSDocComment(tag.comment);
        }
        function emitJSDocSeeTag(tag) {
            emitJSDocTagName(tag.tagName);
            emit(tag.name);
            emitJSDocComment(tag.comment);
        }
        function emitJSDocNameReference(node) {
            writeSpace();
            writePunctuation("{");
            emit(node.name);
            writePunctuation("}");
        }
        function emitJSDocHeritageTag(tag) {
            emitJSDocTagName(tag.tagName);
            writeSpace();
            writePunctuation("{");
            emit(tag.class);
            writePunctuation("}");
            emitJSDocComment(tag.comment);
        }
        function emitJSDocTemplateTag(tag) {
            emitJSDocTagName(tag.tagName);
            emitJSDocTypeExpression(tag.constraint);
            writeSpace();
            emitList(tag, tag.typeParameters, 528 /* ListFormat.CommaListElements */);
            emitJSDocComment(tag.comment);
        }
        function emitJSDocTypedefTag(tag) {
            emitJSDocTagName(tag.tagName);
            if (tag.typeExpression) {
                if (tag.typeExpression.kind === 309 /* SyntaxKind.JSDocTypeExpression */) {
                    emitJSDocTypeExpression(tag.typeExpression);
                }
                else {
                    writeSpace();
                    writePunctuation("{");
                    write("Object");
                    if (tag.typeExpression.isArrayType) {
                        writePunctuation("[");
                        writePunctuation("]");
                    }
                    writePunctuation("}");
                }
            }
            if (tag.fullName) {
                writeSpace();
                emit(tag.fullName);
            }
            emitJSDocComment(tag.comment);
            if (tag.typeExpression && tag.typeExpression.kind === 322 /* SyntaxKind.JSDocTypeLiteral */) {
                emitJSDocTypeLiteral(tag.typeExpression);
            }
        }
        function emitJSDocCallbackTag(tag) {
            emitJSDocTagName(tag.tagName);
            if (tag.name) {
                writeSpace();
                emit(tag.name);
            }
            emitJSDocComment(tag.comment);
            emitJSDocSignature(tag.typeExpression);
        }
        function emitJSDocSimpleTag(tag) {
            emitJSDocTagName(tag.tagName);
            emitJSDocComment(tag.comment);
        }
        function emitJSDocTypeLiteral(lit) {
            emitList(lit, ts.factory.createNodeArray(lit.jsDocPropertyTags), 33 /* ListFormat.JSDocComment */);
        }
        function emitJSDocSignature(sig) {
            if (sig.typeParameters) {
                emitList(sig, ts.factory.createNodeArray(sig.typeParameters), 33 /* ListFormat.JSDocComment */);
            }
            if (sig.parameters) {
                emitList(sig, ts.factory.createNodeArray(sig.parameters), 33 /* ListFormat.JSDocComment */);
            }
            if (sig.type) {
                writeLine();
                writeSpace();
                writePunctuation("*");
                writeSpace();
                emit(sig.type);
            }
        }
        function emitJSDocPropertyLikeTag(param) {
            emitJSDocTagName(param.tagName);
            emitJSDocTypeExpression(param.typeExpression);
            writeSpace();
            if (param.isBracketed) {
                writePunctuation("[");
            }
            emit(param.name);
            if (param.isBracketed) {
                writePunctuation("]");
            }
            emitJSDocComment(param.comment);
        }
        function emitJSDocTagName(tagName) {
            writePunctuation("@");
            emit(tagName);
        }
        function emitJSDocComment(comment) {
            var text = ts.getTextOfJSDocComment(comment);
            if (text) {
                writeSpace();
                write(text);
            }
        }
        function emitJSDocTypeExpression(typeExpression) {
            if (typeExpression) {
                writeSpace();
                writePunctuation("{");
                emit(typeExpression.type);
                writePunctuation("}");
            }
        }
        //
        // Top-level nodes
        //
        function emitSourceFile(node) {
            writeLine();
            var statements = node.statements;
            // Emit detached comment if there are no prologue directives or if the first node is synthesized.
            // The synthesized node will have no leading comment so some comments may be missed.
            var shouldEmitDetachedComment = statements.length === 0 ||
                !ts.isPrologueDirective(statements[0]) ||
                ts.nodeIsSynthesized(statements[0]);
            if (shouldEmitDetachedComment) {
                emitBodyWithDetachedComments(node, statements, emitSourceFileWorker);
                return;
            }
            emitSourceFileWorker(node);
        }
        function emitSyntheticTripleSlashReferencesIfNeeded(node) {
            emitTripleSlashDirectives(!!node.hasNoDefaultLib, node.syntheticFileReferences || [], node.syntheticTypeReferences || [], node.syntheticLibReferences || []);
            for (var _a = 0, _b = node.prepends; _a < _b.length; _a++) {
                var prepend = _b[_a];
                if (ts.isUnparsedSource(prepend) && prepend.syntheticReferences) {
                    for (var _c = 0, _d = prepend.syntheticReferences; _c < _d.length; _c++) {
                        var ref = _d[_c];
                        emit(ref);
                        writeLine();
                    }
                }
            }
        }
        function emitTripleSlashDirectivesIfNeeded(node) {
            if (node.isDeclarationFile)
                emitTripleSlashDirectives(node.hasNoDefaultLib, node.referencedFiles, node.typeReferenceDirectives, node.libReferenceDirectives);
        }
        function emitTripleSlashDirectives(hasNoDefaultLib, files, types, libs) {
            if (hasNoDefaultLib) {
                var pos = writer.getTextPos();
                writeComment("/// <reference no-default-lib=\"true\"/>");
                if (bundleFileInfo)
                    bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "no-default-lib" /* BundleFileSectionKind.NoDefaultLib */ });
                writeLine();
            }
            if (currentSourceFile && currentSourceFile.moduleName) {
                writeComment("/// <amd-module name=\"".concat(currentSourceFile.moduleName, "\" />"));
                writeLine();
            }
            if (currentSourceFile && currentSourceFile.amdDependencies) {
                for (var _a = 0, _b = currentSourceFile.amdDependencies; _a < _b.length; _a++) {
                    var dep = _b[_a];
                    if (dep.name) {
                        writeComment("/// <amd-dependency name=\"".concat(dep.name, "\" path=\"").concat(dep.path, "\" />"));
                    }
                    else {
                        writeComment("/// <amd-dependency path=\"".concat(dep.path, "\" />"));
                    }
                    writeLine();
                }
            }
            for (var _c = 0, files_2 = files; _c < files_2.length; _c++) {
                var directive = files_2[_c];
                var pos = writer.getTextPos();
                writeComment("/// <reference path=\"".concat(directive.fileName, "\" />"));
                if (bundleFileInfo)
                    bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "reference" /* BundleFileSectionKind.Reference */, data: directive.fileName });
                writeLine();
            }
            for (var _d = 0, types_24 = types; _d < types_24.length; _d++) {
                var directive = types_24[_d];
                var pos = writer.getTextPos();
                var resolutionMode = directive.resolutionMode && directive.resolutionMode !== (currentSourceFile === null || currentSourceFile === void 0 ? void 0 : currentSourceFile.impliedNodeFormat)
                    ? "resolution-mode=\"".concat(directive.resolutionMode === ts.ModuleKind.ESNext ? "import" : "require", "\"")
                    : "";
                writeComment("/// <reference types=\"".concat(directive.fileName, "\" ").concat(resolutionMode, "/>"));
                if (bundleFileInfo)
                    bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: !directive.resolutionMode ? "type" /* BundleFileSectionKind.Type */ : directive.resolutionMode === ts.ModuleKind.ESNext ? "type-import" /* BundleFileSectionKind.TypeResolutionModeImport */ : "type-require" /* BundleFileSectionKind.TypeResolutionModeRequire */, data: directive.fileName });
                writeLine();
            }
            for (var _e = 0, libs_1 = libs; _e < libs_1.length; _e++) {
                var directive = libs_1[_e];
                var pos = writer.getTextPos();
                writeComment("/// <reference lib=\"".concat(directive.fileName, "\" />"));
                if (bundleFileInfo)
                    bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "lib" /* BundleFileSectionKind.Lib */, data: directive.fileName });
                writeLine();
            }
        }
        function emitSourceFileWorker(node) {
            var statements = node.statements;
            pushNameGenerationScope(node);
            ts.forEach(node.statements, generateNames);
            emitHelpers(node);
            var index = ts.findIndex(statements, function (statement) { return !ts.isPrologueDirective(statement); });
            emitTripleSlashDirectivesIfNeeded(node);
            emitList(node, statements, 1 /* ListFormat.MultiLine */, /*parenthesizerRule*/ undefined, index === -1 ? statements.length : index);
            popNameGenerationScope(node);
        }
        // Transformation nodes
        function emitPartiallyEmittedExpression(node) {
            var emitFlags = ts.getEmitFlags(node);
            if (!(emitFlags & 512 /* EmitFlags.NoLeadingComments */) && node.pos !== node.expression.pos) {
                emitTrailingCommentsOfPosition(node.expression.pos);
            }
            emitExpression(node.expression);
            if (!(emitFlags & 1024 /* EmitFlags.NoTrailingComments */) && node.end !== node.expression.end) {
                emitLeadingCommentsOfPosition(node.expression.end);
            }
        }
        function emitCommaList(node) {
            emitExpressionList(node, node.elements, 528 /* ListFormat.CommaListElements */, /*parenthesizerRule*/ undefined);
        }
        /**
         * Emits any prologue directives at the start of a Statement list, returning the
         * number of prologue directives written to the output.
         */
        function emitPrologueDirectives(statements, sourceFile, seenPrologueDirectives, recordBundleFileSection) {
            var needsToSetSourceFile = !!sourceFile;
            for (var i = 0; i < statements.length; i++) {
                var statement = statements[i];
                if (ts.isPrologueDirective(statement)) {
                    var shouldEmitPrologueDirective = seenPrologueDirectives ? !seenPrologueDirectives.has(statement.expression.text) : true;
                    if (shouldEmitPrologueDirective) {
                        if (needsToSetSourceFile) {
                            needsToSetSourceFile = false;
                            setSourceFile(sourceFile);
                        }
                        writeLine();
                        var pos = writer.getTextPos();
                        emit(statement);
                        if (recordBundleFileSection && bundleFileInfo)
                            bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "prologue" /* BundleFileSectionKind.Prologue */, data: statement.expression.text });
                        if (seenPrologueDirectives) {
                            seenPrologueDirectives.add(statement.expression.text);
                        }
                    }
                }
                else {
                    // return index of the first non prologue directive
                    return i;
                }
            }
            return statements.length;
        }
        function emitUnparsedPrologues(prologues, seenPrologueDirectives) {
            for (var _a = 0, prologues_1 = prologues; _a < prologues_1.length; _a++) {
                var prologue = prologues_1[_a];
                if (!seenPrologueDirectives.has(prologue.data)) {
                    writeLine();
                    var pos = writer.getTextPos();
                    emit(prologue);
                    if (bundleFileInfo)
                        bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "prologue" /* BundleFileSectionKind.Prologue */, data: prologue.data });
                    if (seenPrologueDirectives) {
                        seenPrologueDirectives.add(prologue.data);
                    }
                }
            }
        }
        function emitPrologueDirectivesIfNeeded(sourceFileOrBundle) {
            if (ts.isSourceFile(sourceFileOrBundle)) {
                emitPrologueDirectives(sourceFileOrBundle.statements, sourceFileOrBundle);
            }
            else {
                var seenPrologueDirectives = new ts.Set();
                for (var _a = 0, _b = sourceFileOrBundle.prepends; _a < _b.length; _a++) {
                    var prepend = _b[_a];
                    emitUnparsedPrologues(prepend.prologues, seenPrologueDirectives);
                }
                for (var _c = 0, _d = sourceFileOrBundle.sourceFiles; _c < _d.length; _c++) {
                    var sourceFile = _d[_c];
                    emitPrologueDirectives(sourceFile.statements, sourceFile, seenPrologueDirectives, /*recordBundleFileSection*/ true);
                }
                setSourceFile(undefined);
            }
        }
        function getPrologueDirectivesFromBundledSourceFiles(bundle) {
            var seenPrologueDirectives = new ts.Set();
            var prologues;
            for (var index = 0; index < bundle.sourceFiles.length; index++) {
                var sourceFile = bundle.sourceFiles[index];
                var directives = void 0;
                var end = 0;
                for (var _a = 0, _b = sourceFile.statements; _a < _b.length; _a++) {
                    var statement = _b[_a];
                    if (!ts.isPrologueDirective(statement))
                        break;
                    if (seenPrologueDirectives.has(statement.expression.text))
                        continue;
                    seenPrologueDirectives.add(statement.expression.text);
                    (directives || (directives = [])).push({
                        pos: statement.pos,
                        end: statement.end,
                        expression: {
                            pos: statement.expression.pos,
                            end: statement.expression.end,
                            text: statement.expression.text
                        }
                    });
                    end = end < statement.end ? statement.end : end;
                }
                if (directives)
                    (prologues || (prologues = [])).push({ file: index, text: sourceFile.text.substring(0, end), directives: directives });
            }
            return prologues;
        }
        function emitShebangIfNeeded(sourceFileOrBundle) {
            if (ts.isSourceFile(sourceFileOrBundle) || ts.isUnparsedSource(sourceFileOrBundle)) {
                var shebang = ts.getShebang(sourceFileOrBundle.text);
                if (shebang) {
                    writeComment(shebang);
                    writeLine();
                    return true;
                }
            }
            else {
                for (var _a = 0, _b = sourceFileOrBundle.prepends; _a < _b.length; _a++) {
                    var prepend = _b[_a];
                    ts.Debug.assertNode(prepend, ts.isUnparsedSource);
                    if (emitShebangIfNeeded(prepend)) {
                        return true;
                    }
                }
                for (var _c = 0, _d = sourceFileOrBundle.sourceFiles; _c < _d.length; _c++) {
                    var sourceFile = _d[_c];
                    // Emit only the first encountered shebang
                    if (emitShebangIfNeeded(sourceFile)) {
                        return true;
                    }
                }
            }
        }
        //
        // Helpers
        //
        function emitNodeWithWriter(node, writer) {
            if (!node)
                return;
            var savedWrite = write;
            write = writer;
            emit(node);
            write = savedWrite;
        }
        function emitModifiers(node, modifiers) {
            if (modifiers && modifiers.length) {
                emitList(node, modifiers, 262656 /* ListFormat.Modifiers */);
                writeSpace();
            }
        }
        function emitTypeAnnotation(node) {
            if (node) {
                writePunctuation(":");
                writeSpace();
                emit(node);
            }
        }
        function emitInitializer(node, equalCommentStartPos, container, parenthesizerRule) {
            if (node) {
                writeSpace();
                emitTokenWithComment(63 /* SyntaxKind.EqualsToken */, equalCommentStartPos, writeOperator, container);
                writeSpace();
                emitExpression(node, parenthesizerRule);
            }
        }
        function emitNodeWithPrefix(prefix, prefixWriter, node, emit) {
            if (node) {
                prefixWriter(prefix);
                emit(node);
            }
        }
        function emitWithLeadingSpace(node) {
            if (node) {
                writeSpace();
                emit(node);
            }
        }
        function emitExpressionWithLeadingSpace(node, parenthesizerRule) {
            if (node) {
                writeSpace();
                emitExpression(node, parenthesizerRule);
            }
        }
        function emitWithTrailingSpace(node) {
            if (node) {
                emit(node);
                writeSpace();
            }
        }
        function emitEmbeddedStatement(parent, node) {
            if (ts.isBlock(node) || ts.getEmitFlags(parent) & 1 /* EmitFlags.SingleLine */) {
                writeSpace();
                emit(node);
            }
            else {
                writeLine();
                increaseIndent();
                if (ts.isEmptyStatement(node)) {
                    pipelineEmit(5 /* EmitHint.EmbeddedStatement */, node);
                }
                else {
                    emit(node);
                }
                decreaseIndent();
            }
        }
        function emitDecorators(parentNode, decorators) {
            emitList(parentNode, decorators, 2146305 /* ListFormat.Decorators */);
        }
        function emitTypeArguments(parentNode, typeArguments) {
            emitList(parentNode, typeArguments, 53776 /* ListFormat.TypeArguments */, typeArgumentParenthesizerRuleSelector);
        }
        function emitTypeParameters(parentNode, typeParameters) {
            if (ts.isFunctionLike(parentNode) && parentNode.typeArguments) { // Quick info uses type arguments in place of type parameters on instantiated signatures
                return emitTypeArguments(parentNode, parentNode.typeArguments);
            }
            emitList(parentNode, typeParameters, 53776 /* ListFormat.TypeParameters */);
        }
        function emitParameters(parentNode, parameters) {
            emitList(parentNode, parameters, 2576 /* ListFormat.Parameters */);
        }
        function canEmitSimpleArrowHead(parentNode, parameters) {
            var parameter = ts.singleOrUndefined(parameters);
            return parameter
                && parameter.pos === parentNode.pos // may not have parsed tokens between parent and parameter
                && ts.isArrowFunction(parentNode) // only arrow functions may have simple arrow head
                && !parentNode.type // arrow function may not have return type annotation
                && !ts.some(parentNode.decorators) // parent may not have decorators
                && !ts.some(parentNode.modifiers) // parent may not have modifiers
                && !ts.some(parentNode.typeParameters) // parent may not have type parameters
                && !ts.some(parameter.decorators) // parameter may not have decorators
                && !ts.some(parameter.modifiers) // parameter may not have modifiers
                && !parameter.dotDotDotToken // parameter may not be rest
                && !parameter.questionToken // parameter may not be optional
                && !parameter.type // parameter may not have a type annotation
                && !parameter.initializer // parameter may not have an initializer
                && ts.isIdentifier(parameter.name); // parameter name must be identifier
        }
        function emitParametersForArrow(parentNode, parameters) {
            if (canEmitSimpleArrowHead(parentNode, parameters)) {
                emitList(parentNode, parameters, 2576 /* ListFormat.Parameters */ & ~2048 /* ListFormat.Parenthesis */);
            }
            else {
                emitParameters(parentNode, parameters);
            }
        }
        function emitParametersForIndexSignature(parentNode, parameters) {
            emitList(parentNode, parameters, 8848 /* ListFormat.IndexSignatureParameters */);
        }
        function writeDelimiter(format) {
            switch (format & 60 /* ListFormat.DelimitersMask */) {
                case 0 /* ListFormat.None */:
                    break;
                case 16 /* ListFormat.CommaDelimited */:
                    writePunctuation(",");
                    break;
                case 4 /* ListFormat.BarDelimited */:
                    writeSpace();
                    writePunctuation("|");
                    break;
                case 32 /* ListFormat.AsteriskDelimited */:
                    writeSpace();
                    writePunctuation("*");
                    writeSpace();
                    break;
                case 8 /* ListFormat.AmpersandDelimited */:
                    writeSpace();
                    writePunctuation("&");
                    break;
            }
        }
        function emitList(parentNode, children, format, parenthesizerRule, start, count) {
            emitNodeList(emit, parentNode, children, format, parenthesizerRule, start, count);
        }
        function emitExpressionList(parentNode, children, format, parenthesizerRule, start, count) {
            emitNodeList(emitExpression, parentNode, children, format, parenthesizerRule, start, count);
        }
        function emitNodeList(emit, parentNode, children, format, parenthesizerRule, start, count) {
            if (start === void 0) { start = 0; }
            if (count === void 0) { count = children ? children.length - start : 0; }
            var isUndefined = children === undefined;
            if (isUndefined && format & 16384 /* ListFormat.OptionalIfUndefined */) {
                return;
            }
            var isEmpty = children === undefined || start >= children.length || count === 0;
            if (isEmpty && format & 32768 /* ListFormat.OptionalIfEmpty */) {
                if (onBeforeEmitNodeArray) {
                    onBeforeEmitNodeArray(children);
                }
                if (onAfterEmitNodeArray) {
                    onAfterEmitNodeArray(children);
                }
                return;
            }
            if (format & 15360 /* ListFormat.BracketsMask */) {
                writePunctuation(getOpeningBracket(format));
                if (isEmpty && children) {
                    emitTrailingCommentsOfPosition(children.pos, /*prefixSpace*/ true); // Emit comments within empty bracketed lists
                }
            }
            if (onBeforeEmitNodeArray) {
                onBeforeEmitNodeArray(children);
            }
            if (isEmpty) {
                // Write a line terminator if the parent node was multi-line
                if (format & 1 /* ListFormat.MultiLine */ && !(preserveSourceNewlines && (!parentNode || currentSourceFile && ts.rangeIsOnSingleLine(parentNode, currentSourceFile)))) {
                    writeLine();
                }
                else if (format & 256 /* ListFormat.SpaceBetweenBraces */ && !(format & 524288 /* ListFormat.NoSpaceIfEmpty */)) {
                    writeSpace();
                }
            }
            else {
                ts.Debug.type(children);
                // Write the opening line terminator or leading whitespace.
                var mayEmitInterveningComments = (format & 262144 /* ListFormat.NoInterveningComments */) === 0;
                var shouldEmitInterveningComments = mayEmitInterveningComments;
                var leadingLineTerminatorCount = getLeadingLineTerminatorCount(parentNode, children, format); // TODO: GH#18217
                if (leadingLineTerminatorCount) {
                    writeLine(leadingLineTerminatorCount);
                    shouldEmitInterveningComments = false;
                }
                else if (format & 256 /* ListFormat.SpaceBetweenBraces */) {
                    writeSpace();
                }
                // Increase the indent, if requested.
                if (format & 128 /* ListFormat.Indented */) {
                    increaseIndent();
                }
                var emitListItem = getEmitListItem(emit, parenthesizerRule);
                // Emit each child.
                var previousSibling = void 0;
                var previousSourceFileTextKind = void 0;
                var shouldDecreaseIndentAfterEmit = false;
                for (var i = 0; i < count; i++) {
                    var child = children[start + i];
                    // Write the delimiter if this is not the first node.
                    if (format & 32 /* ListFormat.AsteriskDelimited */) {
                        // always write JSDoc in the format "\n *"
                        writeLine();
                        writeDelimiter(format);
                    }
                    else if (previousSibling) {
                        // i.e
                        //      function commentedParameters(
                        //          /* Parameter a */
                        //          a
                        //          /* End of parameter a */ -> this comment isn't considered to be trailing comment of parameter "a" due to newline
                        //          ,
                        if (format & 60 /* ListFormat.DelimitersMask */ && previousSibling.end !== (parentNode ? parentNode.end : -1)) {
                            emitLeadingCommentsOfPosition(previousSibling.end);
                        }
                        writeDelimiter(format);
                        recordBundleFileInternalSectionEnd(previousSourceFileTextKind);
                        // Write either a line terminator or whitespace to separate the elements.
                        var separatingLineTerminatorCount = getSeparatingLineTerminatorCount(previousSibling, child, format);
                        if (separatingLineTerminatorCount > 0) {
                            // If a synthesized node in a single-line list starts on a new
                            // line, we should increase the indent.
                            if ((format & (3 /* ListFormat.LinesMask */ | 128 /* ListFormat.Indented */)) === 0 /* ListFormat.SingleLine */) {
                                increaseIndent();
                                shouldDecreaseIndentAfterEmit = true;
                            }
                            writeLine(separatingLineTerminatorCount);
                            shouldEmitInterveningComments = false;
                        }
                        else if (previousSibling && format & 512 /* ListFormat.SpaceBetweenSiblings */) {
                            writeSpace();
                        }
                    }
                    // Emit this child.
                    previousSourceFileTextKind = recordBundleFileInternalSectionStart(child);
                    if (shouldEmitInterveningComments) {
                        var commentRange = ts.getCommentRange(child);
                        emitTrailingCommentsOfPosition(commentRange.pos);
                    }
                    else {
                        shouldEmitInterveningComments = mayEmitInterveningComments;
                    }
                    nextListElementPos = child.pos;
                    emitListItem(child, emit, parenthesizerRule, i);
                    if (shouldDecreaseIndentAfterEmit) {
                        decreaseIndent();
                        shouldDecreaseIndentAfterEmit = false;
                    }
                    previousSibling = child;
                }
                // Write a trailing comma, if requested.
                var emitFlags = previousSibling ? ts.getEmitFlags(previousSibling) : 0;
                var skipTrailingComments = commentsDisabled || !!(emitFlags & 1024 /* EmitFlags.NoTrailingComments */);
                var hasTrailingComma = (children === null || children === void 0 ? void 0 : children.hasTrailingComma) && (format & 64 /* ListFormat.AllowTrailingComma */) && (format & 16 /* ListFormat.CommaDelimited */);
                if (hasTrailingComma) {
                    if (previousSibling && !skipTrailingComments) {
                        emitTokenWithComment(27 /* SyntaxKind.CommaToken */, previousSibling.end, writePunctuation, previousSibling);
                    }
                    else {
                        writePunctuation(",");
                    }
                }
                // Emit any trailing comment of the last element in the list
                // i.e
                //       var array = [...
                //          2
                //          /* end of element 2 */
                //       ];
                if (previousSibling && (parentNode ? parentNode.end : -1) !== previousSibling.end && (format & 60 /* ListFormat.DelimitersMask */) && !skipTrailingComments) {
                    emitLeadingCommentsOfPosition(hasTrailingComma && (children === null || children === void 0 ? void 0 : children.end) ? children.end : previousSibling.end);
                }
                // Decrease the indent, if requested.
                if (format & 128 /* ListFormat.Indented */) {
                    decreaseIndent();
                }
                recordBundleFileInternalSectionEnd(previousSourceFileTextKind);
                // Write the closing line terminator or closing whitespace.
                var closingLineTerminatorCount = getClosingLineTerminatorCount(parentNode, children, format);
                if (closingLineTerminatorCount) {
                    writeLine(closingLineTerminatorCount);
                }
                else if (format & (2097152 /* ListFormat.SpaceAfterList */ | 256 /* ListFormat.SpaceBetweenBraces */)) {
                    writeSpace();
                }
            }
            if (onAfterEmitNodeArray) {
                onAfterEmitNodeArray(children);
            }
            if (format & 15360 /* ListFormat.BracketsMask */) {
                if (isEmpty && children) {
                    emitLeadingCommentsOfPosition(children.end); // Emit leading comments within empty lists
                }
                writePunctuation(getClosingBracket(format));
            }
        }
        // Writers
        function writeLiteral(s) {
            writer.writeLiteral(s);
        }
        function writeStringLiteral(s) {
            writer.writeStringLiteral(s);
        }
        function writeBase(s) {
            writer.write(s);
        }
        function writeSymbol(s, sym) {
            writer.writeSymbol(s, sym);
        }
        function writePunctuation(s) {
            writer.writePunctuation(s);
        }
        function writeTrailingSemicolon() {
            writer.writeTrailingSemicolon(";");
        }
        function writeKeyword(s) {
            writer.writeKeyword(s);
        }
        function writeOperator(s) {
            writer.writeOperator(s);
        }
        function writeParameter(s) {
            writer.writeParameter(s);
        }
        function writeComment(s) {
            writer.writeComment(s);
        }
        function writeSpace() {
            writer.writeSpace(" ");
        }
        function writeProperty(s) {
            writer.writeProperty(s);
        }
        function nonEscapingWrite(s) {
            // This should be defined in a snippet-escaping text writer.
            if (writer.nonEscapingWrite) {
                writer.nonEscapingWrite(s);
            }
            else {
                writer.write(s);
            }
        }
        function writeLine(count) {
            if (count === void 0) { count = 1; }
            for (var i = 0; i < count; i++) {
                writer.writeLine(i > 0);
            }
        }
        function increaseIndent() {
            writer.increaseIndent();
        }
        function decreaseIndent() {
            writer.decreaseIndent();
        }
        function writeToken(token, pos, writer, contextNode) {
            return !sourceMapsDisabled
                ? emitTokenWithSourceMap(contextNode, token, writer, pos, writeTokenText)
                : writeTokenText(token, writer, pos);
        }
        function writeTokenNode(node, writer) {
            if (onBeforeEmitToken) {
                onBeforeEmitToken(node);
            }
            writer(ts.tokenToString(node.kind));
            if (onAfterEmitToken) {
                onAfterEmitToken(node);
            }
        }
        function writeTokenText(token, writer, pos) {
            var tokenString = ts.tokenToString(token);
            writer(tokenString);
            return pos < 0 ? pos : pos + tokenString.length;
        }
        function writeLineOrSpace(parentNode, prevChildNode, nextChildNode) {
            if (ts.getEmitFlags(parentNode) & 1 /* EmitFlags.SingleLine */) {
                writeSpace();
            }
            else if (preserveSourceNewlines) {
                var lines = getLinesBetweenNodes(parentNode, prevChildNode, nextChildNode);
                if (lines) {
                    writeLine(lines);
                }
                else {
                    writeSpace();
                }
            }
            else {
                writeLine();
            }
        }
        function writeLines(text) {
            var lines = text.split(/\r\n?|\n/g);
            var indentation = ts.guessIndentation(lines);
            for (var _a = 0, lines_3 = lines; _a < lines_3.length; _a++) {
                var lineText = lines_3[_a];
                var line = indentation ? lineText.slice(indentation) : lineText;
                if (line.length) {
                    writeLine();
                    write(line);
                }
            }
        }
        function writeLinesAndIndent(lineCount, writeSpaceIfNotIndenting) {
            if (lineCount) {
                increaseIndent();
                writeLine(lineCount);
            }
            else if (writeSpaceIfNotIndenting) {
                writeSpace();
            }
        }
        // Helper function to decrease the indent if we previously indented.  Allows multiple
        // previous indent values to be considered at a time.  This also allows caller to just
        // call this once, passing in all their appropriate indent values, instead of needing
        // to call this helper function multiple times.
        function decreaseIndentIf(value1, value2) {
            if (value1) {
                decreaseIndent();
            }
            if (value2) {
                decreaseIndent();
            }
        }
        function getLeadingLineTerminatorCount(parentNode, children, format) {
            if (format & 2 /* ListFormat.PreserveLines */ || preserveSourceNewlines) {
                if (format & 65536 /* ListFormat.PreferNewLine */) {
                    return 1;
                }
                var firstChild_1 = children[0];
                if (firstChild_1 === undefined) {
                    return !parentNode || currentSourceFile && ts.rangeIsOnSingleLine(parentNode, currentSourceFile) ? 0 : 1;
                }
                if (firstChild_1.pos === nextListElementPos) {
                    // If this child starts at the beginning of a list item in a parent list, its leading
                    // line terminators have already been written as the separating line terminators of the
                    // parent list. Example:
                    //
                    // class Foo {
                    //   constructor() {}
                    //   public foo() {}
                    // }
                    //
                    // The outer list is the list of class members, with one line terminator between the
                    // constructor and the method. The constructor is written, the separating line terminator
                    // is written, and then we start emitting the method. Its modifiers ([public]) constitute an inner
                    // list, so we look for its leading line terminators. If we didn't know that we had already
                    // written a newline as part of the parent list, it would appear that we need to write a
                    // leading newline to start the modifiers.
                    return 0;
                }
                if (firstChild_1.kind === 11 /* SyntaxKind.JsxText */) {
                    // JsxText will be written with its leading whitespace, so don't add more manually.
                    return 0;
                }
                if (currentSourceFile && parentNode &&
                    !ts.positionIsSynthesized(parentNode.pos) &&
                    !ts.nodeIsSynthesized(firstChild_1) &&
                    (!firstChild_1.parent || ts.getOriginalNode(firstChild_1.parent) === ts.getOriginalNode(parentNode))) {
                    if (preserveSourceNewlines) {
                        return getEffectiveLines(function (includeComments) { return ts.getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(firstChild_1.pos, parentNode.pos, currentSourceFile, includeComments); });
                    }
                    return ts.rangeStartPositionsAreOnSameLine(parentNode, firstChild_1, currentSourceFile) ? 0 : 1;
                }
                if (synthesizedNodeStartsOnNewLine(firstChild_1, format)) {
                    return 1;
                }
            }
            return format & 1 /* ListFormat.MultiLine */ ? 1 : 0;
        }
        function getSeparatingLineTerminatorCount(previousNode, nextNode, format) {
            if (format & 2 /* ListFormat.PreserveLines */ || preserveSourceNewlines) {
                if (previousNode === undefined || nextNode === undefined) {
                    return 0;
                }
                if (nextNode.kind === 11 /* SyntaxKind.JsxText */) {
                    // JsxText will be written with its leading whitespace, so don't add more manually.
                    return 0;
                }
                else if (currentSourceFile && !ts.nodeIsSynthesized(previousNode) && !ts.nodeIsSynthesized(nextNode)) {
                    if (preserveSourceNewlines && siblingNodePositionsAreComparable(previousNode, nextNode)) {
                        return getEffectiveLines(function (includeComments) { return ts.getLinesBetweenRangeEndAndRangeStart(previousNode, nextNode, currentSourceFile, includeComments); });
                    }
                    // If `preserveSourceNewlines` is `false` we do not intend to preserve the effective lines between the
                    // previous and next node. Instead we naively check whether nodes are on separate lines within the
                    // same node parent. If so, we intend to preserve a single line terminator. This is less precise and
                    // expensive than checking with `preserveSourceNewlines` as above, but the goal is not to preserve the
                    // effective source lines between two sibling nodes.
                    else if (!preserveSourceNewlines && originalNodesHaveSameParent(previousNode, nextNode)) {
                        return ts.rangeEndIsOnSameLineAsRangeStart(previousNode, nextNode, currentSourceFile) ? 0 : 1;
                    }
                    // If the two nodes are not comparable, add a line terminator based on the format that can indicate
                    // whether new lines are preferred or not.
                    return format & 65536 /* ListFormat.PreferNewLine */ ? 1 : 0;
                }
                else if (synthesizedNodeStartsOnNewLine(previousNode, format) || synthesizedNodeStartsOnNewLine(nextNode, format)) {
                    return 1;
                }
            }
            else if (ts.getStartsOnNewLine(nextNode)) {
                return 1;
            }
            return format & 1 /* ListFormat.MultiLine */ ? 1 : 0;
        }
        function getClosingLineTerminatorCount(parentNode, children, format) {
            if (format & 2 /* ListFormat.PreserveLines */ || preserveSourceNewlines) {
                if (format & 65536 /* ListFormat.PreferNewLine */) {
                    return 1;
                }
                var lastChild = ts.lastOrUndefined(children);
                if (lastChild === undefined) {
                    return !parentNode || currentSourceFile && ts.rangeIsOnSingleLine(parentNode, currentSourceFile) ? 0 : 1;
                }
                if (currentSourceFile && parentNode && !ts.positionIsSynthesized(parentNode.pos) && !ts.nodeIsSynthesized(lastChild) && (!lastChild.parent || lastChild.parent === parentNode)) {
                    if (preserveSourceNewlines) {
                        var end_1 = ts.isNodeArray(children) && !ts.positionIsSynthesized(children.end) ? children.end : lastChild.end;
                        return getEffectiveLines(function (includeComments) { return ts.getLinesBetweenPositionAndNextNonWhitespaceCharacter(end_1, parentNode.end, currentSourceFile, includeComments); });
                    }
                    return ts.rangeEndPositionsAreOnSameLine(parentNode, lastChild, currentSourceFile) ? 0 : 1;
                }
                if (synthesizedNodeStartsOnNewLine(lastChild, format)) {
                    return 1;
                }
            }
            if (format & 1 /* ListFormat.MultiLine */ && !(format & 131072 /* ListFormat.NoTrailingNewLine */)) {
                return 1;
            }
            return 0;
        }
        function getEffectiveLines(getLineDifference) {
            // If 'preserveSourceNewlines' is disabled, we should never call this function
            // because it could be more expensive than alternative approximations.
            ts.Debug.assert(!!preserveSourceNewlines);
            // We start by measuring the line difference from a position to its adjacent comments,
            // so that this is counted as a one-line difference, not two:
            //
            //   node1;
            //   // NODE2 COMMENT
            //   node2;
            var lines = getLineDifference(/*includeComments*/ true);
            if (lines === 0) {
                // However, if the line difference considering comments was 0, we might have this:
                //
                //   node1; // NODE2 COMMENT
                //   node2;
                //
                // in which case we should be ignoring node2's comment, so this too is counted as
                // a one-line difference, not zero.
                return getLineDifference(/*includeComments*/ false);
            }
            return lines;
        }
        function writeLineSeparatorsAndIndentBefore(node, parent) {
            var leadingNewlines = preserveSourceNewlines && getLeadingLineTerminatorCount(parent, [node], 0 /* ListFormat.None */);
            if (leadingNewlines) {
                writeLinesAndIndent(leadingNewlines, /*writeSpaceIfNotIndenting*/ false);
            }
            return !!leadingNewlines;
        }
        function writeLineSeparatorsAfter(node, parent) {
            var trailingNewlines = preserveSourceNewlines && getClosingLineTerminatorCount(parent, [node], 0 /* ListFormat.None */);
            if (trailingNewlines) {
                writeLine(trailingNewlines);
            }
        }
        function synthesizedNodeStartsOnNewLine(node, format) {
            if (ts.nodeIsSynthesized(node)) {
                var startsOnNewLine = ts.getStartsOnNewLine(node);
                if (startsOnNewLine === undefined) {
                    return (format & 65536 /* ListFormat.PreferNewLine */) !== 0;
                }
                return startsOnNewLine;
            }
            return (format & 65536 /* ListFormat.PreferNewLine */) !== 0;
        }
        function getLinesBetweenNodes(parent, node1, node2) {
            if (ts.getEmitFlags(parent) & 131072 /* EmitFlags.NoIndentation */) {
                return 0;
            }
            parent = skipSynthesizedParentheses(parent);
            node1 = skipSynthesizedParentheses(node1);
            node2 = skipSynthesizedParentheses(node2);
            // Always use a newline for synthesized code if the synthesizer desires it.
            if (ts.getStartsOnNewLine(node2)) {
                return 1;
            }
            if (currentSourceFile && !ts.nodeIsSynthesized(parent) && !ts.nodeIsSynthesized(node1) && !ts.nodeIsSynthesized(node2)) {
                if (preserveSourceNewlines) {
                    return getEffectiveLines(function (includeComments) { return ts.getLinesBetweenRangeEndAndRangeStart(node1, node2, currentSourceFile, includeComments); });
                }
                return ts.rangeEndIsOnSameLineAsRangeStart(node1, node2, currentSourceFile) ? 0 : 1;
            }
            return 0;
        }
        function isEmptyBlock(block) {
            return block.statements.length === 0
                && (!currentSourceFile || ts.rangeEndIsOnSameLineAsRangeStart(block, block, currentSourceFile));
        }
        function skipSynthesizedParentheses(node) {
            while (node.kind === 212 /* SyntaxKind.ParenthesizedExpression */ && ts.nodeIsSynthesized(node)) {
                node = node.expression;
            }
            return node;
        }
        function getTextOfNode(node, includeTrivia) {
            if (ts.isGeneratedIdentifier(node)) {
                return generateName(node);
            }
            if (ts.isStringLiteral(node) && node.textSourceNode) {
                return getTextOfNode(node.textSourceNode, includeTrivia);
            }
            var sourceFile = currentSourceFile; // const needed for control flow
            var canUseSourceFile = !!sourceFile && !!node.parent && !ts.nodeIsSynthesized(node);
            if (ts.isMemberName(node)) {
                if (!canUseSourceFile || ts.getSourceFileOfNode(node) !== ts.getOriginalNode(sourceFile)) {
                    return ts.idText(node);
                }
            }
            else {
                ts.Debug.assertNode(node, ts.isLiteralExpression); // not strictly necessary
                if (!canUseSourceFile) {
                    return node.text;
                }
            }
            return ts.getSourceTextOfNodeFromSourceFile(sourceFile, node, includeTrivia);
        }
        function getLiteralTextOfNode(node, neverAsciiEscape, jsxAttributeEscape) {
            if (node.kind === 10 /* SyntaxKind.StringLiteral */ && node.textSourceNode) {
                var textSourceNode = node.textSourceNode;
                if (ts.isIdentifier(textSourceNode) || ts.isNumericLiteral(textSourceNode)) {
                    var text = ts.isNumericLiteral(textSourceNode) ? textSourceNode.text : getTextOfNode(textSourceNode);
                    return jsxAttributeEscape ? "\"".concat(ts.escapeJsxAttributeString(text), "\"") :
                        neverAsciiEscape || (ts.getEmitFlags(node) & 16777216 /* EmitFlags.NoAsciiEscaping */) ? "\"".concat(ts.escapeString(text), "\"") :
                            "\"".concat(ts.escapeNonAsciiString(text), "\"");
                }
                else {
                    return getLiteralTextOfNode(textSourceNode, neverAsciiEscape, jsxAttributeEscape);
                }
            }
            var flags = (neverAsciiEscape ? 1 /* GetLiteralTextFlags.NeverAsciiEscape */ : 0)
                | (jsxAttributeEscape ? 2 /* GetLiteralTextFlags.JsxAttributeEscape */ : 0)
                | (printerOptions.terminateUnterminatedLiterals ? 4 /* GetLiteralTextFlags.TerminateUnterminatedLiterals */ : 0)
                | (printerOptions.target && printerOptions.target === 99 /* ScriptTarget.ESNext */ ? 8 /* GetLiteralTextFlags.AllowNumericSeparator */ : 0);
            return ts.getLiteralText(node, currentSourceFile, flags);
        }
        /**
         * Push a new name generation scope.
         */
        function pushNameGenerationScope(node) {
            if (node && ts.getEmitFlags(node) & 524288 /* EmitFlags.ReuseTempVariableScope */) {
                return;
            }
            tempFlagsStack.push(tempFlags);
            tempFlags = 0;
            reservedNamesStack.push(reservedNames);
        }
        /**
         * Pop the current name generation scope.
         */
        function popNameGenerationScope(node) {
            if (node && ts.getEmitFlags(node) & 524288 /* EmitFlags.ReuseTempVariableScope */) {
                return;
            }
            tempFlags = tempFlagsStack.pop();
            reservedNames = reservedNamesStack.pop();
        }
        function reserveNameInNestedScopes(name) {
            if (!reservedNames || reservedNames === ts.lastOrUndefined(reservedNamesStack)) {
                reservedNames = new ts.Set();
            }
            reservedNames.add(name);
        }
        function generateNames(node) {
            if (!node)
                return;
            switch (node.kind) {
                case 235 /* SyntaxKind.Block */:
                    ts.forEach(node.statements, generateNames);
                    break;
                case 250 /* SyntaxKind.LabeledStatement */:
                case 248 /* SyntaxKind.WithStatement */:
                case 240 /* SyntaxKind.DoStatement */:
                case 241 /* SyntaxKind.WhileStatement */:
                    generateNames(node.statement);
                    break;
                case 239 /* SyntaxKind.IfStatement */:
                    generateNames(node.thenStatement);
                    generateNames(node.elseStatement);
                    break;
                case 242 /* SyntaxKind.ForStatement */:
                case 244 /* SyntaxKind.ForOfStatement */:
                case 243 /* SyntaxKind.ForInStatement */:
                    generateNames(node.initializer);
                    generateNames(node.statement);
                    break;
                case 249 /* SyntaxKind.SwitchStatement */:
                    generateNames(node.caseBlock);
                    break;
                case 263 /* SyntaxKind.CaseBlock */:
                    ts.forEach(node.clauses, generateNames);
                    break;
                case 289 /* SyntaxKind.CaseClause */:
                case 290 /* SyntaxKind.DefaultClause */:
                    ts.forEach(node.statements, generateNames);
                    break;
                case 252 /* SyntaxKind.TryStatement */:
                    generateNames(node.tryBlock);
                    generateNames(node.catchClause);
                    generateNames(node.finallyBlock);
                    break;
                case 292 /* SyntaxKind.CatchClause */:
                    generateNames(node.variableDeclaration);
                    generateNames(node.block);
                    break;
                case 237 /* SyntaxKind.VariableStatement */:
                    generateNames(node.declarationList);
                    break;
                case 255 /* SyntaxKind.VariableDeclarationList */:
                    ts.forEach(node.declarations, generateNames);
                    break;
                case 254 /* SyntaxKind.VariableDeclaration */:
                case 164 /* SyntaxKind.Parameter */:
                case 203 /* SyntaxKind.BindingElement */:
                case 257 /* SyntaxKind.ClassDeclaration */:
                    generateNameIfNeeded(node.name);
                    break;
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    generateNameIfNeeded(node.name);
                    if (ts.getEmitFlags(node) & 524288 /* EmitFlags.ReuseTempVariableScope */) {
                        ts.forEach(node.parameters, generateNames);
                        generateNames(node.body);
                    }
                    break;
                case 201 /* SyntaxKind.ObjectBindingPattern */:
                case 202 /* SyntaxKind.ArrayBindingPattern */:
                    ts.forEach(node.elements, generateNames);
                    break;
                case 266 /* SyntaxKind.ImportDeclaration */:
                    generateNames(node.importClause);
                    break;
                case 267 /* SyntaxKind.ImportClause */:
                    generateNameIfNeeded(node.name);
                    generateNames(node.namedBindings);
                    break;
                case 268 /* SyntaxKind.NamespaceImport */:
                    generateNameIfNeeded(node.name);
                    break;
                case 274 /* SyntaxKind.NamespaceExport */:
                    generateNameIfNeeded(node.name);
                    break;
                case 269 /* SyntaxKind.NamedImports */:
                    ts.forEach(node.elements, generateNames);
                    break;
                case 270 /* SyntaxKind.ImportSpecifier */:
                    generateNameIfNeeded(node.propertyName || node.name);
                    break;
            }
        }
        function generateMemberNames(node) {
            if (!node)
                return;
            switch (node.kind) {
                case 296 /* SyntaxKind.PropertyAssignment */:
                case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                    generateNameIfNeeded(node.name);
                    break;
            }
        }
        function generateNameIfNeeded(name) {
            if (name) {
                if (ts.isGeneratedIdentifier(name)) {
                    generateName(name);
                }
                else if (ts.isBindingPattern(name)) {
                    generateNames(name);
                }
            }
        }
        /**
         * Generate the text for a generated identifier.
         */
        function generateName(name) {
            if ((name.autoGenerateFlags & 7 /* GeneratedIdentifierFlags.KindMask */) === 4 /* GeneratedIdentifierFlags.Node */) {
                // Node names generate unique names based on their original node
                // and are cached based on that node's id.
                return generateNameCached(getNodeForGeneratedName(name), name.autoGenerateFlags);
            }
            else {
                // Auto, Loop, and Unique names are cached based on their unique
                // autoGenerateId.
                var autoGenerateId = name.autoGenerateId;
                return autoGeneratedIdToGeneratedName[autoGenerateId] || (autoGeneratedIdToGeneratedName[autoGenerateId] = makeName(name));
            }
        }
        function generateNameCached(node, flags) {
            var nodeId = ts.getNodeId(node);
            return nodeIdToGeneratedName[nodeId] || (nodeIdToGeneratedName[nodeId] = generateNameForNode(node, flags));
        }
        /**
         * Returns a value indicating whether a name is unique globally, within the current file,
         * or within the NameGenerator.
         */
        function isUniqueName(name) {
            return isFileLevelUniqueName(name)
                && !generatedNames.has(name)
                && !(reservedNames && reservedNames.has(name));
        }
        /**
         * Returns a value indicating whether a name is unique globally or within the current file.
         */
        function isFileLevelUniqueName(name) {
            return currentSourceFile ? ts.isFileLevelUniqueName(currentSourceFile, name, hasGlobalName) : true;
        }
        /**
         * Returns a value indicating whether a name is unique within a container.
         */
        function isUniqueLocalName(name, container) {
            for (var node = container; ts.isNodeDescendantOf(node, container); node = node.nextContainer) {
                if (node.locals) {
                    var local = node.locals.get(ts.escapeLeadingUnderscores(name));
                    // We conservatively include alias symbols to cover cases where they're emitted as locals
                    if (local && local.flags & (111551 /* SymbolFlags.Value */ | 1048576 /* SymbolFlags.ExportValue */ | 2097152 /* SymbolFlags.Alias */)) {
                        return false;
                    }
                }
            }
            return true;
        }
        /**
         * Return the next available name in the pattern _a ... _z, _0, _1, ...
         * TempFlags._i or TempFlags._n may be used to express a preference for that dedicated name.
         * Note that names generated by makeTempVariableName and makeUniqueName will never conflict.
         */
        function makeTempVariableName(flags, reservedInNestedScopes) {
            if (flags && !(tempFlags & flags)) {
                var name = flags === 268435456 /* TempFlags._i */ ? "_i" : "_n";
                if (isUniqueName(name)) {
                    tempFlags |= flags;
                    if (reservedInNestedScopes) {
                        reserveNameInNestedScopes(name);
                    }
                    return name;
                }
            }
            while (true) {
                var count = tempFlags & 268435455 /* TempFlags.CountMask */;
                tempFlags++;
                // Skip over 'i' and 'n'
                if (count !== 8 && count !== 13) {
                    var name = count < 26
                        ? "_" + String.fromCharCode(97 /* CharacterCodes.a */ + count)
                        : "_" + (count - 26);
                    if (isUniqueName(name)) {
                        if (reservedInNestedScopes) {
                            reserveNameInNestedScopes(name);
                        }
                        return name;
                    }
                }
            }
        }
        /**
         * Generate a name that is unique within the current file and doesn't conflict with any names
         * in global scope. The name is formed by adding an '_n' suffix to the specified base name,
         * where n is a positive integer. Note that names generated by makeTempVariableName and
         * makeUniqueName are guaranteed to never conflict.
         * If `optimistic` is set, the first instance will use 'baseName' verbatim instead of 'baseName_1'
         */
        function makeUniqueName(baseName, checkFn, optimistic, scoped) {
            if (checkFn === void 0) { checkFn = isUniqueName; }
            if (optimistic) {
                if (checkFn(baseName)) {
                    if (scoped) {
                        reserveNameInNestedScopes(baseName);
                    }
                    else {
                        generatedNames.add(baseName);
                    }
                    return baseName;
                }
            }
            // Find the first unique 'name_n', where n is a positive number
            if (baseName.charCodeAt(baseName.length - 1) !== 95 /* CharacterCodes._ */) {
                baseName += "_";
            }
            var i = 1;
            while (true) {
                var generatedName = baseName + i;
                if (checkFn(generatedName)) {
                    if (scoped) {
                        reserveNameInNestedScopes(generatedName);
                    }
                    else {
                        generatedNames.add(generatedName);
                    }
                    return generatedName;
                }
                i++;
            }
        }
        function makeFileLevelOptimisticUniqueName(name) {
            return makeUniqueName(name, isFileLevelUniqueName, /*optimistic*/ true);
        }
        /**
         * Generates a unique name for a ModuleDeclaration or EnumDeclaration.
         */
        function generateNameForModuleOrEnum(node) {
            var name = getTextOfNode(node.name);
            // Use module/enum name itself if it is unique, otherwise make a unique variation
            return isUniqueLocalName(name, node) ? name : makeUniqueName(name);
        }
        /**
         * Generates a unique name for an ImportDeclaration or ExportDeclaration.
         */
        function generateNameForImportOrExportDeclaration(node) {
            var expr = ts.getExternalModuleName(node); // TODO: GH#18217
            var baseName = ts.isStringLiteral(expr) ?
                ts.makeIdentifierFromModuleName(expr.text) : "module";
            return makeUniqueName(baseName);
        }
        /**
         * Generates a unique name for a default export.
         */
        function generateNameForExportDefault() {
            return makeUniqueName("default");
        }
        /**
         * Generates a unique name for a class expression.
         */
        function generateNameForClassExpression() {
            return makeUniqueName("class");
        }
        function generateNameForMethodOrAccessor(node) {
            if (ts.isIdentifier(node.name)) {
                return generateNameCached(node.name);
            }
            return makeTempVariableName(0 /* TempFlags.Auto */);
        }
        /**
         * Generates a unique name from a node.
         */
        function generateNameForNode(node, flags) {
            switch (node.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return makeUniqueName(getTextOfNode(node), isUniqueName, !!(flags & 16 /* GeneratedIdentifierFlags.Optimistic */), !!(flags & 8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */));
                case 261 /* SyntaxKind.ModuleDeclaration */:
                case 260 /* SyntaxKind.EnumDeclaration */:
                    return generateNameForModuleOrEnum(node);
                case 266 /* SyntaxKind.ImportDeclaration */:
                case 272 /* SyntaxKind.ExportDeclaration */:
                    return generateNameForImportOrExportDeclaration(node);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 271 /* SyntaxKind.ExportAssignment */:
                    return generateNameForExportDefault();
                case 226 /* SyntaxKind.ClassExpression */:
                    return generateNameForClassExpression();
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                    return generateNameForMethodOrAccessor(node);
                case 162 /* SyntaxKind.ComputedPropertyName */:
                    return makeTempVariableName(0 /* TempFlags.Auto */, /*reserveInNestedScopes*/ true);
                default:
                    return makeTempVariableName(0 /* TempFlags.Auto */);
            }
        }
        /**
         * Generates a unique identifier for a node.
         */
        function makeName(name) {
            switch (name.autoGenerateFlags & 7 /* GeneratedIdentifierFlags.KindMask */) {
                case 1 /* GeneratedIdentifierFlags.Auto */:
                    return makeTempVariableName(0 /* TempFlags.Auto */, !!(name.autoGenerateFlags & 8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */));
                case 2 /* GeneratedIdentifierFlags.Loop */:
                    return makeTempVariableName(268435456 /* TempFlags._i */, !!(name.autoGenerateFlags & 8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */));
                case 3 /* GeneratedIdentifierFlags.Unique */:
                    return makeUniqueName(ts.idText(name), (name.autoGenerateFlags & 32 /* GeneratedIdentifierFlags.FileLevel */) ? isFileLevelUniqueName : isUniqueName, !!(name.autoGenerateFlags & 16 /* GeneratedIdentifierFlags.Optimistic */), !!(name.autoGenerateFlags & 8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */));
            }
            return ts.Debug.fail("Unsupported GeneratedIdentifierKind.");
        }
        /**
         * Gets the node from which a name should be generated.
         */
        function getNodeForGeneratedName(name) {
            var autoGenerateId = name.autoGenerateId;
            var node = name;
            var original = node.original;
            while (original) {
                node = original;
                // if "node" is a different generated name (having a different
                // "autoGenerateId"), use it and stop traversing.
                if (ts.isIdentifier(node)
                    && !!(node.autoGenerateFlags & 4 /* GeneratedIdentifierFlags.Node */)
                    && node.autoGenerateId !== autoGenerateId) {
                    break;
                }
                original = node.original;
            }
            // otherwise, return the original node for the source;
            return node;
        }
        // Comments
        function pipelineEmitWithComments(hint, node) {
            var pipelinePhase = getNextPipelinePhase(2 /* PipelinePhase.Comments */, hint, node);
            var savedContainerPos = containerPos;
            var savedContainerEnd = containerEnd;
            var savedDeclarationListContainerEnd = declarationListContainerEnd;
            emitCommentsBeforeNode(node);
            pipelinePhase(hint, node);
            emitCommentsAfterNode(node, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd);
        }
        function emitCommentsBeforeNode(node) {
            var emitFlags = ts.getEmitFlags(node);
            var commentRange = ts.getCommentRange(node);
            // Emit leading comments
            emitLeadingCommentsOfNode(node, emitFlags, commentRange.pos, commentRange.end);
            if (emitFlags & 2048 /* EmitFlags.NoNestedComments */) {
                commentsDisabled = true;
            }
        }
        function emitCommentsAfterNode(node, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd) {
            var emitFlags = ts.getEmitFlags(node);
            var commentRange = ts.getCommentRange(node);
            // Emit trailing comments
            if (emitFlags & 2048 /* EmitFlags.NoNestedComments */) {
                commentsDisabled = false;
            }
            emitTrailingCommentsOfNode(node, emitFlags, commentRange.pos, commentRange.end, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd);
            var typeNode = ts.getTypeNode(node);
            if (typeNode) {
                emitTrailingCommentsOfNode(node, emitFlags, typeNode.pos, typeNode.end, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd);
            }
        }
        function emitLeadingCommentsOfNode(node, emitFlags, pos, end) {
            enterComment();
            hasWrittenComment = false;
            // We have to explicitly check that the node is JsxText because if the compilerOptions.jsx is "preserve" we will not do any transformation.
            // It is expensive to walk entire tree just to set one kind of node to have no comments.
            var skipLeadingComments = pos < 0 || (emitFlags & 512 /* EmitFlags.NoLeadingComments */) !== 0 || node.kind === 11 /* SyntaxKind.JsxText */;
            var skipTrailingComments = end < 0 || (emitFlags & 1024 /* EmitFlags.NoTrailingComments */) !== 0 || node.kind === 11 /* SyntaxKind.JsxText */;
            // Save current container state on the stack.
            if ((pos > 0 || end > 0) && pos !== end) {
                // Emit leading comments if the position is not synthesized and the node
                // has not opted out from emitting leading comments.
                if (!skipLeadingComments) {
                    emitLeadingComments(pos, /*isEmittedNode*/ node.kind !== 349 /* SyntaxKind.NotEmittedStatement */);
                }
                if (!skipLeadingComments || (pos >= 0 && (emitFlags & 512 /* EmitFlags.NoLeadingComments */) !== 0)) {
                    // Advance the container position if comments get emitted or if they've been disabled explicitly using NoLeadingComments.
                    containerPos = pos;
                }
                if (!skipTrailingComments || (end >= 0 && (emitFlags & 1024 /* EmitFlags.NoTrailingComments */) !== 0)) {
                    // As above.
                    containerEnd = end;
                    // To avoid invalid comment emit in a down-level binding pattern, we
                    // keep track of the last declaration list container's end
                    if (node.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
                        declarationListContainerEnd = end;
                    }
                }
            }
            ts.forEach(ts.getSyntheticLeadingComments(node), emitLeadingSynthesizedComment);
            exitComment();
        }
        function emitTrailingCommentsOfNode(node, emitFlags, pos, end, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd) {
            enterComment();
            var skipTrailingComments = end < 0 || (emitFlags & 1024 /* EmitFlags.NoTrailingComments */) !== 0 || node.kind === 11 /* SyntaxKind.JsxText */;
            ts.forEach(ts.getSyntheticTrailingComments(node), emitTrailingSynthesizedComment);
            if ((pos > 0 || end > 0) && pos !== end) {
                // Restore previous container state.
                containerPos = savedContainerPos;
                containerEnd = savedContainerEnd;
                declarationListContainerEnd = savedDeclarationListContainerEnd;
                // Emit trailing comments if the position is not synthesized and the node
                // has not opted out from emitting leading comments and is an emitted node.
                if (!skipTrailingComments && node.kind !== 349 /* SyntaxKind.NotEmittedStatement */) {
                    emitTrailingComments(end);
                }
            }
            exitComment();
        }
        function emitLeadingSynthesizedComment(comment) {
            if (comment.hasLeadingNewline || comment.kind === 2 /* SyntaxKind.SingleLineCommentTrivia */) {
                writer.writeLine();
            }
            writeSynthesizedComment(comment);
            if (comment.hasTrailingNewLine || comment.kind === 2 /* SyntaxKind.SingleLineCommentTrivia */) {
                writer.writeLine();
            }
            else {
                writer.writeSpace(" ");
            }
        }
        function emitTrailingSynthesizedComment(comment) {
            if (!writer.isAtStartOfLine()) {
                writer.writeSpace(" ");
            }
            writeSynthesizedComment(comment);
            if (comment.hasTrailingNewLine) {
                writer.writeLine();
            }
        }
        function writeSynthesizedComment(comment) {
            var text = formatSynthesizedComment(comment);
            var lineMap = comment.kind === 3 /* SyntaxKind.MultiLineCommentTrivia */ ? ts.computeLineStarts(text) : undefined;
            ts.writeCommentRange(text, lineMap, writer, 0, text.length, newLine);
        }
        function formatSynthesizedComment(comment) {
            return comment.kind === 3 /* SyntaxKind.MultiLineCommentTrivia */
                ? "/*".concat(comment.text, "*/")
                : "//".concat(comment.text);
        }
        function emitBodyWithDetachedComments(node, detachedRange, emitCallback) {
            enterComment();
            var pos = detachedRange.pos, end = detachedRange.end;
            var emitFlags = ts.getEmitFlags(node);
            var skipLeadingComments = pos < 0 || (emitFlags & 512 /* EmitFlags.NoLeadingComments */) !== 0;
            var skipTrailingComments = commentsDisabled || end < 0 || (emitFlags & 1024 /* EmitFlags.NoTrailingComments */) !== 0;
            if (!skipLeadingComments) {
                emitDetachedCommentsAndUpdateCommentsInfo(detachedRange);
            }
            exitComment();
            if (emitFlags & 2048 /* EmitFlags.NoNestedComments */ && !commentsDisabled) {
                commentsDisabled = true;
                emitCallback(node);
                commentsDisabled = false;
            }
            else {
                emitCallback(node);
            }
            enterComment();
            if (!skipTrailingComments) {
                emitLeadingComments(detachedRange.end, /*isEmittedNode*/ true);
                if (hasWrittenComment && !writer.isAtStartOfLine()) {
                    writer.writeLine();
                }
            }
            exitComment();
        }
        function originalNodesHaveSameParent(nodeA, nodeB) {
            nodeA = ts.getOriginalNode(nodeA);
            // For performance, do not call `getOriginalNode` for `nodeB` if `nodeA` doesn't even
            // have a parent node.
            return nodeA.parent && nodeA.parent === ts.getOriginalNode(nodeB).parent;
        }
        function siblingNodePositionsAreComparable(previousNode, nextNode) {
            if (nextNode.pos < previousNode.end) {
                return false;
            }
            previousNode = ts.getOriginalNode(previousNode);
            nextNode = ts.getOriginalNode(nextNode);
            var parent = previousNode.parent;
            if (!parent || parent !== nextNode.parent) {
                return false;
            }
            var parentNodeArray = ts.getContainingNodeArray(previousNode);
            var prevNodeIndex = parentNodeArray === null || parentNodeArray === void 0 ? void 0 : parentNodeArray.indexOf(previousNode);
            return prevNodeIndex !== undefined && prevNodeIndex > -1 && parentNodeArray.indexOf(nextNode) === prevNodeIndex + 1;
        }
        function emitLeadingComments(pos, isEmittedNode) {
            hasWrittenComment = false;
            if (isEmittedNode) {
                if (pos === 0 && (currentSourceFile === null || currentSourceFile === void 0 ? void 0 : currentSourceFile.isDeclarationFile)) {
                    forEachLeadingCommentToEmit(pos, emitNonTripleSlashLeadingComment);
                }
                else {
                    forEachLeadingCommentToEmit(pos, emitLeadingComment);
                }
            }
            else if (pos === 0) {
                // If the node will not be emitted in JS, remove all the comments(normal, pinned and ///) associated with the node,
                // unless it is a triple slash comment at the top of the file.
                // For Example:
                //      /// <reference-path ...>
                //      declare var x;
                //      /// <reference-path ...>
                //      interface F {}
                //  The first /// will NOT be removed while the second one will be removed even though both node will not be emitted
                forEachLeadingCommentToEmit(pos, emitTripleSlashLeadingComment);
            }
        }
        function emitTripleSlashLeadingComment(commentPos, commentEnd, kind, hasTrailingNewLine, rangePos) {
            if (isTripleSlashComment(commentPos, commentEnd)) {
                emitLeadingComment(commentPos, commentEnd, kind, hasTrailingNewLine, rangePos);
            }
        }
        function emitNonTripleSlashLeadingComment(commentPos, commentEnd, kind, hasTrailingNewLine, rangePos) {
            if (!isTripleSlashComment(commentPos, commentEnd)) {
                emitLeadingComment(commentPos, commentEnd, kind, hasTrailingNewLine, rangePos);
            }
        }
        function shouldWriteComment(text, pos) {
            if (printerOptions.onlyPrintJsDocStyle) {
                return (ts.isJSDocLikeText(text, pos) || ts.isPinnedComment(text, pos));
            }
            return true;
        }
        function emitLeadingComment(commentPos, commentEnd, kind, hasTrailingNewLine, rangePos) {
            if (!currentSourceFile || !shouldWriteComment(currentSourceFile.text, commentPos))
                return;
            if (!hasWrittenComment) {
                ts.emitNewLineBeforeLeadingCommentOfPosition(getCurrentLineMap(), writer, rangePos, commentPos);
                hasWrittenComment = true;
            }
            // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
            emitPos(commentPos);
            ts.writeCommentRange(currentSourceFile.text, getCurrentLineMap(), writer, commentPos, commentEnd, newLine);
            emitPos(commentEnd);
            if (hasTrailingNewLine) {
                writer.writeLine();
            }
            else if (kind === 3 /* SyntaxKind.MultiLineCommentTrivia */) {
                writer.writeSpace(" ");
            }
        }
        function emitLeadingCommentsOfPosition(pos) {
            if (commentsDisabled || pos === -1) {
                return;
            }
            emitLeadingComments(pos, /*isEmittedNode*/ true);
        }
        function emitTrailingComments(pos) {
            forEachTrailingCommentToEmit(pos, emitTrailingComment);
        }
        function emitTrailingComment(commentPos, commentEnd, _kind, hasTrailingNewLine) {
            if (!currentSourceFile || !shouldWriteComment(currentSourceFile.text, commentPos))
                return;
            // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment2*/
            if (!writer.isAtStartOfLine()) {
                writer.writeSpace(" ");
            }
            emitPos(commentPos);
            ts.writeCommentRange(currentSourceFile.text, getCurrentLineMap(), writer, commentPos, commentEnd, newLine);
            emitPos(commentEnd);
            if (hasTrailingNewLine) {
                writer.writeLine();
            }
        }
        function emitTrailingCommentsOfPosition(pos, prefixSpace, forceNoNewline) {
            if (commentsDisabled) {
                return;
            }
            enterComment();
            forEachTrailingCommentToEmit(pos, prefixSpace ? emitTrailingComment : forceNoNewline ? emitTrailingCommentOfPositionNoNewline : emitTrailingCommentOfPosition);
            exitComment();
        }
        function emitTrailingCommentOfPositionNoNewline(commentPos, commentEnd, kind) {
            if (!currentSourceFile)
                return;
            // trailing comments of a position are emitted at /*trailing comment1 */space/*trailing comment*/space
            emitPos(commentPos);
            ts.writeCommentRange(currentSourceFile.text, getCurrentLineMap(), writer, commentPos, commentEnd, newLine);
            emitPos(commentEnd);
            if (kind === 2 /* SyntaxKind.SingleLineCommentTrivia */) {
                writer.writeLine(); // still write a newline for single-line comments, so closing tokens aren't written on the same line
            }
        }
        function emitTrailingCommentOfPosition(commentPos, commentEnd, _kind, hasTrailingNewLine) {
            if (!currentSourceFile)
                return;
            // trailing comments of a position are emitted at /*trailing comment1 */space/*trailing comment*/space
            emitPos(commentPos);
            ts.writeCommentRange(currentSourceFile.text, getCurrentLineMap(), writer, commentPos, commentEnd, newLine);
            emitPos(commentEnd);
            if (hasTrailingNewLine) {
                writer.writeLine();
            }
            else {
                writer.writeSpace(" ");
            }
        }
        function forEachLeadingCommentToEmit(pos, cb) {
            // Emit the leading comments only if the container's pos doesn't match because the container should take care of emitting these comments
            if (currentSourceFile && (containerPos === -1 || pos !== containerPos)) {
                if (hasDetachedComments(pos)) {
                    forEachLeadingCommentWithoutDetachedComments(cb);
                }
                else {
                    ts.forEachLeadingCommentRange(currentSourceFile.text, pos, cb, /*state*/ pos);
                }
            }
        }
        function forEachTrailingCommentToEmit(end, cb) {
            // Emit the trailing comments only if the container's end doesn't match because the container should take care of emitting these comments
            if (currentSourceFile && (containerEnd === -1 || (end !== containerEnd && end !== declarationListContainerEnd))) {
                ts.forEachTrailingCommentRange(currentSourceFile.text, end, cb);
            }
        }
        function hasDetachedComments(pos) {
            return detachedCommentsInfo !== undefined && ts.last(detachedCommentsInfo).nodePos === pos;
        }
        function forEachLeadingCommentWithoutDetachedComments(cb) {
            if (!currentSourceFile)
                return;
            // get the leading comments from detachedPos
            var pos = ts.last(detachedCommentsInfo).detachedCommentEndPos;
            if (detachedCommentsInfo.length - 1) {
                detachedCommentsInfo.pop();
            }
            else {
                detachedCommentsInfo = undefined;
            }
            ts.forEachLeadingCommentRange(currentSourceFile.text, pos, cb, /*state*/ pos);
        }
        function emitDetachedCommentsAndUpdateCommentsInfo(range) {
            var currentDetachedCommentInfo = currentSourceFile && ts.emitDetachedComments(currentSourceFile.text, getCurrentLineMap(), writer, emitComment, range, newLine, commentsDisabled);
            if (currentDetachedCommentInfo) {
                if (detachedCommentsInfo) {
                    detachedCommentsInfo.push(currentDetachedCommentInfo);
                }
                else {
                    detachedCommentsInfo = [currentDetachedCommentInfo];
                }
            }
        }
        function emitComment(text, lineMap, writer, commentPos, commentEnd, newLine) {
            if (!currentSourceFile || !shouldWriteComment(currentSourceFile.text, commentPos))
                return;
            emitPos(commentPos);
            ts.writeCommentRange(text, lineMap, writer, commentPos, commentEnd, newLine);
            emitPos(commentEnd);
        }
        /**
         * Determine if the given comment is a triple-slash
         *
         * @return true if the comment is a triple-slash comment else false
         */
        function isTripleSlashComment(commentPos, commentEnd) {
            return !!currentSourceFile && ts.isRecognizedTripleSlashComment(currentSourceFile.text, commentPos, commentEnd);
        }
        // Source Maps
        function getParsedSourceMap(node) {
            if (node.parsedSourceMap === undefined && node.sourceMapText !== undefined) {
                node.parsedSourceMap = ts.tryParseRawSourceMap(node.sourceMapText) || false;
            }
            return node.parsedSourceMap || undefined;
        }
        function pipelineEmitWithSourceMaps(hint, node) {
            var pipelinePhase = getNextPipelinePhase(3 /* PipelinePhase.SourceMaps */, hint, node);
            emitSourceMapsBeforeNode(node);
            pipelinePhase(hint, node);
            emitSourceMapsAfterNode(node);
        }
        function emitSourceMapsBeforeNode(node) {
            var emitFlags = ts.getEmitFlags(node);
            var sourceMapRange = ts.getSourceMapRange(node);
            // Emit leading sourcemap
            if (ts.isUnparsedNode(node)) {
                ts.Debug.assertIsDefined(node.parent, "UnparsedNodes must have parent pointers");
                var parsed = getParsedSourceMap(node.parent);
                if (parsed && sourceMapGenerator) {
                    sourceMapGenerator.appendSourceMap(writer.getLine(), writer.getColumn(), parsed, node.parent.sourceMapPath, node.parent.getLineAndCharacterOfPosition(node.pos), node.parent.getLineAndCharacterOfPosition(node.end));
                }
            }
            else {
                var source = sourceMapRange.source || sourceMapSource;
                if (node.kind !== 349 /* SyntaxKind.NotEmittedStatement */
                    && (emitFlags & 16 /* EmitFlags.NoLeadingSourceMap */) === 0
                    && sourceMapRange.pos >= 0) {
                    emitSourcePos(sourceMapRange.source || sourceMapSource, skipSourceTrivia(source, sourceMapRange.pos));
                }
                if (emitFlags & 64 /* EmitFlags.NoNestedSourceMaps */) {
                    sourceMapsDisabled = true;
                }
            }
        }
        function emitSourceMapsAfterNode(node) {
            var emitFlags = ts.getEmitFlags(node);
            var sourceMapRange = ts.getSourceMapRange(node);
            // Emit trailing sourcemap
            if (!ts.isUnparsedNode(node)) {
                if (emitFlags & 64 /* EmitFlags.NoNestedSourceMaps */) {
                    sourceMapsDisabled = false;
                }
                if (node.kind !== 349 /* SyntaxKind.NotEmittedStatement */
                    && (emitFlags & 32 /* EmitFlags.NoTrailingSourceMap */) === 0
                    && sourceMapRange.end >= 0) {
                    emitSourcePos(sourceMapRange.source || sourceMapSource, sourceMapRange.end);
                }
            }
        }
        /**
         * Skips trivia such as comments and white-space that can be optionally overridden by the source-map source
         */
        function skipSourceTrivia(source, pos) {
            return source.skipTrivia ? source.skipTrivia(pos) : ts.skipTrivia(source.text, pos);
        }
        /**
         * Emits a mapping.
         *
         * If the position is synthetic (undefined or a negative value), no mapping will be
         * created.
         *
         * @param pos The position.
         */
        function emitPos(pos) {
            if (sourceMapsDisabled || ts.positionIsSynthesized(pos) || isJsonSourceMapSource(sourceMapSource)) {
                return;
            }
            var _a = ts.getLineAndCharacterOfPosition(sourceMapSource, pos), sourceLine = _a.line, sourceCharacter = _a.character;
            sourceMapGenerator.addMapping(writer.getLine(), writer.getColumn(), sourceMapSourceIndex, sourceLine, sourceCharacter, 
            /*nameIndex*/ undefined);
        }
        function emitSourcePos(source, pos) {
            if (source !== sourceMapSource) {
                var savedSourceMapSource = sourceMapSource;
                var savedSourceMapSourceIndex = sourceMapSourceIndex;
                setSourceMapSource(source);
                emitPos(pos);
                resetSourceMapSource(savedSourceMapSource, savedSourceMapSourceIndex);
            }
            else {
                emitPos(pos);
            }
        }
        /**
         * Emits a token of a node with possible leading and trailing source maps.
         *
         * @param node The node containing the token.
         * @param token The token to emit.
         * @param tokenStartPos The start pos of the token.
         * @param emitCallback The callback used to emit the token.
         */
        function emitTokenWithSourceMap(node, token, writer, tokenPos, emitCallback) {
            if (sourceMapsDisabled || node && ts.isInJsonFile(node)) {
                return emitCallback(token, writer, tokenPos);
            }
            var emitNode = node && node.emitNode;
            var emitFlags = emitNode && emitNode.flags || 0 /* EmitFlags.None */;
            var range = emitNode && emitNode.tokenSourceMapRanges && emitNode.tokenSourceMapRanges[token];
            var source = range && range.source || sourceMapSource;
            tokenPos = skipSourceTrivia(source, range ? range.pos : tokenPos);
            if ((emitFlags & 128 /* EmitFlags.NoTokenLeadingSourceMaps */) === 0 && tokenPos >= 0) {
                emitSourcePos(source, tokenPos);
            }
            tokenPos = emitCallback(token, writer, tokenPos);
            if (range)
                tokenPos = range.end;
            if ((emitFlags & 256 /* EmitFlags.NoTokenTrailingSourceMaps */) === 0 && tokenPos >= 0) {
                emitSourcePos(source, tokenPos);
            }
            return tokenPos;
        }
        function setSourceMapSource(source) {
            if (sourceMapsDisabled) {
                return;
            }
            sourceMapSource = source;
            if (source === mostRecentlyAddedSourceMapSource) {
                // Fast path for when the new source map is the most recently added, in which case
                // we use its captured index without going through the source map generator.
                sourceMapSourceIndex = mostRecentlyAddedSourceMapSourceIndex;
                return;
            }
            if (isJsonSourceMapSource(source)) {
                return;
            }
            sourceMapSourceIndex = sourceMapGenerator.addSource(source.fileName);
            if (printerOptions.inlineSources) {
                sourceMapGenerator.setSourceContent(sourceMapSourceIndex, source.text);
            }
            mostRecentlyAddedSourceMapSource = source;
            mostRecentlyAddedSourceMapSourceIndex = sourceMapSourceIndex;
        }
        function resetSourceMapSource(source, sourceIndex) {
            sourceMapSource = source;
            sourceMapSourceIndex = sourceIndex;
        }
        function isJsonSourceMapSource(sourceFile) {
            return ts.fileExtensionIs(sourceFile.fileName, ".json" /* Extension.Json */);
        }
    }
    ts.createPrinter = createPrinter;
    function createBracketsMap() {
        var brackets = [];
        brackets[1024 /* ListFormat.Braces */] = ["{", "}"];
        brackets[2048 /* ListFormat.Parenthesis */] = ["(", ")"];
        brackets[4096 /* ListFormat.AngleBrackets */] = ["<", ">"];
        brackets[8192 /* ListFormat.SquareBrackets */] = ["[", "]"];
        return brackets;
    }
    function getOpeningBracket(format) {
        return brackets[format & 15360 /* ListFormat.BracketsMask */][0];
    }
    function getClosingBracket(format) {
        return brackets[format & 15360 /* ListFormat.BracketsMask */][1];
    }
    // Flags enum to track count of temp variables and a few dedicated names
    var TempFlags;
    (function (TempFlags) {
        TempFlags[TempFlags["Auto"] = 0] = "Auto";
        TempFlags[TempFlags["CountMask"] = 268435455] = "CountMask";
        TempFlags[TempFlags["_i"] = 268435456] = "_i";
    })(TempFlags || (TempFlags = {}));
    function emitListItemNoParenthesizer(node, emit, _parenthesizerRule, _index) {
        emit(node);
    }
    function emitListItemWithParenthesizerRuleSelector(node, emit, parenthesizerRuleSelector, index) {
        emit(node, parenthesizerRuleSelector.select(index));
    }
    function emitListItemWithParenthesizerRule(node, emit, parenthesizerRule, _index) {
        emit(node, parenthesizerRule);
    }
    function getEmitListItem(emit, parenthesizerRule) {
        return emit.length === 1 ? emitListItemNoParenthesizer :
            typeof parenthesizerRule === "object" ? emitListItemWithParenthesizerRuleSelector :
                emitListItemWithParenthesizerRule;
    }
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createCachedDirectoryStructureHost(host, currentDirectory, useCaseSensitiveFileNames) {
        if (!host.getDirectories || !host.readDirectory) {
            return undefined;
        }
        var cachedReadDirectoryResult = new ts.Map();
        var getCanonicalFileName = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        return {
            useCaseSensitiveFileNames: useCaseSensitiveFileNames,
            fileExists: fileExists,
            readFile: function (path, encoding) { return host.readFile(path, encoding); },
            directoryExists: host.directoryExists && directoryExists,
            getDirectories: getDirectories,
            readDirectory: readDirectory,
            createDirectory: host.createDirectory && createDirectory,
            writeFile: host.writeFile && writeFile,
            addOrDeleteFileOrDirectory: addOrDeleteFileOrDirectory,
            addOrDeleteFile: addOrDeleteFile,
            clearCache: clearCache,
            realpath: host.realpath && realpath
        };
        function toPath(fileName) {
            return ts.toPath(fileName, currentDirectory, getCanonicalFileName);
        }
        function getCachedFileSystemEntries(rootDirPath) {
            return cachedReadDirectoryResult.get(ts.ensureTrailingDirectorySeparator(rootDirPath));
        }
        function getCachedFileSystemEntriesForBaseDir(path) {
            return getCachedFileSystemEntries(ts.getDirectoryPath(path));
        }
        function getBaseNameOfFileName(fileName) {
            return ts.getBaseFileName(ts.normalizePath(fileName));
        }
        function createCachedFileSystemEntries(rootDir, rootDirPath) {
            var _a;
            if (!host.realpath || ts.ensureTrailingDirectorySeparator(toPath(host.realpath(rootDir))) === rootDirPath) {
                var resultFromHost = {
                    files: ts.map(host.readDirectory(rootDir, /*extensions*/ undefined, /*exclude*/ undefined, /*include*/ ["*.*"]), getBaseNameOfFileName) || [],
                    directories: host.getDirectories(rootDir) || []
                };
                cachedReadDirectoryResult.set(ts.ensureTrailingDirectorySeparator(rootDirPath), resultFromHost);
                return resultFromHost;
            }
            // If the directory is symlink do not cache the result
            if ((_a = host.directoryExists) === null || _a === void 0 ? void 0 : _a.call(host, rootDir)) {
                cachedReadDirectoryResult.set(rootDirPath, false);
                return false;
            }
            // Non existing directory
            return undefined;
        }
        /**
         * If the readDirectory result was already cached, it returns that
         * Otherwise gets result from host and caches it.
         * The host request is done under try catch block to avoid caching incorrect result
         */
        function tryReadDirectory(rootDir, rootDirPath) {
            rootDirPath = ts.ensureTrailingDirectorySeparator(rootDirPath);
            var cachedResult = getCachedFileSystemEntries(rootDirPath);
            if (cachedResult) {
                return cachedResult;
            }
            try {
                return createCachedFileSystemEntries(rootDir, rootDirPath);
            }
            catch (_e) {
                // If there is exception to read directories, dont cache the result and direct the calls to host
                ts.Debug.assert(!cachedReadDirectoryResult.has(ts.ensureTrailingDirectorySeparator(rootDirPath)));
                return undefined;
            }
        }
        function fileNameEqual(name1, name2) {
            return getCanonicalFileName(name1) === getCanonicalFileName(name2);
        }
        function hasEntry(entries, name) {
            return ts.some(entries, function (file) { return fileNameEqual(file, name); });
        }
        function updateFileSystemEntry(entries, baseName, isValid) {
            if (hasEntry(entries, baseName)) {
                if (!isValid) {
                    return ts.filterMutate(entries, function (entry) { return !fileNameEqual(entry, baseName); });
                }
            }
            else if (isValid) {
                return entries.push(baseName);
            }
        }
        function writeFile(fileName, data, writeByteOrderMark) {
            var path = toPath(fileName);
            var result = getCachedFileSystemEntriesForBaseDir(path);
            if (result) {
                updateFilesOfFileSystemEntry(result, getBaseNameOfFileName(fileName), /*fileExists*/ true);
            }
            return host.writeFile(fileName, data, writeByteOrderMark);
        }
        function fileExists(fileName) {
            var path = toPath(fileName);
            var result = getCachedFileSystemEntriesForBaseDir(path);
            return result && hasEntry(result.files, getBaseNameOfFileName(fileName)) ||
                host.fileExists(fileName);
        }
        function directoryExists(dirPath) {
            var path = toPath(dirPath);
            return cachedReadDirectoryResult.has(ts.ensureTrailingDirectorySeparator(path)) || host.directoryExists(dirPath);
        }
        function createDirectory(dirPath) {
            var path = toPath(dirPath);
            var result = getCachedFileSystemEntriesForBaseDir(path);
            var baseFileName = getBaseNameOfFileName(dirPath);
            if (result) {
                updateFileSystemEntry(result.directories, baseFileName, /*isValid*/ true);
            }
            host.createDirectory(dirPath);
        }
        function getDirectories(rootDir) {
            var rootDirPath = toPath(rootDir);
            var result = tryReadDirectory(rootDir, rootDirPath);
            if (result) {
                return result.directories.slice();
            }
            return host.getDirectories(rootDir);
        }
        function readDirectory(rootDir, extensions, excludes, includes, depth) {
            var rootDirPath = toPath(rootDir);
            var rootResult = tryReadDirectory(rootDir, rootDirPath);
            var rootSymLinkResult;
            if (rootResult !== undefined) {
                return ts.matchFiles(rootDir, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getFileSystemEntries, realpath);
            }
            return host.readDirectory(rootDir, extensions, excludes, includes, depth);
            function getFileSystemEntries(dir) {
                var path = toPath(dir);
                if (path === rootDirPath) {
                    return rootResult || getFileSystemEntriesFromHost(dir, path);
                }
                var result = tryReadDirectory(dir, path);
                return result !== undefined ?
                    result || getFileSystemEntriesFromHost(dir, path) :
                    ts.emptyFileSystemEntries;
            }
            function getFileSystemEntriesFromHost(dir, path) {
                if (rootSymLinkResult && path === rootDirPath)
                    return rootSymLinkResult;
                var result = {
                    files: ts.map(host.readDirectory(dir, /*extensions*/ undefined, /*exclude*/ undefined, /*include*/ ["*.*"]), getBaseNameOfFileName) || ts.emptyArray,
                    directories: host.getDirectories(dir) || ts.emptyArray
                };
                if (path === rootDirPath)
                    rootSymLinkResult = result;
                return result;
            }
        }
        function realpath(s) {
            return host.realpath ? host.realpath(s) : s;
        }
        function addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath) {
            var existingResult = getCachedFileSystemEntries(fileOrDirectoryPath);
            if (existingResult !== undefined) {
                // Just clear the cache for now
                // For now just clear the cache, since this could mean that multiple level entries might need to be re-evaluated
                clearCache();
                return undefined;
            }
            var parentResult = getCachedFileSystemEntriesForBaseDir(fileOrDirectoryPath);
            if (!parentResult) {
                return undefined;
            }
            // This was earlier a file (hence not in cached directory contents)
            // or we never cached the directory containing it
            if (!host.directoryExists) {
                // Since host doesnt support directory exists, clear the cache as otherwise it might not be same
                clearCache();
                return undefined;
            }
            var baseName = getBaseNameOfFileName(fileOrDirectory);
            var fsQueryResult = {
                fileExists: host.fileExists(fileOrDirectoryPath),
                directoryExists: host.directoryExists(fileOrDirectoryPath)
            };
            if (fsQueryResult.directoryExists || hasEntry(parentResult.directories, baseName)) {
                // Folder added or removed, clear the cache instead of updating the folder and its structure
                clearCache();
            }
            else {
                // No need to update the directory structure, just files
                updateFilesOfFileSystemEntry(parentResult, baseName, fsQueryResult.fileExists);
            }
            return fsQueryResult;
        }
        function addOrDeleteFile(fileName, filePath, eventKind) {
            if (eventKind === ts.FileWatcherEventKind.Changed) {
                return;
            }
            var parentResult = getCachedFileSystemEntriesForBaseDir(filePath);
            if (parentResult) {
                updateFilesOfFileSystemEntry(parentResult, getBaseNameOfFileName(fileName), eventKind === ts.FileWatcherEventKind.Created);
            }
        }
        function updateFilesOfFileSystemEntry(parentResult, baseName, fileExists) {
            updateFileSystemEntry(parentResult.files, baseName, fileExists);
        }
        function clearCache() {
            cachedReadDirectoryResult.clear();
        }
    }
    ts.createCachedDirectoryStructureHost = createCachedDirectoryStructureHost;
    var ConfigFileProgramReloadLevel;
    (function (ConfigFileProgramReloadLevel) {
        ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["None"] = 0] = "None";
        /** Update the file name list from the disk */
        ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Partial"] = 1] = "Partial";
        /** Reload completely by re-reading contents of config file from disk and updating program */
        ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Full"] = 2] = "Full";
    })(ConfigFileProgramReloadLevel = ts.ConfigFileProgramReloadLevel || (ts.ConfigFileProgramReloadLevel = {}));
    /**
     * Updates the map of shared extended config file watches with a new set of extended config files from a base config file of the project
     */
    function updateSharedExtendedConfigFileWatcher(projectPath, options, extendedConfigFilesMap, createExtendedConfigFileWatch, toPath) {
        var _a;
        var extendedConfigs = ts.arrayToMap(((_a = options === null || options === void 0 ? void 0 : options.configFile) === null || _a === void 0 ? void 0 : _a.extendedSourceFiles) || ts.emptyArray, toPath);
        // remove project from all unrelated watchers
        extendedConfigFilesMap.forEach(function (watcher, extendedConfigFilePath) {
            if (!extendedConfigs.has(extendedConfigFilePath)) {
                watcher.projects.delete(projectPath);
                watcher.close();
            }
        });
        // Update the extended config files watcher
        extendedConfigs.forEach(function (extendedConfigFileName, extendedConfigFilePath) {
            var existing = extendedConfigFilesMap.get(extendedConfigFilePath);
            if (existing) {
                existing.projects.add(projectPath);
            }
            else {
                // start watching previously unseen extended config
                extendedConfigFilesMap.set(extendedConfigFilePath, {
                    projects: new ts.Set([projectPath]),
                    watcher: createExtendedConfigFileWatch(extendedConfigFileName, extendedConfigFilePath),
                    close: function () {
                        var existing = extendedConfigFilesMap.get(extendedConfigFilePath);
                        if (!existing || existing.projects.size !== 0)
                            return;
                        existing.watcher.close();
                        extendedConfigFilesMap.delete(extendedConfigFilePath);
                    },
                });
            }
        });
    }
    ts.updateSharedExtendedConfigFileWatcher = updateSharedExtendedConfigFileWatcher;
    /**
     * Remove the project from the extended config file watchers and close not needed watches
     */
    function clearSharedExtendedConfigFileWatcher(projectPath, extendedConfigFilesMap) {
        extendedConfigFilesMap.forEach(function (watcher) {
            if (watcher.projects.delete(projectPath))
                watcher.close();
        });
    }
    ts.clearSharedExtendedConfigFileWatcher = clearSharedExtendedConfigFileWatcher;
    /**
     * Clean the extendsConfigCache when extended config file has changed
     */
    function cleanExtendedConfigCache(extendedConfigCache, extendedConfigFilePath, toPath) {
        if (!extendedConfigCache.delete(extendedConfigFilePath))
            return;
        extendedConfigCache.forEach(function (_a, key) {
            var _b;
            var extendedResult = _a.extendedResult;
            if ((_b = extendedResult.extendedSourceFiles) === null || _b === void 0 ? void 0 : _b.some(function (extendedFile) { return toPath(extendedFile) === extendedConfigFilePath; })) {
                cleanExtendedConfigCache(extendedConfigCache, key, toPath);
            }
        });
    }
    ts.cleanExtendedConfigCache = cleanExtendedConfigCache;
    /**
     * Updates watchers based on the package json files used in module resolution
     */
    function updatePackageJsonWatch(lookups, packageJsonWatches, createPackageJsonWatch) {
        var newMap = new ts.Map(lookups);
        ts.mutateMap(packageJsonWatches, newMap, {
            createNewValue: createPackageJsonWatch,
            onDeleteValue: ts.closeFileWatcher
        });
    }
    ts.updatePackageJsonWatch = updatePackageJsonWatch;
    /**
     * Updates the existing missing file watches with the new set of missing files after new program is created
     */
    function updateMissingFilePathsWatch(program, missingFileWatches, createMissingFileWatch) {
        var missingFilePaths = program.getMissingFilePaths();
        // TODO(rbuckton): Should be a `Set` but that requires changing the below code that uses `mutateMap`
        var newMissingFilePathMap = ts.arrayToMap(missingFilePaths, ts.identity, ts.returnTrue);
        // Update the missing file paths watcher
        ts.mutateMap(missingFileWatches, newMissingFilePathMap, {
            // Watch the missing files
            createNewValue: createMissingFileWatch,
            // Files that are no longer missing (e.g. because they are no longer required)
            // should no longer be watched.
            onDeleteValue: ts.closeFileWatcher
        });
    }
    ts.updateMissingFilePathsWatch = updateMissingFilePathsWatch;
    /**
     * Updates the existing wild card directory watches with the new set of wild card directories from the config file
     * after new program is created because the config file was reloaded or program was created first time from the config file
     * Note that there is no need to call this function when the program is updated with additional files without reloading config files,
     * as wildcard directories wont change unless reloading config file
     */
    function updateWatchingWildcardDirectories(existingWatchedForWildcards, wildcardDirectories, watchDirectory) {
        ts.mutateMap(existingWatchedForWildcards, wildcardDirectories, {
            // Create new watch and recursive info
            createNewValue: createWildcardDirectoryWatcher,
            // Close existing watch thats not needed any more
            onDeleteValue: closeFileWatcherOf,
            // Close existing watch that doesnt match in the flags
            onExistingValue: updateWildcardDirectoryWatcher
        });
        function createWildcardDirectoryWatcher(directory, flags) {
            // Create new watch and recursive info
            return {
                watcher: watchDirectory(directory, flags),
                flags: flags
            };
        }
        function updateWildcardDirectoryWatcher(existingWatcher, flags, directory) {
            // Watcher needs to be updated if the recursive flags dont match
            if (existingWatcher.flags === flags) {
                return;
            }
            existingWatcher.watcher.close();
            existingWatchedForWildcards.set(directory, createWildcardDirectoryWatcher(directory, flags));
        }
    }
    ts.updateWatchingWildcardDirectories = updateWatchingWildcardDirectories;
    /* @internal */
    function isIgnoredFileFromWildCardWatching(_a) {
        var watchedDirPath = _a.watchedDirPath, fileOrDirectory = _a.fileOrDirectory, fileOrDirectoryPath = _a.fileOrDirectoryPath, configFileName = _a.configFileName, options = _a.options, program = _a.program, extraFileExtensions = _a.extraFileExtensions, currentDirectory = _a.currentDirectory, useCaseSensitiveFileNames = _a.useCaseSensitiveFileNames, writeLog = _a.writeLog, toPath = _a.toPath;
        var newPath = ts.removeIgnoredPath(fileOrDirectoryPath);
        if (!newPath) {
            writeLog("Project: ".concat(configFileName, " Detected ignored path: ").concat(fileOrDirectory));
            return true;
        }
        fileOrDirectoryPath = newPath;
        if (fileOrDirectoryPath === watchedDirPath)
            return false;
        // If the the added or created file or directory is not supported file name, ignore the file
        // But when watched directory is added/removed, we need to reload the file list
        if (ts.hasExtension(fileOrDirectoryPath) && !ts.isSupportedSourceFileName(fileOrDirectory, options, extraFileExtensions)) {
            writeLog("Project: ".concat(configFileName, " Detected file add/remove of non supported extension: ").concat(fileOrDirectory));
            return true;
        }
        if (ts.isExcludedFile(fileOrDirectory, options.configFile.configFileSpecs, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), currentDirectory), useCaseSensitiveFileNames, currentDirectory)) {
            writeLog("Project: ".concat(configFileName, " Detected excluded file: ").concat(fileOrDirectory));
            return true;
        }
        if (!program)
            return false;
        // We want to ignore emit file check if file is not going to be emitted next to source file
        // In that case we follow config file inclusion rules
        if (ts.outFile(options) || options.outDir)
            return false;
        // File if emitted next to input needs to be ignored
        if (ts.isDeclarationFileName(fileOrDirectoryPath)) {
            // If its declaration directory: its not ignored if not excluded by config
            if (options.declarationDir)
                return false;
        }
        else if (!ts.fileExtensionIsOneOf(fileOrDirectoryPath, ts.supportedJSExtensionsFlat)) {
            return false;
        }
        // just check if sourceFile with the name exists
        var filePathWithoutExtension = ts.removeFileExtension(fileOrDirectoryPath);
        var realProgram = ts.isArray(program) ? undefined : isBuilderProgram(program) ? program.getProgramOrUndefined() : program;
        var builderProgram = !realProgram && !ts.isArray(program) ? program : undefined;
        if (hasSourceFile((filePathWithoutExtension + ".ts" /* Extension.Ts */)) ||
            hasSourceFile((filePathWithoutExtension + ".tsx" /* Extension.Tsx */))) {
            writeLog("Project: ".concat(configFileName, " Detected output file: ").concat(fileOrDirectory));
            return true;
        }
        return false;
        function hasSourceFile(file) {
            return realProgram ?
                !!realProgram.getSourceFileByPath(file) :
                builderProgram ?
                    builderProgram.getState().fileInfos.has(file) :
                    !!ts.find(program, function (rootFile) { return toPath(rootFile) === file; });
        }
    }
    ts.isIgnoredFileFromWildCardWatching = isIgnoredFileFromWildCardWatching;
    function isBuilderProgram(program) {
        return !!program.getState;
    }
    function isEmittedFileOfProgram(program, file) {
        if (!program) {
            return false;
        }
        return program.isEmittedFile(file);
    }
    ts.isEmittedFileOfProgram = isEmittedFileOfProgram;
    var WatchLogLevel;
    (function (WatchLogLevel) {
        WatchLogLevel[WatchLogLevel["None"] = 0] = "None";
        WatchLogLevel[WatchLogLevel["TriggerOnly"] = 1] = "TriggerOnly";
        WatchLogLevel[WatchLogLevel["Verbose"] = 2] = "Verbose";
    })(WatchLogLevel = ts.WatchLogLevel || (ts.WatchLogLevel = {}));
    function getWatchFactory(host, watchLogLevel, log, getDetailWatchInfo) {
        ts.setSysLog(watchLogLevel === WatchLogLevel.Verbose ? log : ts.noop);
        var plainInvokeFactory = {
            watchFile: function (file, callback, pollingInterval, options) { return host.watchFile(file, callback, pollingInterval, options); },
            watchDirectory: function (directory, callback, flags, options) { return host.watchDirectory(directory, callback, (flags & 1 /* WatchDirectoryFlags.Recursive */) !== 0, options); },
        };
        var triggerInvokingFactory = watchLogLevel !== WatchLogLevel.None ?
            {
                watchFile: createTriggerLoggingAddWatch("watchFile"),
                watchDirectory: createTriggerLoggingAddWatch("watchDirectory")
            } :
            undefined;
        var factory = watchLogLevel === WatchLogLevel.Verbose ?
            {
                watchFile: createFileWatcherWithLogging,
                watchDirectory: createDirectoryWatcherWithLogging
            } :
            triggerInvokingFactory || plainInvokeFactory;
        var excludeWatcherFactory = watchLogLevel === WatchLogLevel.Verbose ?
            createExcludeWatcherWithLogging :
            ts.returnNoopFileWatcher;
        return {
            watchFile: createExcludeHandlingAddWatch("watchFile"),
            watchDirectory: createExcludeHandlingAddWatch("watchDirectory")
        };
        function createExcludeHandlingAddWatch(key) {
            return function (file, cb, flags, options, detailInfo1, detailInfo2) {
                var _a;
                return !ts.matchesExclude(file, key === "watchFile" ? options === null || options === void 0 ? void 0 : options.excludeFiles : options === null || options === void 0 ? void 0 : options.excludeDirectories, useCaseSensitiveFileNames(), ((_a = host.getCurrentDirectory) === null || _a === void 0 ? void 0 : _a.call(host)) || "") ?
                    factory[key].call(/*thisArgs*/ undefined, file, cb, flags, options, detailInfo1, detailInfo2) :
                    excludeWatcherFactory(file, flags, options, detailInfo1, detailInfo2);
            };
        }
        function useCaseSensitiveFileNames() {
            return typeof host.useCaseSensitiveFileNames === "boolean" ?
                host.useCaseSensitiveFileNames :
                host.useCaseSensitiveFileNames();
        }
        function createExcludeWatcherWithLogging(file, flags, options, detailInfo1, detailInfo2) {
            log("ExcludeWatcher:: Added:: ".concat(getWatchInfo(file, flags, options, detailInfo1, detailInfo2, getDetailWatchInfo)));
            return {
                close: function () { return log("ExcludeWatcher:: Close:: ".concat(getWatchInfo(file, flags, options, detailInfo1, detailInfo2, getDetailWatchInfo))); }
            };
        }
        function createFileWatcherWithLogging(file, cb, flags, options, detailInfo1, detailInfo2) {
            log("FileWatcher:: Added:: ".concat(getWatchInfo(file, flags, options, detailInfo1, detailInfo2, getDetailWatchInfo)));
            var watcher = triggerInvokingFactory.watchFile(file, cb, flags, options, detailInfo1, detailInfo2);
            return {
                close: function () {
                    log("FileWatcher:: Close:: ".concat(getWatchInfo(file, flags, options, detailInfo1, detailInfo2, getDetailWatchInfo)));
                    watcher.close();
                }
            };
        }
        function createDirectoryWatcherWithLogging(file, cb, flags, options, detailInfo1, detailInfo2) {
            var watchInfo = "DirectoryWatcher:: Added:: ".concat(getWatchInfo(file, flags, options, detailInfo1, detailInfo2, getDetailWatchInfo));
            log(watchInfo);
            var start = ts.timestamp();
            var watcher = triggerInvokingFactory.watchDirectory(file, cb, flags, options, detailInfo1, detailInfo2);
            var elapsed = ts.timestamp() - start;
            log("Elapsed:: ".concat(elapsed, "ms ").concat(watchInfo));
            return {
                close: function () {
                    var watchInfo = "DirectoryWatcher:: Close:: ".concat(getWatchInfo(file, flags, options, detailInfo1, detailInfo2, getDetailWatchInfo));
                    log(watchInfo);
                    var start = ts.timestamp();
                    watcher.close();
                    var elapsed = ts.timestamp() - start;
                    log("Elapsed:: ".concat(elapsed, "ms ").concat(watchInfo));
                }
            };
        }
        function createTriggerLoggingAddWatch(key) {
            return function (file, cb, flags, options, detailInfo1, detailInfo2) { return plainInvokeFactory[key].call(/*thisArgs*/ undefined, file, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var triggerredInfo = "".concat(key === "watchFile" ? "FileWatcher" : "DirectoryWatcher", ":: Triggered with ").concat(args[0], " ").concat(args[1] !== undefined ? args[1] : "", ":: ").concat(getWatchInfo(file, flags, options, detailInfo1, detailInfo2, getDetailWatchInfo));
                log(triggerredInfo);
                var start = ts.timestamp();
                cb.call.apply(cb, __spreadArray([/*thisArg*/ undefined], args, false));
                var elapsed = ts.timestamp() - start;
                log("Elapsed:: ".concat(elapsed, "ms ").concat(triggerredInfo));
            }, flags, options, detailInfo1, detailInfo2); };
        }
        function getWatchInfo(file, flags, options, detailInfo1, detailInfo2, getDetailWatchInfo) {
            return "WatchInfo: ".concat(file, " ").concat(flags, " ").concat(JSON.stringify(options), " ").concat(getDetailWatchInfo ? getDetailWatchInfo(detailInfo1, detailInfo2) : detailInfo2 === undefined ? detailInfo1 : "".concat(detailInfo1, " ").concat(detailInfo2));
        }
    }
    ts.getWatchFactory = getWatchFactory;
    function getFallbackOptions(options) {
        var fallbackPolling = options === null || options === void 0 ? void 0 : options.fallbackPolling;
        return {
            watchFile: fallbackPolling !== undefined ?
                fallbackPolling :
                ts.WatchFileKind.PriorityPollingInterval
        };
    }
    ts.getFallbackOptions = getFallbackOptions;
    function closeFileWatcherOf(objWithWatcher) {
        objWithWatcher.watcher.close();
    }
    ts.closeFileWatcherOf = closeFileWatcherOf;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function findConfigFile(searchPath, fileExists, configName) {
        if (configName === void 0) { configName = "tsconfig.json"; }
        return ts.forEachAncestorDirectory(searchPath, function (ancestor) {
            var fileName = ts.combinePaths(ancestor, configName);
            return fileExists(fileName) ? fileName : undefined;
        });
    }
    ts.findConfigFile = findConfigFile;
    function resolveTripleslashReference(moduleName, containingFile) {
        var basePath = ts.getDirectoryPath(containingFile);
        var referencedFileName = ts.isRootedDiskPath(moduleName) ? moduleName : ts.combinePaths(basePath, moduleName);
        return ts.normalizePath(referencedFileName);
    }
    ts.resolveTripleslashReference = resolveTripleslashReference;
    /* @internal */
    function computeCommonSourceDirectoryOfFilenames(fileNames, currentDirectory, getCanonicalFileName) {
        var commonPathComponents;
        var failed = ts.forEach(fileNames, function (sourceFile) {
            // Each file contributes into common source file path
            var sourcePathComponents = ts.getNormalizedPathComponents(sourceFile, currentDirectory);
            sourcePathComponents.pop(); // The base file name is not part of the common directory path
            if (!commonPathComponents) {
                // first file
                commonPathComponents = sourcePathComponents;
                return;
            }
            var n = Math.min(commonPathComponents.length, sourcePathComponents.length);
            for (var i = 0; i < n; i++) {
                if (getCanonicalFileName(commonPathComponents[i]) !== getCanonicalFileName(sourcePathComponents[i])) {
                    if (i === 0) {
                        // Failed to find any common path component
                        return true;
                    }
                    // New common path found that is 0 -> i-1
                    commonPathComponents.length = i;
                    break;
                }
            }
            // If the sourcePathComponents was shorter than the commonPathComponents, truncate to the sourcePathComponents
            if (sourcePathComponents.length < commonPathComponents.length) {
                commonPathComponents.length = sourcePathComponents.length;
            }
        });
        // A common path can not be found when paths span multiple drives on windows, for example
        if (failed) {
            return "";
        }
        if (!commonPathComponents) { // Can happen when all input files are .d.ts files
            return currentDirectory;
        }
        return ts.getPathFromPathComponents(commonPathComponents);
    }
    ts.computeCommonSourceDirectoryOfFilenames = computeCommonSourceDirectoryOfFilenames;
    function createCompilerHost(options, setParentNodes) {
        return createCompilerHostWorker(options, setParentNodes);
    }
    ts.createCompilerHost = createCompilerHost;
    /*@internal*/
    // TODO(shkamat): update this after reworking ts build API
    function createCompilerHostWorker(options, setParentNodes, system) {
        if (system === void 0) { system = ts.sys; }
        var existingDirectories = new ts.Map();
        var getCanonicalFileName = ts.createGetCanonicalFileName(system.useCaseSensitiveFileNames);
        var computeHash = ts.maybeBind(system, system.createHash) || ts.generateDjb2Hash;
        function getSourceFile(fileName, languageVersionOrOptions, onError) {
            var text;
            try {
                ts.performance.mark("beforeIORead");
                text = compilerHost.readFile(fileName);
                ts.performance.mark("afterIORead");
                ts.performance.measure("I/O Read", "beforeIORead", "afterIORead");
            }
            catch (e) {
                if (onError) {
                    onError(e.message);
                }
                text = "";
            }
            return text !== undefined ? ts.createSourceFile(fileName, text, languageVersionOrOptions, setParentNodes) : undefined;
        }
        function directoryExists(directoryPath) {
            if (existingDirectories.has(directoryPath)) {
                return true;
            }
            if ((compilerHost.directoryExists || system.directoryExists)(directoryPath)) {
                existingDirectories.set(directoryPath, true);
                return true;
            }
            return false;
        }
        function writeFile(fileName, data, writeByteOrderMark, onError) {
            try {
                ts.performance.mark("beforeIOWrite");
                // NOTE: If patchWriteFileEnsuringDirectory has been called,
                // the system.writeFile will do its own directory creation and
                // the ensureDirectoriesExist call will always be redundant.
                ts.writeFileEnsuringDirectories(fileName, data, writeByteOrderMark, function (path, data, writeByteOrderMark) { return writeFileWorker(path, data, writeByteOrderMark); }, function (path) { return (compilerHost.createDirectory || system.createDirectory)(path); }, function (path) { return directoryExists(path); });
                ts.performance.mark("afterIOWrite");
                ts.performance.measure("I/O Write", "beforeIOWrite", "afterIOWrite");
            }
            catch (e) {
                if (onError) {
                    onError(e.message);
                }
            }
        }
        var outputFingerprints;
        function writeFileWorker(fileName, data, writeByteOrderMark) {
            if (!ts.isWatchSet(options) || !system.getModifiedTime) {
                system.writeFile(fileName, data, writeByteOrderMark);
                return;
            }
            if (!outputFingerprints) {
                outputFingerprints = new ts.Map();
            }
            var hash = computeHash(data);
            var mtimeBefore = system.getModifiedTime(fileName);
            if (mtimeBefore) {
                var fingerprint = outputFingerprints.get(fileName);
                // If output has not been changed, and the file has no external modification
                if (fingerprint &&
                    fingerprint.byteOrderMark === writeByteOrderMark &&
                    fingerprint.hash === hash &&
                    fingerprint.mtime.getTime() === mtimeBefore.getTime()) {
                    return;
                }
            }
            system.writeFile(fileName, data, writeByteOrderMark);
            var mtimeAfter = system.getModifiedTime(fileName) || ts.missingFileModifiedTime;
            outputFingerprints.set(fileName, {
                hash: hash,
                byteOrderMark: writeByteOrderMark,
                mtime: mtimeAfter
            });
        }
        function getDefaultLibLocation() {
            return ts.getDirectoryPath(ts.normalizePath(system.getExecutingFilePath()));
        }
        var newLine = ts.getNewLineCharacter(options, function () { return system.newLine; });
        var realpath = system.realpath && (function (path) { return system.realpath(path); });
        var compilerHost = {
            getSourceFile: getSourceFile,
            getDefaultLibLocation: getDefaultLibLocation,
            getDefaultLibFileName: function (options) { return ts.combinePaths(getDefaultLibLocation(), ts.getDefaultLibFileName(options)); },
            writeFile: writeFile,
            getCurrentDirectory: ts.memoize(function () { return system.getCurrentDirectory(); }),
            useCaseSensitiveFileNames: function () { return system.useCaseSensitiveFileNames; },
            getCanonicalFileName: getCanonicalFileName,
            getNewLine: function () { return newLine; },
            fileExists: function (fileName) { return system.fileExists(fileName); },
            readFile: function (fileName) { return system.readFile(fileName); },
            trace: function (s) { return system.write(s + newLine); },
            directoryExists: function (directoryName) { return system.directoryExists(directoryName); },
            getEnvironmentVariable: function (name) { return system.getEnvironmentVariable ? system.getEnvironmentVariable(name) : ""; },
            getDirectories: function (path) { return system.getDirectories(path); },
            realpath: realpath,
            readDirectory: function (path, extensions, include, exclude, depth) { return system.readDirectory(path, extensions, include, exclude, depth); },
            createDirectory: function (d) { return system.createDirectory(d); },
            createHash: ts.maybeBind(system, system.createHash)
        };
        return compilerHost;
    }
    ts.createCompilerHostWorker = createCompilerHostWorker;
    /*@internal*/
    function changeCompilerHostLikeToUseCache(host, toPath, getSourceFile) {
        var originalReadFile = host.readFile;
        var originalFileExists = host.fileExists;
        var originalDirectoryExists = host.directoryExists;
        var originalCreateDirectory = host.createDirectory;
        var originalWriteFile = host.writeFile;
        var readFileCache = new ts.Map();
        var fileExistsCache = new ts.Map();
        var directoryExistsCache = new ts.Map();
        var sourceFileCache = new ts.Map();
        var readFileWithCache = function (fileName) {
            var key = toPath(fileName);
            var value = readFileCache.get(key);
            if (value !== undefined)
                return value !== false ? value : undefined;
            return setReadFileCache(key, fileName);
        };
        var setReadFileCache = function (key, fileName) {
            var newValue = originalReadFile.call(host, fileName);
            readFileCache.set(key, newValue !== undefined ? newValue : false);
            return newValue;
        };
        host.readFile = function (fileName) {
            var key = toPath(fileName);
            var value = readFileCache.get(key);
            if (value !== undefined)
                return value !== false ? value : undefined; // could be .d.ts from output
            // Cache json or buildInfo
            if (!ts.fileExtensionIs(fileName, ".json" /* Extension.Json */) && !ts.isBuildInfoFile(fileName)) {
                return originalReadFile.call(host, fileName);
            }
            return setReadFileCache(key, fileName);
        };
        var getSourceFileWithCache = getSourceFile ? function (fileName, languageVersion, onError, shouldCreateNewSourceFile) {
            var key = toPath(fileName);
            var value = sourceFileCache.get(key);
            if (value)
                return value;
            var sourceFile = getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);
            if (sourceFile && (ts.isDeclarationFileName(fileName) || ts.fileExtensionIs(fileName, ".json" /* Extension.Json */))) {
                sourceFileCache.set(key, sourceFile);
            }
            return sourceFile;
        } : undefined;
        // fileExists for any kind of extension
        host.fileExists = function (fileName) {
            var key = toPath(fileName);
            var value = fileExistsCache.get(key);
            if (value !== undefined)
                return value;
            var newValue = originalFileExists.call(host, fileName);
            fileExistsCache.set(key, !!newValue);
            return newValue;
        };
        if (originalWriteFile) {
            host.writeFile = function (fileName, data) {
                var rest = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    rest[_i - 2] = arguments[_i];
                }
                var key = toPath(fileName);
                fileExistsCache.delete(key);
                var value = readFileCache.get(key);
                if (value !== undefined && value !== data) {
                    readFileCache.delete(key);
                    sourceFileCache.delete(key);
                }
                else if (getSourceFileWithCache) {
                    var sourceFile = sourceFileCache.get(key);
                    if (sourceFile && sourceFile.text !== data) {
                        sourceFileCache.delete(key);
                    }
                }
                originalWriteFile.call.apply(originalWriteFile, __spreadArray([host, fileName, data], rest, false));
            };
        }
        // directoryExists
        if (originalDirectoryExists && originalCreateDirectory) {
            host.directoryExists = function (directory) {
                var key = toPath(directory);
                var value = directoryExistsCache.get(key);
                if (value !== undefined)
                    return value;
                var newValue = originalDirectoryExists.call(host, directory);
                directoryExistsCache.set(key, !!newValue);
                return newValue;
            };
            host.createDirectory = function (directory) {
                var key = toPath(directory);
                directoryExistsCache.delete(key);
                originalCreateDirectory.call(host, directory);
            };
        }
        return {
            originalReadFile: originalReadFile,
            originalFileExists: originalFileExists,
            originalDirectoryExists: originalDirectoryExists,
            originalCreateDirectory: originalCreateDirectory,
            originalWriteFile: originalWriteFile,
            getSourceFileWithCache: getSourceFileWithCache,
            readFileWithCache: readFileWithCache
        };
    }
    ts.changeCompilerHostLikeToUseCache = changeCompilerHostLikeToUseCache;
    function getPreEmitDiagnostics(program, sourceFile, cancellationToken) {
        var diagnostics;
        diagnostics = ts.addRange(diagnostics, program.getConfigFileParsingDiagnostics());
        diagnostics = ts.addRange(diagnostics, program.getOptionsDiagnostics(cancellationToken));
        diagnostics = ts.addRange(diagnostics, program.getSyntacticDiagnostics(sourceFile, cancellationToken));
        diagnostics = ts.addRange(diagnostics, program.getGlobalDiagnostics(cancellationToken));
        diagnostics = ts.addRange(diagnostics, program.getSemanticDiagnostics(sourceFile, cancellationToken));
        if (ts.getEmitDeclarations(program.getCompilerOptions())) {
            diagnostics = ts.addRange(diagnostics, program.getDeclarationDiagnostics(sourceFile, cancellationToken));
        }
        return ts.sortAndDeduplicateDiagnostics(diagnostics || ts.emptyArray);
    }
    ts.getPreEmitDiagnostics = getPreEmitDiagnostics;
    function formatDiagnostics(diagnostics, host) {
        var output = "";
        for (var _i = 0, diagnostics_3 = diagnostics; _i < diagnostics_3.length; _i++) {
            var diagnostic = diagnostics_3[_i];
            output += formatDiagnostic(diagnostic, host);
        }
        return output;
    }
    ts.formatDiagnostics = formatDiagnostics;
    function formatDiagnostic(diagnostic, host) {
        var errorMessage = "".concat(ts.diagnosticCategoryName(diagnostic), " TS").concat(diagnostic.code, ": ").concat(flattenDiagnosticMessageText(diagnostic.messageText, host.getNewLine())).concat(host.getNewLine());
        if (diagnostic.file) {
            var _a = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start), line = _a.line, character = _a.character; // TODO: GH#18217
            var fileName = diagnostic.file.fileName;
            var relativeFileName = ts.convertToRelativePath(fileName, host.getCurrentDirectory(), function (fileName) { return host.getCanonicalFileName(fileName); });
            return "".concat(relativeFileName, "(").concat(line + 1, ",").concat(character + 1, "): ") + errorMessage;
        }
        return errorMessage;
    }
    ts.formatDiagnostic = formatDiagnostic;
    /** @internal */
    var ForegroundColorEscapeSequences;
    (function (ForegroundColorEscapeSequences) {
        ForegroundColorEscapeSequences["Grey"] = "\u001B[90m";
        ForegroundColorEscapeSequences["Red"] = "\u001B[91m";
        ForegroundColorEscapeSequences["Yellow"] = "\u001B[93m";
        ForegroundColorEscapeSequences["Blue"] = "\u001B[94m";
        ForegroundColorEscapeSequences["Cyan"] = "\u001B[96m";
    })(ForegroundColorEscapeSequences = ts.ForegroundColorEscapeSequences || (ts.ForegroundColorEscapeSequences = {}));
    var gutterStyleSequence = "\u001b[7m";
    var gutterSeparator = " ";
    var resetEscapeSequence = "\u001b[0m";
    var ellipsis = "...";
    var halfIndent = "  ";
    var indent = "    ";
    function getCategoryFormat(category) {
        switch (category) {
            case ts.DiagnosticCategory.Error: return ForegroundColorEscapeSequences.Red;
            case ts.DiagnosticCategory.Warning: return ForegroundColorEscapeSequences.Yellow;
            case ts.DiagnosticCategory.Suggestion: return ts.Debug.fail("Should never get an Info diagnostic on the command line.");
            case ts.DiagnosticCategory.Message: return ForegroundColorEscapeSequences.Blue;
        }
    }
    /** @internal */
    function formatColorAndReset(text, formatStyle) {
        return formatStyle + text + resetEscapeSequence;
    }
    ts.formatColorAndReset = formatColorAndReset;
    function formatCodeSpan(file, start, length, indent, squiggleColor, host) {
        var _a = ts.getLineAndCharacterOfPosition(file, start), firstLine = _a.line, firstLineChar = _a.character;
        var _b = ts.getLineAndCharacterOfPosition(file, start + length), lastLine = _b.line, lastLineChar = _b.character;
        var lastLineInFile = ts.getLineAndCharacterOfPosition(file, file.text.length).line;
        var hasMoreThanFiveLines = (lastLine - firstLine) >= 4;
        var gutterWidth = (lastLine + 1 + "").length;
        if (hasMoreThanFiveLines) {
            gutterWidth = Math.max(ellipsis.length, gutterWidth);
        }
        var context = "";
        for (var i = firstLine; i <= lastLine; i++) {
            context += host.getNewLine();
            // If the error spans over 5 lines, we'll only show the first 2 and last 2 lines,
            // so we'll skip ahead to the second-to-last line.
            if (hasMoreThanFiveLines && firstLine + 1 < i && i < lastLine - 1) {
                context += indent + formatColorAndReset(ts.padLeft(ellipsis, gutterWidth), gutterStyleSequence) + gutterSeparator + host.getNewLine();
                i = lastLine - 1;
            }
            var lineStart = ts.getPositionOfLineAndCharacter(file, i, 0);
            var lineEnd = i < lastLineInFile ? ts.getPositionOfLineAndCharacter(file, i + 1, 0) : file.text.length;
            var lineContent = file.text.slice(lineStart, lineEnd);
            lineContent = ts.trimStringEnd(lineContent); // trim from end
            lineContent = lineContent.replace(/\t/g, " "); // convert tabs to single spaces
            // Output the gutter and the actual contents of the line.
            context += indent + formatColorAndReset(ts.padLeft(i + 1 + "", gutterWidth), gutterStyleSequence) + gutterSeparator;
            context += lineContent + host.getNewLine();
            // Output the gutter and the error span for the line using tildes.
            context += indent + formatColorAndReset(ts.padLeft("", gutterWidth), gutterStyleSequence) + gutterSeparator;
            context += squiggleColor;
            if (i === firstLine) {
                // If we're on the last line, then limit it to the last character of the last line.
                // Otherwise, we'll just squiggle the rest of the line, giving 'slice' no end position.
                var lastCharForLine = i === lastLine ? lastLineChar : undefined;
                context += lineContent.slice(0, firstLineChar).replace(/\S/g, " ");
                context += lineContent.slice(firstLineChar, lastCharForLine).replace(/./g, "~");
            }
            else if (i === lastLine) {
                context += lineContent.slice(0, lastLineChar).replace(/./g, "~");
            }
            else {
                // Squiggle the entire line.
                context += lineContent.replace(/./g, "~");
            }
            context += resetEscapeSequence;
        }
        return context;
    }
    /* @internal */
    function formatLocation(file, start, host, color) {
        if (color === void 0) { color = formatColorAndReset; }
        var _a = ts.getLineAndCharacterOfPosition(file, start), firstLine = _a.line, firstLineChar = _a.character; // TODO: GH#18217
        var relativeFileName = host ? ts.convertToRelativePath(file.fileName, host.getCurrentDirectory(), function (fileName) { return host.getCanonicalFileName(fileName); }) : file.fileName;
        var output = "";
        output += color(relativeFileName, ForegroundColorEscapeSequences.Cyan);
        output += ":";
        output += color("".concat(firstLine + 1), ForegroundColorEscapeSequences.Yellow);
        output += ":";
        output += color("".concat(firstLineChar + 1), ForegroundColorEscapeSequences.Yellow);
        return output;
    }
    ts.formatLocation = formatLocation;
    function formatDiagnosticsWithColorAndContext(diagnostics, host) {
        var output = "";
        for (var _i = 0, diagnostics_4 = diagnostics; _i < diagnostics_4.length; _i++) {
            var diagnostic = diagnostics_4[_i];
            if (diagnostic.file) {
                var file = diagnostic.file, start = diagnostic.start;
                output += formatLocation(file, start, host); // TODO: GH#18217
                output += " - ";
            }
            output += formatColorAndReset(ts.diagnosticCategoryName(diagnostic), getCategoryFormat(diagnostic.category));
            output += formatColorAndReset(" TS".concat(diagnostic.code, ": "), ForegroundColorEscapeSequences.Grey);
            output += flattenDiagnosticMessageText(diagnostic.messageText, host.getNewLine());
            if (diagnostic.file) {
                output += host.getNewLine();
                output += formatCodeSpan(diagnostic.file, diagnostic.start, diagnostic.length, "", getCategoryFormat(diagnostic.category), host); // TODO: GH#18217
            }
            if (diagnostic.relatedInformation) {
                output += host.getNewLine();
                for (var _a = 0, _b = diagnostic.relatedInformation; _a < _b.length; _a++) {
                    var _c = _b[_a], file = _c.file, start = _c.start, length_9 = _c.length, messageText = _c.messageText;
                    if (file) {
                        output += host.getNewLine();
                        output += halfIndent + formatLocation(file, start, host); // TODO: GH#18217
                        output += formatCodeSpan(file, start, length_9, indent, ForegroundColorEscapeSequences.Cyan, host); // TODO: GH#18217
                    }
                    output += host.getNewLine();
                    output += indent + flattenDiagnosticMessageText(messageText, host.getNewLine());
                }
            }
            output += host.getNewLine();
        }
        return output;
    }
    ts.formatDiagnosticsWithColorAndContext = formatDiagnosticsWithColorAndContext;
    function flattenDiagnosticMessageText(diag, newLine, indent) {
        if (indent === void 0) { indent = 0; }
        if (ts.isString(diag)) {
            return diag;
        }
        else if (diag === undefined) {
            return "";
        }
        var result = "";
        if (indent) {
            result += newLine;
            for (var i = 0; i < indent; i++) {
                result += "  ";
            }
        }
        result += diag.messageText;
        indent++;
        if (diag.next) {
            for (var _i = 0, _a = diag.next; _i < _a.length; _i++) {
                var kid = _a[_i];
                result += flattenDiagnosticMessageText(kid, newLine, indent);
            }
        }
        return result;
    }
    ts.flattenDiagnosticMessageText = flattenDiagnosticMessageText;
    /* @internal */
    function loadWithTypeDirectiveCache(names, containingFile, redirectedReference, containingFileMode, loader) {
        if (names.length === 0) {
            return [];
        }
        var resolutions = [];
        var cache = new ts.Map();
        for (var _i = 0, names_2 = names; _i < names_2.length; _i++) {
            var name = names_2[_i];
            var result = void 0;
            var mode = getModeForFileReference(name, containingFileMode);
            // We lower-case all type references because npm automatically lowercases all packages. See GH#9824.
            var strName = ts.isString(name) ? name : name.fileName.toLowerCase();
            var cacheKey = mode !== undefined ? "".concat(mode, "|").concat(strName) : strName;
            if (cache.has(cacheKey)) {
                result = cache.get(cacheKey);
            }
            else {
                cache.set(cacheKey, result = loader(strName, containingFile, redirectedReference, mode));
            }
            resolutions.push(result);
        }
        return resolutions;
    }
    ts.loadWithTypeDirectiveCache = loadWithTypeDirectiveCache;
    ;
    /**
     * Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly
     * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.
     */
    function getModeForFileReference(ref, containingFileMode) {
        return (ts.isString(ref) ? containingFileMode : ref.resolutionMode) || containingFileMode;
    }
    ts.getModeForFileReference = getModeForFileReference;
    function getModeForResolutionAtIndex(file, index) {
        if (file.impliedNodeFormat === undefined)
            return undefined;
        // we ensure all elements of file.imports and file.moduleAugmentations have the relevant parent pointers set during program setup,
        // so it's safe to use them even pre-bind
        return getModeForUsageLocation(file, getModuleNameStringLiteralAt(file, index));
    }
    ts.getModeForResolutionAtIndex = getModeForResolutionAtIndex;
    /* @internal */
    function isExclusivelyTypeOnlyImportOrExport(decl) {
        var _a;
        if (ts.isExportDeclaration(decl)) {
            return decl.isTypeOnly;
        }
        if ((_a = decl.importClause) === null || _a === void 0 ? void 0 : _a.isTypeOnly) {
            return true;
        }
        return false;
    }
    ts.isExclusivelyTypeOnlyImportOrExport = isExclusivelyTypeOnlyImportOrExport;
    /**
     * Calculates the final resolution mode for a given module reference node. This is generally the explicitly provided resolution mode, if
     * one exists, or the mode of the containing source file. (Excepting import=require, which is always commonjs, and dynamic import, which is always esm).
     * Notably, this function always returns `undefined` if the containing file has an `undefined` `impliedNodeFormat` - this field is only set when
     * `moduleResolution` is `node16`+.
     * @param file The file the import or import-like reference is contained within
     * @param usage The module reference string
     * @returns The final resolution mode of the import
     */
    function getModeForUsageLocation(file, usage) {
        var _a, _b;
        if (file.impliedNodeFormat === undefined)
            return undefined;
        if ((ts.isImportDeclaration(usage.parent) || ts.isExportDeclaration(usage.parent))) {
            var isTypeOnly = isExclusivelyTypeOnlyImportOrExport(usage.parent);
            if (isTypeOnly) {
                var override = getResolutionModeOverrideForClause(usage.parent.assertClause);
                if (override) {
                    return override;
                }
            }
        }
        if (usage.parent.parent && ts.isImportTypeNode(usage.parent.parent)) {
            var override = getResolutionModeOverrideForClause((_a = usage.parent.parent.assertions) === null || _a === void 0 ? void 0 : _a.assertClause);
            if (override) {
                return override;
            }
        }
        if (file.impliedNodeFormat !== ts.ModuleKind.ESNext) {
            // in cjs files, import call expressions are esm format, otherwise everything is cjs
            return ts.isImportCall(ts.walkUpParenthesizedExpressions(usage.parent)) ? ts.ModuleKind.ESNext : ts.ModuleKind.CommonJS;
        }
        // in esm files, import=require statements are cjs format, otherwise everything is esm
        // imports are only parent'd up to their containing declaration/expression, so access farther parents with care
        var exprParentParent = (_b = ts.walkUpParenthesizedExpressions(usage.parent)) === null || _b === void 0 ? void 0 : _b.parent;
        return exprParentParent && ts.isImportEqualsDeclaration(exprParentParent) ? ts.ModuleKind.CommonJS : ts.ModuleKind.ESNext;
    }
    ts.getModeForUsageLocation = getModeForUsageLocation;
    /* @internal */
    function getResolutionModeOverrideForClause(clause, grammarErrorOnNode) {
        if (!clause)
            return undefined;
        if (ts.length(clause.elements) !== 1) {
            grammarErrorOnNode === null || grammarErrorOnNode === void 0 ? void 0 : grammarErrorOnNode(clause, ts.Diagnostics.Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require);
            return undefined;
        }
        var elem = clause.elements[0];
        if (!ts.isStringLiteralLike(elem.name))
            return undefined;
        if (elem.name.text !== "resolution-mode") {
            grammarErrorOnNode === null || grammarErrorOnNode === void 0 ? void 0 : grammarErrorOnNode(elem.name, ts.Diagnostics.resolution_mode_is_the_only_valid_key_for_type_import_assertions);
            return undefined;
        }
        if (!ts.isStringLiteralLike(elem.value))
            return undefined;
        if (elem.value.text !== "import" && elem.value.text !== "require") {
            grammarErrorOnNode === null || grammarErrorOnNode === void 0 ? void 0 : grammarErrorOnNode(elem.value, ts.Diagnostics.resolution_mode_should_be_either_require_or_import);
            return undefined;
        }
        return elem.value.text === "import" ? ts.ModuleKind.ESNext : ts.ModuleKind.CommonJS;
    }
    ts.getResolutionModeOverrideForClause = getResolutionModeOverrideForClause;
    /* @internal */
    function loadWithModeAwareCache(names, containingFile, containingFileName, redirectedReference, loader) {
        if (names.length === 0) {
            return [];
        }
        var resolutions = [];
        var cache = new ts.Map();
        var i = 0;
        for (var _i = 0, names_3 = names; _i < names_3.length; _i++) {
            var name = names_3[_i];
            var result = void 0;
            var mode = getModeForResolutionAtIndex(containingFile, i);
            i++;
            var cacheKey = mode !== undefined ? "".concat(mode, "|").concat(name) : name;
            if (cache.has(cacheKey)) {
                result = cache.get(cacheKey);
            }
            else {
                cache.set(cacheKey, result = loader(name, mode, containingFileName, redirectedReference));
            }
            resolutions.push(result);
        }
        return resolutions;
    }
    ts.loadWithModeAwareCache = loadWithModeAwareCache;
    /* @internal */
    function forEachResolvedProjectReference(resolvedProjectReferences, cb) {
        return forEachProjectReference(/*projectReferences*/ undefined, resolvedProjectReferences, function (resolvedRef, parent) { return resolvedRef && cb(resolvedRef, parent); });
    }
    ts.forEachResolvedProjectReference = forEachResolvedProjectReference;
    function forEachProjectReference(projectReferences, resolvedProjectReferences, cbResolvedRef, cbRef) {
        var seenResolvedRefs;
        return worker(projectReferences, resolvedProjectReferences, /*parent*/ undefined);
        function worker(projectReferences, resolvedProjectReferences, parent) {
            // Visit project references first
            if (cbRef) {
                var result = cbRef(projectReferences, parent);
                if (result)
                    return result;
            }
            return ts.forEach(resolvedProjectReferences, function (resolvedRef, index) {
                if (resolvedRef && (seenResolvedRefs === null || seenResolvedRefs === void 0 ? void 0 : seenResolvedRefs.has(resolvedRef.sourceFile.path))) {
                    // ignore recursives
                    return undefined;
                }
                var result = cbResolvedRef(resolvedRef, parent, index);
                if (result || !resolvedRef)
                    return result;
                (seenResolvedRefs || (seenResolvedRefs = new ts.Set())).add(resolvedRef.sourceFile.path);
                return worker(resolvedRef.commandLine.projectReferences, resolvedRef.references, resolvedRef);
            });
        }
    }
    /* @internal */
    ts.inferredTypesContainingFile = "__inferred type names__.ts";
    /*@internal*/
    function isReferencedFile(reason) {
        switch (reason === null || reason === void 0 ? void 0 : reason.kind) {
            case ts.FileIncludeKind.Import:
            case ts.FileIncludeKind.ReferenceFile:
            case ts.FileIncludeKind.TypeReferenceDirective:
            case ts.FileIncludeKind.LibReferenceDirective:
                return true;
            default:
                return false;
        }
    }
    ts.isReferencedFile = isReferencedFile;
    /*@internal*/
    function isReferenceFileLocation(location) {
        return location.pos !== undefined;
    }
    ts.isReferenceFileLocation = isReferenceFileLocation;
    /*@internal*/
    function getReferencedFileLocation(getSourceFileByPath, ref) {
        var _a, _b, _c;
        var _d, _e, _f, _g;
        var file = ts.Debug.checkDefined(getSourceFileByPath(ref.file));
        var kind = ref.kind, index = ref.index;
        var pos, end, packageId, resolutionMode;
        switch (kind) {
            case ts.FileIncludeKind.Import:
                var importLiteral = getModuleNameStringLiteralAt(file, index);
                packageId = (_e = (_d = file.resolvedModules) === null || _d === void 0 ? void 0 : _d.get(importLiteral.text, getModeForResolutionAtIndex(file, index))) === null || _e === void 0 ? void 0 : _e.packageId;
                if (importLiteral.pos === -1)
                    return { file: file, packageId: packageId, text: importLiteral.text };
                pos = ts.skipTrivia(file.text, importLiteral.pos);
                end = importLiteral.end;
                break;
            case ts.FileIncludeKind.ReferenceFile:
                (_a = file.referencedFiles[index], pos = _a.pos, end = _a.end);
                break;
            case ts.FileIncludeKind.TypeReferenceDirective:
                (_b = file.typeReferenceDirectives[index], pos = _b.pos, end = _b.end, resolutionMode = _b.resolutionMode);
                packageId = (_g = (_f = file.resolvedTypeReferenceDirectiveNames) === null || _f === void 0 ? void 0 : _f.get(ts.toFileNameLowerCase(file.typeReferenceDirectives[index].fileName), resolutionMode || file.impliedNodeFormat)) === null || _g === void 0 ? void 0 : _g.packageId;
                break;
            case ts.FileIncludeKind.LibReferenceDirective:
                (_c = file.libReferenceDirectives[index], pos = _c.pos, end = _c.end);
                break;
            default:
                return ts.Debug.assertNever(kind);
        }
        return { file: file, pos: pos, end: end, packageId: packageId };
    }
    ts.getReferencedFileLocation = getReferencedFileLocation;
    /**
     * Determines if program structure is upto date or needs to be recreated
     */
    /* @internal */
    function isProgramUptoDate(program, rootFileNames, newOptions, getSourceVersion, fileExists, hasInvalidatedResolution, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences) {
        // If we haven't created a program yet or have changed automatic type directives, then it is not up-to-date
        if (!program || (hasChangedAutomaticTypeDirectiveNames === null || hasChangedAutomaticTypeDirectiveNames === void 0 ? void 0 : hasChangedAutomaticTypeDirectiveNames()))
            return false;
        // If root file names don't match
        if (!ts.arrayIsEqualTo(program.getRootFileNames(), rootFileNames))
            return false;
        var seenResolvedRefs;
        // If project references don't match
        if (!ts.arrayIsEqualTo(program.getProjectReferences(), projectReferences, projectReferenceUptoDate))
            return false;
        // If any file is not up-to-date, then the whole program is not up-to-date
        if (program.getSourceFiles().some(sourceFileNotUptoDate))
            return false;
        // If any of the missing file paths are now created
        if (program.getMissingFilePaths().some(fileExists))
            return false;
        var currentOptions = program.getCompilerOptions();
        // If the compilation settings do no match, then the program is not up-to-date
        if (!ts.compareDataObjects(currentOptions, newOptions))
            return false;
        // If everything matches but the text of config file is changed,
        // error locations can change for program options, so update the program
        if (currentOptions.configFile && newOptions.configFile)
            return currentOptions.configFile.text === newOptions.configFile.text;
        return true;
        function sourceFileNotUptoDate(sourceFile) {
            return !sourceFileVersionUptoDate(sourceFile) ||
                hasInvalidatedResolution(sourceFile.path);
        }
        function sourceFileVersionUptoDate(sourceFile) {
            return sourceFile.version === getSourceVersion(sourceFile.resolvedPath, sourceFile.fileName);
        }
        function projectReferenceUptoDate(oldRef, newRef, index) {
            return ts.projectReferenceIsEqualTo(oldRef, newRef) &&
                resolvedProjectReferenceUptoDate(program.getResolvedProjectReferences()[index], oldRef);
        }
        function resolvedProjectReferenceUptoDate(oldResolvedRef, oldRef) {
            if (oldResolvedRef) {
                // Assume true
                if (ts.contains(seenResolvedRefs, oldResolvedRef))
                    return true;
                var refPath_1 = resolveProjectReferencePath(oldRef);
                var newParsedCommandLine = getParsedCommandLine(refPath_1);
                // Check if config file exists
                if (!newParsedCommandLine)
                    return false;
                // If change in source file
                if (oldResolvedRef.commandLine.options.configFile !== newParsedCommandLine.options.configFile)
                    return false;
                // check file names
                if (!ts.arrayIsEqualTo(oldResolvedRef.commandLine.fileNames, newParsedCommandLine.fileNames))
                    return false;
                // Add to seen before checking the referenced paths of this config file
                (seenResolvedRefs || (seenResolvedRefs = [])).push(oldResolvedRef);
                // If child project references are upto date, this project reference is uptodate
                return !ts.forEach(oldResolvedRef.references, function (childResolvedRef, index) {
                    return !resolvedProjectReferenceUptoDate(childResolvedRef, oldResolvedRef.commandLine.projectReferences[index]);
                });
            }
            // In old program, not able to resolve project reference path,
            // so if config file doesnt exist, it is uptodate.
            var refPath = resolveProjectReferencePath(oldRef);
            return !getParsedCommandLine(refPath);
        }
    }
    ts.isProgramUptoDate = isProgramUptoDate;
    function getConfigFileParsingDiagnostics(configFileParseResult) {
        return configFileParseResult.options.configFile ? __spreadArray(__spreadArray([], configFileParseResult.options.configFile.parseDiagnostics, true), configFileParseResult.errors, true) :
            configFileParseResult.errors;
    }
    ts.getConfigFileParsingDiagnostics = getConfigFileParsingDiagnostics;
    /**
     * A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the
     * `options` parameter.
     *
     * @param fileName The normalized absolute path to check the format of (it need not exist on disk)
     * @param [packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often
     * @param host The ModuleResolutionHost which can perform the filesystem lookups for package json data
     * @param options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`
     * @returns `undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format
     */
    function getImpliedNodeFormatForFile(fileName, packageJsonInfoCache, host, options) {
        switch (ts.getEmitModuleResolutionKind(options)) {
            case ts.ModuleResolutionKind.Node16:
            case ts.ModuleResolutionKind.NodeNext:
                return ts.fileExtensionIsOneOf(fileName, [".d.mts" /* Extension.Dmts */, ".mts" /* Extension.Mts */, ".mjs" /* Extension.Mjs */]) ? ts.ModuleKind.ESNext :
                    ts.fileExtensionIsOneOf(fileName, [".d.cts" /* Extension.Dcts */, ".cts" /* Extension.Cts */, ".cjs" /* Extension.Cjs */]) ? ts.ModuleKind.CommonJS :
                        ts.fileExtensionIsOneOf(fileName, [".d.ts" /* Extension.Dts */, ".ts" /* Extension.Ts */, ".tsx" /* Extension.Tsx */, ".js" /* Extension.Js */, ".jsx" /* Extension.Jsx */]) ? lookupFromPackageJson() :
                            undefined; // other extensions, like `json` or `tsbuildinfo`, are set as `undefined` here but they should never be fed through the transformer pipeline
            default:
                return undefined;
        }
        function lookupFromPackageJson() {
            var scope = ts.getPackageScopeForPath(fileName, packageJsonInfoCache, host, options);
            return (scope === null || scope === void 0 ? void 0 : scope.packageJsonContent.type) === "module" ? ts.ModuleKind.ESNext : ts.ModuleKind.CommonJS;
        }
    }
    ts.getImpliedNodeFormatForFile = getImpliedNodeFormatForFile;
    /** @internal */
    ts.plainJSErrors = new ts.Set([
        // binder errors
        ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0.code,
        ts.Diagnostics.A_module_cannot_have_multiple_default_exports.code,
        ts.Diagnostics.Another_export_default_is_here.code,
        ts.Diagnostics.The_first_export_default_is_here.code,
        ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module.code,
        ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode.code,
        ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here.code,
        ts.Diagnostics.constructor_is_a_reserved_word.code,
        ts.Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode.code,
        ts.Diagnostics.Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode.code,
        ts.Diagnostics.Invalid_use_of_0_Modules_are_automatically_in_strict_mode.code,
        ts.Diagnostics.Invalid_use_of_0_in_strict_mode.code,
        ts.Diagnostics.A_label_is_not_allowed_here.code,
        ts.Diagnostics.Octal_literals_are_not_allowed_in_strict_mode.code,
        ts.Diagnostics.with_statements_are_not_allowed_in_strict_mode.code,
        // grammar errors
        ts.Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement.code,
        ts.Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement.code,
        ts.Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name.code,
        ts.Diagnostics.A_class_member_cannot_have_the_0_keyword.code,
        ts.Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name.code,
        ts.Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement.code,
        ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement.code,
        ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement.code,
        ts.Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement.code,
        ts.Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration.code,
        ts.Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context.code,
        ts.Diagnostics.A_destructuring_declaration_must_have_an_initializer.code,
        ts.Diagnostics.A_get_accessor_cannot_have_parameters.code,
        ts.Diagnostics.A_rest_element_cannot_contain_a_binding_pattern.code,
        ts.Diagnostics.A_rest_element_cannot_have_a_property_name.code,
        ts.Diagnostics.A_rest_element_cannot_have_an_initializer.code,
        ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern.code,
        ts.Diagnostics.A_rest_parameter_cannot_have_an_initializer.code,
        ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list.code,
        ts.Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma.code,
        ts.Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block.code,
        ts.Diagnostics.A_set_accessor_cannot_have_rest_parameter.code,
        ts.Diagnostics.A_set_accessor_must_have_exactly_one_parameter.code,
        ts.Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module.code,
        ts.Diagnostics.An_export_declaration_cannot_have_modifiers.code,
        ts.Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module.code,
        ts.Diagnostics.An_import_declaration_cannot_have_modifiers.code,
        ts.Diagnostics.An_object_member_cannot_be_declared_optional.code,
        ts.Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element.code,
        ts.Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable.code,
        ts.Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause.code,
        ts.Diagnostics.Catch_clause_variable_cannot_have_an_initializer.code,
        ts.Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator.code,
        ts.Diagnostics.Classes_can_only_extend_a_single_class.code,
        ts.Diagnostics.Classes_may_not_have_a_field_named_constructor.code,
        ts.Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern.code,
        ts.Diagnostics.Duplicate_label_0.code,
        ts.Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments.code,
        ts.Diagnostics.For_await_loops_cannot_be_used_inside_a_class_static_block.code,
        ts.Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression.code,
        ts.Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name.code,
        ts.Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array.code,
        ts.Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names.code,
        ts.Diagnostics.Jump_target_cannot_cross_function_boundary.code,
        ts.Diagnostics.Line_terminator_not_permitted_before_arrow.code,
        ts.Diagnostics.Modifiers_cannot_appear_here.code,
        ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement.code,
        ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement.code,
        ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies.code,
        ts.Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression.code,
        ts.Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier.code,
        ts.Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain.code,
        ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async.code,
        ts.Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer.code,
        ts.Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer.code,
        ts.Diagnostics.Trailing_comma_not_allowed.code,
        ts.Diagnostics.Variable_declaration_list_cannot_be_empty.code,
        ts.Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses.code,
        ts.Diagnostics._0_expected.code,
        ts.Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2.code,
        ts.Diagnostics._0_list_cannot_be_empty.code,
        ts.Diagnostics._0_modifier_already_seen.code,
        ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration.code,
        ts.Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element.code,
        ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter.code,
        ts.Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind.code,
        ts.Diagnostics._0_modifier_cannot_be_used_here.code,
        ts.Diagnostics._0_modifier_must_precede_1_modifier.code,
        ts.Diagnostics.const_declarations_can_only_be_declared_inside_a_block.code,
        ts.Diagnostics.const_declarations_must_be_initialized.code,
        ts.Diagnostics.extends_clause_already_seen.code,
        ts.Diagnostics.let_declarations_can_only_be_declared_inside_a_block.code,
        ts.Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations.code,
    ]);
    /**
     * Determine if source file needs to be re-created even if its text hasn't changed
     */
    function shouldProgramCreateNewSourceFiles(program, newOptions) {
        if (!program)
            return false;
        // If any compiler options change, we can't reuse old source file even if version match
        // The change in options like these could result in change in syntax tree or `sourceFile.bindDiagnostics`.
        return ts.optionsHaveChanges(program.getCompilerOptions(), newOptions, ts.sourceFileAffectingCompilerOptions);
    }
    function createCreateProgramOptions(rootNames, options, host, oldProgram, configFileParsingDiagnostics) {
        return {
            rootNames: rootNames,
            options: options,
            host: host,
            oldProgram: oldProgram,
            configFileParsingDiagnostics: configFileParsingDiagnostics
        };
    }
    function createProgram(rootNamesOrOptions, _options, _host, _oldProgram, _configFileParsingDiagnostics) {
        var _a, _b, _c, _d;
        var createProgramOptions = ts.isArray(rootNamesOrOptions) ? createCreateProgramOptions(rootNamesOrOptions, _options, _host, _oldProgram, _configFileParsingDiagnostics) : rootNamesOrOptions; // TODO: GH#18217
        var rootNames = createProgramOptions.rootNames, options = createProgramOptions.options, configFileParsingDiagnostics = createProgramOptions.configFileParsingDiagnostics, projectReferences = createProgramOptions.projectReferences;
        var oldProgram = createProgramOptions.oldProgram;
        var processingDefaultLibFiles;
        var processingOtherFiles;
        var files;
        var symlinks;
        var commonSourceDirectory;
        var typeChecker;
        var classifiableNames;
        var ambientModuleNameToUnmodifiedFileName = new ts.Map();
        var fileReasons = ts.createMultiMap();
        var cachedBindAndCheckDiagnosticsForFile = {};
        var cachedDeclarationDiagnosticsForFile = {};
        var resolvedTypeReferenceDirectives = ts.createModeAwareCache();
        var fileProcessingDiagnostics;
        // The below settings are to track if a .js file should be add to the program if loaded via searching under node_modules.
        // This works as imported modules are discovered recursively in a depth first manner, specifically:
        // - For each root file, findSourceFile is called.
        // - This calls processImportedModules for each module imported in the source file.
        // - This calls resolveModuleNames, and then calls findSourceFile for each resolved module.
        // As all these operations happen - and are nested - within the createProgram call, they close over the below variables.
        // The current resolution depth is tracked by incrementing/decrementing as the depth first search progresses.
        var maxNodeModuleJsDepth = typeof options.maxNodeModuleJsDepth === "number" ? options.maxNodeModuleJsDepth : 0;
        var currentNodeModulesDepth = 0;
        // If a module has some of its imports skipped due to being at the depth limit under node_modules, then track
        // this, as it may be imported at a shallower depth later, and then it will need its skipped imports processed.
        var modulesWithElidedImports = new ts.Map();
        // Track source files that are source files found by searching under node_modules, as these shouldn't be compiled.
        var sourceFilesFoundSearchingNodeModules = new ts.Map();
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "createProgram", { configFilePath: options.configFilePath, rootDir: options.rootDir }, /*separateBeginAndEnd*/ true);
        ts.performance.mark("beforeProgram");
        var host = createProgramOptions.host || createCompilerHost(options);
        var configParsingHost = parseConfigHostFromCompilerHostLike(host);
        var skipDefaultLib = options.noLib;
        var getDefaultLibraryFileName = ts.memoize(function () { return host.getDefaultLibFileName(options); });
        var defaultLibraryPath = host.getDefaultLibLocation ? host.getDefaultLibLocation() : ts.getDirectoryPath(getDefaultLibraryFileName());
        var programDiagnostics = ts.createDiagnosticCollection();
        var currentDirectory = host.getCurrentDirectory();
        var supportedExtensions = ts.getSupportedExtensions(options);
        var supportedExtensionsWithJsonIfResolveJsonModule = ts.getSupportedExtensionsWithJsonIfResolveJsonModule(options, supportedExtensions);
        // Map storing if there is emit blocking diagnostics for given input
        var hasEmitBlockingDiagnostics = new ts.Map();
        var _compilerOptionsObjectLiteralSyntax;
        var moduleResolutionCache;
        var typeReferenceDirectiveResolutionCache;
        var actualResolveModuleNamesWorker;
        var hasInvalidatedResolution = host.hasInvalidatedResolution || ts.returnFalse;
        if (host.resolveModuleNames) {
            actualResolveModuleNamesWorker = function (moduleNames, containingFile, containingFileName, reusedNames, redirectedReference) { return host.resolveModuleNames(ts.Debug.checkEachDefined(moduleNames), containingFileName, reusedNames, redirectedReference, options, containingFile).map(function (resolved) {
                // An older host may have omitted extension, in which case we should infer it from the file extension of resolvedFileName.
                if (!resolved || resolved.extension !== undefined) {
                    return resolved;
                }
                var withExtension = ts.clone(resolved);
                withExtension.extension = ts.extensionFromPath(resolved.resolvedFileName);
                return withExtension;
            }); };
            moduleResolutionCache = (_a = host.getModuleResolutionCache) === null || _a === void 0 ? void 0 : _a.call(host);
        }
        else {
            moduleResolutionCache = ts.createModuleResolutionCache(currentDirectory, getCanonicalFileName, options);
            var loader_1 = function (moduleName, resolverMode, containingFileName, redirectedReference) { return ts.resolveModuleName(moduleName, containingFileName, options, host, moduleResolutionCache, redirectedReference, resolverMode).resolvedModule; }; // TODO: GH#18217
            actualResolveModuleNamesWorker = function (moduleNames, containingFile, containingFileName, _reusedNames, redirectedReference) { return loadWithModeAwareCache(ts.Debug.checkEachDefined(moduleNames), containingFile, containingFileName, redirectedReference, loader_1); };
        }
        var actualResolveTypeReferenceDirectiveNamesWorker;
        if (host.resolveTypeReferenceDirectives) {
            actualResolveTypeReferenceDirectiveNamesWorker = function (typeDirectiveNames, containingFile, redirectedReference, containingFileMode) { return host.resolveTypeReferenceDirectives(ts.Debug.checkEachDefined(typeDirectiveNames), containingFile, redirectedReference, options, containingFileMode); };
        }
        else {
            typeReferenceDirectiveResolutionCache = ts.createTypeReferenceDirectiveResolutionCache(currentDirectory, getCanonicalFileName, /*options*/ undefined, moduleResolutionCache === null || moduleResolutionCache === void 0 ? void 0 : moduleResolutionCache.getPackageJsonInfoCache());
            var loader_2 = function (typesRef, containingFile, redirectedReference, resolutionMode) { return ts.resolveTypeReferenceDirective(typesRef, containingFile, options, host, redirectedReference, typeReferenceDirectiveResolutionCache, resolutionMode).resolvedTypeReferenceDirective; }; // TODO: GH#18217
            actualResolveTypeReferenceDirectiveNamesWorker = function (typeReferenceDirectiveNames, containingFile, redirectedReference, containingFileMode) { return loadWithTypeDirectiveCache(ts.Debug.checkEachDefined(typeReferenceDirectiveNames), containingFile, redirectedReference, containingFileMode, loader_2); };
        }
        // Map from a stringified PackageId to the source file with that id.
        // Only one source file may have a given packageId. Others become redirects (see createRedirectSourceFile).
        // `packageIdToSourceFile` is only used while building the program, while `sourceFileToPackageName` and `isSourceFileTargetOfRedirect` are kept around.
        var packageIdToSourceFile = new ts.Map();
        // Maps from a SourceFile's `.path` to the name of the package it was imported with.
        var sourceFileToPackageName = new ts.Map();
        // Key is a file name. Value is the (non-empty, or undefined) list of files that redirect to it.
        var redirectTargetsMap = ts.createMultiMap();
        var usesUriStyleNodeCoreModules = false;
        /**
         * map with
         * - SourceFile if present
         * - false if sourceFile missing for source of project reference redirect
         * - undefined otherwise
         */
        var filesByName = new ts.Map();
        var missingFilePaths;
        // stores 'filename -> file association' ignoring case
        // used to track cases when two file names differ only in casing
        var filesByNameIgnoreCase = host.useCaseSensitiveFileNames() ? new ts.Map() : undefined;
        // A parallel array to projectReferences storing the results of reading in the referenced tsconfig files
        var resolvedProjectReferences;
        var projectReferenceRedirects;
        var mapFromFileToProjectReferenceRedirects;
        var mapFromToProjectReferenceRedirectSource;
        var useSourceOfProjectReferenceRedirect = !!((_b = host.useSourceOfProjectReferenceRedirect) === null || _b === void 0 ? void 0 : _b.call(host)) &&
            !options.disableSourceOfProjectReferenceRedirect;
        var _e = updateHostForUseSourceOfProjectReferenceRedirect({
            compilerHost: host,
            getSymlinkCache: getSymlinkCache,
            useSourceOfProjectReferenceRedirect: useSourceOfProjectReferenceRedirect,
            toPath: toPath,
            getResolvedProjectReferences: getResolvedProjectReferences,
            getSourceOfProjectReferenceRedirect: getSourceOfProjectReferenceRedirect,
            forEachResolvedProjectReference: forEachResolvedProjectReference
        }), onProgramCreateComplete = _e.onProgramCreateComplete, fileExists = _e.fileExists, directoryExists = _e.directoryExists;
        var readFile = host.readFile.bind(host);
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "shouldProgramCreateNewSourceFiles", { hasOldProgram: !!oldProgram });
        var shouldCreateNewSourceFile = shouldProgramCreateNewSourceFiles(oldProgram, options);
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        // We set `structuralIsReused` to `undefined` because `tryReuseStructureFromOldProgram` calls `tryReuseStructureFromOldProgram` which checks
        // `structuralIsReused`, which would be a TDZ violation if it was not set in advance to `undefined`.
        var structureIsReused;
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "tryReuseStructureFromOldProgram", {});
        structureIsReused = tryReuseStructureFromOldProgram(); // eslint-disable-line prefer-const
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        if (structureIsReused !== 2 /* StructureIsReused.Completely */) {
            processingDefaultLibFiles = [];
            processingOtherFiles = [];
            if (projectReferences) {
                if (!resolvedProjectReferences) {
                    resolvedProjectReferences = projectReferences.map(parseProjectReferenceConfigFile);
                }
                if (rootNames.length) {
                    resolvedProjectReferences === null || resolvedProjectReferences === void 0 ? void 0 : resolvedProjectReferences.forEach(function (parsedRef, index) {
                        if (!parsedRef)
                            return;
                        var out = ts.outFile(parsedRef.commandLine.options);
                        if (useSourceOfProjectReferenceRedirect) {
                            if (out || ts.getEmitModuleKind(parsedRef.commandLine.options) === ts.ModuleKind.None) {
                                for (var _i = 0, _a = parsedRef.commandLine.fileNames; _i < _a.length; _i++) {
                                    var fileName = _a[_i];
                                    processProjectReferenceFile(fileName, { kind: ts.FileIncludeKind.SourceFromProjectReference, index: index });
                                }
                            }
                        }
                        else {
                            if (out) {
                                processProjectReferenceFile(ts.changeExtension(out, ".d.ts"), { kind: ts.FileIncludeKind.OutputFromProjectReference, index: index });
                            }
                            else if (ts.getEmitModuleKind(parsedRef.commandLine.options) === ts.ModuleKind.None) {
                                var getCommonSourceDirectory_2 = ts.memoize(function () { return ts.getCommonSourceDirectoryOfConfig(parsedRef.commandLine, !host.useCaseSensitiveFileNames()); });
                                for (var _b = 0, _c = parsedRef.commandLine.fileNames; _b < _c.length; _b++) {
                                    var fileName = _c[_b];
                                    if (!ts.isDeclarationFileName(fileName) && !ts.fileExtensionIs(fileName, ".json" /* Extension.Json */)) {
                                        processProjectReferenceFile(ts.getOutputDeclarationFileName(fileName, parsedRef.commandLine, !host.useCaseSensitiveFileNames(), getCommonSourceDirectory_2), { kind: ts.FileIncludeKind.OutputFromProjectReference, index: index });
                                    }
                                }
                            }
                        }
                    });
                }
            }
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "processRootFiles", { count: rootNames.length });
            ts.forEach(rootNames, function (name, index) { return processRootFile(name, /*isDefaultLib*/ false, /*ignoreNoDefaultLib*/ false, { kind: ts.FileIncludeKind.RootFile, index: index }); });
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            // load type declarations specified via 'types' argument or implicitly from types/ and node_modules/@types folders
            var typeReferences = rootNames.length ? ts.getAutomaticTypeDirectiveNames(options, host) : ts.emptyArray;
            if (typeReferences.length) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "processTypeReferences", { count: typeReferences.length });
                // This containingFilename needs to match with the one used in managed-side
                var containingDirectory = options.configFilePath ? ts.getDirectoryPath(options.configFilePath) : host.getCurrentDirectory();
                var containingFilename = ts.combinePaths(containingDirectory, ts.inferredTypesContainingFile);
                var resolutions = resolveTypeReferenceDirectiveNamesWorker(typeReferences, containingFilename);
                for (var i = 0; i < typeReferences.length; i++) {
                    // under node16/nodenext module resolution, load `types`/ata include names as cjs resolution results by passing an `undefined` mode
                    processTypeReferenceDirective(typeReferences[i], /*mode*/ undefined, resolutions[i], { kind: ts.FileIncludeKind.AutomaticTypeDirectiveFile, typeReference: typeReferences[i], packageId: (_c = resolutions[i]) === null || _c === void 0 ? void 0 : _c.packageId });
                }
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            }
            // Do not process the default library if:
            //  - The '--noLib' flag is used.
            //  - A 'no-default-lib' reference comment is encountered in
            //      processing the root files.
            if (rootNames.length && !skipDefaultLib) {
                // If '--lib' is not specified, include default library file according to '--target'
                // otherwise, using options specified in '--lib' instead of '--target' default library file
                var defaultLibraryFileName = getDefaultLibraryFileName();
                if (!options.lib && defaultLibraryFileName) {
                    processRootFile(defaultLibraryFileName, /*isDefaultLib*/ true, /*ignoreNoDefaultLib*/ false, { kind: ts.FileIncludeKind.LibFile });
                }
                else {
                    ts.forEach(options.lib, function (libFileName, index) {
                        processRootFile(pathForLibFile(libFileName), /*isDefaultLib*/ true, /*ignoreNoDefaultLib*/ false, { kind: ts.FileIncludeKind.LibFile, index: index });
                    });
                }
            }
            missingFilePaths = ts.arrayFrom(ts.mapDefinedIterator(filesByName.entries(), function (_a) {
                var path = _a[0], file = _a[1];
                return file === undefined ? path : undefined;
            }));
            files = ts.stableSort(processingDefaultLibFiles, compareDefaultLibFiles).concat(processingOtherFiles);
            processingDefaultLibFiles = undefined;
            processingOtherFiles = undefined;
        }
        ts.Debug.assert(!!missingFilePaths);
        // Release any files we have acquired in the old program but are
        // not part of the new program.
        if (oldProgram && host.onReleaseOldSourceFile) {
            var oldSourceFiles = oldProgram.getSourceFiles();
            for (var _i = 0, oldSourceFiles_1 = oldSourceFiles; _i < oldSourceFiles_1.length; _i++) {
                var oldSourceFile = oldSourceFiles_1[_i];
                var newFile = getSourceFileByPath(oldSourceFile.resolvedPath);
                if (shouldCreateNewSourceFile || !newFile ||
                    // old file wasn't redirect but new file is
                    (oldSourceFile.resolvedPath === oldSourceFile.path && newFile.resolvedPath !== oldSourceFile.path)) {
                    host.onReleaseOldSourceFile(oldSourceFile, oldProgram.getCompilerOptions(), !!getSourceFileByPath(oldSourceFile.path));
                }
            }
            if (!host.getParsedCommandLine) {
                oldProgram.forEachResolvedProjectReference(function (resolvedProjectReference) {
                    if (!getResolvedProjectReferenceByPath(resolvedProjectReference.sourceFile.path)) {
                        host.onReleaseOldSourceFile(resolvedProjectReference.sourceFile, oldProgram.getCompilerOptions(), /*hasSourceFileByPath*/ false);
                    }
                });
            }
        }
        // Release commandlines that new program does not use
        if (oldProgram && host.onReleaseParsedCommandLine) {
            forEachProjectReference(oldProgram.getProjectReferences(), oldProgram.getResolvedProjectReferences(), function (oldResolvedRef, parent, index) {
                var oldReference = (parent === null || parent === void 0 ? void 0 : parent.commandLine.projectReferences[index]) || oldProgram.getProjectReferences()[index];
                var oldRefPath = resolveProjectReferencePath(oldReference);
                if (!(projectReferenceRedirects === null || projectReferenceRedirects === void 0 ? void 0 : projectReferenceRedirects.has(toPath(oldRefPath)))) {
                    host.onReleaseParsedCommandLine(oldRefPath, oldResolvedRef, oldProgram.getCompilerOptions());
                }
            });
        }
        typeReferenceDirectiveResolutionCache = undefined;
        // unconditionally set oldProgram to undefined to prevent it from being captured in closure
        oldProgram = undefined;
        var program = {
            getRootFileNames: function () { return rootNames; },
            getSourceFile: getSourceFile,
            getSourceFileByPath: getSourceFileByPath,
            getSourceFiles: function () { return files; },
            getMissingFilePaths: function () { return missingFilePaths; },
            getModuleResolutionCache: function () { return moduleResolutionCache; },
            getFilesByNameMap: function () { return filesByName; },
            getCompilerOptions: function () { return options; },
            getSyntacticDiagnostics: getSyntacticDiagnostics,
            getOptionsDiagnostics: getOptionsDiagnostics,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getSemanticDiagnostics: getSemanticDiagnostics,
            getCachedSemanticDiagnostics: getCachedSemanticDiagnostics,
            getSuggestionDiagnostics: getSuggestionDiagnostics,
            getDeclarationDiagnostics: getDeclarationDiagnostics,
            getBindAndCheckDiagnostics: getBindAndCheckDiagnostics,
            getProgramDiagnostics: getProgramDiagnostics,
            getTypeChecker: getTypeChecker,
            getClassifiableNames: getClassifiableNames,
            getCommonSourceDirectory: getCommonSourceDirectory,
            emit: emit,
            getCurrentDirectory: function () { return currentDirectory; },
            getNodeCount: function () { return getTypeChecker().getNodeCount(); },
            getIdentifierCount: function () { return getTypeChecker().getIdentifierCount(); },
            getSymbolCount: function () { return getTypeChecker().getSymbolCount(); },
            getTypeCount: function () { return getTypeChecker().getTypeCount(); },
            getInstantiationCount: function () { return getTypeChecker().getInstantiationCount(); },
            getRelationCacheSizes: function () { return getTypeChecker().getRelationCacheSizes(); },
            getFileProcessingDiagnostics: function () { return fileProcessingDiagnostics; },
            getResolvedTypeReferenceDirectives: function () { return resolvedTypeReferenceDirectives; },
            isSourceFileFromExternalLibrary: isSourceFileFromExternalLibrary,
            isSourceFileDefaultLibrary: isSourceFileDefaultLibrary,
            getSourceFileFromReference: getSourceFileFromReference,
            getLibFileFromReference: getLibFileFromReference,
            sourceFileToPackageName: sourceFileToPackageName,
            redirectTargetsMap: redirectTargetsMap,
            usesUriStyleNodeCoreModules: usesUriStyleNodeCoreModules,
            isEmittedFile: isEmittedFile,
            getConfigFileParsingDiagnostics: getConfigFileParsingDiagnostics,
            getResolvedModuleWithFailedLookupLocationsFromCache: getResolvedModuleWithFailedLookupLocationsFromCache,
            getProjectReferences: getProjectReferences,
            getResolvedProjectReferences: getResolvedProjectReferences,
            getProjectReferenceRedirect: getProjectReferenceRedirect,
            getResolvedProjectReferenceToRedirect: getResolvedProjectReferenceToRedirect,
            getResolvedProjectReferenceByPath: getResolvedProjectReferenceByPath,
            forEachResolvedProjectReference: forEachResolvedProjectReference,
            isSourceOfProjectReferenceRedirect: isSourceOfProjectReferenceRedirect,
            emitBuildInfo: emitBuildInfo,
            fileExists: fileExists,
            readFile: readFile,
            directoryExists: directoryExists,
            getSymlinkCache: getSymlinkCache,
            realpath: (_d = host.realpath) === null || _d === void 0 ? void 0 : _d.bind(host),
            useCaseSensitiveFileNames: function () { return host.useCaseSensitiveFileNames(); },
            getFileIncludeReasons: function () { return fileReasons; },
            structureIsReused: structureIsReused,
            writeFile: writeFile,
        };
        onProgramCreateComplete();
        // Add file processingDiagnostics
        fileProcessingDiagnostics === null || fileProcessingDiagnostics === void 0 ? void 0 : fileProcessingDiagnostics.forEach(function (diagnostic) {
            switch (diagnostic.kind) {
                case 1 /* FilePreprocessingDiagnosticsKind.FilePreprocessingFileExplainingDiagnostic */:
                    return programDiagnostics.add(createDiagnosticExplainingFile(diagnostic.file && getSourceFileByPath(diagnostic.file), diagnostic.fileProcessingReason, diagnostic.diagnostic, diagnostic.args || ts.emptyArray));
                case 0 /* FilePreprocessingDiagnosticsKind.FilePreprocessingReferencedDiagnostic */:
                    var _a = getReferencedFileLocation(getSourceFileByPath, diagnostic.reason), file = _a.file, pos = _a.pos, end = _a.end;
                    return programDiagnostics.add(ts.createFileDiagnostic.apply(void 0, __spreadArray([file, ts.Debug.checkDefined(pos), ts.Debug.checkDefined(end) - pos, diagnostic.diagnostic], diagnostic.args || ts.emptyArray, false)));
                default:
                    ts.Debug.assertNever(diagnostic);
            }
        });
        verifyCompilerOptions();
        ts.performance.mark("afterProgram");
        ts.performance.measure("Program", "beforeProgram", "afterProgram");
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        return program;
        function addResolutionDiagnostics(list) {
            if (!list)
                return;
            for (var _i = 0, list_3 = list; _i < list_3.length; _i++) {
                var elem = list_3[_i];
                programDiagnostics.add(elem);
            }
        }
        function pullDiagnosticsFromCache(names, containingFile) {
            var _a;
            if (!moduleResolutionCache)
                return;
            var containingFileName = ts.getNormalizedAbsolutePath(containingFile.originalFileName, currentDirectory);
            var containingFileMode = !ts.isString(containingFile) ? containingFile.impliedNodeFormat : undefined;
            var containingDir = ts.getDirectoryPath(containingFileName);
            var redirectedReference = getRedirectReferenceForResolution(containingFile);
            var i = 0;
            for (var _i = 0, names_4 = names; _i < names_4.length; _i++) {
                var n = names_4[_i];
                // mimics logic done in the resolution cache, should be resilient to upgrading it to use `FileReference`s for non-type-reference modal lookups to make it rely on the index in the list less
                var mode = typeof n === "string" ? getModeForResolutionAtIndex(containingFile, i) : getModeForFileReference(n, containingFileMode);
                var name = typeof n === "string" ? n : n.fileName;
                i++;
                // only nonrelative names hit the cache, and, at least as of right now, only nonrelative names can issue diagnostics
                // (Since diagnostics are only issued via import or export map lookup)
                // This may totally change if/when the issue of output paths not mapping to input files is fixed in a broader context
                // When it is, how we extract diagnostics from the module name resolver will have the be refined - the current cache
                // APIs wrapping the underlying resolver make it almost impossible to smuggle the diagnostics out in a generalized way
                if (ts.isExternalModuleNameRelative(name))
                    continue;
                var diags = (_a = moduleResolutionCache.getOrCreateCacheForModuleName(name, mode, redirectedReference).get(containingDir)) === null || _a === void 0 ? void 0 : _a.resolutionDiagnostics;
                addResolutionDiagnostics(diags);
            }
        }
        function resolveModuleNamesWorker(moduleNames, containingFile, reusedNames) {
            if (!moduleNames.length)
                return ts.emptyArray;
            var containingFileName = ts.getNormalizedAbsolutePath(containingFile.originalFileName, currentDirectory);
            var redirectedReference = getRedirectReferenceForResolution(containingFile);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "resolveModuleNamesWorker", { containingFileName: containingFileName });
            ts.performance.mark("beforeResolveModule");
            var result = actualResolveModuleNamesWorker(moduleNames, containingFile, containingFileName, reusedNames, redirectedReference);
            ts.performance.mark("afterResolveModule");
            ts.performance.measure("ResolveModule", "beforeResolveModule", "afterResolveModule");
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            pullDiagnosticsFromCache(moduleNames, containingFile);
            return result;
        }
        function resolveTypeReferenceDirectiveNamesWorker(typeDirectiveNames, containingFile) {
            if (!typeDirectiveNames.length)
                return [];
            var containingFileName = !ts.isString(containingFile) ? ts.getNormalizedAbsolutePath(containingFile.originalFileName, currentDirectory) : containingFile;
            var redirectedReference = !ts.isString(containingFile) ? getRedirectReferenceForResolution(containingFile) : undefined;
            var containingFileMode = !ts.isString(containingFile) ? containingFile.impliedNodeFormat : undefined;
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "resolveTypeReferenceDirectiveNamesWorker", { containingFileName: containingFileName });
            ts.performance.mark("beforeResolveTypeReference");
            var result = actualResolveTypeReferenceDirectiveNamesWorker(typeDirectiveNames, containingFileName, redirectedReference, containingFileMode);
            ts.performance.mark("afterResolveTypeReference");
            ts.performance.measure("ResolveTypeReference", "beforeResolveTypeReference", "afterResolveTypeReference");
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            return result;
        }
        function getRedirectReferenceForResolution(file) {
            var redirect = getResolvedProjectReferenceToRedirect(file.originalFileName);
            if (redirect || !ts.isDeclarationFileName(file.originalFileName))
                return redirect;
            // The originalFileName could not be actual source file name if file found was d.ts from referecned project
            // So in this case try to look up if this is output from referenced project, if it is use the redirected project in that case
            var resultFromDts = getRedirectReferenceForResolutionFromSourceOfProject(file.path);
            if (resultFromDts)
                return resultFromDts;
            // If preserveSymlinks is true, module resolution wont jump the symlink
            // but the resolved real path may be the .d.ts from project reference
            // Note:: Currently we try the real path only if the
            // file is from node_modules to avoid having to run real path on all file paths
            if (!host.realpath || !options.preserveSymlinks || !ts.stringContains(file.originalFileName, ts.nodeModulesPathPart))
                return undefined;
            var realDeclarationPath = toPath(host.realpath(file.originalFileName));
            return realDeclarationPath === file.path ? undefined : getRedirectReferenceForResolutionFromSourceOfProject(realDeclarationPath);
        }
        function getRedirectReferenceForResolutionFromSourceOfProject(filePath) {
            var source = getSourceOfProjectReferenceRedirect(filePath);
            if (ts.isString(source))
                return getResolvedProjectReferenceToRedirect(source);
            if (!source)
                return undefined;
            // Output of .d.ts file so return resolved ref that matches the out file name
            return forEachResolvedProjectReference(function (resolvedRef) {
                var out = ts.outFile(resolvedRef.commandLine.options);
                if (!out)
                    return undefined;
                return toPath(out) === filePath ? resolvedRef : undefined;
            });
        }
        function compareDefaultLibFiles(a, b) {
            return ts.compareValues(getDefaultLibFilePriority(a), getDefaultLibFilePriority(b));
        }
        function getDefaultLibFilePriority(a) {
            if (ts.containsPath(defaultLibraryPath, a.fileName, /*ignoreCase*/ false)) {
                var basename = ts.getBaseFileName(a.fileName);
                if (basename === "lib.d.ts" || basename === "lib.es6.d.ts")
                    return 0;
                var name = ts.removeSuffix(ts.removePrefix(basename, "lib."), ".d.ts");
                var index = ts.libs.indexOf(name);
                if (index !== -1)
                    return index + 1;
            }
            return ts.libs.length + 2;
        }
        function getResolvedModuleWithFailedLookupLocationsFromCache(moduleName, containingFile, mode) {
            return moduleResolutionCache && ts.resolveModuleNameFromCache(moduleName, containingFile, moduleResolutionCache, mode);
        }
        function toPath(fileName) {
            return ts.toPath(fileName, currentDirectory, getCanonicalFileName);
        }
        function getCommonSourceDirectory() {
            if (commonSourceDirectory === undefined) {
                var emittedFiles_1 = ts.filter(files, function (file) { return ts.sourceFileMayBeEmitted(file, program); });
                commonSourceDirectory = ts.getCommonSourceDirectory(options, function () { return ts.mapDefined(emittedFiles_1, function (file) { return file.isDeclarationFile ? undefined : file.fileName; }); }, currentDirectory, getCanonicalFileName, function (commonSourceDirectory) { return checkSourceFilesBelongToPath(emittedFiles_1, commonSourceDirectory); });
            }
            return commonSourceDirectory;
        }
        function getClassifiableNames() {
            var _a;
            if (!classifiableNames) {
                // Initialize a checker so that all our files are bound.
                getTypeChecker();
                classifiableNames = new ts.Set();
                for (var _i = 0, files_3 = files; _i < files_3.length; _i++) {
                    var sourceFile = files_3[_i];
                    (_a = sourceFile.classifiableNames) === null || _a === void 0 ? void 0 : _a.forEach(function (value) { return classifiableNames.add(value); });
                }
            }
            return classifiableNames;
        }
        function resolveModuleNamesReusingOldState(moduleNames, file) {
            if (structureIsReused === 0 /* StructureIsReused.Not */ && !file.ambientModuleNames.length) {
                // If the old program state does not permit reusing resolutions and `file` does not contain locally defined ambient modules,
                // the best we can do is fallback to the default logic.
                return resolveModuleNamesWorker(moduleNames, file, /*reusedNames*/ undefined);
            }
            var oldSourceFile = oldProgram && oldProgram.getSourceFile(file.fileName);
            if (oldSourceFile !== file && file.resolvedModules) {
                // `file` was created for the new program.
                //
                // We only set `file.resolvedModules` via work from the current function,
                // so it is defined iff we already called the current function on `file`.
                // That call happened no later than the creation of the `file` object,
                // which per above occurred during the current program creation.
                // Since we assume the filesystem does not change during program creation,
                // it is safe to reuse resolutions from the earlier call.
                var result_14 = [];
                var i = 0;
                for (var _i = 0, moduleNames_1 = moduleNames; _i < moduleNames_1.length; _i++) {
                    var moduleName = moduleNames_1[_i];
                    var resolvedModule = file.resolvedModules.get(moduleName, getModeForResolutionAtIndex(file, i));
                    i++;
                    result_14.push(resolvedModule);
                }
                return result_14;
            }
            // At this point, we know at least one of the following hold:
            // - file has local declarations for ambient modules
            // - old program state is available
            // With this information, we can infer some module resolutions without performing resolution.
            /** An ordered list of module names for which we cannot recover the resolution. */
            var unknownModuleNames;
            /**
             * The indexing of elements in this list matches that of `moduleNames`.
             *
             * Before combining results, result[i] is in one of the following states:
             * * undefined: needs to be recomputed,
             * * predictedToResolveToAmbientModuleMarker: known to be an ambient module.
             * Needs to be reset to undefined before returning,
             * * ResolvedModuleFull instance: can be reused.
             */
            var result;
            var reusedNames;
            /** A transient placeholder used to mark predicted resolution in the result list. */
            var predictedToResolveToAmbientModuleMarker = {};
            for (var i = 0; i < moduleNames.length; i++) {
                var moduleName = moduleNames[i];
                // If the source file is unchanged and doesnt have invalidated resolution, reuse the module resolutions
                if (file === oldSourceFile && !hasInvalidatedResolution(oldSourceFile.path)) {
                    var oldResolvedModule = ts.getResolvedModule(oldSourceFile, moduleName, getModeForResolutionAtIndex(oldSourceFile, i));
                    if (oldResolvedModule) {
                        if (ts.isTraceEnabled(options, host)) {
                            ts.trace(host, oldResolvedModule.packageId ?
                                ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3 :
                                ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2, moduleName, ts.getNormalizedAbsolutePath(file.originalFileName, currentDirectory), oldResolvedModule.resolvedFileName, oldResolvedModule.packageId && ts.packageIdToString(oldResolvedModule.packageId));
                        }
                        (result || (result = new Array(moduleNames.length)))[i] = oldResolvedModule;
                        (reusedNames || (reusedNames = [])).push(moduleName);
                        continue;
                    }
                }
                // We know moduleName resolves to an ambient module provided that moduleName:
                // - is in the list of ambient modules locally declared in the current source file.
                // - resolved to an ambient module in the old program whose declaration is in an unmodified file
                //   (so the same module declaration will land in the new program)
                var resolvesToAmbientModuleInNonModifiedFile = false;
                if (ts.contains(file.ambientModuleNames, moduleName)) {
                    resolvesToAmbientModuleInNonModifiedFile = true;
                    if (ts.isTraceEnabled(options, host)) {
                        ts.trace(host, ts.Diagnostics.Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1, moduleName, ts.getNormalizedAbsolutePath(file.originalFileName, currentDirectory));
                    }
                }
                else {
                    resolvesToAmbientModuleInNonModifiedFile = moduleNameResolvesToAmbientModuleInNonModifiedFile(moduleName, i);
                }
                if (resolvesToAmbientModuleInNonModifiedFile) {
                    (result || (result = new Array(moduleNames.length)))[i] = predictedToResolveToAmbientModuleMarker;
                }
                else {
                    // Resolution failed in the old program, or resolved to an ambient module for which we can't reuse the result.
                    (unknownModuleNames || (unknownModuleNames = [])).push(moduleName);
                }
            }
            var resolutions = unknownModuleNames && unknownModuleNames.length
                ? resolveModuleNamesWorker(unknownModuleNames, file, reusedNames)
                : ts.emptyArray;
            // Combine results of resolutions and predicted results
            if (!result) {
                // There were no unresolved/ambient resolutions.
                ts.Debug.assert(resolutions.length === moduleNames.length);
                return resolutions;
            }
            var j = 0;
            for (var i = 0; i < result.length; i++) {
                if (result[i]) {
                    // `result[i]` is either a `ResolvedModuleFull` or a marker.
                    // If it is the former, we can leave it as is.
                    if (result[i] === predictedToResolveToAmbientModuleMarker) {
                        result[i] = undefined; // TODO: GH#18217
                    }
                }
                else {
                    result[i] = resolutions[j];
                    j++;
                }
            }
            ts.Debug.assert(j === resolutions.length);
            return result;
            // If we change our policy of rechecking failed lookups on each program create,
            // we should adjust the value returned here.
            function moduleNameResolvesToAmbientModuleInNonModifiedFile(moduleName, index) {
                if (index >= ts.length(oldSourceFile === null || oldSourceFile === void 0 ? void 0 : oldSourceFile.imports) + ts.length(oldSourceFile === null || oldSourceFile === void 0 ? void 0 : oldSourceFile.moduleAugmentations))
                    return false; // mode index out of bounds, don't reuse resolution
                var resolutionToFile = ts.getResolvedModule(oldSourceFile, moduleName, oldSourceFile && getModeForResolutionAtIndex(oldSourceFile, index));
                var resolvedFile = resolutionToFile && oldProgram.getSourceFile(resolutionToFile.resolvedFileName);
                if (resolutionToFile && resolvedFile) {
                    // In the old program, we resolved to an ambient module that was in the same
                    //   place as we expected to find an actual module file.
                    // We actually need to return 'false' here even though this seems like a 'true' case
                    //   because the normal module resolution algorithm will find this anyway.
                    return false;
                }
                // at least one of declarations should come from non-modified source file
                var unmodifiedFile = ambientModuleNameToUnmodifiedFileName.get(moduleName);
                if (!unmodifiedFile) {
                    return false;
                }
                if (ts.isTraceEnabled(options, host)) {
                    ts.trace(host, ts.Diagnostics.Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified, moduleName, unmodifiedFile);
                }
                return true;
            }
        }
        function canReuseProjectReferences() {
            return !forEachProjectReference(oldProgram.getProjectReferences(), oldProgram.getResolvedProjectReferences(), function (oldResolvedRef, parent, index) {
                var newRef = (parent ? parent.commandLine.projectReferences : projectReferences)[index];
                var newResolvedRef = parseProjectReferenceConfigFile(newRef);
                if (oldResolvedRef) {
                    // Resolved project reference has gone missing or changed
                    return !newResolvedRef ||
                        newResolvedRef.sourceFile !== oldResolvedRef.sourceFile ||
                        !ts.arrayIsEqualTo(oldResolvedRef.commandLine.fileNames, newResolvedRef.commandLine.fileNames);
                }
                else {
                    // A previously-unresolved reference may be resolved now
                    return newResolvedRef !== undefined;
                }
            }, function (oldProjectReferences, parent) {
                // If array of references is changed, we cant resue old program
                var newReferences = parent ? getResolvedProjectReferenceByPath(parent.sourceFile.path).commandLine.projectReferences : projectReferences;
                return !ts.arrayIsEqualTo(oldProjectReferences, newReferences, ts.projectReferenceIsEqualTo);
            });
        }
        function tryReuseStructureFromOldProgram() {
            var _a;
            if (!oldProgram) {
                return 0 /* StructureIsReused.Not */;
            }
            // check properties that can affect structure of the program or module resolution strategy
            // if any of these properties has changed - structure cannot be reused
            var oldOptions = oldProgram.getCompilerOptions();
            if (ts.changesAffectModuleResolution(oldOptions, options)) {
                return 0 /* StructureIsReused.Not */;
            }
            // there is an old program, check if we can reuse its structure
            var oldRootNames = oldProgram.getRootFileNames();
            if (!ts.arrayIsEqualTo(oldRootNames, rootNames)) {
                return 0 /* StructureIsReused.Not */;
            }
            // Check if any referenced project tsconfig files are different
            if (!canReuseProjectReferences()) {
                return 0 /* StructureIsReused.Not */;
            }
            if (projectReferences) {
                resolvedProjectReferences = projectReferences.map(parseProjectReferenceConfigFile);
            }
            // check if program source files has changed in the way that can affect structure of the program
            var newSourceFiles = [];
            var modifiedSourceFiles = [];
            structureIsReused = 2 /* StructureIsReused.Completely */;
            // If the missing file paths are now present, it can change the progam structure,
            // and hence cant reuse the structure.
            // This is same as how we dont reuse the structure if one of the file from old program is now missing
            if (oldProgram.getMissingFilePaths().some(function (missingFilePath) { return host.fileExists(missingFilePath); })) {
                return 0 /* StructureIsReused.Not */;
            }
            var oldSourceFiles = oldProgram.getSourceFiles();
            var SeenPackageName;
            (function (SeenPackageName) {
                SeenPackageName[SeenPackageName["Exists"] = 0] = "Exists";
                SeenPackageName[SeenPackageName["Modified"] = 1] = "Modified";
            })(SeenPackageName || (SeenPackageName = {}));
            var seenPackageNames = new ts.Map();
            for (var _i = 0, oldSourceFiles_2 = oldSourceFiles; _i < oldSourceFiles_2.length; _i++) {
                var oldSourceFile = oldSourceFiles_2[_i];
                var newSourceFile = host.getSourceFileByPath
                    ? host.getSourceFileByPath(oldSourceFile.fileName, oldSourceFile.resolvedPath, getCreateSourceFileOptions(oldSourceFile.fileName, moduleResolutionCache, host, options), /*onError*/ undefined, shouldCreateNewSourceFile)
                    : host.getSourceFile(oldSourceFile.fileName, getCreateSourceFileOptions(oldSourceFile.fileName, moduleResolutionCache, host, options), /*onError*/ undefined, shouldCreateNewSourceFile); // TODO: GH#18217
                if (!newSourceFile) {
                    return 0 /* StructureIsReused.Not */;
                }
                ts.Debug.assert(!newSourceFile.redirectInfo, "Host should not return a redirect source file from `getSourceFile`");
                var fileChanged = void 0;
                if (oldSourceFile.redirectInfo) {
                    // We got `newSourceFile` by path, so it is actually for the unredirected file.
                    // This lets us know if the unredirected file has changed. If it has we should break the redirect.
                    if (newSourceFile !== oldSourceFile.redirectInfo.unredirected) {
                        // Underlying file has changed. Might not redirect anymore. Must rebuild program.
                        return 0 /* StructureIsReused.Not */;
                    }
                    fileChanged = false;
                    newSourceFile = oldSourceFile; // Use the redirect.
                }
                else if (oldProgram.redirectTargetsMap.has(oldSourceFile.path)) {
                    // If a redirected-to source file changes, the redirect may be broken.
                    if (newSourceFile !== oldSourceFile) {
                        return 0 /* StructureIsReused.Not */;
                    }
                    fileChanged = false;
                }
                else {
                    fileChanged = newSourceFile !== oldSourceFile;
                }
                // Since the project references havent changed, its right to set originalFileName and resolvedPath here
                newSourceFile.path = oldSourceFile.path;
                newSourceFile.originalFileName = oldSourceFile.originalFileName;
                newSourceFile.resolvedPath = oldSourceFile.resolvedPath;
                newSourceFile.fileName = oldSourceFile.fileName;
                var packageName = oldProgram.sourceFileToPackageName.get(oldSourceFile.path);
                if (packageName !== undefined) {
                    // If there are 2 different source files for the same package name and at least one of them changes,
                    // they might become redirects. So we must rebuild the program.
                    var prevKind = seenPackageNames.get(packageName);
                    var newKind = fileChanged ? 1 /* SeenPackageName.Modified */ : 0 /* SeenPackageName.Exists */;
                    if ((prevKind !== undefined && newKind === 1 /* SeenPackageName.Modified */) || prevKind === 1 /* SeenPackageName.Modified */) {
                        return 0 /* StructureIsReused.Not */;
                    }
                    seenPackageNames.set(packageName, newKind);
                }
                if (fileChanged) {
                    // The `newSourceFile` object was created for the new program.
                    if (!ts.arrayIsEqualTo(oldSourceFile.libReferenceDirectives, newSourceFile.libReferenceDirectives, fileReferenceIsEqualTo)) {
                        // 'lib' references has changed. Matches behavior in changesAffectModuleResolution
                        structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    }
                    if (oldSourceFile.hasNoDefaultLib !== newSourceFile.hasNoDefaultLib) {
                        // value of no-default-lib has changed
                        // this will affect if default library is injected into the list of files
                        structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    }
                    // check tripleslash references
                    if (!ts.arrayIsEqualTo(oldSourceFile.referencedFiles, newSourceFile.referencedFiles, fileReferenceIsEqualTo)) {
                        // tripleslash references has changed
                        structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    }
                    // check imports and module augmentations
                    collectExternalModuleReferences(newSourceFile);
                    if (!ts.arrayIsEqualTo(oldSourceFile.imports, newSourceFile.imports, moduleNameIsEqualTo)) {
                        // imports has changed
                        structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    }
                    if (!ts.arrayIsEqualTo(oldSourceFile.moduleAugmentations, newSourceFile.moduleAugmentations, moduleNameIsEqualTo)) {
                        // moduleAugmentations has changed
                        structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    }
                    if ((oldSourceFile.flags & 6291456 /* NodeFlags.PermanentlySetIncrementalFlags */) !== (newSourceFile.flags & 6291456 /* NodeFlags.PermanentlySetIncrementalFlags */)) {
                        // dynamicImport has changed
                        structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    }
                    if (!ts.arrayIsEqualTo(oldSourceFile.typeReferenceDirectives, newSourceFile.typeReferenceDirectives, fileReferenceIsEqualTo)) {
                        // 'types' references has changed
                        structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    }
                    // tentatively approve the file
                    modifiedSourceFiles.push({ oldFile: oldSourceFile, newFile: newSourceFile });
                }
                else if (hasInvalidatedResolution(oldSourceFile.path)) {
                    // 'module/types' references could have changed
                    structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    // add file to the modified list so that we will resolve it later
                    modifiedSourceFiles.push({ oldFile: oldSourceFile, newFile: newSourceFile });
                }
                // if file has passed all checks it should be safe to reuse it
                newSourceFiles.push(newSourceFile);
            }
            if (structureIsReused !== 2 /* StructureIsReused.Completely */) {
                return structureIsReused;
            }
            var modifiedFiles = modifiedSourceFiles.map(function (f) { return f.oldFile; });
            for (var _b = 0, oldSourceFiles_3 = oldSourceFiles; _b < oldSourceFiles_3.length; _b++) {
                var oldFile = oldSourceFiles_3[_b];
                if (!ts.contains(modifiedFiles, oldFile)) {
                    for (var _c = 0, _d = oldFile.ambientModuleNames; _c < _d.length; _c++) {
                        var moduleName = _d[_c];
                        ambientModuleNameToUnmodifiedFileName.set(moduleName, oldFile.fileName);
                    }
                }
            }
            // try to verify results of module resolution
            for (var _e = 0, modifiedSourceFiles_1 = modifiedSourceFiles; _e < modifiedSourceFiles_1.length; _e++) {
                var _f = modifiedSourceFiles_1[_e], oldSourceFile = _f.oldFile, newSourceFile = _f.newFile;
                var moduleNames = getModuleNames(newSourceFile);
                var resolutions = resolveModuleNamesReusingOldState(moduleNames, newSourceFile);
                // ensure that module resolution results are still correct
                var resolutionsChanged = ts.hasChangesInResolutions(moduleNames, resolutions, oldSourceFile.resolvedModules, oldSourceFile, ts.moduleResolutionIsEqualTo);
                if (resolutionsChanged) {
                    structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    newSourceFile.resolvedModules = ts.zipToModeAwareCache(newSourceFile, moduleNames, resolutions);
                }
                else {
                    newSourceFile.resolvedModules = oldSourceFile.resolvedModules;
                }
                var typesReferenceDirectives = newSourceFile.typeReferenceDirectives;
                var typeReferenceResolutions = resolveTypeReferenceDirectiveNamesWorker(typesReferenceDirectives, newSourceFile);
                // ensure that types resolutions are still correct
                var typeReferenceResolutionsChanged = ts.hasChangesInResolutions(typesReferenceDirectives, typeReferenceResolutions, oldSourceFile.resolvedTypeReferenceDirectiveNames, oldSourceFile, ts.typeDirectiveIsEqualTo);
                if (typeReferenceResolutionsChanged) {
                    structureIsReused = 1 /* StructureIsReused.SafeModules */;
                    newSourceFile.resolvedTypeReferenceDirectiveNames = ts.zipToModeAwareCache(newSourceFile, typesReferenceDirectives, typeReferenceResolutions);
                }
                else {
                    newSourceFile.resolvedTypeReferenceDirectiveNames = oldSourceFile.resolvedTypeReferenceDirectiveNames;
                }
            }
            if (structureIsReused !== 2 /* StructureIsReused.Completely */) {
                return structureIsReused;
            }
            if (ts.changesAffectingProgramStructure(oldOptions, options) || ((_a = host.hasChangedAutomaticTypeDirectiveNames) === null || _a === void 0 ? void 0 : _a.call(host))) {
                return 1 /* StructureIsReused.SafeModules */;
            }
            missingFilePaths = oldProgram.getMissingFilePaths();
            // update fileName -> file mapping
            ts.Debug.assert(newSourceFiles.length === oldProgram.getSourceFiles().length);
            for (var _g = 0, newSourceFiles_1 = newSourceFiles; _g < newSourceFiles_1.length; _g++) {
                var newSourceFile = newSourceFiles_1[_g];
                filesByName.set(newSourceFile.path, newSourceFile);
            }
            var oldFilesByNameMap = oldProgram.getFilesByNameMap();
            oldFilesByNameMap.forEach(function (oldFile, path) {
                if (!oldFile) {
                    filesByName.set(path, oldFile);
                    return;
                }
                if (oldFile.path === path) {
                    // Set the file as found during node modules search if it was found that way in old progra,
                    if (oldProgram.isSourceFileFromExternalLibrary(oldFile)) {
                        sourceFilesFoundSearchingNodeModules.set(oldFile.path, true);
                    }
                    return;
                }
                filesByName.set(path, filesByName.get(oldFile.path));
            });
            files = newSourceFiles;
            fileReasons = oldProgram.getFileIncludeReasons();
            fileProcessingDiagnostics = oldProgram.getFileProcessingDiagnostics();
            resolvedTypeReferenceDirectives = oldProgram.getResolvedTypeReferenceDirectives();
            sourceFileToPackageName = oldProgram.sourceFileToPackageName;
            redirectTargetsMap = oldProgram.redirectTargetsMap;
            usesUriStyleNodeCoreModules = oldProgram.usesUriStyleNodeCoreModules;
            return 2 /* StructureIsReused.Completely */;
        }
        function getEmitHost(writeFileCallback) {
            return {
                getPrependNodes: getPrependNodes,
                getCanonicalFileName: getCanonicalFileName,
                getCommonSourceDirectory: program.getCommonSourceDirectory,
                getCompilerOptions: program.getCompilerOptions,
                getCurrentDirectory: function () { return currentDirectory; },
                getNewLine: function () { return host.getNewLine(); },
                getSourceFile: program.getSourceFile,
                getSourceFileByPath: program.getSourceFileByPath,
                getSourceFiles: program.getSourceFiles,
                getLibFileFromReference: program.getLibFileFromReference,
                isSourceFileFromExternalLibrary: isSourceFileFromExternalLibrary,
                getResolvedProjectReferenceToRedirect: getResolvedProjectReferenceToRedirect,
                getProjectReferenceRedirect: getProjectReferenceRedirect,
                isSourceOfProjectReferenceRedirect: isSourceOfProjectReferenceRedirect,
                getSymlinkCache: getSymlinkCache,
                writeFile: writeFileCallback || writeFile,
                isEmitBlocked: isEmitBlocked,
                readFile: function (f) { return host.readFile(f); },
                fileExists: function (f) {
                    // Use local caches
                    var path = toPath(f);
                    if (getSourceFileByPath(path))
                        return true;
                    if (ts.contains(missingFilePaths, path))
                        return false;
                    // Before falling back to the host
                    return host.fileExists(f);
                },
                useCaseSensitiveFileNames: function () { return host.useCaseSensitiveFileNames(); },
                getProgramBuildInfo: function () { return program.getProgramBuildInfo && program.getProgramBuildInfo(); },
                getSourceFileFromReference: function (file, ref) { return program.getSourceFileFromReference(file, ref); },
                redirectTargetsMap: redirectTargetsMap,
                getFileIncludeReasons: program.getFileIncludeReasons,
            };
        }
        function writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data) {
            host.writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data);
        }
        function emitBuildInfo(writeFileCallback) {
            ts.Debug.assert(!ts.outFile(options));
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("emit" /* tracing.Phase.Emit */, "emitBuildInfo", {}, /*separateBeginAndEnd*/ true);
            ts.performance.mark("beforeEmit");
            var emitResult = ts.emitFiles(ts.notImplementedResolver, getEmitHost(writeFileCallback), 
            /*targetSourceFile*/ undefined, 
            /*transformers*/ ts.noTransformers, 
            /*emitOnlyDtsFiles*/ false, 
            /*onlyBuildInfo*/ true);
            ts.performance.mark("afterEmit");
            ts.performance.measure("Emit", "beforeEmit", "afterEmit");
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            return emitResult;
        }
        function getResolvedProjectReferences() {
            return resolvedProjectReferences;
        }
        function getProjectReferences() {
            return projectReferences;
        }
        function getPrependNodes() {
            return createPrependNodes(projectReferences, function (_ref, index) { var _a; return (_a = resolvedProjectReferences[index]) === null || _a === void 0 ? void 0 : _a.commandLine; }, function (fileName) {
                var path = toPath(fileName);
                var sourceFile = getSourceFileByPath(path);
                return sourceFile ? sourceFile.text : filesByName.has(path) ? undefined : host.readFile(path);
            });
        }
        function isSourceFileFromExternalLibrary(file) {
            return !!sourceFilesFoundSearchingNodeModules.get(file.path);
        }
        function isSourceFileDefaultLibrary(file) {
            if (!file.isDeclarationFile) {
                return false;
            }
            if (file.hasNoDefaultLib) {
                return true;
            }
            if (!options.noLib) {
                return false;
            }
            // If '--lib' is not specified, include default library file according to '--target'
            // otherwise, using options specified in '--lib' instead of '--target' default library file
            var equalityComparer = host.useCaseSensitiveFileNames() ? ts.equateStringsCaseSensitive : ts.equateStringsCaseInsensitive;
            if (!options.lib) {
                return equalityComparer(file.fileName, getDefaultLibraryFileName());
            }
            else {
                return ts.some(options.lib, function (libFileName) { return equalityComparer(file.fileName, pathForLibFile(libFileName)); });
            }
        }
        function getTypeChecker() {
            return typeChecker || (typeChecker = ts.createTypeChecker(program));
        }
        function emit(sourceFile, writeFileCallback, cancellationToken, emitOnlyDtsFiles, transformers, forceDtsEmit) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("emit" /* tracing.Phase.Emit */, "emit", { path: sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.path }, /*separateBeginAndEnd*/ true);
            var result = runWithCancellationToken(function () { return emitWorker(program, sourceFile, writeFileCallback, cancellationToken, emitOnlyDtsFiles, transformers, forceDtsEmit); });
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            return result;
        }
        function isEmitBlocked(emitFileName) {
            return hasEmitBlockingDiagnostics.has(toPath(emitFileName));
        }
        function emitWorker(program, sourceFile, writeFileCallback, cancellationToken, emitOnlyDtsFiles, customTransformers, forceDtsEmit) {
            if (!forceDtsEmit) {
                var result = handleNoEmitOptions(program, sourceFile, writeFileCallback, cancellationToken);
                if (result)
                    return result;
            }
            // Create the emit resolver outside of the "emitTime" tracking code below.  That way
            // any cost associated with it (like type checking) are appropriate associated with
            // the type-checking counter.
            //
            // If the -out option is specified, we should not pass the source file to getEmitResolver.
            // This is because in the -out scenario all files need to be emitted, and therefore all
            // files need to be type checked. And the way to specify that all files need to be type
            // checked is to not pass the file to getEmitResolver.
            var emitResolver = getTypeChecker().getEmitResolver(ts.outFile(options) ? undefined : sourceFile, cancellationToken);
            ts.performance.mark("beforeEmit");
            var emitResult = ts.emitFiles(emitResolver, getEmitHost(writeFileCallback), sourceFile, ts.getTransformers(options, customTransformers, emitOnlyDtsFiles), emitOnlyDtsFiles, 
            /*onlyBuildInfo*/ false, forceDtsEmit);
            ts.performance.mark("afterEmit");
            ts.performance.measure("Emit", "beforeEmit", "afterEmit");
            return emitResult;
        }
        function getSourceFile(fileName) {
            return getSourceFileByPath(toPath(fileName));
        }
        function getSourceFileByPath(path) {
            return filesByName.get(path) || undefined;
        }
        function getDiagnosticsHelper(sourceFile, getDiagnostics, cancellationToken) {
            if (sourceFile) {
                return getDiagnostics(sourceFile, cancellationToken);
            }
            return ts.sortAndDeduplicateDiagnostics(ts.flatMap(program.getSourceFiles(), function (sourceFile) {
                if (cancellationToken) {
                    cancellationToken.throwIfCancellationRequested();
                }
                return getDiagnostics(sourceFile, cancellationToken);
            }));
        }
        function getSyntacticDiagnostics(sourceFile, cancellationToken) {
            return getDiagnosticsHelper(sourceFile, getSyntacticDiagnosticsForFile, cancellationToken);
        }
        function getSemanticDiagnostics(sourceFile, cancellationToken) {
            return getDiagnosticsHelper(sourceFile, getSemanticDiagnosticsForFile, cancellationToken);
        }
        function getCachedSemanticDiagnostics(sourceFile) {
            var _a;
            return sourceFile
                ? (_a = cachedBindAndCheckDiagnosticsForFile.perFile) === null || _a === void 0 ? void 0 : _a.get(sourceFile.path)
                : cachedBindAndCheckDiagnosticsForFile.allDiagnostics;
        }
        function getBindAndCheckDiagnostics(sourceFile, cancellationToken) {
            return getBindAndCheckDiagnosticsForFile(sourceFile, cancellationToken);
        }
        function getProgramDiagnostics(sourceFile) {
            var _a;
            if (ts.skipTypeChecking(sourceFile, options, program)) {
                return ts.emptyArray;
            }
            var programDiagnosticsInFile = programDiagnostics.getDiagnostics(sourceFile.fileName);
            if (!((_a = sourceFile.commentDirectives) === null || _a === void 0 ? void 0 : _a.length)) {
                return programDiagnosticsInFile;
            }
            return getDiagnosticsWithPrecedingDirectives(sourceFile, sourceFile.commentDirectives, programDiagnosticsInFile).diagnostics;
        }
        function getDeclarationDiagnostics(sourceFile, cancellationToken) {
            var options = program.getCompilerOptions();
            // collect diagnostics from the program only once if either no source file was specified or out/outFile is set (bundled emit)
            if (!sourceFile || ts.outFile(options)) {
                return getDeclarationDiagnosticsWorker(sourceFile, cancellationToken);
            }
            else {
                return getDiagnosticsHelper(sourceFile, getDeclarationDiagnosticsForFile, cancellationToken);
            }
        }
        function getSyntacticDiagnosticsForFile(sourceFile) {
            // For JavaScript files, we report semantic errors for using TypeScript-only
            // constructs from within a JavaScript file as syntactic errors.
            if (ts.isSourceFileJS(sourceFile)) {
                if (!sourceFile.additionalSyntacticDiagnostics) {
                    sourceFile.additionalSyntacticDiagnostics = getJSSyntacticDiagnosticsForFile(sourceFile);
                }
                return ts.concatenate(sourceFile.additionalSyntacticDiagnostics, sourceFile.parseDiagnostics);
            }
            return sourceFile.parseDiagnostics;
        }
        function runWithCancellationToken(func) {
            try {
                return func();
            }
            catch (e) {
                if (e instanceof ts.OperationCanceledException) {
                    // We were canceled while performing the operation.  Because our type checker
                    // might be a bad state, we need to throw it away.
                    typeChecker = undefined;
                }
                throw e;
            }
        }
        function getSemanticDiagnosticsForFile(sourceFile, cancellationToken) {
            return ts.concatenate(filterSemanticDiagnostics(getBindAndCheckDiagnosticsForFile(sourceFile, cancellationToken), options), getProgramDiagnostics(sourceFile));
        }
        function getBindAndCheckDiagnosticsForFile(sourceFile, cancellationToken) {
            return getAndCacheDiagnostics(sourceFile, cancellationToken, cachedBindAndCheckDiagnosticsForFile, getBindAndCheckDiagnosticsForFileNoCache);
        }
        function getBindAndCheckDiagnosticsForFileNoCache(sourceFile, cancellationToken) {
            return runWithCancellationToken(function () {
                if (ts.skipTypeChecking(sourceFile, options, program)) {
                    return ts.emptyArray;
                }
                var typeChecker = getTypeChecker();
                ts.Debug.assert(!!sourceFile.bindDiagnostics);
                var isJs = sourceFile.scriptKind === 1 /* ScriptKind.JS */ || sourceFile.scriptKind === 2 /* ScriptKind.JSX */;
                var isCheckJs = isJs && ts.isCheckJsEnabledForFile(sourceFile, options);
                var isPlainJs = ts.isPlainJsFile(sourceFile, options.checkJs);
                var isTsNoCheck = !!sourceFile.checkJsDirective && sourceFile.checkJsDirective.enabled === false;
                // By default, only type-check .ts, .tsx, Deferred, plain JS, checked JS and External
                // - plain JS: .js files with no // ts-check and checkJs: undefined
                // - check JS: .js files with either // ts-check or checkJs: true
                // - external: files that are added by plugins
                var includeBindAndCheckDiagnostics = !isTsNoCheck && (sourceFile.scriptKind === 3 /* ScriptKind.TS */ || sourceFile.scriptKind === 4 /* ScriptKind.TSX */
                    || sourceFile.scriptKind === 5 /* ScriptKind.External */ || isPlainJs || isCheckJs || sourceFile.scriptKind === 7 /* ScriptKind.Deferred */);
                var bindDiagnostics = includeBindAndCheckDiagnostics ? sourceFile.bindDiagnostics : ts.emptyArray;
                var checkDiagnostics = includeBindAndCheckDiagnostics ? typeChecker.getDiagnostics(sourceFile, cancellationToken) : ts.emptyArray;
                if (isPlainJs) {
                    bindDiagnostics = ts.filter(bindDiagnostics, function (d) { return ts.plainJSErrors.has(d.code); });
                    checkDiagnostics = ts.filter(checkDiagnostics, function (d) { return ts.plainJSErrors.has(d.code); });
                }
                // skip ts-expect-error errors in plain JS files, and skip JSDoc errors except in checked JS
                return getMergedBindAndCheckDiagnostics(sourceFile, includeBindAndCheckDiagnostics && !isPlainJs, bindDiagnostics, checkDiagnostics, isCheckJs ? sourceFile.jsDocDiagnostics : undefined);
            });
        }
        function getMergedBindAndCheckDiagnostics(sourceFile, includeBindAndCheckDiagnostics) {
            var _a;
            var allDiagnostics = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                allDiagnostics[_i - 2] = arguments[_i];
            }
            var flatDiagnostics = ts.flatten(allDiagnostics);
            if (!includeBindAndCheckDiagnostics || !((_a = sourceFile.commentDirectives) === null || _a === void 0 ? void 0 : _a.length)) {
                return flatDiagnostics;
            }
            var _b = getDiagnosticsWithPrecedingDirectives(sourceFile, sourceFile.commentDirectives, flatDiagnostics), diagnostics = _b.diagnostics, directives = _b.directives;
            for (var _c = 0, _d = directives.getUnusedExpectations(); _c < _d.length; _c++) {
                var errorExpectation = _d[_c];
                diagnostics.push(ts.createDiagnosticForRange(sourceFile, errorExpectation.range, ts.Diagnostics.Unused_ts_expect_error_directive));
            }
            return diagnostics;
        }
        /**
         * Creates a map of comment directives along with the diagnostics immediately preceded by one of them.
         * Comments that match to any of those diagnostics are marked as used.
         */
        function getDiagnosticsWithPrecedingDirectives(sourceFile, commentDirectives, flatDiagnostics) {
            // Diagnostics are only reported if there is no comment directive preceding them
            // This will modify the directives map by marking "used" ones with a corresponding diagnostic
            var directives = ts.createCommentDirectivesMap(sourceFile, commentDirectives);
            var diagnostics = flatDiagnostics.filter(function (diagnostic) { return markPrecedingCommentDirectiveLine(diagnostic, directives) === -1; });
            return { diagnostics: diagnostics, directives: directives };
        }
        function getSuggestionDiagnostics(sourceFile, cancellationToken) {
            return runWithCancellationToken(function () {
                return getTypeChecker().getSuggestionDiagnostics(sourceFile, cancellationToken);
            });
        }
        /**
         * @returns The line index marked as preceding the diagnostic, or -1 if none was.
         */
        function markPrecedingCommentDirectiveLine(diagnostic, directives) {
            var file = diagnostic.file, start = diagnostic.start;
            if (!file) {
                return -1;
            }
            // Start out with the line just before the text
            var lineStarts = ts.getLineStarts(file);
            var line = ts.computeLineAndCharacterOfPosition(lineStarts, start).line - 1; // TODO: GH#18217
            while (line >= 0) {
                // As soon as that line is known to have a comment directive, use that
                if (directives.markUsed(line)) {
                    return line;
                }
                // Stop searching if the line is not empty and not a comment
                var lineText = file.text.slice(lineStarts[line], lineStarts[line + 1]).trim();
                if (lineText !== "" && !/^(\s*)\/\/(.*)$/.test(lineText)) {
                    return -1;
                }
                line--;
            }
            return -1;
        }
        function getJSSyntacticDiagnosticsForFile(sourceFile) {
            return runWithCancellationToken(function () {
                var diagnostics = [];
                walk(sourceFile, sourceFile);
                ts.forEachChildRecursively(sourceFile, walk, walkArray);
                return diagnostics;
                function walk(node, parent) {
                    // Return directly from the case if the given node doesnt want to visit each child
                    // Otherwise break to visit each child
                    switch (parent.kind) {
                        case 164 /* SyntaxKind.Parameter */:
                        case 167 /* SyntaxKind.PropertyDeclaration */:
                        case 169 /* SyntaxKind.MethodDeclaration */:
                            if (parent.questionToken === node) {
                                diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.The_0_modifier_can_only_be_used_in_TypeScript_files, "?"));
                                return "skip";
                            }
                        // falls through
                        case 168 /* SyntaxKind.MethodSignature */:
                        case 171 /* SyntaxKind.Constructor */:
                        case 172 /* SyntaxKind.GetAccessor */:
                        case 173 /* SyntaxKind.SetAccessor */:
                        case 213 /* SyntaxKind.FunctionExpression */:
                        case 256 /* SyntaxKind.FunctionDeclaration */:
                        case 214 /* SyntaxKind.ArrowFunction */:
                        case 254 /* SyntaxKind.VariableDeclaration */:
                            // type annotation
                            if (parent.type === node) {
                                diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.Type_annotations_can_only_be_used_in_TypeScript_files));
                                return "skip";
                            }
                    }
                    switch (node.kind) {
                        case 267 /* SyntaxKind.ImportClause */:
                            if (node.isTypeOnly) {
                                diagnostics.push(createDiagnosticForNode(parent, ts.Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, "import type"));
                                return "skip";
                            }
                            break;
                        case 272 /* SyntaxKind.ExportDeclaration */:
                            if (node.isTypeOnly) {
                                diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, "export type"));
                                return "skip";
                            }
                            break;
                        case 270 /* SyntaxKind.ImportSpecifier */:
                        case 275 /* SyntaxKind.ExportSpecifier */:
                            if (node.isTypeOnly) {
                                diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, ts.isImportSpecifier(node) ? "import...type" : "export...type"));
                                return "skip";
                            }
                            break;
                        case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                            diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.import_can_only_be_used_in_TypeScript_files));
                            return "skip";
                        case 271 /* SyntaxKind.ExportAssignment */:
                            if (node.isExportEquals) {
                                diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.export_can_only_be_used_in_TypeScript_files));
                                return "skip";
                            }
                            break;
                        case 291 /* SyntaxKind.HeritageClause */:
                            var heritageClause = node;
                            if (heritageClause.token === 117 /* SyntaxKind.ImplementsKeyword */) {
                                diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.implements_clauses_can_only_be_used_in_TypeScript_files));
                                return "skip";
                            }
                            break;
                        case 258 /* SyntaxKind.InterfaceDeclaration */:
                            var interfaceKeyword = ts.tokenToString(118 /* SyntaxKind.InterfaceKeyword */);
                            ts.Debug.assertIsDefined(interfaceKeyword);
                            diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, interfaceKeyword));
                            return "skip";
                        case 261 /* SyntaxKind.ModuleDeclaration */:
                            var moduleKeyword = node.flags & 16 /* NodeFlags.Namespace */ ? ts.tokenToString(142 /* SyntaxKind.NamespaceKeyword */) : ts.tokenToString(141 /* SyntaxKind.ModuleKeyword */);
                            ts.Debug.assertIsDefined(moduleKeyword);
                            diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, moduleKeyword));
                            return "skip";
                        case 259 /* SyntaxKind.TypeAliasDeclaration */:
                            diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.Type_aliases_can_only_be_used_in_TypeScript_files));
                            return "skip";
                        case 260 /* SyntaxKind.EnumDeclaration */:
                            var enumKeyword = ts.Debug.checkDefined(ts.tokenToString(92 /* SyntaxKind.EnumKeyword */));
                            diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, enumKeyword));
                            return "skip";
                        case 230 /* SyntaxKind.NonNullExpression */:
                            diagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.Non_null_assertions_can_only_be_used_in_TypeScript_files));
                            return "skip";
                        case 229 /* SyntaxKind.AsExpression */:
                            diagnostics.push(createDiagnosticForNode(node.type, ts.Diagnostics.Type_assertion_expressions_can_only_be_used_in_TypeScript_files));
                            return "skip";
                        case 211 /* SyntaxKind.TypeAssertionExpression */:
                            ts.Debug.fail(); // Won't parse these in a JS file anyway, as they are interpreted as JSX.
                    }
                }
                function walkArray(nodes, parent) {
                    if (parent.decorators === nodes && !options.experimentalDecorators) {
                        diagnostics.push(createDiagnosticForNode(parent, ts.Diagnostics.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning));
                    }
                    switch (parent.kind) {
                        case 257 /* SyntaxKind.ClassDeclaration */:
                        case 226 /* SyntaxKind.ClassExpression */:
                        case 169 /* SyntaxKind.MethodDeclaration */:
                        case 171 /* SyntaxKind.Constructor */:
                        case 172 /* SyntaxKind.GetAccessor */:
                        case 173 /* SyntaxKind.SetAccessor */:
                        case 213 /* SyntaxKind.FunctionExpression */:
                        case 256 /* SyntaxKind.FunctionDeclaration */:
                        case 214 /* SyntaxKind.ArrowFunction */:
                            // Check type parameters
                            if (nodes === parent.typeParameters) {
                                diagnostics.push(createDiagnosticForNodeArray(nodes, ts.Diagnostics.Type_parameter_declarations_can_only_be_used_in_TypeScript_files));
                                return "skip";
                            }
                        // falls through
                        case 237 /* SyntaxKind.VariableStatement */:
                            // Check modifiers
                            if (nodes === parent.modifiers) {
                                checkModifiers(parent.modifiers, parent.kind === 237 /* SyntaxKind.VariableStatement */);
                                return "skip";
                            }
                            break;
                        case 167 /* SyntaxKind.PropertyDeclaration */:
                            // Check modifiers of property declaration
                            if (nodes === parent.modifiers) {
                                for (var _i = 0, _a = nodes; _i < _a.length; _i++) {
                                    var modifier = _a[_i];
                                    if (modifier.kind !== 124 /* SyntaxKind.StaticKeyword */) {
                                        diagnostics.push(createDiagnosticForNode(modifier, ts.Diagnostics.The_0_modifier_can_only_be_used_in_TypeScript_files, ts.tokenToString(modifier.kind)));
                                    }
                                }
                                return "skip";
                            }
                            break;
                        case 164 /* SyntaxKind.Parameter */:
                            // Check modifiers of parameter declaration
                            if (nodes === parent.modifiers) {
                                diagnostics.push(createDiagnosticForNodeArray(nodes, ts.Diagnostics.Parameter_modifiers_can_only_be_used_in_TypeScript_files));
                                return "skip";
                            }
                            break;
                        case 208 /* SyntaxKind.CallExpression */:
                        case 209 /* SyntaxKind.NewExpression */:
                        case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                        case 279 /* SyntaxKind.JsxSelfClosingElement */:
                        case 280 /* SyntaxKind.JsxOpeningElement */:
                        case 210 /* SyntaxKind.TaggedTemplateExpression */:
                            // Check type arguments
                            if (nodes === parent.typeArguments) {
                                diagnostics.push(createDiagnosticForNodeArray(nodes, ts.Diagnostics.Type_arguments_can_only_be_used_in_TypeScript_files));
                                return "skip";
                            }
                            break;
                    }
                }
                function checkModifiers(modifiers, isConstValid) {
                    for (var _i = 0, modifiers_2 = modifiers; _i < modifiers_2.length; _i++) {
                        var modifier = modifiers_2[_i];
                        switch (modifier.kind) {
                            case 85 /* SyntaxKind.ConstKeyword */:
                                if (isConstValid) {
                                    continue;
                                }
                            // to report error,
                            // falls through
                            case 123 /* SyntaxKind.PublicKeyword */:
                            case 121 /* SyntaxKind.PrivateKeyword */:
                            case 122 /* SyntaxKind.ProtectedKeyword */:
                            case 145 /* SyntaxKind.ReadonlyKeyword */:
                            case 135 /* SyntaxKind.DeclareKeyword */:
                            case 126 /* SyntaxKind.AbstractKeyword */:
                            case 159 /* SyntaxKind.OverrideKeyword */:
                            case 101 /* SyntaxKind.InKeyword */:
                            case 144 /* SyntaxKind.OutKeyword */:
                                diagnostics.push(createDiagnosticForNode(modifier, ts.Diagnostics.The_0_modifier_can_only_be_used_in_TypeScript_files, ts.tokenToString(modifier.kind)));
                                break;
                            // These are all legal modifiers.
                            case 124 /* SyntaxKind.StaticKeyword */:
                            case 93 /* SyntaxKind.ExportKeyword */:
                            case 88 /* SyntaxKind.DefaultKeyword */:
                        }
                    }
                }
                function createDiagnosticForNodeArray(nodes, message, arg0, arg1, arg2) {
                    var start = nodes.pos;
                    return ts.createFileDiagnostic(sourceFile, start, nodes.end - start, message, arg0, arg1, arg2);
                }
                // Since these are syntactic diagnostics, parent might not have been set
                // this means the sourceFile cannot be infered from the node
                function createDiagnosticForNode(node, message, arg0, arg1, arg2) {
                    return ts.createDiagnosticForNodeInSourceFile(sourceFile, node, message, arg0, arg1, arg2);
                }
            });
        }
        function getDeclarationDiagnosticsWorker(sourceFile, cancellationToken) {
            return getAndCacheDiagnostics(sourceFile, cancellationToken, cachedDeclarationDiagnosticsForFile, getDeclarationDiagnosticsForFileNoCache);
        }
        function getDeclarationDiagnosticsForFileNoCache(sourceFile, cancellationToken) {
            return runWithCancellationToken(function () {
                var resolver = getTypeChecker().getEmitResolver(sourceFile, cancellationToken);
                // Don't actually write any files since we're just getting diagnostics.
                return ts.getDeclarationDiagnostics(getEmitHost(ts.noop), resolver, sourceFile) || ts.emptyArray;
            });
        }
        function getAndCacheDiagnostics(sourceFile, cancellationToken, cache, getDiagnostics) {
            var _a;
            var cachedResult = sourceFile
                ? (_a = cache.perFile) === null || _a === void 0 ? void 0 : _a.get(sourceFile.path)
                : cache.allDiagnostics;
            if (cachedResult) {
                return cachedResult;
            }
            var result = getDiagnostics(sourceFile, cancellationToken);
            if (sourceFile) {
                (cache.perFile || (cache.perFile = new ts.Map())).set(sourceFile.path, result);
            }
            else {
                cache.allDiagnostics = result;
            }
            return result;
        }
        function getDeclarationDiagnosticsForFile(sourceFile, cancellationToken) {
            return sourceFile.isDeclarationFile ? [] : getDeclarationDiagnosticsWorker(sourceFile, cancellationToken);
        }
        function getOptionsDiagnostics() {
            return ts.sortAndDeduplicateDiagnostics(ts.concatenate(programDiagnostics.getGlobalDiagnostics(), getOptionsDiagnosticsOfConfigFile()));
        }
        function getOptionsDiagnosticsOfConfigFile() {
            if (!options.configFile)
                return ts.emptyArray;
            var diagnostics = programDiagnostics.getDiagnostics(options.configFile.fileName);
            forEachResolvedProjectReference(function (resolvedRef) {
                diagnostics = ts.concatenate(diagnostics, programDiagnostics.getDiagnostics(resolvedRef.sourceFile.fileName));
            });
            return diagnostics;
        }
        function getGlobalDiagnostics() {
            return rootNames.length ? ts.sortAndDeduplicateDiagnostics(getTypeChecker().getGlobalDiagnostics().slice()) : ts.emptyArray;
        }
        function getConfigFileParsingDiagnostics() {
            return configFileParsingDiagnostics || ts.emptyArray;
        }
        function processRootFile(fileName, isDefaultLib, ignoreNoDefaultLib, reason) {
            processSourceFile(ts.normalizePath(fileName), isDefaultLib, ignoreNoDefaultLib, /*packageId*/ undefined, reason);
        }
        function fileReferenceIsEqualTo(a, b) {
            return a.fileName === b.fileName;
        }
        function moduleNameIsEqualTo(a, b) {
            return a.kind === 79 /* SyntaxKind.Identifier */
                ? b.kind === 79 /* SyntaxKind.Identifier */ && a.escapedText === b.escapedText
                : b.kind === 10 /* SyntaxKind.StringLiteral */ && a.text === b.text;
        }
        function createSyntheticImport(text, file) {
            var externalHelpersModuleReference = ts.factory.createStringLiteral(text);
            var importDecl = ts.factory.createImportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*importClause*/ undefined, externalHelpersModuleReference, /*assertClause*/ undefined);
            ts.addEmitFlags(importDecl, 67108864 /* EmitFlags.NeverApplyImportHelper */);
            ts.setParent(externalHelpersModuleReference, importDecl);
            ts.setParent(importDecl, file);
            // explicitly unset the synthesized flag on these declarations so the checker API will answer questions about them
            // (which is required to build the dependency graph for incremental emit)
            externalHelpersModuleReference.flags &= ~8 /* NodeFlags.Synthesized */;
            importDecl.flags &= ~8 /* NodeFlags.Synthesized */;
            return externalHelpersModuleReference;
        }
        function collectExternalModuleReferences(file) {
            if (file.imports) {
                return;
            }
            var isJavaScriptFile = ts.isSourceFileJS(file);
            var isExternalModuleFile = ts.isExternalModule(file);
            // file.imports may not be undefined if there exists dynamic import
            var imports;
            var moduleAugmentations;
            var ambientModules;
            // If we are importing helpers, we need to add a synthetic reference to resolve the
            // helpers library.
            if ((options.isolatedModules || isExternalModuleFile)
                && !file.isDeclarationFile) {
                if (options.importHelpers) {
                    // synthesize 'import "tslib"' declaration
                    imports = [createSyntheticImport(ts.externalHelpersModuleNameText, file)];
                }
                var jsxImport = ts.getJSXRuntimeImport(ts.getJSXImplicitImportBase(options, file), options);
                if (jsxImport) {
                    // synthesize `import "base/jsx-runtime"` declaration
                    (imports || (imports = [])).push(createSyntheticImport(jsxImport, file));
                }
            }
            for (var _i = 0, _a = file.statements; _i < _a.length; _i++) {
                var node = _a[_i];
                collectModuleReferences(node, /*inAmbientModule*/ false);
            }
            if ((file.flags & 2097152 /* NodeFlags.PossiblyContainsDynamicImport */) || isJavaScriptFile) {
                collectDynamicImportOrRequireCalls(file);
            }
            file.imports = imports || ts.emptyArray;
            file.moduleAugmentations = moduleAugmentations || ts.emptyArray;
            file.ambientModuleNames = ambientModules || ts.emptyArray;
            return;
            function collectModuleReferences(node, inAmbientModule) {
                if (ts.isAnyImportOrReExport(node)) {
                    var moduleNameExpr = ts.getExternalModuleName(node);
                    // TypeScript 1.0 spec (April 2014): 12.1.6
                    // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference other external modules
                    // only through top - level external module names. Relative external module names are not permitted.
                    if (moduleNameExpr && ts.isStringLiteral(moduleNameExpr) && moduleNameExpr.text && (!inAmbientModule || !ts.isExternalModuleNameRelative(moduleNameExpr.text))) {
                        ts.setParentRecursive(node, /*incremental*/ false); // we need parent data on imports before the program is fully bound, so we ensure it's set here
                        imports = ts.append(imports, moduleNameExpr);
                        if (!usesUriStyleNodeCoreModules && currentNodeModulesDepth === 0 && !file.isDeclarationFile) {
                            usesUriStyleNodeCoreModules = ts.startsWith(moduleNameExpr.text, "node:");
                        }
                    }
                }
                else if (ts.isModuleDeclaration(node)) {
                    if (ts.isAmbientModule(node) && (inAmbientModule || ts.hasSyntacticModifier(node, 2 /* ModifierFlags.Ambient */) || file.isDeclarationFile)) {
                        node.name.parent = node;
                        var nameText = ts.getTextOfIdentifierOrLiteral(node.name);
                        // Ambient module declarations can be interpreted as augmentations for some existing external modules.
                        // This will happen in two cases:
                        // - if current file is external module then module augmentation is a ambient module declaration defined in the top level scope
                        // - if current file is not external module then module augmentation is an ambient module declaration with non-relative module name
                        //   immediately nested in top level ambient module declaration .
                        if (isExternalModuleFile || (inAmbientModule && !ts.isExternalModuleNameRelative(nameText))) {
                            (moduleAugmentations || (moduleAugmentations = [])).push(node.name);
                        }
                        else if (!inAmbientModule) {
                            if (file.isDeclarationFile) {
                                // for global .d.ts files record name of ambient module
                                (ambientModules || (ambientModules = [])).push(nameText);
                            }
                            // An AmbientExternalModuleDeclaration declares an external module.
                            // This type of declaration is permitted only in the global module.
                            // The StringLiteral must specify a top - level external module name.
                            // Relative external module names are not permitted
                            // NOTE: body of ambient module is always a module block, if it exists
                            var body = node.body;
                            if (body) {
                                for (var _i = 0, _a = body.statements; _i < _a.length; _i++) {
                                    var statement = _a[_i];
                                    collectModuleReferences(statement, /*inAmbientModule*/ true);
                                }
                            }
                        }
                    }
                }
            }
            function collectDynamicImportOrRequireCalls(file) {
                var r = /import|require/g;
                while (r.exec(file.text) !== null) { // eslint-disable-line no-null/no-null
                    var node = getNodeAtPosition(file, r.lastIndex);
                    if (isJavaScriptFile && ts.isRequireCall(node, /*checkArgumentIsStringLiteralLike*/ true)) {
                        ts.setParentRecursive(node, /*incremental*/ false); // we need parent data on imports before the program is fully bound, so we ensure it's set here
                        imports = ts.append(imports, node.arguments[0]);
                    }
                    // we have to check the argument list has length of at least 1. We will still have to process these even though we have parsing error.
                    else if (ts.isImportCall(node) && node.arguments.length >= 1 && ts.isStringLiteralLike(node.arguments[0])) {
                        ts.setParentRecursive(node, /*incremental*/ false); // we need parent data on imports before the program is fully bound, so we ensure it's set here
                        imports = ts.append(imports, node.arguments[0]);
                    }
                    else if (ts.isLiteralImportTypeNode(node)) {
                        ts.setParentRecursive(node, /*incremental*/ false); // we need parent data on imports before the program is fully bound, so we ensure it's set here
                        imports = ts.append(imports, node.argument.literal);
                    }
                }
            }
            /** Returns a token if position is in [start-of-leading-trivia, end), includes JSDoc only in JS files */
            function getNodeAtPosition(sourceFile, position) {
                var current = sourceFile;
                var getContainingChild = function (child) {
                    if (child.pos <= position && (position < child.end || (position === child.end && (child.kind === 1 /* SyntaxKind.EndOfFileToken */)))) {
                        return child;
                    }
                };
                while (true) {
                    var child = isJavaScriptFile && ts.hasJSDocNodes(current) && ts.forEach(current.jsDoc, getContainingChild) || ts.forEachChild(current, getContainingChild);
                    if (!child) {
                        return current;
                    }
                    current = child;
                }
            }
        }
        function getLibFileFromReference(ref) {
            var libName = ts.toFileNameLowerCase(ref.fileName);
            var libFileName = ts.libMap.get(libName);
            if (libFileName) {
                return getSourceFile(pathForLibFile(libFileName));
            }
        }
        /** This should have similar behavior to 'processSourceFile' without diagnostics or mutation. */
        function getSourceFileFromReference(referencingFile, ref) {
            return getSourceFileFromReferenceWorker(resolveTripleslashReference(ref.fileName, referencingFile.fileName), getSourceFile);
        }
        function getSourceFileFromReferenceWorker(fileName, getSourceFile, fail, reason) {
            if (ts.hasExtension(fileName)) {
                var canonicalFileName_1 = host.getCanonicalFileName(fileName);
                if (!options.allowNonTsExtensions && !ts.forEach(ts.flatten(supportedExtensionsWithJsonIfResolveJsonModule), function (extension) { return ts.fileExtensionIs(canonicalFileName_1, extension); })) {
                    if (fail) {
                        if (ts.hasJSFileExtension(canonicalFileName_1)) {
                            fail(ts.Diagnostics.File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option, fileName);
                        }
                        else {
                            fail(ts.Diagnostics.File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1, fileName, "'" + ts.flatten(supportedExtensions).join("', '") + "'");
                        }
                    }
                    return undefined;
                }
                var sourceFile = getSourceFile(fileName);
                if (fail) {
                    if (!sourceFile) {
                        var redirect = getProjectReferenceRedirect(fileName);
                        if (redirect) {
                            fail(ts.Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, fileName);
                        }
                        else {
                            fail(ts.Diagnostics.File_0_not_found, fileName);
                        }
                    }
                    else if (isReferencedFile(reason) && canonicalFileName_1 === host.getCanonicalFileName(getSourceFileByPath(reason.file).fileName)) {
                        fail(ts.Diagnostics.A_file_cannot_have_a_reference_to_itself);
                    }
                }
                return sourceFile;
            }
            else {
                var sourceFileNoExtension = options.allowNonTsExtensions && getSourceFile(fileName);
                if (sourceFileNoExtension)
                    return sourceFileNoExtension;
                if (fail && options.allowNonTsExtensions) {
                    fail(ts.Diagnostics.File_0_not_found, fileName);
                    return undefined;
                }
                // Only try adding extensions from the first supported group (which should be .ts/.tsx/.d.ts)
                var sourceFileWithAddedExtension = ts.forEach(supportedExtensions[0], function (extension) { return getSourceFile(fileName + extension); });
                if (fail && !sourceFileWithAddedExtension)
                    fail(ts.Diagnostics.Could_not_resolve_the_path_0_with_the_extensions_Colon_1, fileName, "'" + ts.flatten(supportedExtensions).join("', '") + "'");
                return sourceFileWithAddedExtension;
            }
        }
        /** This has side effects through `findSourceFile`. */
        function processSourceFile(fileName, isDefaultLib, ignoreNoDefaultLib, packageId, reason) {
            getSourceFileFromReferenceWorker(fileName, function (fileName) { return findSourceFile(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId); }, // TODO: GH#18217
            function (diagnostic) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return addFilePreprocessingFileExplainingDiagnostic(/*file*/ undefined, reason, diagnostic, args);
            }, reason);
        }
        function processProjectReferenceFile(fileName, reason) {
            return processSourceFile(fileName, /*isDefaultLib*/ false, /*ignoreNoDefaultLib*/ false, /*packageId*/ undefined, reason);
        }
        function reportFileNamesDifferOnlyInCasingError(fileName, existingFile, reason) {
            var hasExistingReasonToReportErrorOn = !isReferencedFile(reason) && ts.some(fileReasons.get(existingFile.path), isReferencedFile);
            if (hasExistingReasonToReportErrorOn) {
                addFilePreprocessingFileExplainingDiagnostic(existingFile, reason, ts.Diagnostics.Already_included_file_name_0_differs_from_file_name_1_only_in_casing, [existingFile.fileName, fileName]);
            }
            else {
                addFilePreprocessingFileExplainingDiagnostic(existingFile, reason, ts.Diagnostics.File_name_0_differs_from_already_included_file_name_1_only_in_casing, [fileName, existingFile.fileName]);
            }
        }
        function createRedirectSourceFile(redirectTarget, unredirected, fileName, path, resolvedPath, originalFileName) {
            var redirect = Object.create(redirectTarget);
            redirect.fileName = fileName;
            redirect.path = path;
            redirect.resolvedPath = resolvedPath;
            redirect.originalFileName = originalFileName;
            redirect.redirectInfo = { redirectTarget: redirectTarget, unredirected: unredirected };
            sourceFilesFoundSearchingNodeModules.set(path, currentNodeModulesDepth > 0);
            Object.defineProperties(redirect, {
                id: {
                    get: function () { return this.redirectInfo.redirectTarget.id; },
                    set: function (value) { this.redirectInfo.redirectTarget.id = value; },
                },
                symbol: {
                    get: function () { return this.redirectInfo.redirectTarget.symbol; },
                    set: function (value) { this.redirectInfo.redirectTarget.symbol = value; },
                },
            });
            return redirect;
        }
        // Get source file from normalized fileName
        function findSourceFile(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "findSourceFile", {
                fileName: fileName,
                isDefaultLib: isDefaultLib || undefined,
                fileIncludeKind: ts.FileIncludeKind[reason.kind],
            });
            var result = findSourceFileWorker(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            return result;
        }
        function getCreateSourceFileOptions(fileName, moduleResolutionCache, host, options) {
            // It's a _little odd_ that we can't set `impliedNodeFormat` until the program step - but it's the first and only time we have a resolution cache
            // and a freshly made source file node on hand at the same time, and we need both to set the field. Persisting the resolution cache all the way
            // to the check and emit steps would be bad - so we much prefer detecting and storing the format information on the source file node upfront.
            var impliedNodeFormat = getImpliedNodeFormatForFile(toPath(fileName), moduleResolutionCache === null || moduleResolutionCache === void 0 ? void 0 : moduleResolutionCache.getPackageJsonInfoCache(), host, options);
            return {
                languageVersion: ts.getEmitScriptTarget(options),
                impliedNodeFormat: impliedNodeFormat,
                setExternalModuleIndicator: ts.getSetExternalModuleIndicator(options)
            };
        }
        function findSourceFileWorker(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId) {
            var path = toPath(fileName);
            if (useSourceOfProjectReferenceRedirect) {
                var source = getSourceOfProjectReferenceRedirect(path);
                // If preserveSymlinks is true, module resolution wont jump the symlink
                // but the resolved real path may be the .d.ts from project reference
                // Note:: Currently we try the real path only if the
                // file is from node_modules to avoid having to run real path on all file paths
                if (!source &&
                    host.realpath &&
                    options.preserveSymlinks &&
                    ts.isDeclarationFileName(fileName) &&
                    ts.stringContains(fileName, ts.nodeModulesPathPart)) {
                    var realPath = toPath(host.realpath(fileName));
                    if (realPath !== path)
                        source = getSourceOfProjectReferenceRedirect(realPath);
                }
                if (source) {
                    var file_1 = ts.isString(source) ?
                        findSourceFile(source, isDefaultLib, ignoreNoDefaultLib, reason, packageId) :
                        undefined;
                    if (file_1)
                        addFileToFilesByName(file_1, path, /*redirectedPath*/ undefined);
                    return file_1;
                }
            }
            var originalFileName = fileName;
            if (filesByName.has(path)) {
                var file_2 = filesByName.get(path);
                addFileIncludeReason(file_2 || undefined, reason);
                // try to check if we've already seen this file but with a different casing in path
                // NOTE: this only makes sense for case-insensitive file systems, and only on files which are not redirected
                if (file_2 && options.forceConsistentCasingInFileNames) {
                    var checkedName = file_2.fileName;
                    var isRedirect = toPath(checkedName) !== toPath(fileName);
                    if (isRedirect) {
                        fileName = getProjectReferenceRedirect(fileName) || fileName;
                    }
                    // Check if it differs only in drive letters its ok to ignore that error:
                    var checkedAbsolutePath = ts.getNormalizedAbsolutePathWithoutRoot(checkedName, currentDirectory);
                    var inputAbsolutePath = ts.getNormalizedAbsolutePathWithoutRoot(fileName, currentDirectory);
                    if (checkedAbsolutePath !== inputAbsolutePath) {
                        reportFileNamesDifferOnlyInCasingError(fileName, file_2, reason);
                    }
                }
                // If the file was previously found via a node_modules search, but is now being processed as a root file,
                // then everything it sucks in may also be marked incorrectly, and needs to be checked again.
                if (file_2 && sourceFilesFoundSearchingNodeModules.get(file_2.path) && currentNodeModulesDepth === 0) {
                    sourceFilesFoundSearchingNodeModules.set(file_2.path, false);
                    if (!options.noResolve) {
                        processReferencedFiles(file_2, isDefaultLib);
                        processTypeReferenceDirectives(file_2);
                    }
                    if (!options.noLib) {
                        processLibReferenceDirectives(file_2);
                    }
                    modulesWithElidedImports.set(file_2.path, false);
                    processImportedModules(file_2);
                }
                // See if we need to reprocess the imports due to prior skipped imports
                else if (file_2 && modulesWithElidedImports.get(file_2.path)) {
                    if (currentNodeModulesDepth < maxNodeModuleJsDepth) {
                        modulesWithElidedImports.set(file_2.path, false);
                        processImportedModules(file_2);
                    }
                }
                return file_2 || undefined;
            }
            var redirectedPath;
            if (isReferencedFile(reason) && !useSourceOfProjectReferenceRedirect) {
                var redirectProject = getProjectReferenceRedirectProject(fileName);
                if (redirectProject) {
                    if (ts.outFile(redirectProject.commandLine.options)) {
                        // Shouldnt create many to 1 mapping file in --out scenario
                        return undefined;
                    }
                    var redirect = getProjectReferenceOutputName(redirectProject, fileName);
                    fileName = redirect;
                    // Once we start redirecting to a file, we can potentially come back to it
                    // via a back-reference from another file in the .d.ts folder. If that happens we'll
                    // end up trying to add it to the program *again* because we were tracking it via its
                    // original (un-redirected) name. So we have to map both the original path and the redirected path
                    // to the source file we're about to find/create
                    redirectedPath = toPath(redirect);
                }
            }
            // We haven't looked for this file, do so now and cache result
            var file = host.getSourceFile(fileName, getCreateSourceFileOptions(fileName, moduleResolutionCache, host, options), function (hostErrorMessage) { return addFilePreprocessingFileExplainingDiagnostic(/*file*/ undefined, reason, ts.Diagnostics.Cannot_read_file_0_Colon_1, [fileName, hostErrorMessage]); }, shouldCreateNewSourceFile);
            if (packageId) {
                var packageIdKey = ts.packageIdToString(packageId);
                var fileFromPackageId = packageIdToSourceFile.get(packageIdKey);
                if (fileFromPackageId) {
                    // Some other SourceFile already exists with this package name and version.
                    // Instead of creating a duplicate, just redirect to the existing one.
                    var dupFile = createRedirectSourceFile(fileFromPackageId, file, fileName, path, toPath(fileName), originalFileName); // TODO: GH#18217
                    redirectTargetsMap.add(fileFromPackageId.path, fileName);
                    addFileToFilesByName(dupFile, path, redirectedPath);
                    addFileIncludeReason(dupFile, reason);
                    sourceFileToPackageName.set(path, ts.packageIdToPackageName(packageId));
                    processingOtherFiles.push(dupFile);
                    return dupFile;
                }
                else if (file) {
                    // This is the first source file to have this packageId.
                    packageIdToSourceFile.set(packageIdKey, file);
                    sourceFileToPackageName.set(path, ts.packageIdToPackageName(packageId));
                }
            }
            addFileToFilesByName(file, path, redirectedPath);
            if (file) {
                sourceFilesFoundSearchingNodeModules.set(path, currentNodeModulesDepth > 0);
                file.fileName = fileName; // Ensure that source file has same name as what we were looking for
                file.path = path;
                file.resolvedPath = toPath(fileName);
                file.originalFileName = originalFileName;
                addFileIncludeReason(file, reason);
                if (host.useCaseSensitiveFileNames()) {
                    var pathLowerCase = ts.toFileNameLowerCase(path);
                    // for case-sensitive file systems check if we've already seen some file with similar filename ignoring case
                    var existingFile = filesByNameIgnoreCase.get(pathLowerCase);
                    if (existingFile) {
                        reportFileNamesDifferOnlyInCasingError(fileName, existingFile, reason);
                    }
                    else {
                        filesByNameIgnoreCase.set(pathLowerCase, file);
                    }
                }
                skipDefaultLib = skipDefaultLib || (file.hasNoDefaultLib && !ignoreNoDefaultLib);
                if (!options.noResolve) {
                    processReferencedFiles(file, isDefaultLib);
                    processTypeReferenceDirectives(file);
                }
                if (!options.noLib) {
                    processLibReferenceDirectives(file);
                }
                // always process imported modules to record module name resolutions
                processImportedModules(file);
                if (isDefaultLib) {
                    processingDefaultLibFiles.push(file);
                }
                else {
                    processingOtherFiles.push(file);
                }
            }
            return file;
        }
        function addFileIncludeReason(file, reason) {
            if (file)
                fileReasons.add(file.path, reason);
        }
        function addFileToFilesByName(file, path, redirectedPath) {
            if (redirectedPath) {
                filesByName.set(redirectedPath, file);
                filesByName.set(path, file || false);
            }
            else {
                filesByName.set(path, file);
            }
        }
        function getProjectReferenceRedirect(fileName) {
            var referencedProject = getProjectReferenceRedirectProject(fileName);
            return referencedProject && getProjectReferenceOutputName(referencedProject, fileName);
        }
        function getProjectReferenceRedirectProject(fileName) {
            // Ignore dts or any json files
            if (!resolvedProjectReferences || !resolvedProjectReferences.length || ts.isDeclarationFileName(fileName) || ts.fileExtensionIs(fileName, ".json" /* Extension.Json */)) {
                return undefined;
            }
            // If this file is produced by a referenced project, we need to rewrite it to
            // look in the output folder of the referenced project rather than the input
            return getResolvedProjectReferenceToRedirect(fileName);
        }
        function getProjectReferenceOutputName(referencedProject, fileName) {
            var out = ts.outFile(referencedProject.commandLine.options);
            return out ?
                ts.changeExtension(out, ".d.ts" /* Extension.Dts */) :
                ts.getOutputDeclarationFileName(fileName, referencedProject.commandLine, !host.useCaseSensitiveFileNames());
        }
        /**
         * Get the referenced project if the file is input file from that reference project
         */
        function getResolvedProjectReferenceToRedirect(fileName) {
            if (mapFromFileToProjectReferenceRedirects === undefined) {
                mapFromFileToProjectReferenceRedirects = new ts.Map();
                forEachResolvedProjectReference(function (referencedProject) {
                    // not input file from the referenced project, ignore
                    if (toPath(options.configFilePath) !== referencedProject.sourceFile.path) {
                        referencedProject.commandLine.fileNames.forEach(function (f) {
                            return mapFromFileToProjectReferenceRedirects.set(toPath(f), referencedProject.sourceFile.path);
                        });
                    }
                });
            }
            var referencedProjectPath = mapFromFileToProjectReferenceRedirects.get(toPath(fileName));
            return referencedProjectPath && getResolvedProjectReferenceByPath(referencedProjectPath);
        }
        function forEachResolvedProjectReference(cb) {
            return ts.forEachResolvedProjectReference(resolvedProjectReferences, cb);
        }
        function getSourceOfProjectReferenceRedirect(path) {
            if (!ts.isDeclarationFileName(path))
                return undefined;
            if (mapFromToProjectReferenceRedirectSource === undefined) {
                mapFromToProjectReferenceRedirectSource = new ts.Map();
                forEachResolvedProjectReference(function (resolvedRef) {
                    var out = ts.outFile(resolvedRef.commandLine.options);
                    if (out) {
                        // Dont know which source file it means so return true?
                        var outputDts = ts.changeExtension(out, ".d.ts" /* Extension.Dts */);
                        mapFromToProjectReferenceRedirectSource.set(toPath(outputDts), true);
                    }
                    else {
                        var getCommonSourceDirectory_3 = ts.memoize(function () { return ts.getCommonSourceDirectoryOfConfig(resolvedRef.commandLine, !host.useCaseSensitiveFileNames()); });
                        ts.forEach(resolvedRef.commandLine.fileNames, function (fileName) {
                            if (!ts.isDeclarationFileName(fileName) && !ts.fileExtensionIs(fileName, ".json" /* Extension.Json */)) {
                                var outputDts = ts.getOutputDeclarationFileName(fileName, resolvedRef.commandLine, !host.useCaseSensitiveFileNames(), getCommonSourceDirectory_3);
                                mapFromToProjectReferenceRedirectSource.set(toPath(outputDts), fileName);
                            }
                        });
                    }
                });
            }
            return mapFromToProjectReferenceRedirectSource.get(path);
        }
        function isSourceOfProjectReferenceRedirect(fileName) {
            return useSourceOfProjectReferenceRedirect && !!getResolvedProjectReferenceToRedirect(fileName);
        }
        function getResolvedProjectReferenceByPath(projectReferencePath) {
            if (!projectReferenceRedirects) {
                return undefined;
            }
            return projectReferenceRedirects.get(projectReferencePath) || undefined;
        }
        function processReferencedFiles(file, isDefaultLib) {
            ts.forEach(file.referencedFiles, function (ref, index) {
                processSourceFile(resolveTripleslashReference(ref.fileName, file.fileName), isDefaultLib, 
                /*ignoreNoDefaultLib*/ false, 
                /*packageId*/ undefined, { kind: ts.FileIncludeKind.ReferenceFile, file: file.path, index: index, });
            });
        }
        function processTypeReferenceDirectives(file) {
            var typeDirectives = file.typeReferenceDirectives;
            if (!typeDirectives) {
                return;
            }
            var resolutions = resolveTypeReferenceDirectiveNamesWorker(typeDirectives, file);
            for (var index = 0; index < typeDirectives.length; index++) {
                var ref = file.typeReferenceDirectives[index];
                var resolvedTypeReferenceDirective = resolutions[index];
                // store resolved type directive on the file
                var fileName = ts.toFileNameLowerCase(ref.fileName);
                ts.setResolvedTypeReferenceDirective(file, fileName, resolvedTypeReferenceDirective);
                var mode = ref.resolutionMode || file.impliedNodeFormat;
                if (mode && ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.Node16 && ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.NodeNext) {
                    programDiagnostics.add(ts.createDiagnosticForRange(file, ref, ts.Diagnostics.resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext));
                }
                processTypeReferenceDirective(fileName, mode, resolvedTypeReferenceDirective, { kind: ts.FileIncludeKind.TypeReferenceDirective, file: file.path, index: index, });
            }
        }
        function processTypeReferenceDirective(typeReferenceDirective, mode, resolvedTypeReferenceDirective, reason) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("program" /* tracing.Phase.Program */, "processTypeReferenceDirective", { directive: typeReferenceDirective, hasResolved: !!resolveModuleNamesReusingOldState, refKind: reason.kind, refPath: isReferencedFile(reason) ? reason.file : undefined });
            processTypeReferenceDirectiveWorker(typeReferenceDirective, mode, resolvedTypeReferenceDirective, reason);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        }
        function processTypeReferenceDirectiveWorker(typeReferenceDirective, mode, resolvedTypeReferenceDirective, reason) {
            // If we already found this library as a primary reference - nothing to do
            var previousResolution = resolvedTypeReferenceDirectives.get(typeReferenceDirective, mode);
            if (previousResolution && previousResolution.primary) {
                return;
            }
            var saveResolution = true;
            if (resolvedTypeReferenceDirective) {
                if (resolvedTypeReferenceDirective.isExternalLibraryImport)
                    currentNodeModulesDepth++;
                if (resolvedTypeReferenceDirective.primary) {
                    // resolved from the primary path
                    processSourceFile(resolvedTypeReferenceDirective.resolvedFileName, /*isDefaultLib*/ false, /*ignoreNoDefaultLib*/ false, resolvedTypeReferenceDirective.packageId, reason); // TODO: GH#18217
                }
                else {
                    // If we already resolved to this file, it must have been a secondary reference. Check file contents
                    // for sameness and possibly issue an error
                    if (previousResolution) {
                        // Don't bother reading the file again if it's the same file.
                        if (resolvedTypeReferenceDirective.resolvedFileName !== previousResolution.resolvedFileName) {
                            var otherFileText = host.readFile(resolvedTypeReferenceDirective.resolvedFileName);
                            var existingFile = getSourceFile(previousResolution.resolvedFileName);
                            if (otherFileText !== existingFile.text) {
                                addFilePreprocessingFileExplainingDiagnostic(existingFile, reason, ts.Diagnostics.Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict, [typeReferenceDirective, resolvedTypeReferenceDirective.resolvedFileName, previousResolution.resolvedFileName]);
                            }
                        }
                        // don't overwrite previous resolution result
                        saveResolution = false;
                    }
                    else {
                        // First resolution of this library
                        processSourceFile(resolvedTypeReferenceDirective.resolvedFileName, /*isDefaultLib*/ false, /*ignoreNoDefaultLib*/ false, resolvedTypeReferenceDirective.packageId, reason);
                    }
                }
                if (resolvedTypeReferenceDirective.isExternalLibraryImport)
                    currentNodeModulesDepth--;
            }
            else {
                addFilePreprocessingFileExplainingDiagnostic(/*file*/ undefined, reason, ts.Diagnostics.Cannot_find_type_definition_file_for_0, [typeReferenceDirective]);
            }
            if (saveResolution) {
                resolvedTypeReferenceDirectives.set(typeReferenceDirective, mode, resolvedTypeReferenceDirective);
            }
        }
        function pathForLibFile(libFileName) {
            // Support resolving to lib.dom.d.ts -> @typescript/lib-dom, and
            //                      lib.dom.iterable.d.ts -> @typescript/lib-dom/iterable
            //                      lib.es2015.symbol.wellknown.d.ts -> @typescript/lib-es2015/symbol-wellknown
            var components = libFileName.split(".");
            var path = components[1];
            var i = 2;
            while (components[i] && components[i] !== "d") {
                path += (i === 2 ? "/" : "-") + components[i];
                i++;
            }
            var resolveFrom = ts.combinePaths(currentDirectory, "__lib_node_modules_lookup_".concat(libFileName, "__.ts"));
            var localOverrideModuleResult = ts.resolveModuleName("@typescript/lib-" + path, resolveFrom, { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, moduleResolutionCache);
            if (localOverrideModuleResult === null || localOverrideModuleResult === void 0 ? void 0 : localOverrideModuleResult.resolvedModule) {
                return localOverrideModuleResult.resolvedModule.resolvedFileName;
            }
            return ts.combinePaths(defaultLibraryPath, libFileName);
        }
        function processLibReferenceDirectives(file) {
            ts.forEach(file.libReferenceDirectives, function (libReference, index) {
                var libName = ts.toFileNameLowerCase(libReference.fileName);
                var libFileName = ts.libMap.get(libName);
                if (libFileName) {
                    // we ignore any 'no-default-lib' reference set on this file.
                    processRootFile(pathForLibFile(libFileName), /*isDefaultLib*/ true, /*ignoreNoDefaultLib*/ true, { kind: ts.FileIncludeKind.LibReferenceDirective, file: file.path, index: index, });
                }
                else {
                    var unqualifiedLibName = ts.removeSuffix(ts.removePrefix(libName, "lib."), ".d.ts");
                    var suggestion = ts.getSpellingSuggestion(unqualifiedLibName, ts.libs, ts.identity);
                    var diagnostic = suggestion ? ts.Diagnostics.Cannot_find_lib_definition_for_0_Did_you_mean_1 : ts.Diagnostics.Cannot_find_lib_definition_for_0;
                    (fileProcessingDiagnostics || (fileProcessingDiagnostics = [])).push({
                        kind: 0 /* FilePreprocessingDiagnosticsKind.FilePreprocessingReferencedDiagnostic */,
                        reason: { kind: ts.FileIncludeKind.LibReferenceDirective, file: file.path, index: index, },
                        diagnostic: diagnostic,
                        args: [libName, suggestion]
                    });
                }
            });
        }
        function getCanonicalFileName(fileName) {
            return host.getCanonicalFileName(fileName);
        }
        function processImportedModules(file) {
            var _a;
            collectExternalModuleReferences(file);
            if (file.imports.length || file.moduleAugmentations.length) {
                // Because global augmentation doesn't have string literal name, we can check for global augmentation as such.
                var moduleNames = getModuleNames(file);
                var resolutions = resolveModuleNamesReusingOldState(moduleNames, file);
                ts.Debug.assert(resolutions.length === moduleNames.length);
                var optionsForFile = (useSourceOfProjectReferenceRedirect ? (_a = getRedirectReferenceForResolution(file)) === null || _a === void 0 ? void 0 : _a.commandLine.options : undefined) || options;
                for (var index = 0; index < moduleNames.length; index++) {
                    var resolution = resolutions[index];
                    ts.setResolvedModule(file, moduleNames[index], resolution, getModeForResolutionAtIndex(file, index));
                    if (!resolution) {
                        continue;
                    }
                    var isFromNodeModulesSearch = resolution.isExternalLibraryImport;
                    var isJsFile = !ts.resolutionExtensionIsTSOrJson(resolution.extension);
                    var isJsFileFromNodeModules = isFromNodeModulesSearch && isJsFile;
                    var resolvedFileName = resolution.resolvedFileName;
                    if (isFromNodeModulesSearch) {
                        currentNodeModulesDepth++;
                    }
                    // add file to program only if:
                    // - resolution was successful
                    // - noResolve is falsy
                    // - module name comes from the list of imports
                    // - it's not a top level JavaScript module that exceeded the search max
                    var elideImport = isJsFileFromNodeModules && currentNodeModulesDepth > maxNodeModuleJsDepth;
                    // Don't add the file if it has a bad extension (e.g. 'tsx' if we don't have '--allowJs')
                    // This may still end up being an untyped module -- the file won't be included but imports will be allowed.
                    var shouldAddFile = resolvedFileName
                        && !getResolutionDiagnostic(optionsForFile, resolution)
                        && !optionsForFile.noResolve
                        && index < file.imports.length
                        && !elideImport
                        && !(isJsFile && !ts.getAllowJSCompilerOption(optionsForFile))
                        && (ts.isInJSFile(file.imports[index]) || !(file.imports[index].flags & 8388608 /* NodeFlags.JSDoc */));
                    if (elideImport) {
                        modulesWithElidedImports.set(file.path, true);
                    }
                    else if (shouldAddFile) {
                        findSourceFile(resolvedFileName, 
                        /*isDefaultLib*/ false, 
                        /*ignoreNoDefaultLib*/ false, { kind: ts.FileIncludeKind.Import, file: file.path, index: index, }, resolution.packageId);
                    }
                    if (isFromNodeModulesSearch) {
                        currentNodeModulesDepth--;
                    }
                }
            }
            else {
                // no imports - drop cached module resolutions
                file.resolvedModules = undefined;
            }
        }
        function checkSourceFilesBelongToPath(sourceFiles, rootDirectory) {
            var allFilesBelongToPath = true;
            var absoluteRootDirectoryPath = host.getCanonicalFileName(ts.getNormalizedAbsolutePath(rootDirectory, currentDirectory));
            for (var _i = 0, sourceFiles_2 = sourceFiles; _i < sourceFiles_2.length; _i++) {
                var sourceFile = sourceFiles_2[_i];
                if (!sourceFile.isDeclarationFile) {
                    var absoluteSourceFilePath = host.getCanonicalFileName(ts.getNormalizedAbsolutePath(sourceFile.fileName, currentDirectory));
                    if (absoluteSourceFilePath.indexOf(absoluteRootDirectoryPath) !== 0) {
                        addProgramDiagnosticExplainingFile(sourceFile, ts.Diagnostics.File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files, [sourceFile.fileName, rootDirectory]);
                        allFilesBelongToPath = false;
                    }
                }
            }
            return allFilesBelongToPath;
        }
        function parseProjectReferenceConfigFile(ref) {
            if (!projectReferenceRedirects) {
                projectReferenceRedirects = new ts.Map();
            }
            // The actual filename (i.e. add "/tsconfig.json" if necessary)
            var refPath = resolveProjectReferencePath(ref);
            var sourceFilePath = toPath(refPath);
            var fromCache = projectReferenceRedirects.get(sourceFilePath);
            if (fromCache !== undefined) {
                return fromCache || undefined;
            }
            var commandLine;
            var sourceFile;
            if (host.getParsedCommandLine) {
                commandLine = host.getParsedCommandLine(refPath);
                if (!commandLine) {
                    addFileToFilesByName(/*sourceFile*/ undefined, sourceFilePath, /*redirectedPath*/ undefined);
                    projectReferenceRedirects.set(sourceFilePath, false);
                    return undefined;
                }
                sourceFile = ts.Debug.checkDefined(commandLine.options.configFile);
                ts.Debug.assert(!sourceFile.path || sourceFile.path === sourceFilePath);
                addFileToFilesByName(sourceFile, sourceFilePath, /*redirectedPath*/ undefined);
            }
            else {
                // An absolute path pointing to the containing directory of the config file
                var basePath = ts.getNormalizedAbsolutePath(ts.getDirectoryPath(refPath), host.getCurrentDirectory());
                sourceFile = host.getSourceFile(refPath, 100 /* ScriptTarget.JSON */);
                addFileToFilesByName(sourceFile, sourceFilePath, /*redirectedPath*/ undefined);
                if (sourceFile === undefined) {
                    projectReferenceRedirects.set(sourceFilePath, false);
                    return undefined;
                }
                commandLine = ts.parseJsonSourceFileConfigFileContent(sourceFile, configParsingHost, basePath, /*existingOptions*/ undefined, refPath);
            }
            sourceFile.fileName = refPath;
            sourceFile.path = sourceFilePath;
            sourceFile.resolvedPath = sourceFilePath;
            sourceFile.originalFileName = refPath;
            var resolvedRef = { commandLine: commandLine, sourceFile: sourceFile };
            projectReferenceRedirects.set(sourceFilePath, resolvedRef);
            if (commandLine.projectReferences) {
                resolvedRef.references = commandLine.projectReferences.map(parseProjectReferenceConfigFile);
            }
            return resolvedRef;
        }
        function verifyCompilerOptions() {
            if (options.strictPropertyInitialization && !ts.getStrictOptionValue(options, "strictNullChecks")) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "strictPropertyInitialization", "strictNullChecks");
            }
            if (options.exactOptionalPropertyTypes && !ts.getStrictOptionValue(options, "strictNullChecks")) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "exactOptionalPropertyTypes", "strictNullChecks");
            }
            if (options.isolatedModules) {
                if (options.out) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "out", "isolatedModules");
                }
                if (options.outFile) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "outFile", "isolatedModules");
                }
            }
            if (options.inlineSourceMap) {
                if (options.sourceMap) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "sourceMap", "inlineSourceMap");
                }
                if (options.mapRoot) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "mapRoot", "inlineSourceMap");
                }
            }
            if (options.composite) {
                if (options.declaration === false) {
                    createDiagnosticForOptionName(ts.Diagnostics.Composite_projects_may_not_disable_declaration_emit, "declaration");
                }
                if (options.incremental === false) {
                    createDiagnosticForOptionName(ts.Diagnostics.Composite_projects_may_not_disable_incremental_compilation, "declaration");
                }
            }
            var outputFile = ts.outFile(options);
            if (options.tsBuildInfoFile) {
                if (!ts.isIncrementalCompilation(options)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "tsBuildInfoFile", "incremental", "composite");
                }
            }
            else if (options.incremental && !outputFile && !options.configFilePath) {
                programDiagnostics.add(ts.createCompilerDiagnostic(ts.Diagnostics.Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified));
            }
            verifyProjectReferences();
            // List of collected files is complete; validate exhautiveness if this is a project with a file list
            if (options.composite) {
                var rootPaths = new ts.Set(rootNames.map(toPath));
                for (var _i = 0, files_4 = files; _i < files_4.length; _i++) {
                    var file = files_4[_i];
                    // Ignore file that is not emitted
                    if (ts.sourceFileMayBeEmitted(file, program) && !rootPaths.has(file.path)) {
                        addProgramDiagnosticExplainingFile(file, ts.Diagnostics.File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern, [file.fileName, options.configFilePath || ""]);
                    }
                }
            }
            if (options.paths) {
                for (var key in options.paths) {
                    if (!ts.hasProperty(options.paths, key)) {
                        continue;
                    }
                    if (!ts.hasZeroOrOneAsteriskCharacter(key)) {
                        createDiagnosticForOptionPaths(/*onKey*/ true, key, ts.Diagnostics.Pattern_0_can_have_at_most_one_Asterisk_character, key);
                    }
                    if (ts.isArray(options.paths[key])) {
                        var len = options.paths[key].length;
                        if (len === 0) {
                            createDiagnosticForOptionPaths(/*onKey*/ false, key, ts.Diagnostics.Substitutions_for_pattern_0_shouldn_t_be_an_empty_array, key);
                        }
                        for (var i = 0; i < len; i++) {
                            var subst = options.paths[key][i];
                            var typeOfSubst = typeof subst;
                            if (typeOfSubst === "string") {
                                if (!ts.hasZeroOrOneAsteriskCharacter(subst)) {
                                    createDiagnosticForOptionPathKeyValue(key, i, ts.Diagnostics.Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character, subst, key);
                                }
                                if (!options.baseUrl && !ts.pathIsRelative(subst) && !ts.pathIsAbsolute(subst)) {
                                    createDiagnosticForOptionPathKeyValue(key, i, ts.Diagnostics.Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash);
                                }
                            }
                            else {
                                createDiagnosticForOptionPathKeyValue(key, i, ts.Diagnostics.Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2, subst, key, typeOfSubst);
                            }
                        }
                    }
                    else {
                        createDiagnosticForOptionPaths(/*onKey*/ false, key, ts.Diagnostics.Substitutions_for_pattern_0_should_be_an_array, key);
                    }
                }
            }
            if (!options.sourceMap && !options.inlineSourceMap) {
                if (options.inlineSources) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided, "inlineSources");
                }
                if (options.sourceRoot) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided, "sourceRoot");
                }
            }
            if (options.out && options.outFile) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "out", "outFile");
            }
            if (options.mapRoot && !(options.sourceMap || options.declarationMap)) {
                // Error to specify --mapRoot without --sourcemap
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "mapRoot", "sourceMap", "declarationMap");
            }
            if (options.declarationDir) {
                if (!ts.getEmitDeclarations(options)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "declarationDir", "declaration", "composite");
                }
                if (outputFile) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "declarationDir", options.out ? "out" : "outFile");
                }
            }
            if (options.declarationMap && !ts.getEmitDeclarations(options)) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "declarationMap", "declaration", "composite");
            }
            if (options.lib && options.noLib) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "lib", "noLib");
            }
            if (options.noImplicitUseStrict && ts.getStrictOptionValue(options, "alwaysStrict")) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "noImplicitUseStrict", "alwaysStrict");
            }
            var languageVersion = ts.getEmitScriptTarget(options);
            var firstNonAmbientExternalModuleSourceFile = ts.find(files, function (f) { return ts.isExternalModule(f) && !f.isDeclarationFile; });
            if (options.isolatedModules) {
                if (options.module === ts.ModuleKind.None && languageVersion < 2 /* ScriptTarget.ES2015 */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher, "isolatedModules", "target");
                }
                if (options.preserveConstEnums === false) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_preserveConstEnums_cannot_be_disabled_when_isolatedModules_is_enabled, "preserveConstEnums", "isolatedModules");
                }
                var firstNonExternalModuleSourceFile = ts.find(files, function (f) { return !ts.isExternalModule(f) && !ts.isSourceFileJS(f) && !f.isDeclarationFile && f.scriptKind !== 6 /* ScriptKind.JSON */; });
                if (firstNonExternalModuleSourceFile) {
                    var span = ts.getErrorSpanForNode(firstNonExternalModuleSourceFile, firstNonExternalModuleSourceFile);
                    programDiagnostics.add(ts.createFileDiagnostic(firstNonExternalModuleSourceFile, span.start, span.length, ts.Diagnostics._0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_import_export_or_an_empty_export_statement_to_make_it_a_module, ts.getBaseFileName(firstNonExternalModuleSourceFile.fileName)));
                }
            }
            else if (firstNonAmbientExternalModuleSourceFile && languageVersion < 2 /* ScriptTarget.ES2015 */ && options.module === ts.ModuleKind.None) {
                // We cannot use createDiagnosticFromNode because nodes do not have parents yet
                var span = ts.getErrorSpanForNode(firstNonAmbientExternalModuleSourceFile, typeof firstNonAmbientExternalModuleSourceFile.externalModuleIndicator === "boolean" ? firstNonAmbientExternalModuleSourceFile : firstNonAmbientExternalModuleSourceFile.externalModuleIndicator);
                programDiagnostics.add(ts.createFileDiagnostic(firstNonAmbientExternalModuleSourceFile, span.start, span.length, ts.Diagnostics.Cannot_use_imports_exports_or_module_augmentations_when_module_is_none));
            }
            // Cannot specify module gen that isn't amd or system with --out
            if (outputFile && !options.emitDeclarationOnly) {
                if (options.module && !(options.module === ts.ModuleKind.AMD || options.module === ts.ModuleKind.System)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Only_amd_and_system_modules_are_supported_alongside_0, options.out ? "out" : "outFile", "module");
                }
                else if (options.module === undefined && firstNonAmbientExternalModuleSourceFile) {
                    var span = ts.getErrorSpanForNode(firstNonAmbientExternalModuleSourceFile, typeof firstNonAmbientExternalModuleSourceFile.externalModuleIndicator === "boolean" ? firstNonAmbientExternalModuleSourceFile : firstNonAmbientExternalModuleSourceFile.externalModuleIndicator);
                    programDiagnostics.add(ts.createFileDiagnostic(firstNonAmbientExternalModuleSourceFile, span.start, span.length, ts.Diagnostics.Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system, options.out ? "out" : "outFile"));
                }
            }
            if (options.resolveJsonModule) {
                if (ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.NodeJs &&
                    ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.Node16 &&
                    ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.NodeNext) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy, "resolveJsonModule");
                }
                // Any emit other than common js, amd, es2015 or esnext is error
                else if (!ts.hasJsonModuleEmitEnabled(options)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_esNext, "resolveJsonModule", "module");
                }
            }
            // there has to be common source directory if user specified --outdir || --rootDir || --sourceRoot
            // if user specified --mapRoot, there needs to be common source directory if there would be multiple files being emitted
            if (options.outDir || // there is --outDir specified
                options.rootDir || // there is --rootDir specified
                options.sourceRoot || // there is --sourceRoot specified
                options.mapRoot) { // there is --mapRoot specified
                // Precalculate and cache the common source directory
                var dir = getCommonSourceDirectory();
                // If we failed to find a good common directory, but outDir is specified and at least one of our files is on a windows drive/URL/other resource, add a failure
                if (options.outDir && dir === "" && files.some(function (file) { return ts.getRootLength(file.fileName) > 1; })) {
                    createDiagnosticForOptionName(ts.Diagnostics.Cannot_find_the_common_subdirectory_path_for_the_input_files, "outDir");
                }
            }
            if (options.useDefineForClassFields && languageVersion === 0 /* ScriptTarget.ES3 */) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_target_is_ES3, "useDefineForClassFields");
            }
            if (options.checkJs && !ts.getAllowJSCompilerOption(options)) {
                programDiagnostics.add(ts.createCompilerDiagnostic(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "checkJs", "allowJs"));
            }
            if (options.emitDeclarationOnly) {
                if (!ts.getEmitDeclarations(options)) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "emitDeclarationOnly", "declaration", "composite");
                }
                if (options.noEmit) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "emitDeclarationOnly", "noEmit");
                }
            }
            if (options.emitDecoratorMetadata &&
                !options.experimentalDecorators) {
                createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "emitDecoratorMetadata", "experimentalDecorators");
            }
            if (options.jsxFactory) {
                if (options.reactNamespace) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_with_option_1, "reactNamespace", "jsxFactory");
                }
                if (options.jsx === 4 /* JsxEmit.ReactJSX */ || options.jsx === 5 /* JsxEmit.ReactJSXDev */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "jsxFactory", ts.inverseJsxOptionMap.get("" + options.jsx));
                }
                if (!ts.parseIsolatedEntityName(options.jsxFactory, languageVersion)) {
                    createOptionValueDiagnostic("jsxFactory", ts.Diagnostics.Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name, options.jsxFactory);
                }
            }
            else if (options.reactNamespace && !ts.isIdentifierText(options.reactNamespace, languageVersion)) {
                createOptionValueDiagnostic("reactNamespace", ts.Diagnostics.Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier, options.reactNamespace);
            }
            if (options.jsxFragmentFactory) {
                if (!options.jsxFactory) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "jsxFragmentFactory", "jsxFactory");
                }
                if (options.jsx === 4 /* JsxEmit.ReactJSX */ || options.jsx === 5 /* JsxEmit.ReactJSXDev */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "jsxFragmentFactory", ts.inverseJsxOptionMap.get("" + options.jsx));
                }
                if (!ts.parseIsolatedEntityName(options.jsxFragmentFactory, languageVersion)) {
                    createOptionValueDiagnostic("jsxFragmentFactory", ts.Diagnostics.Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name, options.jsxFragmentFactory);
                }
            }
            if (options.reactNamespace) {
                if (options.jsx === 4 /* JsxEmit.ReactJSX */ || options.jsx === 5 /* JsxEmit.ReactJSXDev */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "reactNamespace", ts.inverseJsxOptionMap.get("" + options.jsx));
                }
            }
            if (options.jsxImportSource) {
                if (options.jsx === 2 /* JsxEmit.React */) {
                    createDiagnosticForOptionName(ts.Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "jsxImportSource", ts.inverseJsxOptionMap.get("" + options.jsx));
                }
            }
            if (options.preserveValueImports && ts.getEmitModuleKind(options) < ts.ModuleKind.ES2015) {
                createOptionValueDiagnostic("importsNotUsedAsValues", ts.Diagnostics.Option_preserveValueImports_can_only_be_used_when_module_is_set_to_es2015_or_later);
            }
            // If the emit is enabled make sure that every output file is unique and not overwriting any of the input files
            if (!options.noEmit && !options.suppressOutputPathCheck) {
                var emitHost = getEmitHost();
                var emitFilesSeen_1 = new ts.Set();
                ts.forEachEmittedFile(emitHost, function (emitFileNames) {
                    if (!options.emitDeclarationOnly) {
                        verifyEmitFilePath(emitFileNames.jsFilePath, emitFilesSeen_1);
                    }
                    verifyEmitFilePath(emitFileNames.declarationFilePath, emitFilesSeen_1);
                });
            }
            // Verify that all the emit files are unique and don't overwrite input files
            function verifyEmitFilePath(emitFileName, emitFilesSeen) {
                if (emitFileName) {
                    var emitFilePath = toPath(emitFileName);
                    // Report error if the output overwrites input file
                    if (filesByName.has(emitFilePath)) {
                        var chain = void 0;
                        if (!options.configFilePath) {
                            // The program is from either an inferred project or an external project
                            chain = ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig);
                        }
                        chain = ts.chainDiagnosticMessages(chain, ts.Diagnostics.Cannot_write_file_0_because_it_would_overwrite_input_file, emitFileName);
                        blockEmittingOfFile(emitFileName, ts.createCompilerDiagnosticFromMessageChain(chain));
                    }
                    var emitFileKey = !host.useCaseSensitiveFileNames() ? ts.toFileNameLowerCase(emitFilePath) : emitFilePath;
                    // Report error if multiple files write into same file
                    if (emitFilesSeen.has(emitFileKey)) {
                        // Already seen the same emit file - report error
                        blockEmittingOfFile(emitFileName, ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files, emitFileName));
                    }
                    else {
                        emitFilesSeen.add(emitFileKey);
                    }
                }
            }
        }
        function createDiagnosticExplainingFile(file, fileProcessingReason, diagnostic, args) {
            var _a;
            var fileIncludeReasons;
            var relatedInfo;
            var locationReason = isReferencedFile(fileProcessingReason) ? fileProcessingReason : undefined;
            if (file)
                (_a = fileReasons.get(file.path)) === null || _a === void 0 ? void 0 : _a.forEach(processReason);
            if (fileProcessingReason)
                processReason(fileProcessingReason);
            // If we have location and there is only one reason file is in which is the location, dont add details for file include
            if (locationReason && (fileIncludeReasons === null || fileIncludeReasons === void 0 ? void 0 : fileIncludeReasons.length) === 1)
                fileIncludeReasons = undefined;
            var location = locationReason && getReferencedFileLocation(getSourceFileByPath, locationReason);
            var fileIncludeReasonDetails = fileIncludeReasons && ts.chainDiagnosticMessages(fileIncludeReasons, ts.Diagnostics.The_file_is_in_the_program_because_Colon);
            var redirectInfo = file && ts.explainIfFileIsRedirect(file);
            var chain = ts.chainDiagnosticMessages.apply(void 0, __spreadArray([redirectInfo ? fileIncludeReasonDetails ? __spreadArray([fileIncludeReasonDetails], redirectInfo, true) : redirectInfo : fileIncludeReasonDetails, diagnostic], args || ts.emptyArray, false));
            return location && isReferenceFileLocation(location) ?
                ts.createFileDiagnosticFromMessageChain(location.file, location.pos, location.end - location.pos, chain, relatedInfo) :
                ts.createCompilerDiagnosticFromMessageChain(chain, relatedInfo);
            function processReason(reason) {
                (fileIncludeReasons || (fileIncludeReasons = [])).push(ts.fileIncludeReasonToDiagnostics(program, reason));
                if (!locationReason && isReferencedFile(reason)) {
                    // Report error at first reference file or file currently in processing and dont report in related information
                    locationReason = reason;
                }
                else if (locationReason !== reason) {
                    relatedInfo = ts.append(relatedInfo, fileIncludeReasonToRelatedInformation(reason));
                }
                // Remove fileProcessingReason if its already included in fileReasons of the program
                if (reason === fileProcessingReason)
                    fileProcessingReason = undefined;
            }
        }
        function addFilePreprocessingFileExplainingDiagnostic(file, fileProcessingReason, diagnostic, args) {
            (fileProcessingDiagnostics || (fileProcessingDiagnostics = [])).push({
                kind: 1 /* FilePreprocessingDiagnosticsKind.FilePreprocessingFileExplainingDiagnostic */,
                file: file && file.path,
                fileProcessingReason: fileProcessingReason,
                diagnostic: diagnostic,
                args: args
            });
        }
        function addProgramDiagnosticExplainingFile(file, diagnostic, args) {
            programDiagnostics.add(createDiagnosticExplainingFile(file, /*fileProcessingReason*/ undefined, diagnostic, args));
        }
        function fileIncludeReasonToRelatedInformation(reason) {
            if (isReferencedFile(reason)) {
                var referenceLocation = getReferencedFileLocation(getSourceFileByPath, reason);
                var message_2;
                switch (reason.kind) {
                    case ts.FileIncludeKind.Import:
                        message_2 = ts.Diagnostics.File_is_included_via_import_here;
                        break;
                    case ts.FileIncludeKind.ReferenceFile:
                        message_2 = ts.Diagnostics.File_is_included_via_reference_here;
                        break;
                    case ts.FileIncludeKind.TypeReferenceDirective:
                        message_2 = ts.Diagnostics.File_is_included_via_type_library_reference_here;
                        break;
                    case ts.FileIncludeKind.LibReferenceDirective:
                        message_2 = ts.Diagnostics.File_is_included_via_library_reference_here;
                        break;
                    default:
                        ts.Debug.assertNever(reason);
                }
                return isReferenceFileLocation(referenceLocation) ? ts.createFileDiagnostic(referenceLocation.file, referenceLocation.pos, referenceLocation.end - referenceLocation.pos, message_2) : undefined;
            }
            if (!options.configFile)
                return undefined;
            var configFileNode;
            var message;
            switch (reason.kind) {
                case ts.FileIncludeKind.RootFile:
                    if (!options.configFile.configFileSpecs)
                        return undefined;
                    var fileName = ts.getNormalizedAbsolutePath(rootNames[reason.index], currentDirectory);
                    var matchedByFiles = ts.getMatchedFileSpec(program, fileName);
                    if (matchedByFiles) {
                        configFileNode = ts.getTsConfigPropArrayElementValue(options.configFile, "files", matchedByFiles);
                        message = ts.Diagnostics.File_is_matched_by_files_list_specified_here;
                        break;
                    }
                    var matchedByInclude = ts.getMatchedIncludeSpec(program, fileName);
                    // Could be additional files specified as roots
                    if (!matchedByInclude)
                        return undefined;
                    configFileNode = ts.getTsConfigPropArrayElementValue(options.configFile, "include", matchedByInclude);
                    message = ts.Diagnostics.File_is_matched_by_include_pattern_specified_here;
                    break;
                case ts.FileIncludeKind.SourceFromProjectReference:
                case ts.FileIncludeKind.OutputFromProjectReference:
                    var referencedResolvedRef_1 = ts.Debug.checkDefined(resolvedProjectReferences === null || resolvedProjectReferences === void 0 ? void 0 : resolvedProjectReferences[reason.index]);
                    var referenceInfo = forEachProjectReference(projectReferences, resolvedProjectReferences, function (resolvedRef, parent, index) {
                        return resolvedRef === referencedResolvedRef_1 ? { sourceFile: (parent === null || parent === void 0 ? void 0 : parent.sourceFile) || options.configFile, index: index } : undefined;
                    });
                    if (!referenceInfo)
                        return undefined;
                    var sourceFile = referenceInfo.sourceFile, index = referenceInfo.index;
                    var referencesSyntax = ts.firstDefined(ts.getTsConfigPropArray(sourceFile, "references"), function (property) { return ts.isArrayLiteralExpression(property.initializer) ? property.initializer : undefined; });
                    return referencesSyntax && referencesSyntax.elements.length > index ?
                        ts.createDiagnosticForNodeInSourceFile(sourceFile, referencesSyntax.elements[index], reason.kind === ts.FileIncludeKind.OutputFromProjectReference ?
                            ts.Diagnostics.File_is_output_from_referenced_project_specified_here :
                            ts.Diagnostics.File_is_source_from_referenced_project_specified_here) :
                        undefined;
                case ts.FileIncludeKind.AutomaticTypeDirectiveFile:
                    if (!options.types)
                        return undefined;
                    configFileNode = getOptionsSyntaxByArrayElementValue("types", reason.typeReference);
                    message = ts.Diagnostics.File_is_entry_point_of_type_library_specified_here;
                    break;
                case ts.FileIncludeKind.LibFile:
                    if (reason.index !== undefined) {
                        configFileNode = getOptionsSyntaxByArrayElementValue("lib", options.lib[reason.index]);
                        message = ts.Diagnostics.File_is_library_specified_here;
                        break;
                    }
                    var target = ts.forEachEntry(ts.targetOptionDeclaration.type, function (value, key) { return value === ts.getEmitScriptTarget(options) ? key : undefined; });
                    configFileNode = target ? getOptionsSyntaxByValue("target", target) : undefined;
                    message = ts.Diagnostics.File_is_default_library_for_target_specified_here;
                    break;
                default:
                    ts.Debug.assertNever(reason);
            }
            return configFileNode && ts.createDiagnosticForNodeInSourceFile(options.configFile, configFileNode, message);
        }
        function verifyProjectReferences() {
            var buildInfoPath = !options.suppressOutputPathCheck ? ts.getTsBuildInfoEmitOutputFilePath(options) : undefined;
            forEachProjectReference(projectReferences, resolvedProjectReferences, function (resolvedRef, parent, index) {
                var ref = (parent ? parent.commandLine.projectReferences : projectReferences)[index];
                var parentFile = parent && parent.sourceFile;
                if (!resolvedRef) {
                    createDiagnosticForReference(parentFile, index, ts.Diagnostics.File_0_not_found, ref.path);
                    return;
                }
                var options = resolvedRef.commandLine.options;
                if (!options.composite || options.noEmit) {
                    // ok to not have composite if the current program is container only
                    var inputs = parent ? parent.commandLine.fileNames : rootNames;
                    if (inputs.length) {
                        if (!options.composite)
                            createDiagnosticForReference(parentFile, index, ts.Diagnostics.Referenced_project_0_must_have_setting_composite_Colon_true, ref.path);
                        if (options.noEmit)
                            createDiagnosticForReference(parentFile, index, ts.Diagnostics.Referenced_project_0_may_not_disable_emit, ref.path);
                    }
                }
                if (ref.prepend) {
                    var out = ts.outFile(options);
                    if (out) {
                        if (!host.fileExists(out)) {
                            createDiagnosticForReference(parentFile, index, ts.Diagnostics.Output_file_0_from_project_1_does_not_exist, out, ref.path);
                        }
                    }
                    else {
                        createDiagnosticForReference(parentFile, index, ts.Diagnostics.Cannot_prepend_project_0_because_it_does_not_have_outFile_set, ref.path);
                    }
                }
                if (!parent && buildInfoPath && buildInfoPath === ts.getTsBuildInfoEmitOutputFilePath(options)) {
                    createDiagnosticForReference(parentFile, index, ts.Diagnostics.Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1, buildInfoPath, ref.path);
                    hasEmitBlockingDiagnostics.set(toPath(buildInfoPath), true);
                }
            });
        }
        function createDiagnosticForOptionPathKeyValue(key, valueIndex, message, arg0, arg1, arg2) {
            var needCompilerDiagnostic = true;
            var pathsSyntax = getOptionPathsSyntax();
            for (var _i = 0, pathsSyntax_1 = pathsSyntax; _i < pathsSyntax_1.length; _i++) {
                var pathProp = pathsSyntax_1[_i];
                if (ts.isObjectLiteralExpression(pathProp.initializer)) {
                    for (var _a = 0, _b = ts.getPropertyAssignment(pathProp.initializer, key); _a < _b.length; _a++) {
                        var keyProps = _b[_a];
                        var initializer = keyProps.initializer;
                        if (ts.isArrayLiteralExpression(initializer) && initializer.elements.length > valueIndex) {
                            programDiagnostics.add(ts.createDiagnosticForNodeInSourceFile(options.configFile, initializer.elements[valueIndex], message, arg0, arg1, arg2));
                            needCompilerDiagnostic = false;
                        }
                    }
                }
            }
            if (needCompilerDiagnostic) {
                programDiagnostics.add(ts.createCompilerDiagnostic(message, arg0, arg1, arg2));
            }
        }
        function createDiagnosticForOptionPaths(onKey, key, message, arg0) {
            var needCompilerDiagnostic = true;
            var pathsSyntax = getOptionPathsSyntax();
            for (var _i = 0, pathsSyntax_2 = pathsSyntax; _i < pathsSyntax_2.length; _i++) {
                var pathProp = pathsSyntax_2[_i];
                if (ts.isObjectLiteralExpression(pathProp.initializer) &&
                    createOptionDiagnosticInObjectLiteralSyntax(pathProp.initializer, onKey, key, /*key2*/ undefined, message, arg0)) {
                    needCompilerDiagnostic = false;
                }
            }
            if (needCompilerDiagnostic) {
                programDiagnostics.add(ts.createCompilerDiagnostic(message, arg0));
            }
        }
        function getOptionsSyntaxByName(name) {
            var compilerOptionsObjectLiteralSyntax = getCompilerOptionsObjectLiteralSyntax();
            return compilerOptionsObjectLiteralSyntax && ts.getPropertyAssignment(compilerOptionsObjectLiteralSyntax, name);
        }
        function getOptionPathsSyntax() {
            return getOptionsSyntaxByName("paths") || ts.emptyArray;
        }
        function getOptionsSyntaxByValue(name, value) {
            var syntaxByName = getOptionsSyntaxByName(name);
            return syntaxByName && ts.firstDefined(syntaxByName, function (property) { return ts.isStringLiteral(property.initializer) && property.initializer.text === value ? property.initializer : undefined; });
        }
        function getOptionsSyntaxByArrayElementValue(name, value) {
            var compilerOptionsObjectLiteralSyntax = getCompilerOptionsObjectLiteralSyntax();
            return compilerOptionsObjectLiteralSyntax && ts.getPropertyArrayElementValue(compilerOptionsObjectLiteralSyntax, name, value);
        }
        function createDiagnosticForOptionName(message, option1, option2, option3) {
            createDiagnosticForOption(/*onKey*/ true, option1, option2, message, option1, option2, option3);
        }
        function createOptionValueDiagnostic(option1, message, arg0, arg1) {
            createDiagnosticForOption(/*onKey*/ false, option1, /*option2*/ undefined, message, arg0, arg1);
        }
        function createDiagnosticForReference(sourceFile, index, message, arg0, arg1) {
            var referencesSyntax = ts.firstDefined(ts.getTsConfigPropArray(sourceFile || options.configFile, "references"), function (property) { return ts.isArrayLiteralExpression(property.initializer) ? property.initializer : undefined; });
            if (referencesSyntax && referencesSyntax.elements.length > index) {
                programDiagnostics.add(ts.createDiagnosticForNodeInSourceFile(sourceFile || options.configFile, referencesSyntax.elements[index], message, arg0, arg1));
            }
            else {
                programDiagnostics.add(ts.createCompilerDiagnostic(message, arg0, arg1));
            }
        }
        function createDiagnosticForOption(onKey, option1, option2, message, arg0, arg1, arg2) {
            var compilerOptionsObjectLiteralSyntax = getCompilerOptionsObjectLiteralSyntax();
            var needCompilerDiagnostic = !compilerOptionsObjectLiteralSyntax ||
                !createOptionDiagnosticInObjectLiteralSyntax(compilerOptionsObjectLiteralSyntax, onKey, option1, option2, message, arg0, arg1, arg2);
            if (needCompilerDiagnostic) {
                programDiagnostics.add(ts.createCompilerDiagnostic(message, arg0, arg1, arg2));
            }
        }
        function getCompilerOptionsObjectLiteralSyntax() {
            if (_compilerOptionsObjectLiteralSyntax === undefined) {
                _compilerOptionsObjectLiteralSyntax = false;
                var jsonObjectLiteral = ts.getTsConfigObjectLiteralExpression(options.configFile);
                if (jsonObjectLiteral) {
                    for (var _i = 0, _a = ts.getPropertyAssignment(jsonObjectLiteral, "compilerOptions"); _i < _a.length; _i++) {
                        var prop = _a[_i];
                        if (ts.isObjectLiteralExpression(prop.initializer)) {
                            _compilerOptionsObjectLiteralSyntax = prop.initializer;
                            break;
                        }
                    }
                }
            }
            return _compilerOptionsObjectLiteralSyntax || undefined;
        }
        function createOptionDiagnosticInObjectLiteralSyntax(objectLiteral, onKey, key1, key2, message, arg0, arg1, arg2) {
            var props = ts.getPropertyAssignment(objectLiteral, key1, key2);
            for (var _i = 0, props_3 = props; _i < props_3.length; _i++) {
                var prop = props_3[_i];
                programDiagnostics.add(ts.createDiagnosticForNodeInSourceFile(options.configFile, onKey ? prop.name : prop.initializer, message, arg0, arg1, arg2));
            }
            return !!props.length;
        }
        function blockEmittingOfFile(emitFileName, diag) {
            hasEmitBlockingDiagnostics.set(toPath(emitFileName), true);
            programDiagnostics.add(diag);
        }
        function isEmittedFile(file) {
            if (options.noEmit) {
                return false;
            }
            // If this is source file, its not emitted file
            var filePath = toPath(file);
            if (getSourceFileByPath(filePath)) {
                return false;
            }
            // If options have --outFile or --out just check that
            var out = ts.outFile(options);
            if (out) {
                return isSameFile(filePath, out) || isSameFile(filePath, ts.removeFileExtension(out) + ".d.ts" /* Extension.Dts */);
            }
            // If declarationDir is specified, return if its a file in that directory
            if (options.declarationDir && ts.containsPath(options.declarationDir, filePath, currentDirectory, !host.useCaseSensitiveFileNames())) {
                return true;
            }
            // If --outDir, check if file is in that directory
            if (options.outDir) {
                return ts.containsPath(options.outDir, filePath, currentDirectory, !host.useCaseSensitiveFileNames());
            }
            if (ts.fileExtensionIsOneOf(filePath, ts.supportedJSExtensionsFlat) || ts.isDeclarationFileName(filePath)) {
                // Otherwise just check if sourceFile with the name exists
                var filePathWithoutExtension = ts.removeFileExtension(filePath);
                return !!getSourceFileByPath((filePathWithoutExtension + ".ts" /* Extension.Ts */)) ||
                    !!getSourceFileByPath((filePathWithoutExtension + ".tsx" /* Extension.Tsx */));
            }
            return false;
        }
        function isSameFile(file1, file2) {
            return ts.comparePaths(file1, file2, currentDirectory, !host.useCaseSensitiveFileNames()) === 0 /* Comparison.EqualTo */;
        }
        function getSymlinkCache() {
            if (host.getSymlinkCache) {
                return host.getSymlinkCache();
            }
            if (!symlinks) {
                symlinks = ts.createSymlinkCache(currentDirectory, getCanonicalFileName);
            }
            if (files && resolvedTypeReferenceDirectives && !symlinks.hasProcessedResolutions()) {
                symlinks.setSymlinksFromResolutions(files, resolvedTypeReferenceDirectives);
            }
            return symlinks;
        }
    }
    ts.createProgram = createProgram;
    function updateHostForUseSourceOfProjectReferenceRedirect(host) {
        var setOfDeclarationDirectories;
        var originalFileExists = host.compilerHost.fileExists;
        var originalDirectoryExists = host.compilerHost.directoryExists;
        var originalGetDirectories = host.compilerHost.getDirectories;
        var originalRealpath = host.compilerHost.realpath;
        if (!host.useSourceOfProjectReferenceRedirect)
            return { onProgramCreateComplete: ts.noop, fileExists: fileExists };
        host.compilerHost.fileExists = fileExists;
        var directoryExists;
        if (originalDirectoryExists) {
            // This implementation of directoryExists checks if the directory being requested is
            // directory of .d.ts file for the referenced Project.
            // If it is it returns true irrespective of whether that directory exists on host
            directoryExists = host.compilerHost.directoryExists = function (path) {
                if (originalDirectoryExists.call(host.compilerHost, path)) {
                    handleDirectoryCouldBeSymlink(path);
                    return true;
                }
                if (!host.getResolvedProjectReferences())
                    return false;
                if (!setOfDeclarationDirectories) {
                    setOfDeclarationDirectories = new ts.Set();
                    host.forEachResolvedProjectReference(function (ref) {
                        var out = ts.outFile(ref.commandLine.options);
                        if (out) {
                            setOfDeclarationDirectories.add(ts.getDirectoryPath(host.toPath(out)));
                        }
                        else {
                            // Set declaration's in different locations only, if they are next to source the directory present doesnt change
                            var declarationDir = ref.commandLine.options.declarationDir || ref.commandLine.options.outDir;
                            if (declarationDir) {
                                setOfDeclarationDirectories.add(host.toPath(declarationDir));
                            }
                        }
                    });
                }
                return fileOrDirectoryExistsUsingSource(path, /*isFile*/ false);
            };
        }
        if (originalGetDirectories) {
            // Call getDirectories only if directory actually present on the host
            // This is needed to ensure that we arent getting directories that we fake about presence for
            host.compilerHost.getDirectories = function (path) {
                return !host.getResolvedProjectReferences() || (originalDirectoryExists && originalDirectoryExists.call(host.compilerHost, path)) ?
                    originalGetDirectories.call(host.compilerHost, path) :
                    [];
            };
        }
        // This is something we keep for life time of the host
        if (originalRealpath) {
            host.compilerHost.realpath = function (s) {
                var _a;
                return ((_a = host.getSymlinkCache().getSymlinkedFiles()) === null || _a === void 0 ? void 0 : _a.get(host.toPath(s))) ||
                    originalRealpath.call(host.compilerHost, s);
            };
        }
        return { onProgramCreateComplete: onProgramCreateComplete, fileExists: fileExists, directoryExists: directoryExists };
        function onProgramCreateComplete() {
            host.compilerHost.fileExists = originalFileExists;
            host.compilerHost.directoryExists = originalDirectoryExists;
            host.compilerHost.getDirectories = originalGetDirectories;
            // DO not revert realpath as it could be used later
        }
        // This implementation of fileExists checks if the file being requested is
        // .d.ts file for the referenced Project.
        // If it is it returns true irrespective of whether that file exists on host
        function fileExists(file) {
            if (originalFileExists.call(host.compilerHost, file))
                return true;
            if (!host.getResolvedProjectReferences())
                return false;
            if (!ts.isDeclarationFileName(file))
                return false;
            // Project references go to source file instead of .d.ts file
            return fileOrDirectoryExistsUsingSource(file, /*isFile*/ true);
        }
        function fileExistsIfProjectReferenceDts(file) {
            var source = host.getSourceOfProjectReferenceRedirect(host.toPath(file));
            return source !== undefined ?
                ts.isString(source) ? originalFileExists.call(host.compilerHost, source) : true :
                undefined;
        }
        function directoryExistsIfProjectReferenceDeclDir(dir) {
            var dirPath = host.toPath(dir);
            var dirPathWithTrailingDirectorySeparator = "".concat(dirPath).concat(ts.directorySeparator);
            return ts.forEachKey(setOfDeclarationDirectories, function (declDirPath) { return dirPath === declDirPath ||
                // Any parent directory of declaration dir
                ts.startsWith(declDirPath, dirPathWithTrailingDirectorySeparator) ||
                // Any directory inside declaration dir
                ts.startsWith(dirPath, "".concat(declDirPath, "/")); });
        }
        function handleDirectoryCouldBeSymlink(directory) {
            var _a;
            if (!host.getResolvedProjectReferences() || ts.containsIgnoredPath(directory))
                return;
            // Because we already watch node_modules, handle symlinks in there
            if (!originalRealpath || !ts.stringContains(directory, ts.nodeModulesPathPart))
                return;
            var symlinkCache = host.getSymlinkCache();
            var directoryPath = ts.ensureTrailingDirectorySeparator(host.toPath(directory));
            if ((_a = symlinkCache.getSymlinkedDirectories()) === null || _a === void 0 ? void 0 : _a.has(directoryPath))
                return;
            var real = ts.normalizePath(originalRealpath.call(host.compilerHost, directory));
            var realPath;
            if (real === directory ||
                (realPath = ts.ensureTrailingDirectorySeparator(host.toPath(real))) === directoryPath) {
                // not symlinked
                symlinkCache.setSymlinkedDirectory(directoryPath, false);
                return;
            }
            symlinkCache.setSymlinkedDirectory(directory, {
                real: ts.ensureTrailingDirectorySeparator(real),
                realPath: realPath
            });
        }
        function fileOrDirectoryExistsUsingSource(fileOrDirectory, isFile) {
            var _a;
            var fileOrDirectoryExistsUsingSource = isFile ?
                function (file) { return fileExistsIfProjectReferenceDts(file); } :
                function (dir) { return directoryExistsIfProjectReferenceDeclDir(dir); };
            // Check current directory or file
            var result = fileOrDirectoryExistsUsingSource(fileOrDirectory);
            if (result !== undefined)
                return result;
            var symlinkCache = host.getSymlinkCache();
            var symlinkedDirectories = symlinkCache.getSymlinkedDirectories();
            if (!symlinkedDirectories)
                return false;
            var fileOrDirectoryPath = host.toPath(fileOrDirectory);
            if (!ts.stringContains(fileOrDirectoryPath, ts.nodeModulesPathPart))
                return false;
            if (isFile && ((_a = symlinkCache.getSymlinkedFiles()) === null || _a === void 0 ? void 0 : _a.has(fileOrDirectoryPath)))
                return true;
            // If it contains node_modules check if its one of the symlinked path we know of
            return ts.firstDefinedIterator(symlinkedDirectories.entries(), function (_a) {
                var directoryPath = _a[0], symlinkedDirectory = _a[1];
                if (!symlinkedDirectory || !ts.startsWith(fileOrDirectoryPath, directoryPath))
                    return undefined;
                var result = fileOrDirectoryExistsUsingSource(fileOrDirectoryPath.replace(directoryPath, symlinkedDirectory.realPath));
                if (isFile && result) {
                    // Store the real path for the file'
                    var absolutePath = ts.getNormalizedAbsolutePath(fileOrDirectory, host.compilerHost.getCurrentDirectory());
                    symlinkCache.setSymlinkedFile(fileOrDirectoryPath, "".concat(symlinkedDirectory.real).concat(absolutePath.replace(new RegExp(directoryPath, "i"), "")));
                }
                return result;
            }) || false;
        }
    }
    /*@internal*/
    ts.emitSkippedWithNoDiagnostics = { diagnostics: ts.emptyArray, sourceMaps: undefined, emittedFiles: undefined, emitSkipped: true };
    /*@internal*/
    function handleNoEmitOptions(program, sourceFile, writeFile, cancellationToken) {
        var options = program.getCompilerOptions();
        if (options.noEmit) {
            // Cache the semantic diagnostics
            program.getSemanticDiagnostics(sourceFile, cancellationToken);
            return sourceFile || ts.outFile(options) ?
                ts.emitSkippedWithNoDiagnostics :
                program.emitBuildInfo(writeFile, cancellationToken);
        }
        // If the noEmitOnError flag is set, then check if we have any errors so far.  If so,
        // immediately bail out.  Note that we pass 'undefined' for 'sourceFile' so that we
        // get any preEmit diagnostics, not just the ones
        if (!options.noEmitOnError)
            return undefined;
        var diagnostics = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], program.getOptionsDiagnostics(cancellationToken), true), program.getSyntacticDiagnostics(sourceFile, cancellationToken), true), program.getGlobalDiagnostics(cancellationToken), true), program.getSemanticDiagnostics(sourceFile, cancellationToken), true);
        if (diagnostics.length === 0 && ts.getEmitDeclarations(program.getCompilerOptions())) {
            diagnostics = program.getDeclarationDiagnostics(/*sourceFile*/ undefined, cancellationToken);
        }
        if (!diagnostics.length)
            return undefined;
        var emittedFiles;
        if (!sourceFile && !ts.outFile(options)) {
            var emitResult = program.emitBuildInfo(writeFile, cancellationToken);
            if (emitResult.diagnostics)
                diagnostics = __spreadArray(__spreadArray([], diagnostics, true), emitResult.diagnostics, true);
            emittedFiles = emitResult.emittedFiles;
        }
        return { diagnostics: diagnostics, sourceMaps: undefined, emittedFiles: emittedFiles, emitSkipped: true };
    }
    ts.handleNoEmitOptions = handleNoEmitOptions;
    /*@internal*/
    function filterSemanticDiagnostics(diagnostic, option) {
        return ts.filter(diagnostic, function (d) { return !d.skippedOn || !option[d.skippedOn]; });
    }
    ts.filterSemanticDiagnostics = filterSemanticDiagnostics;
    /* @internal */
    function parseConfigHostFromCompilerHostLike(host, directoryStructureHost) {
        if (directoryStructureHost === void 0) { directoryStructureHost = host; }
        return {
            fileExists: function (f) { return directoryStructureHost.fileExists(f); },
            readDirectory: function (root, extensions, excludes, includes, depth) {
                ts.Debug.assertIsDefined(directoryStructureHost.readDirectory, "'CompilerHost.readDirectory' must be implemented to correctly process 'projectReferences'");
                return directoryStructureHost.readDirectory(root, extensions, excludes, includes, depth);
            },
            readFile: function (f) { return directoryStructureHost.readFile(f); },
            useCaseSensitiveFileNames: host.useCaseSensitiveFileNames(),
            getCurrentDirectory: function () { return host.getCurrentDirectory(); },
            onUnRecoverableConfigFileDiagnostic: host.onUnRecoverableConfigFileDiagnostic || ts.returnUndefined,
            trace: host.trace ? function (s) { return host.trace(s); } : undefined
        };
    }
    ts.parseConfigHostFromCompilerHostLike = parseConfigHostFromCompilerHostLike;
    /* @internal */
    function createPrependNodes(projectReferences, getCommandLine, readFile) {
        if (!projectReferences)
            return ts.emptyArray;
        var nodes;
        for (var i = 0; i < projectReferences.length; i++) {
            var ref = projectReferences[i];
            var resolvedRefOpts = getCommandLine(ref, i);
            if (ref.prepend && resolvedRefOpts && resolvedRefOpts.options) {
                var out = ts.outFile(resolvedRefOpts.options);
                // Upstream project didn't have outFile set -- skip (error will have been issued earlier)
                if (!out)
                    continue;
                var _a = ts.getOutputPathsForBundle(resolvedRefOpts.options, /*forceDtsPaths*/ true), jsFilePath = _a.jsFilePath, sourceMapFilePath = _a.sourceMapFilePath, declarationFilePath = _a.declarationFilePath, declarationMapPath = _a.declarationMapPath, buildInfoPath = _a.buildInfoPath;
                var node = ts.createInputFiles(readFile, jsFilePath, sourceMapFilePath, declarationFilePath, declarationMapPath, buildInfoPath);
                (nodes || (nodes = [])).push(node);
            }
        }
        return nodes || ts.emptyArray;
    }
    ts.createPrependNodes = createPrependNodes;
    function resolveProjectReferencePath(hostOrRef, ref) {
        var passedInRef = ref ? ref : hostOrRef;
        return ts.resolveConfigFileProjectName(passedInRef.path);
    }
    ts.resolveProjectReferencePath = resolveProjectReferencePath;
    /* @internal */
    /**
     * Returns a DiagnosticMessage if we won't include a resolved module due to its extension.
     * The DiagnosticMessage's parameters are the imported module name, and the filename it resolved to.
     * This returns a diagnostic even if the module will be an untyped module.
     */
    function getResolutionDiagnostic(options, _a) {
        var extension = _a.extension;
        switch (extension) {
            case ".ts" /* Extension.Ts */:
            case ".d.ts" /* Extension.Dts */:
                // These are always allowed.
                return undefined;
            case ".tsx" /* Extension.Tsx */:
                return needJsx();
            case ".jsx" /* Extension.Jsx */:
                return needJsx() || needAllowJs();
            case ".js" /* Extension.Js */:
                return needAllowJs();
            case ".json" /* Extension.Json */:
                return needResolveJsonModule();
        }
        function needJsx() {
            return options.jsx ? undefined : ts.Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set;
        }
        function needAllowJs() {
            return ts.getAllowJSCompilerOption(options) || !ts.getStrictOptionValue(options, "noImplicitAny") ? undefined : ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type;
        }
        function needResolveJsonModule() {
            return options.resolveJsonModule ? undefined : ts.Diagnostics.Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used;
        }
    }
    ts.getResolutionDiagnostic = getResolutionDiagnostic;
    function getModuleNames(_a) {
        var imports = _a.imports, moduleAugmentations = _a.moduleAugmentations;
        var res = imports.map(function (i) { return i.text; });
        for (var _i = 0, moduleAugmentations_1 = moduleAugmentations; _i < moduleAugmentations_1.length; _i++) {
            var aug = moduleAugmentations_1[_i];
            if (aug.kind === 10 /* SyntaxKind.StringLiteral */) {
                res.push(aug.text);
            }
            // Do nothing if it's an Identifier; we don't need to do module resolution for `declare global`.
        }
        return res;
    }
    /* @internal */
    function getModuleNameStringLiteralAt(_a, index) {
        var imports = _a.imports, moduleAugmentations = _a.moduleAugmentations;
        if (index < imports.length)
            return imports[index];
        var augIndex = imports.length;
        for (var _i = 0, moduleAugmentations_2 = moduleAugmentations; _i < moduleAugmentations_2.length; _i++) {
            var aug = moduleAugmentations_2[_i];
            if (aug.kind === 10 /* SyntaxKind.StringLiteral */) {
                if (index === augIndex)
                    return aug;
                augIndex++;
            }
            // Do nothing if it's an Identifier; we don't need to do module resolution for `declare global`.
        }
        ts.Debug.fail("should never ask for module name at index higher than possible module name");
    }
    ts.getModuleNameStringLiteralAt = getModuleNameStringLiteralAt;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function getFileEmitOutput(program, sourceFile, emitOnlyDtsFiles, cancellationToken, customTransformers, forceDtsEmit) {
        var outputFiles = [];
        var _a = program.emit(sourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers, forceDtsEmit), emitSkipped = _a.emitSkipped, diagnostics = _a.diagnostics, exportedModulesFromDeclarationEmit = _a.exportedModulesFromDeclarationEmit;
        return { outputFiles: outputFiles, emitSkipped: emitSkipped, diagnostics: diagnostics, exportedModulesFromDeclarationEmit: exportedModulesFromDeclarationEmit };
        function writeFile(fileName, text, writeByteOrderMark) {
            outputFiles.push({ name: fileName, writeByteOrderMark: writeByteOrderMark, text: text });
        }
    }
    ts.getFileEmitOutput = getFileEmitOutput;
    var BuilderState;
    (function (BuilderState) {
        function createManyToManyPathMap() {
            function create(forward, reverse, deleted) {
                var map = {
                    clone: function () { return create(new ts.Map(forward), new ts.Map(reverse), deleted && new ts.Set(deleted)); },
                    forEach: function (fn) { return forward.forEach(fn); },
                    getKeys: function (v) { return reverse.get(v); },
                    getValues: function (k) { return forward.get(k); },
                    hasKey: function (k) { return forward.has(k); },
                    keys: function () { return forward.keys(); },
                    deletedKeys: function () { return deleted; },
                    deleteKey: function (k) {
                        (deleted || (deleted = new ts.Set())).add(k);
                        var set = forward.get(k);
                        if (!set) {
                            return false;
                        }
                        set.forEach(function (v) { return deleteFromMultimap(reverse, v, k); });
                        forward.delete(k);
                        return true;
                    },
                    set: function (k, vSet) {
                        deleted === null || deleted === void 0 ? void 0 : deleted.delete(k);
                        var existingVSet = forward.get(k);
                        forward.set(k, vSet);
                        existingVSet === null || existingVSet === void 0 ? void 0 : existingVSet.forEach(function (v) {
                            if (!vSet.has(v)) {
                                deleteFromMultimap(reverse, v, k);
                            }
                        });
                        vSet.forEach(function (v) {
                            if (!(existingVSet === null || existingVSet === void 0 ? void 0 : existingVSet.has(v))) {
                                addToMultimap(reverse, v, k);
                            }
                        });
                        return map;
                    },
                    clear: function () {
                        forward.clear();
                        reverse.clear();
                        deleted === null || deleted === void 0 ? void 0 : deleted.clear();
                    }
                };
                return map;
            }
            return create(new ts.Map(), new ts.Map(), /*deleted*/ undefined);
        }
        BuilderState.createManyToManyPathMap = createManyToManyPathMap;
        function addToMultimap(map, k, v) {
            var set = map.get(k);
            if (!set) {
                set = new ts.Set();
                map.set(k, set);
            }
            set.add(v);
        }
        function deleteFromMultimap(map, k, v) {
            var set = map.get(k);
            if (set === null || set === void 0 ? void 0 : set.delete(v)) {
                if (!set.size) {
                    map.delete(k);
                }
                return true;
            }
            return false;
        }
        function getReferencedFilesFromImportedModuleSymbol(symbol) {
            return ts.mapDefined(symbol.declarations, function (declaration) { var _a; return (_a = ts.getSourceFileOfNode(declaration)) === null || _a === void 0 ? void 0 : _a.resolvedPath; });
        }
        /**
         * Get the module source file and all augmenting files from the import name node from file
         */
        function getReferencedFilesFromImportLiteral(checker, importName) {
            var symbol = checker.getSymbolAtLocation(importName);
            return symbol && getReferencedFilesFromImportedModuleSymbol(symbol);
        }
        /**
         * Gets the path to reference file from file name, it could be resolvedPath if present otherwise path
         */
        function getReferencedFileFromFileName(program, fileName, sourceFileDirectory, getCanonicalFileName) {
            return ts.toPath(program.getProjectReferenceRedirect(fileName) || fileName, sourceFileDirectory, getCanonicalFileName);
        }
        /**
         * Gets the referenced files for a file from the program with values for the keys as referenced file's path to be true
         */
        function getReferencedFiles(program, sourceFile, getCanonicalFileName) {
            var referencedFiles;
            // We need to use a set here since the code can contain the same import twice,
            // but that will only be one dependency.
            // To avoid invernal conversion, the key of the referencedFiles map must be of type Path
            if (sourceFile.imports && sourceFile.imports.length > 0) {
                var checker = program.getTypeChecker();
                for (var _i = 0, _a = sourceFile.imports; _i < _a.length; _i++) {
                    var importName = _a[_i];
                    var declarationSourceFilePaths = getReferencedFilesFromImportLiteral(checker, importName);
                    declarationSourceFilePaths === null || declarationSourceFilePaths === void 0 ? void 0 : declarationSourceFilePaths.forEach(addReferencedFile);
                }
            }
            var sourceFileDirectory = ts.getDirectoryPath(sourceFile.resolvedPath);
            // Handle triple slash references
            if (sourceFile.referencedFiles && sourceFile.referencedFiles.length > 0) {
                for (var _b = 0, _c = sourceFile.referencedFiles; _b < _c.length; _b++) {
                    var referencedFile = _c[_b];
                    var referencedPath = getReferencedFileFromFileName(program, referencedFile.fileName, sourceFileDirectory, getCanonicalFileName);
                    addReferencedFile(referencedPath);
                }
            }
            // Handle type reference directives
            if (sourceFile.resolvedTypeReferenceDirectiveNames) {
                sourceFile.resolvedTypeReferenceDirectiveNames.forEach(function (resolvedTypeReferenceDirective) {
                    if (!resolvedTypeReferenceDirective) {
                        return;
                    }
                    var fileName = resolvedTypeReferenceDirective.resolvedFileName; // TODO: GH#18217
                    var typeFilePath = getReferencedFileFromFileName(program, fileName, sourceFileDirectory, getCanonicalFileName);
                    addReferencedFile(typeFilePath);
                });
            }
            // Add module augmentation as references
            if (sourceFile.moduleAugmentations.length) {
                var checker = program.getTypeChecker();
                for (var _d = 0, _e = sourceFile.moduleAugmentations; _d < _e.length; _d++) {
                    var moduleName = _e[_d];
                    if (!ts.isStringLiteral(moduleName))
                        continue;
                    var symbol = checker.getSymbolAtLocation(moduleName);
                    if (!symbol)
                        continue;
                    // Add any file other than our own as reference
                    addReferenceFromAmbientModule(symbol);
                }
            }
            // From ambient modules
            for (var _f = 0, _g = program.getTypeChecker().getAmbientModules(); _f < _g.length; _f++) {
                var ambientModule = _g[_f];
                if (ambientModule.declarations && ambientModule.declarations.length > 1) {
                    addReferenceFromAmbientModule(ambientModule);
                }
            }
            return referencedFiles;
            function addReferenceFromAmbientModule(symbol) {
                if (!symbol.declarations) {
                    return;
                }
                // Add any file other than our own as reference
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    var declarationSourceFile = ts.getSourceFileOfNode(declaration);
                    if (declarationSourceFile &&
                        declarationSourceFile !== sourceFile) {
                        addReferencedFile(declarationSourceFile.resolvedPath);
                    }
                }
            }
            function addReferencedFile(referencedPath) {
                (referencedFiles || (referencedFiles = new ts.Set())).add(referencedPath);
            }
        }
        /**
         * Returns true if oldState is reusable, that is the emitKind = module/non module has not changed
         */
        function canReuseOldState(newReferencedMap, oldState) {
            return oldState && !oldState.referencedMap === !newReferencedMap;
        }
        BuilderState.canReuseOldState = canReuseOldState;
        /**
         * Creates the state of file references and signature for the new program from oldState if it is safe
         */
        function create(newProgram, getCanonicalFileName, oldState, disableUseFileVersionAsSignature) {
            var fileInfos = new ts.Map();
            var referencedMap = newProgram.getCompilerOptions().module !== ts.ModuleKind.None ? createManyToManyPathMap() : undefined;
            var exportedModulesMap = referencedMap ? createManyToManyPathMap() : undefined;
            var hasCalledUpdateShapeSignature = new ts.Set();
            var useOldState = canReuseOldState(referencedMap, oldState);
            // Ensure source files have parent pointers set
            newProgram.getTypeChecker();
            // Create the reference map, and set the file infos
            for (var _i = 0, _a = newProgram.getSourceFiles(); _i < _a.length; _i++) {
                var sourceFile = _a[_i];
                var version_2 = ts.Debug.checkDefined(sourceFile.version, "Program intended to be used with Builder should have source files with versions set");
                var oldInfo = useOldState ? oldState.fileInfos.get(sourceFile.resolvedPath) : undefined;
                if (referencedMap) {
                    var newReferences = getReferencedFiles(newProgram, sourceFile, getCanonicalFileName);
                    if (newReferences) {
                        referencedMap.set(sourceFile.resolvedPath, newReferences);
                    }
                    // Copy old visible to outside files map
                    if (useOldState) {
                        var exportedModules = oldState.exportedModulesMap.getValues(sourceFile.resolvedPath);
                        if (exportedModules) {
                            exportedModulesMap.set(sourceFile.resolvedPath, exportedModules);
                        }
                    }
                }
                fileInfos.set(sourceFile.resolvedPath, { version: version_2, signature: oldInfo && oldInfo.signature, affectsGlobalScope: isFileAffectingGlobalScope(sourceFile) || undefined, impliedFormat: sourceFile.impliedNodeFormat });
            }
            return {
                fileInfos: fileInfos,
                referencedMap: referencedMap,
                exportedModulesMap: exportedModulesMap,
                hasCalledUpdateShapeSignature: hasCalledUpdateShapeSignature,
                useFileVersionAsSignature: !disableUseFileVersionAsSignature && !useOldState
            };
        }
        BuilderState.create = create;
        /**
         * Releases needed properties
         */
        function releaseCache(state) {
            state.allFilesExcludingDefaultLibraryFile = undefined;
            state.allFileNames = undefined;
        }
        BuilderState.releaseCache = releaseCache;
        /**
         * Creates a clone of the state
         */
        function clone(state) {
            var _a, _b;
            // Dont need to backup allFiles info since its cache anyway
            return {
                fileInfos: new ts.Map(state.fileInfos),
                referencedMap: (_a = state.referencedMap) === null || _a === void 0 ? void 0 : _a.clone(),
                exportedModulesMap: (_b = state.exportedModulesMap) === null || _b === void 0 ? void 0 : _b.clone(),
                hasCalledUpdateShapeSignature: new ts.Set(state.hasCalledUpdateShapeSignature),
                useFileVersionAsSignature: state.useFileVersionAsSignature,
            };
        }
        BuilderState.clone = clone;
        /**
         * Gets the files affected by the path from the program
         */
        function getFilesAffectedBy(state, programOfThisState, path, cancellationToken, computeHash, cacheToUpdateSignature, exportedModulesMapCache) {
            // Since the operation could be cancelled, the signatures are always stored in the cache
            // They will be committed once it is safe to use them
            // eg when calling this api from tsserver, if there is no cancellation of the operation
            // In the other cases the affected files signatures are committed only after the iteration through the result is complete
            var signatureCache = cacheToUpdateSignature || new ts.Map();
            var sourceFile = programOfThisState.getSourceFileByPath(path);
            if (!sourceFile) {
                return ts.emptyArray;
            }
            if (!updateShapeSignature(state, programOfThisState, sourceFile, signatureCache, cancellationToken, computeHash, exportedModulesMapCache)) {
                return [sourceFile];
            }
            var result = (state.referencedMap ? getFilesAffectedByUpdatedShapeWhenModuleEmit : getFilesAffectedByUpdatedShapeWhenNonModuleEmit)(state, programOfThisState, sourceFile, signatureCache, cancellationToken, computeHash, exportedModulesMapCache);
            if (!cacheToUpdateSignature) {
                // Commit all the signatures in the signature cache
                updateSignaturesFromCache(state, signatureCache);
            }
            return result;
        }
        BuilderState.getFilesAffectedBy = getFilesAffectedBy;
        /**
         * Updates the signatures from the cache into state's fileinfo signatures
         * This should be called whenever it is safe to commit the state of the builder
         */
        function updateSignaturesFromCache(state, signatureCache) {
            signatureCache.forEach(function (signature, path) { return updateSignatureOfFile(state, signature, path); });
        }
        BuilderState.updateSignaturesFromCache = updateSignaturesFromCache;
        function updateSignatureOfFile(state, signature, path) {
            state.fileInfos.get(path).signature = signature;
            state.hasCalledUpdateShapeSignature.add(path);
        }
        BuilderState.updateSignatureOfFile = updateSignatureOfFile;
        /**
         * Returns if the shape of the signature has changed since last emit
         */
        function updateShapeSignature(state, programOfThisState, sourceFile, cacheToUpdateSignature, cancellationToken, computeHash, exportedModulesMapCache, useFileVersionAsSignature) {
            if (useFileVersionAsSignature === void 0) { useFileVersionAsSignature = state.useFileVersionAsSignature; }
            ts.Debug.assert(!!sourceFile);
            ts.Debug.assert(!exportedModulesMapCache || !!state.exportedModulesMap, "Compute visible to outside map only if visibleToOutsideReferencedMap present in the state");
            // If we have cached the result for this file, that means hence forth we should assume file shape is uptodate
            if (state.hasCalledUpdateShapeSignature.has(sourceFile.resolvedPath) || cacheToUpdateSignature.has(sourceFile.resolvedPath)) {
                return false;
            }
            var info = state.fileInfos.get(sourceFile.resolvedPath);
            if (!info)
                return ts.Debug.fail();
            var prevSignature = info.signature;
            var latestSignature;
            if (!sourceFile.isDeclarationFile && !useFileVersionAsSignature) {
                var emitOutput_1 = getFileEmitOutput(programOfThisState, sourceFile, 
                /*emitOnlyDtsFiles*/ true, cancellationToken, 
                /*customTransformers*/ undefined, 
                /*forceDtsEmit*/ true);
                var firstDts_1 = ts.firstOrUndefined(emitOutput_1.outputFiles);
                if (firstDts_1) {
                    ts.Debug.assert(ts.isDeclarationFileName(firstDts_1.name), "File extension for signature expected to be dts", function () { return "Found: ".concat(ts.getAnyExtensionFromPath(firstDts_1.name), " for ").concat(firstDts_1.name, ":: All output files: ").concat(JSON.stringify(emitOutput_1.outputFiles.map(function (f) { return f.name; }))); });
                    latestSignature = (computeHash || ts.generateDjb2Hash)(firstDts_1.text);
                    if (exportedModulesMapCache && latestSignature !== prevSignature) {
                        updateExportedModules(sourceFile, emitOutput_1.exportedModulesFromDeclarationEmit, exportedModulesMapCache);
                    }
                }
            }
            // Default is to use file version as signature
            if (latestSignature === undefined) {
                latestSignature = sourceFile.version;
                if (exportedModulesMapCache && latestSignature !== prevSignature) {
                    // All the references in this file are exported
                    var references = state.referencedMap ? state.referencedMap.getValues(sourceFile.resolvedPath) : undefined;
                    if (references) {
                        exportedModulesMapCache.set(sourceFile.resolvedPath, references);
                    }
                    else {
                        exportedModulesMapCache.deleteKey(sourceFile.resolvedPath);
                    }
                }
            }
            cacheToUpdateSignature.set(sourceFile.resolvedPath, latestSignature);
            return latestSignature !== prevSignature;
        }
        BuilderState.updateShapeSignature = updateShapeSignature;
        /**
         * Coverts the declaration emit result into exported modules map
         */
        function updateExportedModules(sourceFile, exportedModulesFromDeclarationEmit, exportedModulesMapCache) {
            if (!exportedModulesFromDeclarationEmit) {
                exportedModulesMapCache.deleteKey(sourceFile.resolvedPath);
                return;
            }
            var exportedModules;
            exportedModulesFromDeclarationEmit.forEach(function (symbol) { return addExportedModule(getReferencedFilesFromImportedModuleSymbol(symbol)); });
            if (exportedModules) {
                exportedModulesMapCache.set(sourceFile.resolvedPath, exportedModules);
            }
            else {
                exportedModulesMapCache.deleteKey(sourceFile.resolvedPath);
            }
            function addExportedModule(exportedModulePaths) {
                if (exportedModulePaths === null || exportedModulePaths === void 0 ? void 0 : exportedModulePaths.length) {
                    if (!exportedModules) {
                        exportedModules = new ts.Set();
                    }
                    exportedModulePaths.forEach(function (path) { return exportedModules.add(path); });
                }
            }
        }
        BuilderState.updateExportedModules = updateExportedModules;
        /**
         * Updates the exported modules from cache into state's exported modules map
         * This should be called whenever it is safe to commit the state of the builder
         */
        function updateExportedFilesMapFromCache(state, exportedModulesMapCache) {
            var _a;
            if (exportedModulesMapCache) {
                ts.Debug.assert(!!state.exportedModulesMap);
                (_a = exportedModulesMapCache.deletedKeys()) === null || _a === void 0 ? void 0 : _a.forEach(function (path) { return state.exportedModulesMap.deleteKey(path); });
                exportedModulesMapCache.forEach(function (exportedModules, path) { return state.exportedModulesMap.set(path, exportedModules); });
            }
        }
        BuilderState.updateExportedFilesMapFromCache = updateExportedFilesMapFromCache;
        /**
         * Get all the dependencies of the sourceFile
         */
        function getAllDependencies(state, programOfThisState, sourceFile) {
            var compilerOptions = programOfThisState.getCompilerOptions();
            // With --out or --outFile all outputs go into single file, all files depend on each other
            if (ts.outFile(compilerOptions)) {
                return getAllFileNames(state, programOfThisState);
            }
            // If this is non module emit, or its a global file, it depends on all the source files
            if (!state.referencedMap || isFileAffectingGlobalScope(sourceFile)) {
                return getAllFileNames(state, programOfThisState);
            }
            // Get the references, traversing deep from the referenceMap
            var seenMap = new ts.Set();
            var queue = [sourceFile.resolvedPath];
            while (queue.length) {
                var path = queue.pop();
                if (!seenMap.has(path)) {
                    seenMap.add(path);
                    var references = state.referencedMap.getValues(path);
                    if (references) {
                        var iterator = references.keys();
                        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
                            queue.push(iterResult.value);
                        }
                    }
                }
            }
            return ts.arrayFrom(ts.mapDefinedIterator(seenMap.keys(), function (path) { var _a, _b; return (_b = (_a = programOfThisState.getSourceFileByPath(path)) === null || _a === void 0 ? void 0 : _a.fileName) !== null && _b !== void 0 ? _b : path; }));
        }
        BuilderState.getAllDependencies = getAllDependencies;
        /**
         * Gets the names of all files from the program
         */
        function getAllFileNames(state, programOfThisState) {
            if (!state.allFileNames) {
                var sourceFiles = programOfThisState.getSourceFiles();
                state.allFileNames = sourceFiles === ts.emptyArray ? ts.emptyArray : sourceFiles.map(function (file) { return file.fileName; });
            }
            return state.allFileNames;
        }
        /**
         * Gets the files referenced by the the file path
         */
        function getReferencedByPaths(state, referencedFilePath) {
            var keys = state.referencedMap.getKeys(referencedFilePath);
            return keys ? ts.arrayFrom(keys.keys()) : [];
        }
        BuilderState.getReferencedByPaths = getReferencedByPaths;
        /**
         * For script files that contains only ambient external modules, although they are not actually external module files,
         * they can only be consumed via importing elements from them. Regular script files cannot consume them. Therefore,
         * there are no point to rebuild all script files if these special files have changed. However, if any statement
         * in the file is not ambient external module, we treat it as a regular script file.
         */
        function containsOnlyAmbientModules(sourceFile) {
            for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
                var statement = _a[_i];
                if (!ts.isModuleWithStringLiteralName(statement)) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Return true if file contains anything that augments to global scope we need to build them as if
         * they are global files as well as module
         */
        function containsGlobalScopeAugmentation(sourceFile) {
            return ts.some(sourceFile.moduleAugmentations, function (augmentation) { return ts.isGlobalScopeAugmentation(augmentation.parent); });
        }
        /**
         * Return true if the file will invalidate all files because it affectes global scope
         */
        function isFileAffectingGlobalScope(sourceFile) {
            return containsGlobalScopeAugmentation(sourceFile) ||
                !ts.isExternalOrCommonJsModule(sourceFile) && !ts.isJsonSourceFile(sourceFile) && !containsOnlyAmbientModules(sourceFile);
        }
        /**
         * Gets all files of the program excluding the default library file
         */
        function getAllFilesExcludingDefaultLibraryFile(state, programOfThisState, firstSourceFile) {
            // Use cached result
            if (state.allFilesExcludingDefaultLibraryFile) {
                return state.allFilesExcludingDefaultLibraryFile;
            }
            var result;
            if (firstSourceFile)
                addSourceFile(firstSourceFile);
            for (var _i = 0, _a = programOfThisState.getSourceFiles(); _i < _a.length; _i++) {
                var sourceFile = _a[_i];
                if (sourceFile !== firstSourceFile) {
                    addSourceFile(sourceFile);
                }
            }
            state.allFilesExcludingDefaultLibraryFile = result || ts.emptyArray;
            return state.allFilesExcludingDefaultLibraryFile;
            function addSourceFile(sourceFile) {
                if (!programOfThisState.isSourceFileDefaultLibrary(sourceFile)) {
                    (result || (result = [])).push(sourceFile);
                }
            }
        }
        BuilderState.getAllFilesExcludingDefaultLibraryFile = getAllFilesExcludingDefaultLibraryFile;
        /**
         * When program emits non modular code, gets the files affected by the sourceFile whose shape has changed
         */
        function getFilesAffectedByUpdatedShapeWhenNonModuleEmit(state, programOfThisState, sourceFileWithUpdatedShape) {
            var compilerOptions = programOfThisState.getCompilerOptions();
            // If `--out` or `--outFile` is specified, any new emit will result in re-emitting the entire project,
            // so returning the file itself is good enough.
            if (compilerOptions && ts.outFile(compilerOptions)) {
                return [sourceFileWithUpdatedShape];
            }
            return getAllFilesExcludingDefaultLibraryFile(state, programOfThisState, sourceFileWithUpdatedShape);
        }
        /**
         * When program emits modular code, gets the files affected by the sourceFile whose shape has changed
         */
        function getFilesAffectedByUpdatedShapeWhenModuleEmit(state, programOfThisState, sourceFileWithUpdatedShape, cacheToUpdateSignature, cancellationToken, computeHash, exportedModulesMapCache) {
            if (isFileAffectingGlobalScope(sourceFileWithUpdatedShape)) {
                return getAllFilesExcludingDefaultLibraryFile(state, programOfThisState, sourceFileWithUpdatedShape);
            }
            var compilerOptions = programOfThisState.getCompilerOptions();
            if (compilerOptions && (compilerOptions.isolatedModules || ts.outFile(compilerOptions))) {
                return [sourceFileWithUpdatedShape];
            }
            // Now we need to if each file in the referencedBy list has a shape change as well.
            // Because if so, its own referencedBy files need to be saved as well to make the
            // emitting result consistent with files on disk.
            var seenFileNamesMap = new ts.Map();
            // Start with the paths this file was referenced by
            seenFileNamesMap.set(sourceFileWithUpdatedShape.resolvedPath, sourceFileWithUpdatedShape);
            var queue = getReferencedByPaths(state, sourceFileWithUpdatedShape.resolvedPath);
            while (queue.length > 0) {
                var currentPath = queue.pop();
                if (!seenFileNamesMap.has(currentPath)) {
                    var currentSourceFile = programOfThisState.getSourceFileByPath(currentPath);
                    seenFileNamesMap.set(currentPath, currentSourceFile);
                    if (currentSourceFile && updateShapeSignature(state, programOfThisState, currentSourceFile, cacheToUpdateSignature, cancellationToken, computeHash, exportedModulesMapCache)) {
                        queue.push.apply(queue, getReferencedByPaths(state, currentSourceFile.resolvedPath));
                    }
                }
            }
            // Return array of values that needs emit
            return ts.arrayFrom(ts.mapDefinedIterator(seenFileNamesMap.values(), function (value) { return value; }));
        }
    })(BuilderState = ts.BuilderState || (ts.BuilderState = {}));
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var BuilderFileEmit;
    (function (BuilderFileEmit) {
        BuilderFileEmit[BuilderFileEmit["DtsOnly"] = 0] = "DtsOnly";
        BuilderFileEmit[BuilderFileEmit["Full"] = 1] = "Full";
    })(BuilderFileEmit = ts.BuilderFileEmit || (ts.BuilderFileEmit = {}));
    function hasSameKeys(map1, map2) {
        // Has same size and every key is present in both maps
        return map1 === map2 || map1 !== undefined && map2 !== undefined && map1.size === map2.size && !ts.forEachKey(map1, function (key) { return !map2.has(key); });
    }
    /**
     * Create the state so that we can iterate on changedFiles/affected files
     */
    function createBuilderProgramState(newProgram, getCanonicalFileName, oldState, disableUseFileVersionAsSignature) {
        var state = ts.BuilderState.create(newProgram, getCanonicalFileName, oldState, disableUseFileVersionAsSignature);
        state.program = newProgram;
        var compilerOptions = newProgram.getCompilerOptions();
        state.compilerOptions = compilerOptions;
        // With --out or --outFile, any change affects all semantic diagnostics so no need to cache them
        if (!ts.outFile(compilerOptions)) {
            state.semanticDiagnosticsPerFile = new ts.Map();
        }
        state.changedFilesSet = new ts.Set();
        var useOldState = ts.BuilderState.canReuseOldState(state.referencedMap, oldState);
        var oldCompilerOptions = useOldState ? oldState.compilerOptions : undefined;
        var canCopySemanticDiagnostics = useOldState && oldState.semanticDiagnosticsPerFile && !!state.semanticDiagnosticsPerFile &&
            !ts.compilerOptionsAffectSemanticDiagnostics(compilerOptions, oldCompilerOptions);
        if (useOldState) {
            // Verify the sanity of old state
            if (!oldState.currentChangedFilePath) {
                var affectedSignatures = oldState.currentAffectedFilesSignatures;
                ts.Debug.assert(!oldState.affectedFiles && (!affectedSignatures || !affectedSignatures.size), "Cannot reuse if only few affected files of currentChangedFile were iterated");
            }
            var changedFilesSet = oldState.changedFilesSet;
            if (canCopySemanticDiagnostics) {
                ts.Debug.assert(!changedFilesSet || !ts.forEachKey(changedFilesSet, function (path) { return oldState.semanticDiagnosticsPerFile.has(path); }), "Semantic diagnostics shouldnt be available for changed files");
            }
            // Copy old state's changed files set
            changedFilesSet === null || changedFilesSet === void 0 ? void 0 : changedFilesSet.forEach(function (value) { return state.changedFilesSet.add(value); });
            if (!ts.outFile(compilerOptions) && oldState.affectedFilesPendingEmit) {
                state.affectedFilesPendingEmit = oldState.affectedFilesPendingEmit.slice();
                state.affectedFilesPendingEmitKind = oldState.affectedFilesPendingEmitKind && new ts.Map(oldState.affectedFilesPendingEmitKind);
                state.affectedFilesPendingEmitIndex = oldState.affectedFilesPendingEmitIndex;
                state.seenAffectedFiles = new ts.Set();
            }
        }
        // Update changed files and copy semantic diagnostics if we can
        var referencedMap = state.referencedMap;
        var oldReferencedMap = useOldState ? oldState.referencedMap : undefined;
        var copyDeclarationFileDiagnostics = canCopySemanticDiagnostics && !compilerOptions.skipLibCheck === !oldCompilerOptions.skipLibCheck;
        var copyLibFileDiagnostics = copyDeclarationFileDiagnostics && !compilerOptions.skipDefaultLibCheck === !oldCompilerOptions.skipDefaultLibCheck;
        state.fileInfos.forEach(function (info, sourceFilePath) {
            var oldInfo;
            var newReferences;
            // if not using old state, every file is changed
            if (!useOldState ||
                // File wasn't present in old state
                !(oldInfo = oldState.fileInfos.get(sourceFilePath)) ||
                // versions dont match
                oldInfo.version !== info.version ||
                // Referenced files changed
                !hasSameKeys(newReferences = referencedMap && referencedMap.getValues(sourceFilePath), oldReferencedMap && oldReferencedMap.getValues(sourceFilePath)) ||
                // Referenced file was deleted in the new program
                newReferences && ts.forEachKey(newReferences, function (path) { return !state.fileInfos.has(path) && oldState.fileInfos.has(path); })) {
                // Register file as changed file and do not copy semantic diagnostics, since all changed files need to be re-evaluated
                state.changedFilesSet.add(sourceFilePath);
            }
            else if (canCopySemanticDiagnostics) {
                var sourceFile = newProgram.getSourceFileByPath(sourceFilePath);
                if (sourceFile.isDeclarationFile && !copyDeclarationFileDiagnostics)
                    return;
                if (sourceFile.hasNoDefaultLib && !copyLibFileDiagnostics)
                    return;
                // Unchanged file copy diagnostics
                var diagnostics = oldState.semanticDiagnosticsPerFile.get(sourceFilePath);
                if (diagnostics) {
                    state.semanticDiagnosticsPerFile.set(sourceFilePath, oldState.hasReusableDiagnostic ? convertToDiagnostics(diagnostics, newProgram, getCanonicalFileName) : diagnostics);
                    if (!state.semanticDiagnosticsFromOldState) {
                        state.semanticDiagnosticsFromOldState = new ts.Set();
                    }
                    state.semanticDiagnosticsFromOldState.add(sourceFilePath);
                }
            }
        });
        // If the global file is removed, add all files as changed
        if (useOldState && ts.forEachEntry(oldState.fileInfos, function (info, sourceFilePath) { return info.affectsGlobalScope && !state.fileInfos.has(sourceFilePath); })) {
            ts.BuilderState.getAllFilesExcludingDefaultLibraryFile(state, newProgram, /*firstSourceFile*/ undefined)
                .forEach(function (file) { return state.changedFilesSet.add(file.resolvedPath); });
        }
        else if (oldCompilerOptions && !ts.outFile(compilerOptions) && ts.compilerOptionsAffectEmit(compilerOptions, oldCompilerOptions)) {
            // Add all files to affectedFilesPendingEmit since emit changed
            newProgram.getSourceFiles().forEach(function (f) { return addToAffectedFilesPendingEmit(state, f.resolvedPath, 1 /* BuilderFileEmit.Full */); });
            ts.Debug.assert(!state.seenAffectedFiles || !state.seenAffectedFiles.size);
            state.seenAffectedFiles = state.seenAffectedFiles || new ts.Set();
        }
        if (useOldState) {
            // Any time the interpretation of a source file changes, mark it as changed
            ts.forEachEntry(oldState.fileInfos, function (info, sourceFilePath) {
                if (state.fileInfos.has(sourceFilePath) && state.fileInfos.get(sourceFilePath).impliedFormat !== info.impliedFormat) {
                    state.changedFilesSet.add(sourceFilePath);
                }
            });
        }
        state.buildInfoEmitPending = !!state.changedFilesSet.size;
        return state;
    }
    function convertToDiagnostics(diagnostics, newProgram, getCanonicalFileName) {
        if (!diagnostics.length)
            return ts.emptyArray;
        var buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(ts.getTsBuildInfoEmitOutputFilePath(newProgram.getCompilerOptions()), newProgram.getCurrentDirectory()));
        return diagnostics.map(function (diagnostic) {
            var result = convertToDiagnosticRelatedInformation(diagnostic, newProgram, toPath);
            result.reportsUnnecessary = diagnostic.reportsUnnecessary;
            result.reportsDeprecated = diagnostic.reportDeprecated;
            result.source = diagnostic.source;
            result.skippedOn = diagnostic.skippedOn;
            var relatedInformation = diagnostic.relatedInformation;
            result.relatedInformation = relatedInformation ?
                relatedInformation.length ?
                    relatedInformation.map(function (r) { return convertToDiagnosticRelatedInformation(r, newProgram, toPath); }) :
                    [] :
                undefined;
            return result;
        });
        function toPath(path) {
            return ts.toPath(path, buildInfoDirectory, getCanonicalFileName);
        }
    }
    function convertToDiagnosticRelatedInformation(diagnostic, newProgram, toPath) {
        var file = diagnostic.file;
        return __assign(__assign({}, diagnostic), { file: file ? newProgram.getSourceFileByPath(toPath(file)) : undefined });
    }
    /**
     * Releases program and other related not needed properties
     */
    function releaseCache(state) {
        ts.BuilderState.releaseCache(state);
        state.program = undefined;
    }
    /**
     * Creates a clone of the state
     */
    function cloneBuilderProgramState(state) {
        var _a;
        var newState = ts.BuilderState.clone(state);
        newState.semanticDiagnosticsPerFile = state.semanticDiagnosticsPerFile && new ts.Map(state.semanticDiagnosticsPerFile);
        newState.changedFilesSet = new ts.Set(state.changedFilesSet);
        newState.affectedFiles = state.affectedFiles;
        newState.affectedFilesIndex = state.affectedFilesIndex;
        newState.currentChangedFilePath = state.currentChangedFilePath;
        newState.currentAffectedFilesSignatures = state.currentAffectedFilesSignatures && new ts.Map(state.currentAffectedFilesSignatures);
        newState.currentAffectedFilesExportedModulesMap = (_a = state.currentAffectedFilesExportedModulesMap) === null || _a === void 0 ? void 0 : _a.clone();
        newState.seenAffectedFiles = state.seenAffectedFiles && new ts.Set(state.seenAffectedFiles);
        newState.cleanedDiagnosticsOfLibFiles = state.cleanedDiagnosticsOfLibFiles;
        newState.semanticDiagnosticsFromOldState = state.semanticDiagnosticsFromOldState && new ts.Set(state.semanticDiagnosticsFromOldState);
        newState.program = state.program;
        newState.compilerOptions = state.compilerOptions;
        newState.affectedFilesPendingEmit = state.affectedFilesPendingEmit && state.affectedFilesPendingEmit.slice();
        newState.affectedFilesPendingEmitKind = state.affectedFilesPendingEmitKind && new ts.Map(state.affectedFilesPendingEmitKind);
        newState.affectedFilesPendingEmitIndex = state.affectedFilesPendingEmitIndex;
        newState.seenEmittedFiles = state.seenEmittedFiles && new ts.Map(state.seenEmittedFiles);
        newState.programEmitComplete = state.programEmitComplete;
        return newState;
    }
    /**
     * Verifies that source file is ok to be used in calls that arent handled by next
     */
    function assertSourceFileOkWithoutNextAffectedCall(state, sourceFile) {
        ts.Debug.assert(!sourceFile || !state.affectedFiles || state.affectedFiles[state.affectedFilesIndex - 1] !== sourceFile || !state.semanticDiagnosticsPerFile.has(sourceFile.resolvedPath));
    }
    /**
     * This function returns the next affected file to be processed.
     * Note that until doneAffected is called it would keep reporting same result
     * This is to allow the callers to be able to actually remove affected file only when the operation is complete
     * eg. if during diagnostics check cancellation token ends up cancelling the request, the affected file should be retained
     */
    function getNextAffectedFile(state, cancellationToken, computeHash, host) {
        var _a;
        while (true) {
            var affectedFiles = state.affectedFiles;
            if (affectedFiles) {
                var seenAffectedFiles = state.seenAffectedFiles;
                var affectedFilesIndex = state.affectedFilesIndex; // TODO: GH#18217
                while (affectedFilesIndex < affectedFiles.length) {
                    var affectedFile = affectedFiles[affectedFilesIndex];
                    if (!seenAffectedFiles.has(affectedFile.resolvedPath)) {
                        // Set the next affected file as seen and remove the cached semantic diagnostics
                        state.affectedFilesIndex = affectedFilesIndex;
                        handleDtsMayChangeOfAffectedFile(state, affectedFile, cancellationToken, computeHash, host);
                        return affectedFile;
                    }
                    affectedFilesIndex++;
                }
                // Remove the changed file from the change set
                state.changedFilesSet.delete(state.currentChangedFilePath);
                state.currentChangedFilePath = undefined;
                // Commit the changes in file signature
                ts.BuilderState.updateSignaturesFromCache(state, state.currentAffectedFilesSignatures);
                state.currentAffectedFilesSignatures.clear();
                ts.BuilderState.updateExportedFilesMapFromCache(state, state.currentAffectedFilesExportedModulesMap);
                (_a = state.currentAffectedFilesExportedModulesMap) === null || _a === void 0 ? void 0 : _a.clear();
                state.affectedFiles = undefined;
            }
            // Get next changed file
            var nextKey = state.changedFilesSet.keys().next();
            if (nextKey.done) {
                // Done
                return undefined;
            }
            // With --out or --outFile all outputs go into single file
            // so operations are performed directly on program, return program
            var program = ts.Debug.checkDefined(state.program);
            var compilerOptions = program.getCompilerOptions();
            if (ts.outFile(compilerOptions)) {
                ts.Debug.assert(!state.semanticDiagnosticsPerFile);
                return program;
            }
            // Get next batch of affected files
            if (!state.currentAffectedFilesSignatures)
                state.currentAffectedFilesSignatures = new ts.Map();
            if (state.exportedModulesMap) {
                state.currentAffectedFilesExportedModulesMap || (state.currentAffectedFilesExportedModulesMap = ts.BuilderState.createManyToManyPathMap());
            }
            state.affectedFiles = ts.BuilderState.getFilesAffectedBy(state, program, nextKey.value, cancellationToken, computeHash, state.currentAffectedFilesSignatures, state.currentAffectedFilesExportedModulesMap);
            state.currentChangedFilePath = nextKey.value;
            state.affectedFilesIndex = 0;
            if (!state.seenAffectedFiles)
                state.seenAffectedFiles = new ts.Set();
        }
    }
    function clearAffectedFilesPendingEmit(state) {
        state.affectedFilesPendingEmit = undefined;
        state.affectedFilesPendingEmitKind = undefined;
        state.affectedFilesPendingEmitIndex = undefined;
    }
    /**
     * Returns next file to be emitted from files that retrieved semantic diagnostics but did not emit yet
     */
    function getNextAffectedFilePendingEmit(state) {
        var affectedFilesPendingEmit = state.affectedFilesPendingEmit;
        if (affectedFilesPendingEmit) {
            var seenEmittedFiles = (state.seenEmittedFiles || (state.seenEmittedFiles = new ts.Map()));
            for (var i = state.affectedFilesPendingEmitIndex; i < affectedFilesPendingEmit.length; i++) {
                var affectedFile = ts.Debug.checkDefined(state.program).getSourceFileByPath(affectedFilesPendingEmit[i]);
                if (affectedFile) {
                    var seenKind = seenEmittedFiles.get(affectedFile.resolvedPath);
                    var emitKind = ts.Debug.checkDefined(ts.Debug.checkDefined(state.affectedFilesPendingEmitKind).get(affectedFile.resolvedPath));
                    if (seenKind === undefined || seenKind < emitKind) {
                        // emit this file
                        state.affectedFilesPendingEmitIndex = i;
                        return { affectedFile: affectedFile, emitKind: emitKind };
                    }
                }
            }
            clearAffectedFilesPendingEmit(state);
        }
        return undefined;
    }
    function removeDiagnosticsOfLibraryFiles(state) {
        if (!state.cleanedDiagnosticsOfLibFiles) {
            state.cleanedDiagnosticsOfLibFiles = true;
            var program_1 = ts.Debug.checkDefined(state.program);
            var options_2 = program_1.getCompilerOptions();
            ts.forEach(program_1.getSourceFiles(), function (f) {
                return program_1.isSourceFileDefaultLibrary(f) &&
                    !ts.skipTypeChecking(f, options_2, program_1) &&
                    removeSemanticDiagnosticsOf(state, f.resolvedPath);
            });
        }
    }
    /**
     *  Handles semantic diagnostics and dts emit for affectedFile and files, that are referencing modules that export entities from affected file
     *  This is because even though js emit doesnt change, dts emit / type used can change resulting in need for dts emit and js change
     */
    function handleDtsMayChangeOfAffectedFile(state, affectedFile, cancellationToken, computeHash, host) {
        var _a;
        removeSemanticDiagnosticsOf(state, affectedFile.resolvedPath);
        // If affected files is everything except default library, then nothing more to do
        if (state.allFilesExcludingDefaultLibraryFile === state.affectedFiles) {
            removeDiagnosticsOfLibraryFiles(state);
            // When a change affects the global scope, all files are considered to be affected without updating their signature
            // That means when affected file is handled, its signature can be out of date
            // To avoid this, ensure that we update the signature for any affected file in this scenario.
            ts.BuilderState.updateShapeSignature(state, ts.Debug.checkDefined(state.program), affectedFile, ts.Debug.checkDefined(state.currentAffectedFilesSignatures), cancellationToken, computeHash, state.currentAffectedFilesExportedModulesMap);
            return;
        }
        ts.Debug.assert(state.hasCalledUpdateShapeSignature.has(affectedFile.resolvedPath) || ((_a = state.currentAffectedFilesSignatures) === null || _a === void 0 ? void 0 : _a.has(affectedFile.resolvedPath)), "Signature not updated for affected file: ".concat(affectedFile.fileName));
        if (state.compilerOptions.assumeChangesOnlyAffectDirectDependencies)
            return;
        handleDtsMayChangeOfReferencingExportOfAffectedFile(state, affectedFile, cancellationToken, computeHash, host);
    }
    /**
     * Handle the dts may change, so they need to be added to pending emit if dts emit is enabled,
     * Also we need to make sure signature is updated for these files
     */
    function handleDtsMayChangeOf(state, path, cancellationToken, computeHash, host) {
        removeSemanticDiagnosticsOf(state, path);
        if (!state.changedFilesSet.has(path)) {
            var program = ts.Debug.checkDefined(state.program);
            var sourceFile = program.getSourceFileByPath(path);
            if (sourceFile) {
                // Even though the js emit doesnt change and we are already handling dts emit and semantic diagnostics
                // we need to update the signature to reflect correctness of the signature(which is output d.ts emit) of this file
                // This ensures that we dont later during incremental builds considering wrong signature.
                // Eg where this also is needed to ensure that .tsbuildinfo generated by incremental build should be same as if it was first fresh build
                // But we avoid expensive full shape computation, as using file version as shape is enough for correctness.
                ts.BuilderState.updateShapeSignature(state, program, sourceFile, ts.Debug.checkDefined(state.currentAffectedFilesSignatures), cancellationToken, computeHash, state.currentAffectedFilesExportedModulesMap, !host.disableUseFileVersionAsSignature);
                // If not dts emit, nothing more to do
                if (ts.getEmitDeclarations(state.compilerOptions)) {
                    addToAffectedFilesPendingEmit(state, path, 0 /* BuilderFileEmit.DtsOnly */);
                }
            }
        }
    }
    /**
     * Removes semantic diagnostics for path and
     * returns true if there are no more semantic diagnostics from the old state
     */
    function removeSemanticDiagnosticsOf(state, path) {
        if (!state.semanticDiagnosticsFromOldState) {
            return true;
        }
        state.semanticDiagnosticsFromOldState.delete(path);
        state.semanticDiagnosticsPerFile.delete(path);
        return !state.semanticDiagnosticsFromOldState.size;
    }
    function isChangedSignature(state, path) {
        var newSignature = ts.Debug.checkDefined(state.currentAffectedFilesSignatures).get(path);
        var oldSignature = ts.Debug.checkDefined(state.fileInfos.get(path)).signature;
        return newSignature !== oldSignature;
    }
    function forEachKeyOfExportedModulesMap(state, filePath, fn) {
        // Go through exported modules from cache first
        var keys = state.currentAffectedFilesExportedModulesMap.getKeys(filePath);
        var result = keys && ts.forEachKey(keys, fn);
        if (result)
            return result;
        // If exported from path is not from cache and exported modules has path, all files referencing file exported from are affected
        keys = state.exportedModulesMap.getKeys(filePath);
        return keys && ts.forEachKey(keys, function (exportedFromPath) {
            var _a;
            // If the cache had an updated value, skip
            return !state.currentAffectedFilesExportedModulesMap.hasKey(exportedFromPath) &&
                !((_a = state.currentAffectedFilesExportedModulesMap.deletedKeys()) === null || _a === void 0 ? void 0 : _a.has(exportedFromPath)) ?
                fn(exportedFromPath) :
                undefined;
        });
    }
    function handleDtsMayChangeOfGlobalScope(state, filePath, cancellationToken, computeHash, host) {
        var _a;
        if (!((_a = state.fileInfos.get(filePath)) === null || _a === void 0 ? void 0 : _a.affectsGlobalScope))
            return false;
        // Every file needs to be handled
        ts.BuilderState.getAllFilesExcludingDefaultLibraryFile(state, state.program, /*firstSourceFile*/ undefined)
            .forEach(function (file) { return handleDtsMayChangeOf(state, file.resolvedPath, cancellationToken, computeHash, host); });
        removeDiagnosticsOfLibraryFiles(state);
        return true;
    }
    /**
     * Iterate on referencing modules that export entities from affected file and delete diagnostics and add pending emit
     */
    function handleDtsMayChangeOfReferencingExportOfAffectedFile(state, affectedFile, cancellationToken, computeHash, host) {
        // If there was change in signature (dts output) for the changed file,
        // then only we need to handle pending file emit
        if (!state.exportedModulesMap || !state.changedFilesSet.has(affectedFile.resolvedPath))
            return;
        if (!isChangedSignature(state, affectedFile.resolvedPath))
            return;
        // Since isolated modules dont change js files, files affected by change in signature is itself
        // But we need to cleanup semantic diagnostics and queue dts emit for affected files
        if (state.compilerOptions.isolatedModules) {
            var seenFileNamesMap = new ts.Map();
            seenFileNamesMap.set(affectedFile.resolvedPath, true);
            var queue = ts.BuilderState.getReferencedByPaths(state, affectedFile.resolvedPath);
            while (queue.length > 0) {
                var currentPath = queue.pop();
                if (!seenFileNamesMap.has(currentPath)) {
                    seenFileNamesMap.set(currentPath, true);
                    if (handleDtsMayChangeOfGlobalScope(state, currentPath, cancellationToken, computeHash, host))
                        return;
                    handleDtsMayChangeOf(state, currentPath, cancellationToken, computeHash, host);
                    if (isChangedSignature(state, currentPath)) {
                        var currentSourceFile = ts.Debug.checkDefined(state.program).getSourceFileByPath(currentPath);
                        queue.push.apply(queue, ts.BuilderState.getReferencedByPaths(state, currentSourceFile.resolvedPath));
                    }
                }
            }
        }
        ts.Debug.assert(!!state.currentAffectedFilesExportedModulesMap);
        var seenFileAndExportsOfFile = new ts.Set();
        // Go through exported modules from cache first
        // If exported modules has path, all files referencing file exported from are affected
        forEachKeyOfExportedModulesMap(state, affectedFile.resolvedPath, function (exportedFromPath) {
            if (handleDtsMayChangeOfGlobalScope(state, exportedFromPath, cancellationToken, computeHash, host))
                return true;
            var references = state.referencedMap.getKeys(exportedFromPath);
            return references && ts.forEachKey(references, function (filePath) {
                return handleDtsMayChangeOfFileAndExportsOfFile(state, filePath, seenFileAndExportsOfFile, cancellationToken, computeHash, host);
            });
        });
    }
    /**
     * handle dts and semantic diagnostics on file and iterate on anything that exports this file
     * return true when all work is done and we can exit handling dts emit and semantic diagnostics
     */
    function handleDtsMayChangeOfFileAndExportsOfFile(state, filePath, seenFileAndExportsOfFile, cancellationToken, computeHash, host) {
        var _a;
        if (!ts.tryAddToSet(seenFileAndExportsOfFile, filePath))
            return undefined;
        if (handleDtsMayChangeOfGlobalScope(state, filePath, cancellationToken, computeHash, host))
            return true;
        handleDtsMayChangeOf(state, filePath, cancellationToken, computeHash, host);
        ts.Debug.assert(!!state.currentAffectedFilesExportedModulesMap);
        // If exported modules has path, all files referencing file exported from are affected
        forEachKeyOfExportedModulesMap(state, filePath, function (exportedFromPath) {
            return handleDtsMayChangeOfFileAndExportsOfFile(state, exportedFromPath, seenFileAndExportsOfFile, cancellationToken, computeHash, host);
        });
        // Remove diagnostics of files that import this file (without going to exports of referencing files)
        (_a = state.referencedMap.getKeys(filePath)) === null || _a === void 0 ? void 0 : _a.forEach(function (referencingFilePath) {
            return !seenFileAndExportsOfFile.has(referencingFilePath) && // Not already removed diagnostic file
                handleDtsMayChangeOf(// Dont add to seen since this is not yet done with the export removal
                state, referencingFilePath, cancellationToken, computeHash, host);
        });
        return undefined;
    }
    /**
     * This is called after completing operation on the next affected file.
     * The operations here are postponed to ensure that cancellation during the iteration is handled correctly
     */
    function doneWithAffectedFile(state, affected, emitKind, isPendingEmit, isBuildInfoEmit) {
        if (isBuildInfoEmit) {
            state.buildInfoEmitPending = false;
        }
        else if (affected === state.program) {
            state.changedFilesSet.clear();
            state.programEmitComplete = true;
        }
        else {
            state.seenAffectedFiles.add(affected.resolvedPath);
            if (emitKind !== undefined) {
                (state.seenEmittedFiles || (state.seenEmittedFiles = new ts.Map())).set(affected.resolvedPath, emitKind);
            }
            if (isPendingEmit) {
                state.affectedFilesPendingEmitIndex++;
                state.buildInfoEmitPending = true;
            }
            else {
                state.affectedFilesIndex++;
            }
        }
    }
    /**
     * Returns the result with affected file
     */
    function toAffectedFileResult(state, result, affected) {
        doneWithAffectedFile(state, affected);
        return { result: result, affected: affected };
    }
    /**
     * Returns the result with affected file
     */
    function toAffectedFileEmitResult(state, result, affected, emitKind, isPendingEmit, isBuildInfoEmit) {
        doneWithAffectedFile(state, affected, emitKind, isPendingEmit, isBuildInfoEmit);
        return { result: result, affected: affected };
    }
    /**
     * Gets semantic diagnostics for the file which are
     * bindAndCheckDiagnostics (from cache) and program diagnostics
     */
    function getSemanticDiagnosticsOfFile(state, sourceFile, cancellationToken) {
        return ts.concatenate(getBinderAndCheckerDiagnosticsOfFile(state, sourceFile, cancellationToken), ts.Debug.checkDefined(state.program).getProgramDiagnostics(sourceFile));
    }
    /**
     * Gets the binder and checker diagnostics either from cache if present, or otherwise from program and caches it
     * Note that it is assumed that when asked about binder and checker diagnostics, the file has been taken out of affected files/changed file set
     */
    function getBinderAndCheckerDiagnosticsOfFile(state, sourceFile, cancellationToken) {
        var path = sourceFile.resolvedPath;
        if (state.semanticDiagnosticsPerFile) {
            var cachedDiagnostics = state.semanticDiagnosticsPerFile.get(path);
            // Report the bind and check diagnostics from the cache if we already have those diagnostics present
            if (cachedDiagnostics) {
                return ts.filterSemanticDiagnostics(cachedDiagnostics, state.compilerOptions);
            }
        }
        // Diagnostics werent cached, get them from program, and cache the result
        var diagnostics = ts.Debug.checkDefined(state.program).getBindAndCheckDiagnostics(sourceFile, cancellationToken);
        if (state.semanticDiagnosticsPerFile) {
            state.semanticDiagnosticsPerFile.set(path, diagnostics);
        }
        return ts.filterSemanticDiagnostics(diagnostics, state.compilerOptions);
    }
    /**
     * Gets the program information to be emitted in buildInfo so that we can use it to create new program
     */
    function getProgramBuildInfo(state, getCanonicalFileName) {
        if (ts.outFile(state.compilerOptions))
            return undefined;
        var currentDirectory = ts.Debug.checkDefined(state.program).getCurrentDirectory();
        var buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(ts.getTsBuildInfoEmitOutputFilePath(state.compilerOptions), currentDirectory));
        var fileNames = [];
        var fileNameToFileId = new ts.Map();
        var fileIdsList;
        var fileNamesToFileIdListId;
        var fileInfos = ts.arrayFrom(state.fileInfos.entries(), function (_a) {
            var key = _a[0], value = _a[1];
            // Ensure fileId
            var fileId = toFileId(key);
            ts.Debug.assert(fileNames[fileId - 1] === relativeToBuildInfo(key));
            var signature = state.currentAffectedFilesSignatures && state.currentAffectedFilesSignatures.get(key);
            var actualSignature = signature !== null && signature !== void 0 ? signature : value.signature;
            return value.version === actualSignature ?
                value.affectsGlobalScope || value.impliedFormat ?
                    // If file version is same as signature, dont serialize signature
                    { version: value.version, signature: undefined, affectsGlobalScope: value.affectsGlobalScope, impliedFormat: value.impliedFormat } :
                    // If file info only contains version and signature and both are same we can just write string
                    value.version :
                actualSignature !== undefined ? // If signature is not same as version, encode signature in the fileInfo
                    signature === undefined ?
                        // If we havent computed signature, use fileInfo as is
                        value :
                        // Serialize fileInfo with new updated signature
                        { version: value.version, signature: signature, affectsGlobalScope: value.affectsGlobalScope, impliedFormat: value.impliedFormat } :
                    // Signature of the FileInfo is undefined, serialize it as false
                    { version: value.version, signature: false, affectsGlobalScope: value.affectsGlobalScope, impliedFormat: value.impliedFormat };
        });
        var referencedMap;
        if (state.referencedMap) {
            referencedMap = ts.arrayFrom(state.referencedMap.keys()).sort(ts.compareStringsCaseSensitive).map(function (key) { return [
                toFileId(key),
                toFileIdListId(state.referencedMap.getValues(key))
            ]; });
        }
        var exportedModulesMap;
        if (state.exportedModulesMap) {
            exportedModulesMap = ts.mapDefined(ts.arrayFrom(state.exportedModulesMap.keys()).sort(ts.compareStringsCaseSensitive), function (key) {
                var _a;
                if (state.currentAffectedFilesExportedModulesMap) {
                    if ((_a = state.currentAffectedFilesExportedModulesMap.deletedKeys()) === null || _a === void 0 ? void 0 : _a.has(key)) {
                        return undefined;
                    }
                    var newValue = state.currentAffectedFilesExportedModulesMap.getValues(key);
                    if (newValue) {
                        return [toFileId(key), toFileIdListId(newValue)];
                    }
                }
                // Not in temporary cache, use existing value
                return [toFileId(key), toFileIdListId(state.exportedModulesMap.getValues(key))];
            });
        }
        var semanticDiagnosticsPerFile;
        if (state.semanticDiagnosticsPerFile) {
            for (var _i = 0, _a = ts.arrayFrom(state.semanticDiagnosticsPerFile.keys()).sort(ts.compareStringsCaseSensitive); _i < _a.length; _i++) {
                var key = _a[_i];
                var value = state.semanticDiagnosticsPerFile.get(key);
                (semanticDiagnosticsPerFile || (semanticDiagnosticsPerFile = [])).push(value.length ?
                    [
                        toFileId(key),
                        state.hasReusableDiagnostic ?
                            value :
                            convertToReusableDiagnostics(value, relativeToBuildInfo)
                    ] :
                    toFileId(key));
            }
        }
        var affectedFilesPendingEmit;
        if (state.affectedFilesPendingEmit) {
            var seenFiles = new ts.Set();
            for (var _b = 0, _c = state.affectedFilesPendingEmit.slice(state.affectedFilesPendingEmitIndex).sort(ts.compareStringsCaseSensitive); _b < _c.length; _b++) {
                var path = _c[_b];
                if (ts.tryAddToSet(seenFiles, path)) {
                    (affectedFilesPendingEmit || (affectedFilesPendingEmit = [])).push([toFileId(path), state.affectedFilesPendingEmitKind.get(path)]);
                }
            }
        }
        return {
            fileNames: fileNames,
            fileInfos: fileInfos,
            options: convertToProgramBuildInfoCompilerOptions(state.compilerOptions, relativeToBuildInfoEnsuringAbsolutePath),
            fileIdsList: fileIdsList,
            referencedMap: referencedMap,
            exportedModulesMap: exportedModulesMap,
            semanticDiagnosticsPerFile: semanticDiagnosticsPerFile,
            affectedFilesPendingEmit: affectedFilesPendingEmit,
        };
        function relativeToBuildInfoEnsuringAbsolutePath(path) {
            return relativeToBuildInfo(ts.getNormalizedAbsolutePath(path, currentDirectory));
        }
        function relativeToBuildInfo(path) {
            return ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(buildInfoDirectory, path, getCanonicalFileName));
        }
        function toFileId(path) {
            var fileId = fileNameToFileId.get(path);
            if (fileId === undefined) {
                fileNames.push(relativeToBuildInfo(path));
                fileNameToFileId.set(path, fileId = fileNames.length);
            }
            return fileId;
        }
        function toFileIdListId(set) {
            var fileIds = ts.arrayFrom(set.keys(), toFileId).sort(ts.compareValues);
            var key = fileIds.join();
            var fileIdListId = fileNamesToFileIdListId === null || fileNamesToFileIdListId === void 0 ? void 0 : fileNamesToFileIdListId.get(key);
            if (fileIdListId === undefined) {
                (fileIdsList || (fileIdsList = [])).push(fileIds);
                (fileNamesToFileIdListId || (fileNamesToFileIdListId = new ts.Map())).set(key, fileIdListId = fileIdsList.length);
            }
            return fileIdListId;
        }
    }
    function convertToProgramBuildInfoCompilerOptions(options, relativeToBuildInfo) {
        var result;
        var optionsNameMap = ts.getOptionsNameMap().optionsNameMap;
        for (var _i = 0, _a = ts.getOwnKeys(options).sort(ts.compareStringsCaseSensitive); _i < _a.length; _i++) {
            var name = _a[_i];
            var optionKey = name.toLowerCase();
            var optionInfo = optionsNameMap.get(optionKey);
            if ((optionInfo === null || optionInfo === void 0 ? void 0 : optionInfo.affectsEmit) || (optionInfo === null || optionInfo === void 0 ? void 0 : optionInfo.affectsSemanticDiagnostics) ||
                // We need to store `strict`, even though it won't be examined directly, so that the
                // flags it controls (e.g. `strictNullChecks`) will be retrieved correctly from the buildinfo
                optionKey === "strict" ||
                // We need to store these to determine whether `lib` files need to be rechecked.
                optionKey === "skiplibcheck" || optionKey === "skipdefaultlibcheck") {
                (result || (result = {}))[name] = convertToReusableCompilerOptionValue(optionInfo, options[name], relativeToBuildInfo);
            }
        }
        return result;
    }
    function convertToReusableCompilerOptionValue(option, value, relativeToBuildInfo) {
        if (option) {
            if (option.type === "list") {
                var values = value;
                if (option.element.isFilePath && values.length) {
                    return values.map(relativeToBuildInfo);
                }
            }
            else if (option.isFilePath) {
                return relativeToBuildInfo(value);
            }
        }
        return value;
    }
    function convertToReusableDiagnostics(diagnostics, relativeToBuildInfo) {
        ts.Debug.assert(!!diagnostics.length);
        return diagnostics.map(function (diagnostic) {
            var result = convertToReusableDiagnosticRelatedInformation(diagnostic, relativeToBuildInfo);
            result.reportsUnnecessary = diagnostic.reportsUnnecessary;
            result.reportDeprecated = diagnostic.reportsDeprecated;
            result.source = diagnostic.source;
            result.skippedOn = diagnostic.skippedOn;
            var relatedInformation = diagnostic.relatedInformation;
            result.relatedInformation = relatedInformation ?
                relatedInformation.length ?
                    relatedInformation.map(function (r) { return convertToReusableDiagnosticRelatedInformation(r, relativeToBuildInfo); }) :
                    [] :
                undefined;
            return result;
        });
    }
    function convertToReusableDiagnosticRelatedInformation(diagnostic, relativeToBuildInfo) {
        var file = diagnostic.file;
        return __assign(__assign({}, diagnostic), { file: file ? relativeToBuildInfo(file.resolvedPath) : undefined });
    }
    var BuilderProgramKind;
    (function (BuilderProgramKind) {
        BuilderProgramKind[BuilderProgramKind["SemanticDiagnosticsBuilderProgram"] = 0] = "SemanticDiagnosticsBuilderProgram";
        BuilderProgramKind[BuilderProgramKind["EmitAndSemanticDiagnosticsBuilderProgram"] = 1] = "EmitAndSemanticDiagnosticsBuilderProgram";
    })(BuilderProgramKind = ts.BuilderProgramKind || (ts.BuilderProgramKind = {}));
    function getBuilderCreationParameters(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences) {
        var host;
        var newProgram;
        var oldProgram;
        if (newProgramOrRootNames === undefined) {
            ts.Debug.assert(hostOrOptions === undefined);
            host = oldProgramOrHost;
            oldProgram = configFileParsingDiagnosticsOrOldProgram;
            ts.Debug.assert(!!oldProgram);
            newProgram = oldProgram.getProgram();
        }
        else if (ts.isArray(newProgramOrRootNames)) {
            oldProgram = configFileParsingDiagnosticsOrOldProgram;
            newProgram = ts.createProgram({
                rootNames: newProgramOrRootNames,
                options: hostOrOptions,
                host: oldProgramOrHost,
                oldProgram: oldProgram && oldProgram.getProgramOrUndefined(),
                configFileParsingDiagnostics: configFileParsingDiagnostics,
                projectReferences: projectReferences
            });
            host = oldProgramOrHost;
        }
        else {
            newProgram = newProgramOrRootNames;
            host = hostOrOptions;
            oldProgram = oldProgramOrHost;
            configFileParsingDiagnostics = configFileParsingDiagnosticsOrOldProgram;
        }
        return { host: host, newProgram: newProgram, oldProgram: oldProgram, configFileParsingDiagnostics: configFileParsingDiagnostics || ts.emptyArray };
    }
    ts.getBuilderCreationParameters = getBuilderCreationParameters;
    function createBuilderProgram(kind, _a) {
        var newProgram = _a.newProgram, host = _a.host, oldProgram = _a.oldProgram, configFileParsingDiagnostics = _a.configFileParsingDiagnostics;
        // Return same program if underlying program doesnt change
        var oldState = oldProgram && oldProgram.getState();
        if (oldState && newProgram === oldState.program && configFileParsingDiagnostics === newProgram.getConfigFileParsingDiagnostics()) {
            newProgram = undefined; // TODO: GH#18217
            oldState = undefined;
            return oldProgram;
        }
        /**
         * Create the canonical file name for identity
         */
        var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames());
        /**
         * Computing hash to for signature verification
         */
        var computeHash = ts.maybeBind(host, host.createHash);
        var state = createBuilderProgramState(newProgram, getCanonicalFileName, oldState, host.disableUseFileVersionAsSignature);
        var backupState;
        newProgram.getProgramBuildInfo = function () { return getProgramBuildInfo(state, getCanonicalFileName); };
        // To ensure that we arent storing any references to old program or new program without state
        newProgram = undefined; // TODO: GH#18217
        oldProgram = undefined;
        oldState = undefined;
        var getState = function () { return state; };
        var builderProgram = createRedirectedBuilderProgram(getState, configFileParsingDiagnostics);
        builderProgram.getState = getState;
        builderProgram.backupState = function () {
            ts.Debug.assert(backupState === undefined);
            backupState = cloneBuilderProgramState(state);
        };
        builderProgram.restoreState = function () {
            state = ts.Debug.checkDefined(backupState);
            backupState = undefined;
        };
        builderProgram.getAllDependencies = function (sourceFile) { return ts.BuilderState.getAllDependencies(state, ts.Debug.checkDefined(state.program), sourceFile); };
        builderProgram.getSemanticDiagnostics = getSemanticDiagnostics;
        builderProgram.emit = emit;
        builderProgram.releaseProgram = function () {
            releaseCache(state);
            backupState = undefined;
        };
        if (kind === BuilderProgramKind.SemanticDiagnosticsBuilderProgram) {
            builderProgram.getSemanticDiagnosticsOfNextAffectedFile = getSemanticDiagnosticsOfNextAffectedFile;
        }
        else if (kind === BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram) {
            builderProgram.getSemanticDiagnosticsOfNextAffectedFile = getSemanticDiagnosticsOfNextAffectedFile;
            builderProgram.emitNextAffectedFile = emitNextAffectedFile;
            builderProgram.emitBuildInfo = emitBuildInfo;
        }
        else {
            ts.notImplemented();
        }
        return builderProgram;
        function emitBuildInfo(writeFile, cancellationToken) {
            if (state.buildInfoEmitPending) {
                var result = ts.Debug.checkDefined(state.program).emitBuildInfo(writeFile || ts.maybeBind(host, host.writeFile), cancellationToken);
                state.buildInfoEmitPending = false;
                return result;
            }
            return ts.emitSkippedWithNoDiagnostics;
        }
        /**
         * Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
         * in that order would be used to write the files
         */
        function emitNextAffectedFile(writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
            var affected = getNextAffectedFile(state, cancellationToken, computeHash, host);
            var emitKind = 1 /* BuilderFileEmit.Full */;
            var isPendingEmitFile = false;
            if (!affected) {
                if (!ts.outFile(state.compilerOptions)) {
                    var pendingAffectedFile = getNextAffectedFilePendingEmit(state);
                    if (!pendingAffectedFile) {
                        if (!state.buildInfoEmitPending) {
                            return undefined;
                        }
                        var affected_1 = ts.Debug.checkDefined(state.program);
                        return toAffectedFileEmitResult(state, 
                        // When whole program is affected, do emit only once (eg when --out or --outFile is specified)
                        // Otherwise just affected file
                        affected_1.emitBuildInfo(writeFile || ts.maybeBind(host, host.writeFile), cancellationToken), affected_1, 1 /* BuilderFileEmit.Full */, 
                        /*isPendingEmitFile*/ false, 
                        /*isBuildInfoEmit*/ true);
                    }
                    (affected = pendingAffectedFile.affectedFile, emitKind = pendingAffectedFile.emitKind);
                    isPendingEmitFile = true;
                }
                else {
                    var program = ts.Debug.checkDefined(state.program);
                    if (state.programEmitComplete)
                        return undefined;
                    affected = program;
                }
            }
            return toAffectedFileEmitResult(state, 
            // When whole program is affected, do emit only once (eg when --out or --outFile is specified)
            // Otherwise just affected file
            ts.Debug.checkDefined(state.program).emit(affected === state.program ? undefined : affected, affected !== state.program && ts.getEmitDeclarations(state.compilerOptions) && !customTransformers ?
                getWriteFileUpdatingSignatureCallback(writeFile) :
                writeFile || ts.maybeBind(host, host.writeFile), cancellationToken, emitOnlyDtsFiles || emitKind === 0 /* BuilderFileEmit.DtsOnly */, customTransformers), affected, emitKind, isPendingEmitFile);
        }
        function getWriteFileUpdatingSignatureCallback(writeFile) {
            return function (fileName, text, writeByteOrderMark, onError, sourceFiles, data) {
                var _a;
                if (ts.isDeclarationFileName(fileName)) {
                    ts.Debug.assert((sourceFiles === null || sourceFiles === void 0 ? void 0 : sourceFiles.length) === 1);
                    var file = sourceFiles[0];
                    var info = state.fileInfos.get(file.resolvedPath);
                    var signature = ((_a = state.currentAffectedFilesSignatures) === null || _a === void 0 ? void 0 : _a.get(file.resolvedPath)) || info.signature;
                    if (signature === file.version) {
                        var newSignature = (computeHash || ts.generateDjb2Hash)((data === null || data === void 0 ? void 0 : data.sourceMapUrlPos) !== undefined ? text.substring(0, data.sourceMapUrlPos) : text);
                        if (newSignature !== file.version) { // Update it
                            if (host.storeFilesChangingSignatureDuringEmit)
                                (state.filesChangingSignature || (state.filesChangingSignature = new ts.Set())).add(file.resolvedPath);
                            if (state.exportedModulesMap)
                                ts.BuilderState.updateExportedModules(file, file.exportedModulesFromDeclarationEmit, state.currentAffectedFilesExportedModulesMap || (state.currentAffectedFilesExportedModulesMap = ts.BuilderState.createManyToManyPathMap()));
                            if (state.affectedFiles && state.affectedFilesIndex < state.affectedFiles.length) {
                                state.currentAffectedFilesSignatures.set(file.resolvedPath, newSignature);
                            }
                            else {
                                info.signature = newSignature;
                                if (state.exportedModulesMap)
                                    ts.BuilderState.updateExportedFilesMapFromCache(state, state.currentAffectedFilesExportedModulesMap);
                            }
                        }
                    }
                }
                if (writeFile)
                    writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data);
                else if (host.writeFile)
                    host.writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data);
                else
                    state.program.writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data);
            };
        }
        /**
         * Emits the JavaScript and declaration files.
         * When targetSource file is specified, emits the files corresponding to that source file,
         * otherwise for the whole program.
         * In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,
         * it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,
         * it will only emit all the affected files instead of whole program
         *
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
         * in that order would be used to write the files
         */
        function emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
            var _a;
            if (kind === BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram) {
                assertSourceFileOkWithoutNextAffectedCall(state, targetSourceFile);
            }
            var result = ts.handleNoEmitOptions(builderProgram, targetSourceFile, writeFile, cancellationToken);
            if (result)
                return result;
            // Emit only affected files if using builder for emit
            if (!targetSourceFile) {
                if (kind === BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram) {
                    // Emit and report any errors we ran into.
                    var sourceMaps = [];
                    var emitSkipped = false;
                    var diagnostics = void 0;
                    var emittedFiles = [];
                    var affectedEmitResult = void 0;
                    while (affectedEmitResult = emitNextAffectedFile(writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers)) {
                        emitSkipped = emitSkipped || affectedEmitResult.result.emitSkipped;
                        diagnostics = ts.addRange(diagnostics, affectedEmitResult.result.diagnostics);
                        emittedFiles = ts.addRange(emittedFiles, affectedEmitResult.result.emittedFiles);
                        sourceMaps = ts.addRange(sourceMaps, affectedEmitResult.result.sourceMaps);
                    }
                    return {
                        emitSkipped: emitSkipped,
                        diagnostics: diagnostics || ts.emptyArray,
                        emittedFiles: emittedFiles,
                        sourceMaps: sourceMaps
                    };
                }
                // In non Emit builder, clear affected files pending emit
                else if ((_a = state.affectedFilesPendingEmitKind) === null || _a === void 0 ? void 0 : _a.size) {
                    ts.Debug.assert(kind === BuilderProgramKind.SemanticDiagnosticsBuilderProgram);
                    // State can clear affected files pending emit if
                    if (!emitOnlyDtsFiles // If we are doing complete emit, affected files pending emit can be cleared
                        // If every file pending emit is pending on only dts emit
                        || ts.every(state.affectedFilesPendingEmit, function (path, index) {
                            return index < state.affectedFilesPendingEmitIndex ||
                                state.affectedFilesPendingEmitKind.get(path) === 0 /* BuilderFileEmit.DtsOnly */;
                        })) {
                        clearAffectedFilesPendingEmit(state);
                    }
                }
            }
            return ts.Debug.checkDefined(state.program).emit(targetSourceFile, !ts.outFile(state.compilerOptions) && ts.getEmitDeclarations(state.compilerOptions) && !customTransformers ?
                getWriteFileUpdatingSignatureCallback(writeFile) :
                writeFile || ts.maybeBind(host, host.writeFile), cancellationToken, emitOnlyDtsFiles, customTransformers);
        }
        /**
         * Return the semantic diagnostics for the next affected file or undefined if iteration is complete
         * If provided ignoreSourceFile would be called before getting the diagnostics and would ignore the sourceFile if the returned value was true
         */
        function getSemanticDiagnosticsOfNextAffectedFile(cancellationToken, ignoreSourceFile) {
            while (true) {
                var affected = getNextAffectedFile(state, cancellationToken, computeHash, host);
                if (!affected) {
                    // Done
                    return undefined;
                }
                else if (affected === state.program) {
                    // When whole program is affected, get all semantic diagnostics (eg when --out or --outFile is specified)
                    return toAffectedFileResult(state, state.program.getSemanticDiagnostics(/*targetSourceFile*/ undefined, cancellationToken), affected);
                }
                // Add file to affected file pending emit to handle for later emit time
                // Apart for emit builder do this for tsbuildinfo, do this for non emit builder when noEmit is set as tsbuildinfo is written and reused between emitters
                if (kind === BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram || state.compilerOptions.noEmit || state.compilerOptions.noEmitOnError) {
                    addToAffectedFilesPendingEmit(state, affected.resolvedPath, 1 /* BuilderFileEmit.Full */);
                }
                // Get diagnostics for the affected file if its not ignored
                if (ignoreSourceFile && ignoreSourceFile(affected)) {
                    // Get next affected file
                    doneWithAffectedFile(state, affected);
                    continue;
                }
                return toAffectedFileResult(state, getSemanticDiagnosticsOfFile(state, affected, cancellationToken), affected);
            }
        }
        /**
         * Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program
         * The semantic diagnostics are cached and managed here
         * Note that it is assumed that when asked about semantic diagnostics through this API,
         * the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics
         * In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,
         * it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics
         */
        function getSemanticDiagnostics(sourceFile, cancellationToken) {
            assertSourceFileOkWithoutNextAffectedCall(state, sourceFile);
            var compilerOptions = ts.Debug.checkDefined(state.program).getCompilerOptions();
            if (ts.outFile(compilerOptions)) {
                ts.Debug.assert(!state.semanticDiagnosticsPerFile);
                // We dont need to cache the diagnostics just return them from program
                return ts.Debug.checkDefined(state.program).getSemanticDiagnostics(sourceFile, cancellationToken);
            }
            if (sourceFile) {
                return getSemanticDiagnosticsOfFile(state, sourceFile, cancellationToken);
            }
            // When semantic builder asks for diagnostics of the whole program,
            // ensure that all the affected files are handled
            // eslint-disable-next-line no-empty
            while (getSemanticDiagnosticsOfNextAffectedFile(cancellationToken)) {
            }
            var diagnostics;
            for (var _i = 0, _a = ts.Debug.checkDefined(state.program).getSourceFiles(); _i < _a.length; _i++) {
                var sourceFile_1 = _a[_i];
                diagnostics = ts.addRange(diagnostics, getSemanticDiagnosticsOfFile(state, sourceFile_1, cancellationToken));
            }
            return diagnostics || ts.emptyArray;
        }
    }
    ts.createBuilderProgram = createBuilderProgram;
    function addToAffectedFilesPendingEmit(state, affectedFilePendingEmit, kind) {
        if (!state.affectedFilesPendingEmit)
            state.affectedFilesPendingEmit = [];
        if (!state.affectedFilesPendingEmitKind)
            state.affectedFilesPendingEmitKind = new ts.Map();
        var existingKind = state.affectedFilesPendingEmitKind.get(affectedFilePendingEmit);
        state.affectedFilesPendingEmit.push(affectedFilePendingEmit);
        state.affectedFilesPendingEmitKind.set(affectedFilePendingEmit, existingKind || kind);
        // affectedFilesPendingEmitIndex === undefined
        // - means the emit state.affectedFilesPendingEmit was undefined before adding current affected files
        //   so start from 0 as array would be affectedFilesPendingEmit
        // else, continue to iterate from existing index, the current set is appended to existing files
        if (state.affectedFilesPendingEmitIndex === undefined) {
            state.affectedFilesPendingEmitIndex = 0;
        }
    }
    function toBuilderStateFileInfo(fileInfo) {
        return ts.isString(fileInfo) ?
            { version: fileInfo, signature: fileInfo, affectsGlobalScope: undefined, impliedFormat: undefined } :
            ts.isString(fileInfo.signature) ?
                fileInfo :
                { version: fileInfo.version, signature: fileInfo.signature === false ? undefined : fileInfo.version, affectsGlobalScope: fileInfo.affectsGlobalScope, impliedFormat: fileInfo.impliedFormat };
    }
    ts.toBuilderStateFileInfo = toBuilderStateFileInfo;
    function createBuildProgramUsingProgramBuildInfo(program, buildInfoPath, host) {
        var _a;
        var buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(buildInfoPath, host.getCurrentDirectory()));
        var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames());
        var filePaths = program.fileNames.map(toPath);
        var filePathsSetList = (_a = program.fileIdsList) === null || _a === void 0 ? void 0 : _a.map(function (fileIds) { return new ts.Set(fileIds.map(toFilePath)); });
        var fileInfos = new ts.Map();
        program.fileInfos.forEach(function (fileInfo, index) { return fileInfos.set(toFilePath(index + 1), toBuilderStateFileInfo(fileInfo)); });
        var state = {
            fileInfos: fileInfos,
            compilerOptions: program.options ? ts.convertToOptionsWithAbsolutePaths(program.options, toAbsolutePath) : {},
            referencedMap: toManyToManyPathMap(program.referencedMap),
            exportedModulesMap: toManyToManyPathMap(program.exportedModulesMap),
            semanticDiagnosticsPerFile: program.semanticDiagnosticsPerFile && ts.arrayToMap(program.semanticDiagnosticsPerFile, function (value) { return toFilePath(ts.isNumber(value) ? value : value[0]); }, function (value) { return ts.isNumber(value) ? ts.emptyArray : value[1]; }),
            hasReusableDiagnostic: true,
            affectedFilesPendingEmit: ts.map(program.affectedFilesPendingEmit, function (value) { return toFilePath(value[0]); }),
            affectedFilesPendingEmitKind: program.affectedFilesPendingEmit && ts.arrayToMap(program.affectedFilesPendingEmit, function (value) { return toFilePath(value[0]); }, function (value) { return value[1]; }),
            affectedFilesPendingEmitIndex: program.affectedFilesPendingEmit && 0,
        };
        return {
            getState: function () { return state; },
            backupState: ts.noop,
            restoreState: ts.noop,
            getProgram: ts.notImplemented,
            getProgramOrUndefined: ts.returnUndefined,
            releaseProgram: ts.noop,
            getCompilerOptions: function () { return state.compilerOptions; },
            getSourceFile: ts.notImplemented,
            getSourceFiles: ts.notImplemented,
            getOptionsDiagnostics: ts.notImplemented,
            getGlobalDiagnostics: ts.notImplemented,
            getConfigFileParsingDiagnostics: ts.notImplemented,
            getSyntacticDiagnostics: ts.notImplemented,
            getDeclarationDiagnostics: ts.notImplemented,
            getSemanticDiagnostics: ts.notImplemented,
            emit: ts.notImplemented,
            getAllDependencies: ts.notImplemented,
            getCurrentDirectory: ts.notImplemented,
            emitNextAffectedFile: ts.notImplemented,
            getSemanticDiagnosticsOfNextAffectedFile: ts.notImplemented,
            emitBuildInfo: ts.notImplemented,
            close: ts.noop,
        };
        function toPath(path) {
            return ts.toPath(path, buildInfoDirectory, getCanonicalFileName);
        }
        function toAbsolutePath(path) {
            return ts.getNormalizedAbsolutePath(path, buildInfoDirectory);
        }
        function toFilePath(fileId) {
            return filePaths[fileId - 1];
        }
        function toFilePathsSet(fileIdsListId) {
            return filePathsSetList[fileIdsListId - 1];
        }
        function toManyToManyPathMap(referenceMap) {
            if (!referenceMap) {
                return undefined;
            }
            var map = ts.BuilderState.createManyToManyPathMap();
            referenceMap.forEach(function (_a) {
                var fileId = _a[0], fileIdListId = _a[1];
                return map.set(toFilePath(fileId), toFilePathsSet(fileIdListId));
            });
            return map;
        }
    }
    ts.createBuildProgramUsingProgramBuildInfo = createBuildProgramUsingProgramBuildInfo;
    function createRedirectedBuilderProgram(getState, configFileParsingDiagnostics) {
        return {
            getState: ts.notImplemented,
            backupState: ts.noop,
            restoreState: ts.noop,
            getProgram: getProgram,
            getProgramOrUndefined: function () { return getState().program; },
            releaseProgram: function () { return getState().program = undefined; },
            getCompilerOptions: function () { return getState().compilerOptions; },
            getSourceFile: function (fileName) { return getProgram().getSourceFile(fileName); },
            getSourceFiles: function () { return getProgram().getSourceFiles(); },
            getOptionsDiagnostics: function (cancellationToken) { return getProgram().getOptionsDiagnostics(cancellationToken); },
            getGlobalDiagnostics: function (cancellationToken) { return getProgram().getGlobalDiagnostics(cancellationToken); },
            getConfigFileParsingDiagnostics: function () { return configFileParsingDiagnostics; },
            getSyntacticDiagnostics: function (sourceFile, cancellationToken) { return getProgram().getSyntacticDiagnostics(sourceFile, cancellationToken); },
            getDeclarationDiagnostics: function (sourceFile, cancellationToken) { return getProgram().getDeclarationDiagnostics(sourceFile, cancellationToken); },
            getSemanticDiagnostics: function (sourceFile, cancellationToken) { return getProgram().getSemanticDiagnostics(sourceFile, cancellationToken); },
            emit: function (sourceFile, writeFile, cancellationToken, emitOnlyDts, customTransformers) { return getProgram().emit(sourceFile, writeFile, cancellationToken, emitOnlyDts, customTransformers); },
            emitBuildInfo: function (writeFile, cancellationToken) { return getProgram().emitBuildInfo(writeFile, cancellationToken); },
            getAllDependencies: ts.notImplemented,
            getCurrentDirectory: function () { return getProgram().getCurrentDirectory(); },
            close: ts.noop,
        };
        function getProgram() {
            return ts.Debug.checkDefined(getState().program);
        }
    }
    ts.createRedirectedBuilderProgram = createRedirectedBuilderProgram;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createSemanticDiagnosticsBuilderProgram(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences) {
        return ts.createBuilderProgram(ts.BuilderProgramKind.SemanticDiagnosticsBuilderProgram, ts.getBuilderCreationParameters(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences));
    }
    ts.createSemanticDiagnosticsBuilderProgram = createSemanticDiagnosticsBuilderProgram;
    function createEmitAndSemanticDiagnosticsBuilderProgram(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences) {
        return ts.createBuilderProgram(ts.BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram, ts.getBuilderCreationParameters(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences));
    }
    ts.createEmitAndSemanticDiagnosticsBuilderProgram = createEmitAndSemanticDiagnosticsBuilderProgram;
    function createAbstractBuilder(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences) {
        var _a = ts.getBuilderCreationParameters(newProgramOrRootNames, hostOrOptions, oldProgramOrHost, configFileParsingDiagnosticsOrOldProgram, configFileParsingDiagnostics, projectReferences), newProgram = _a.newProgram, newConfigFileParsingDiagnostics = _a.configFileParsingDiagnostics;
        return ts.createRedirectedBuilderProgram(function () { return ({ program: newProgram, compilerOptions: newProgram.getCompilerOptions() }); }, newConfigFileParsingDiagnostics);
    }
    ts.createAbstractBuilder = createAbstractBuilder;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function removeIgnoredPath(path) {
        // Consider whole staging folder as if node_modules changed.
        if (ts.endsWith(path, "/node_modules/.staging")) {
            return ts.removeSuffix(path, "/.staging");
        }
        return ts.some(ts.ignoredPaths, function (searchPath) { return ts.stringContains(path, searchPath); }) ?
            undefined :
            path;
    }
    ts.removeIgnoredPath = removeIgnoredPath;
    /**
     * Filter out paths like
     * "/", "/user", "/user/username", "/user/username/folderAtRoot",
     * "c:/", "c:/users", "c:/users/username", "c:/users/username/folderAtRoot", "c:/folderAtRoot"
     * @param dirPath
     */
    function canWatchDirectory(dirPath) {
        var rootLength = ts.getRootLength(dirPath);
        if (dirPath.length === rootLength) {
            // Ignore "/", "c:/"
            return false;
        }
        var nextDirectorySeparator = dirPath.indexOf(ts.directorySeparator, rootLength);
        if (nextDirectorySeparator === -1) {
            // ignore "/user", "c:/users" or "c:/folderAtRoot"
            return false;
        }
        var pathPartForUserCheck = dirPath.substring(rootLength, nextDirectorySeparator + 1);
        var isNonDirectorySeparatorRoot = rootLength > 1 || dirPath.charCodeAt(0) !== 47 /* CharacterCodes.slash */;
        if (isNonDirectorySeparatorRoot &&
            dirPath.search(/[a-zA-Z]:/) !== 0 && // Non dos style paths
            pathPartForUserCheck.search(/[a-zA-z]\$\//) === 0) { // Dos style nextPart
            nextDirectorySeparator = dirPath.indexOf(ts.directorySeparator, nextDirectorySeparator + 1);
            if (nextDirectorySeparator === -1) {
                // ignore "//vda1cs4850/c$/folderAtRoot"
                return false;
            }
            pathPartForUserCheck = dirPath.substring(rootLength + pathPartForUserCheck.length, nextDirectorySeparator + 1);
        }
        if (isNonDirectorySeparatorRoot &&
            pathPartForUserCheck.search(/users\//i) !== 0) {
            // Paths like c:/folderAtRoot/subFolder are allowed
            return true;
        }
        for (var searchIndex = nextDirectorySeparator + 1, searchLevels = 2; searchLevels > 0; searchLevels--) {
            searchIndex = dirPath.indexOf(ts.directorySeparator, searchIndex) + 1;
            if (searchIndex === 0) {
                // Folder isnt at expected minimum levels
                return false;
            }
        }
        return true;
    }
    ts.canWatchDirectory = canWatchDirectory;
    function createResolutionCache(resolutionHost, rootDirForResolution, logChangesWhenResolvingModule) {
        var filesWithChangedSetOfUnresolvedImports;
        var filesWithInvalidatedResolutions;
        var filesWithInvalidatedNonRelativeUnresolvedImports;
        var nonRelativeExternalModuleResolutions = ts.createMultiMap();
        var resolutionsWithFailedLookups = [];
        var resolvedFileToResolution = ts.createMultiMap();
        var hasChangedAutomaticTypeDirectiveNames = false;
        var failedLookupChecks;
        var startsWithPathChecks;
        var isInDirectoryChecks;
        var getCurrentDirectory = ts.memoize(function () { return resolutionHost.getCurrentDirectory(); }); // TODO: GH#18217
        var cachedDirectoryStructureHost = resolutionHost.getCachedDirectoryStructureHost();
        // The resolvedModuleNames and resolvedTypeReferenceDirectives are the cache of resolutions per file.
        // The key in the map is source file's path.
        // The values are Map of resolutions with key being name lookedup.
        var resolvedModuleNames = new ts.Map();
        var perDirectoryResolvedModuleNames = ts.createCacheWithRedirects();
        var nonRelativeModuleNameCache = ts.createCacheWithRedirects();
        var moduleResolutionCache = ts.createModuleResolutionCache(getCurrentDirectory(), resolutionHost.getCanonicalFileName, 
        /*options*/ undefined, perDirectoryResolvedModuleNames, nonRelativeModuleNameCache);
        var resolvedTypeReferenceDirectives = new ts.Map();
        var perDirectoryResolvedTypeReferenceDirectives = ts.createCacheWithRedirects();
        var typeReferenceDirectiveResolutionCache = ts.createTypeReferenceDirectiveResolutionCache(getCurrentDirectory(), resolutionHost.getCanonicalFileName, 
        /*options*/ undefined, moduleResolutionCache.getPackageJsonInfoCache(), perDirectoryResolvedTypeReferenceDirectives);
        /**
         * These are the extensions that failed lookup files will have by default,
         * any other extension of failed lookup will be store that path in custom failed lookup path
         * This helps in not having to comb through all resolutions when files are added/removed
         * Note that .d.ts file also has .d.ts extension hence will be part of default extensions
         */
        var failedLookupDefaultExtensions = [".ts" /* Extension.Ts */, ".tsx" /* Extension.Tsx */, ".js" /* Extension.Js */, ".jsx" /* Extension.Jsx */, ".json" /* Extension.Json */];
        var customFailedLookupPaths = new ts.Map();
        var directoryWatchesOfFailedLookups = new ts.Map();
        var rootDir = rootDirForResolution && ts.removeTrailingDirectorySeparator(ts.getNormalizedAbsolutePath(rootDirForResolution, getCurrentDirectory()));
        var rootPath = (rootDir && resolutionHost.toPath(rootDir)); // TODO: GH#18217
        var rootSplitLength = rootPath !== undefined ? rootPath.split(ts.directorySeparator).length : 0;
        // TypeRoot watches for the types that get added as part of getAutomaticTypeDirectiveNames
        var typeRootsWatches = new ts.Map();
        return {
            getModuleResolutionCache: function () { return moduleResolutionCache; },
            startRecordingFilesWithChangedResolutions: startRecordingFilesWithChangedResolutions,
            finishRecordingFilesWithChangedResolutions: finishRecordingFilesWithChangedResolutions,
            // perDirectoryResolvedModuleNames and perDirectoryResolvedTypeReferenceDirectives could be non empty if there was exception during program update
            // (between startCachingPerDirectoryResolution and finishCachingPerDirectoryResolution)
            startCachingPerDirectoryResolution: clearPerDirectoryResolutions,
            finishCachingPerDirectoryResolution: finishCachingPerDirectoryResolution,
            resolveModuleNames: resolveModuleNames,
            getResolvedModuleWithFailedLookupLocationsFromCache: getResolvedModuleWithFailedLookupLocationsFromCache,
            resolveTypeReferenceDirectives: resolveTypeReferenceDirectives,
            removeResolutionsFromProjectReferenceRedirects: removeResolutionsFromProjectReferenceRedirects,
            removeResolutionsOfFile: removeResolutionsOfFile,
            hasChangedAutomaticTypeDirectiveNames: function () { return hasChangedAutomaticTypeDirectiveNames; },
            invalidateResolutionOfFile: invalidateResolutionOfFile,
            invalidateResolutionsOfFailedLookupLocations: invalidateResolutionsOfFailedLookupLocations,
            setFilesWithInvalidatedNonRelativeUnresolvedImports: setFilesWithInvalidatedNonRelativeUnresolvedImports,
            createHasInvalidatedResolution: createHasInvalidatedResolution,
            isFileWithInvalidatedNonRelativeUnresolvedImports: isFileWithInvalidatedNonRelativeUnresolvedImports,
            updateTypeRootsWatch: updateTypeRootsWatch,
            closeTypeRootsWatch: closeTypeRootsWatch,
            clear: clear
        };
        function getResolvedModule(resolution) {
            return resolution.resolvedModule;
        }
        function getResolvedTypeReferenceDirective(resolution) {
            return resolution.resolvedTypeReferenceDirective;
        }
        function isInDirectoryPath(dir, file) {
            if (dir === undefined || file.length <= dir.length) {
                return false;
            }
            return ts.startsWith(file, dir) && file[dir.length] === ts.directorySeparator;
        }
        function clear() {
            ts.clearMap(directoryWatchesOfFailedLookups, ts.closeFileWatcherOf);
            customFailedLookupPaths.clear();
            nonRelativeExternalModuleResolutions.clear();
            closeTypeRootsWatch();
            resolvedModuleNames.clear();
            resolvedTypeReferenceDirectives.clear();
            resolvedFileToResolution.clear();
            resolutionsWithFailedLookups.length = 0;
            failedLookupChecks = undefined;
            startsWithPathChecks = undefined;
            isInDirectoryChecks = undefined;
            // perDirectoryResolvedModuleNames and perDirectoryResolvedTypeReferenceDirectives could be non empty if there was exception during program update
            // (between startCachingPerDirectoryResolution and finishCachingPerDirectoryResolution)
            clearPerDirectoryResolutions();
            hasChangedAutomaticTypeDirectiveNames = false;
        }
        function startRecordingFilesWithChangedResolutions() {
            filesWithChangedSetOfUnresolvedImports = [];
        }
        function finishRecordingFilesWithChangedResolutions() {
            var collected = filesWithChangedSetOfUnresolvedImports;
            filesWithChangedSetOfUnresolvedImports = undefined;
            return collected;
        }
        function isFileWithInvalidatedNonRelativeUnresolvedImports(path) {
            if (!filesWithInvalidatedNonRelativeUnresolvedImports) {
                return false;
            }
            // Invalidated if file has unresolved imports
            var value = filesWithInvalidatedNonRelativeUnresolvedImports.get(path);
            return !!value && !!value.length;
        }
        function createHasInvalidatedResolution(forceAllFilesAsInvalidated) {
            // Ensure pending resolutions are applied
            invalidateResolutionsOfFailedLookupLocations();
            if (forceAllFilesAsInvalidated) {
                // Any file asked would have invalidated resolution
                filesWithInvalidatedResolutions = undefined;
                return ts.returnTrue;
            }
            var collected = filesWithInvalidatedResolutions;
            filesWithInvalidatedResolutions = undefined;
            return function (path) { return (!!collected && collected.has(path)) ||
                isFileWithInvalidatedNonRelativeUnresolvedImports(path); };
        }
        function clearPerDirectoryResolutions() {
            moduleResolutionCache.clear();
            typeReferenceDirectiveResolutionCache.clear();
            nonRelativeExternalModuleResolutions.forEach(watchFailedLookupLocationOfNonRelativeModuleResolutions);
            nonRelativeExternalModuleResolutions.clear();
        }
        function finishCachingPerDirectoryResolution() {
            filesWithInvalidatedNonRelativeUnresolvedImports = undefined;
            clearPerDirectoryResolutions();
            directoryWatchesOfFailedLookups.forEach(function (watcher, path) {
                if (watcher.refCount === 0) {
                    directoryWatchesOfFailedLookups.delete(path);
                    watcher.watcher.close();
                }
            });
            hasChangedAutomaticTypeDirectiveNames = false;
        }
        function resolveModuleName(moduleName, containingFile, compilerOptions, host, redirectedReference, _containingSourceFile, mode) {
            var _a;
            var primaryResult = ts.resolveModuleName(moduleName, containingFile, compilerOptions, host, moduleResolutionCache, redirectedReference, mode);
            // return result immediately only if global cache support is not enabled or if it is .ts, .tsx or .d.ts
            if (!resolutionHost.getGlobalCache) {
                return primaryResult;
            }
            // otherwise try to load typings from @types
            var globalCache = resolutionHost.getGlobalCache();
            if (globalCache !== undefined && !ts.isExternalModuleNameRelative(moduleName) && !(primaryResult.resolvedModule && ts.extensionIsTS(primaryResult.resolvedModule.extension))) {
                // create different collection of failed lookup locations for second pass
                // if it will fail and we've already found something during the first pass - we don't want to pollute its results
                var _b = ts.loadModuleFromGlobalCache(ts.Debug.checkDefined(resolutionHost.globalCacheResolutionModuleName)(moduleName), resolutionHost.projectName, compilerOptions, host, globalCache, moduleResolutionCache), resolvedModule = _b.resolvedModule, failedLookupLocations = _b.failedLookupLocations;
                if (resolvedModule) {
                    // Modify existing resolution so its saved in the directory cache as well
                    primaryResult.resolvedModule = resolvedModule;
                    (_a = primaryResult.failedLookupLocations).push.apply(_a, failedLookupLocations);
                    return primaryResult;
                }
            }
            // Default return the result from the first pass
            return primaryResult;
        }
        function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference, _containingSourceFile, resolutionMode) {
            return ts.resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference, typeReferenceDirectiveResolutionCache, resolutionMode);
        }
        function resolveNamesWithLocalCache(_a) {
            var _b, _c, _d;
            var names = _a.names, containingFile = _a.containingFile, redirectedReference = _a.redirectedReference, cache = _a.cache, perDirectoryCacheWithRedirects = _a.perDirectoryCacheWithRedirects, loader = _a.loader, getResolutionWithResolvedFileName = _a.getResolutionWithResolvedFileName, shouldRetryResolution = _a.shouldRetryResolution, reusedNames = _a.reusedNames, logChanges = _a.logChanges, containingSourceFile = _a.containingSourceFile, containingSourceFileMode = _a.containingSourceFileMode;
            var path = resolutionHost.toPath(containingFile);
            var resolutionsInFile = cache.get(path) || cache.set(path, ts.createModeAwareCache()).get(path);
            var dirPath = ts.getDirectoryPath(path);
            var perDirectoryCache = perDirectoryCacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
            var perDirectoryResolution = perDirectoryCache.get(dirPath);
            if (!perDirectoryResolution) {
                perDirectoryResolution = ts.createModeAwareCache();
                perDirectoryCache.set(dirPath, perDirectoryResolution);
            }
            var resolvedModules = [];
            var compilerOptions = resolutionHost.getCompilationSettings();
            var hasInvalidatedNonRelativeUnresolvedImport = logChanges && isFileWithInvalidatedNonRelativeUnresolvedImports(path);
            // All the resolutions in this file are invalidated if this file wasn't resolved using same redirect
            var program = resolutionHost.getCurrentProgram();
            var oldRedirect = program && program.getResolvedProjectReferenceToRedirect(containingFile);
            var unmatchedRedirects = oldRedirect ?
                !redirectedReference || redirectedReference.sourceFile.path !== oldRedirect.sourceFile.path :
                !!redirectedReference;
            var seenNamesInFile = ts.createModeAwareCache();
            var i = 0;
            for (var _i = 0, names_5 = names; _i < names_5.length; _i++) {
                var entry = names_5[_i];
                var name = ts.isString(entry) ? entry : entry.fileName.toLowerCase();
                // Imports supply a `containingSourceFile` but no `containingSourceFileMode` - it would be redundant
                // they require calculating the mode for a given import from it's position in the resolution table, since a given
                // import's syntax may override the file's default mode.
                // Type references instead supply a `containingSourceFileMode` and a non-string entry which contains
                // a default file mode override if applicable.
                var mode = !ts.isString(entry) ? ts.getModeForFileReference(entry, containingSourceFileMode) :
                    containingSourceFile ? ts.getModeForResolutionAtIndex(containingSourceFile, i) : undefined;
                i++;
                var resolution = resolutionsInFile.get(name, mode);
                // Resolution is valid if it is present and not invalidated
                if (!seenNamesInFile.has(name, mode) &&
                    unmatchedRedirects || !resolution || resolution.isInvalidated ||
                    // If the name is unresolved import that was invalidated, recalculate
                    (hasInvalidatedNonRelativeUnresolvedImport && !ts.isExternalModuleNameRelative(name) && shouldRetryResolution(resolution))) {
                    var existingResolution = resolution;
                    var resolutionInDirectory = perDirectoryResolution.get(name, mode);
                    if (resolutionInDirectory) {
                        resolution = resolutionInDirectory;
                        var host = ((_b = resolutionHost.getCompilerHost) === null || _b === void 0 ? void 0 : _b.call(resolutionHost)) || resolutionHost;
                        if (ts.isTraceEnabled(compilerOptions, host)) {
                            var resolved = getResolutionWithResolvedFileName(resolution);
                            ts.trace(host, loader === resolveModuleName ?
                                (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                    resolved.packagetId ?
                                        ts.Diagnostics.Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4 :
                                        ts.Diagnostics.Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3 :
                                    ts.Diagnostics.Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved :
                                (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                    resolved.packagetId ?
                                        ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4 :
                                        ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3 :
                                    ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved, name, containingFile, ts.getDirectoryPath(containingFile), resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName, (resolved === null || resolved === void 0 ? void 0 : resolved.packagetId) && ts.packageIdToString(resolved.packagetId));
                        }
                    }
                    else {
                        resolution = loader(name, containingFile, compilerOptions, ((_c = resolutionHost.getCompilerHost) === null || _c === void 0 ? void 0 : _c.call(resolutionHost)) || resolutionHost, redirectedReference, containingSourceFile, mode);
                        perDirectoryResolution.set(name, mode, resolution);
                        if (resolutionHost.onDiscoveredSymlink && resolutionIsSymlink(resolution)) {
                            resolutionHost.onDiscoveredSymlink();
                        }
                    }
                    resolutionsInFile.set(name, mode, resolution);
                    watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution, path, getResolutionWithResolvedFileName);
                    if (existingResolution) {
                        stopWatchFailedLookupLocationOfResolution(existingResolution, path, getResolutionWithResolvedFileName);
                    }
                    if (logChanges && filesWithChangedSetOfUnresolvedImports && !resolutionIsEqualTo(existingResolution, resolution)) {
                        filesWithChangedSetOfUnresolvedImports.push(path);
                        // reset log changes to avoid recording the same file multiple times
                        logChanges = false;
                    }
                }
                else {
                    var host = ((_d = resolutionHost.getCompilerHost) === null || _d === void 0 ? void 0 : _d.call(resolutionHost)) || resolutionHost;
                    if (ts.isTraceEnabled(compilerOptions, host) && !seenNamesInFile.has(name, mode)) {
                        var resolved = getResolutionWithResolvedFileName(resolution);
                        ts.trace(host, loader === resolveModuleName ?
                            (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                resolved.packagetId ?
                                    ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3 :
                                    ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2 :
                                ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved :
                            (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                resolved.packagetId ?
                                    ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3 :
                                    ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2 :
                                ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved, name, containingFile, resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName, (resolved === null || resolved === void 0 ? void 0 : resolved.packagetId) && ts.packageIdToString(resolved.packagetId));
                    }
                }
                ts.Debug.assert(resolution !== undefined && !resolution.isInvalidated);
                seenNamesInFile.set(name, mode, true);
                resolvedModules.push(getResolutionWithResolvedFileName(resolution));
            }
            // Stop watching and remove the unused name
            resolutionsInFile.forEach(function (resolution, name, mode) {
                if (!seenNamesInFile.has(name, mode) && !ts.contains(reusedNames, name)) {
                    stopWatchFailedLookupLocationOfResolution(resolution, path, getResolutionWithResolvedFileName);
                    resolutionsInFile.delete(name, mode);
                }
            });
            return resolvedModules;
            function resolutionIsEqualTo(oldResolution, newResolution) {
                if (oldResolution === newResolution) {
                    return true;
                }
                if (!oldResolution || !newResolution) {
                    return false;
                }
                var oldResult = getResolutionWithResolvedFileName(oldResolution);
                var newResult = getResolutionWithResolvedFileName(newResolution);
                if (oldResult === newResult) {
                    return true;
                }
                if (!oldResult || !newResult) {
                    return false;
                }
                return oldResult.resolvedFileName === newResult.resolvedFileName;
            }
        }
        function resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, redirectedReference, containingFileMode) {
            return resolveNamesWithLocalCache({
                names: typeDirectiveNames,
                containingFile: containingFile,
                redirectedReference: redirectedReference,
                cache: resolvedTypeReferenceDirectives,
                perDirectoryCacheWithRedirects: perDirectoryResolvedTypeReferenceDirectives,
                loader: resolveTypeReferenceDirective,
                getResolutionWithResolvedFileName: getResolvedTypeReferenceDirective,
                shouldRetryResolution: function (resolution) { return resolution.resolvedTypeReferenceDirective === undefined; },
                containingSourceFileMode: containingFileMode
            });
        }
        function resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, containingSourceFile) {
            return resolveNamesWithLocalCache({
                names: moduleNames,
                containingFile: containingFile,
                redirectedReference: redirectedReference,
                cache: resolvedModuleNames,
                perDirectoryCacheWithRedirects: perDirectoryResolvedModuleNames,
                loader: resolveModuleName,
                getResolutionWithResolvedFileName: getResolvedModule,
                shouldRetryResolution: function (resolution) { return !resolution.resolvedModule || !ts.resolutionExtensionIsTSOrJson(resolution.resolvedModule.extension); },
                reusedNames: reusedNames,
                logChanges: logChangesWhenResolvingModule,
                containingSourceFile: containingSourceFile,
            });
        }
        function getResolvedModuleWithFailedLookupLocationsFromCache(moduleName, containingFile, resolutionMode) {
            var cache = resolvedModuleNames.get(resolutionHost.toPath(containingFile));
            if (!cache)
                return undefined;
            return cache.get(moduleName, resolutionMode);
        }
        function isNodeModulesAtTypesDirectory(dirPath) {
            return ts.endsWith(dirPath, "/node_modules/@types");
        }
        function getDirectoryToWatchFailedLookupLocation(failedLookupLocation, failedLookupLocationPath) {
            if (isInDirectoryPath(rootPath, failedLookupLocationPath)) {
                // Ensure failed look up is normalized path
                failedLookupLocation = ts.isRootedDiskPath(failedLookupLocation) ? ts.normalizePath(failedLookupLocation) : ts.getNormalizedAbsolutePath(failedLookupLocation, getCurrentDirectory());
                var failedLookupPathSplit = failedLookupLocationPath.split(ts.directorySeparator);
                var failedLookupSplit = failedLookupLocation.split(ts.directorySeparator);
                ts.Debug.assert(failedLookupSplit.length === failedLookupPathSplit.length, "FailedLookup: ".concat(failedLookupLocation, " failedLookupLocationPath: ").concat(failedLookupLocationPath));
                if (failedLookupPathSplit.length > rootSplitLength + 1) {
                    // Instead of watching root, watch directory in root to avoid watching excluded directories not needed for module resolution
                    return {
                        dir: failedLookupSplit.slice(0, rootSplitLength + 1).join(ts.directorySeparator),
                        dirPath: failedLookupPathSplit.slice(0, rootSplitLength + 1).join(ts.directorySeparator)
                    };
                }
                else {
                    // Always watch root directory non recursively
                    return {
                        dir: rootDir,
                        dirPath: rootPath,
                        nonRecursive: false
                    };
                }
            }
            return getDirectoryToWatchFromFailedLookupLocationDirectory(ts.getDirectoryPath(ts.getNormalizedAbsolutePath(failedLookupLocation, getCurrentDirectory())), ts.getDirectoryPath(failedLookupLocationPath));
        }
        function getDirectoryToWatchFromFailedLookupLocationDirectory(dir, dirPath) {
            // If directory path contains node module, get the most parent node_modules directory for watching
            while (ts.pathContainsNodeModules(dirPath)) {
                dir = ts.getDirectoryPath(dir);
                dirPath = ts.getDirectoryPath(dirPath);
            }
            // If the directory is node_modules use it to watch, always watch it recursively
            if (ts.isNodeModulesDirectory(dirPath)) {
                return canWatchDirectory(ts.getDirectoryPath(dirPath)) ? { dir: dir, dirPath: dirPath } : undefined;
            }
            var nonRecursive = true;
            // Use some ancestor of the root directory
            var subDirectoryPath, subDirectory;
            if (rootPath !== undefined) {
                while (!isInDirectoryPath(dirPath, rootPath)) {
                    var parentPath = ts.getDirectoryPath(dirPath);
                    if (parentPath === dirPath) {
                        break;
                    }
                    nonRecursive = false;
                    subDirectoryPath = dirPath;
                    subDirectory = dir;
                    dirPath = parentPath;
                    dir = ts.getDirectoryPath(dir);
                }
            }
            return canWatchDirectory(dirPath) ? { dir: subDirectory || dir, dirPath: subDirectoryPath || dirPath, nonRecursive: nonRecursive } : undefined;
        }
        function isPathWithDefaultFailedLookupExtension(path) {
            return ts.fileExtensionIsOneOf(path, failedLookupDefaultExtensions);
        }
        function watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution, filePath, getResolutionWithResolvedFileName) {
            if (resolution.refCount) {
                resolution.refCount++;
                ts.Debug.assertIsDefined(resolution.files);
            }
            else {
                resolution.refCount = 1;
                ts.Debug.assert(ts.length(resolution.files) === 0); // This resolution shouldnt be referenced by any file yet
                if (ts.isExternalModuleNameRelative(name)) {
                    watchFailedLookupLocationOfResolution(resolution);
                }
                else {
                    nonRelativeExternalModuleResolutions.add(name, resolution);
                }
                var resolved = getResolutionWithResolvedFileName(resolution);
                if (resolved && resolved.resolvedFileName) {
                    resolvedFileToResolution.add(resolutionHost.toPath(resolved.resolvedFileName), resolution);
                }
            }
            (resolution.files || (resolution.files = [])).push(filePath);
        }
        function watchFailedLookupLocationOfResolution(resolution) {
            ts.Debug.assert(!!resolution.refCount);
            var failedLookupLocations = resolution.failedLookupLocations;
            if (!failedLookupLocations.length)
                return;
            resolutionsWithFailedLookups.push(resolution);
            var setAtRoot = false;
            for (var _i = 0, failedLookupLocations_1 = failedLookupLocations; _i < failedLookupLocations_1.length; _i++) {
                var failedLookupLocation = failedLookupLocations_1[_i];
                var failedLookupLocationPath = resolutionHost.toPath(failedLookupLocation);
                var toWatch = getDirectoryToWatchFailedLookupLocation(failedLookupLocation, failedLookupLocationPath);
                if (toWatch) {
                    var dir = toWatch.dir, dirPath = toWatch.dirPath, nonRecursive = toWatch.nonRecursive;
                    // If the failed lookup location path is not one of the supported extensions,
                    // store it in the custom path
                    if (!isPathWithDefaultFailedLookupExtension(failedLookupLocationPath)) {
                        var refCount = customFailedLookupPaths.get(failedLookupLocationPath) || 0;
                        customFailedLookupPaths.set(failedLookupLocationPath, refCount + 1);
                    }
                    if (dirPath === rootPath) {
                        ts.Debug.assert(!nonRecursive);
                        setAtRoot = true;
                    }
                    else {
                        setDirectoryWatcher(dir, dirPath, nonRecursive);
                    }
                }
            }
            if (setAtRoot) {
                // This is always non recursive
                setDirectoryWatcher(rootDir, rootPath, /*nonRecursive*/ true); // TODO: GH#18217
            }
        }
        function watchFailedLookupLocationOfNonRelativeModuleResolutions(resolutions, name) {
            var program = resolutionHost.getCurrentProgram();
            if (!program || !program.getTypeChecker().tryFindAmbientModuleWithoutAugmentations(name)) {
                resolutions.forEach(watchFailedLookupLocationOfResolution);
            }
        }
        function setDirectoryWatcher(dir, dirPath, nonRecursive) {
            var dirWatcher = directoryWatchesOfFailedLookups.get(dirPath);
            if (dirWatcher) {
                ts.Debug.assert(!!nonRecursive === !!dirWatcher.nonRecursive);
                dirWatcher.refCount++;
            }
            else {
                directoryWatchesOfFailedLookups.set(dirPath, { watcher: createDirectoryWatcher(dir, dirPath, nonRecursive), refCount: 1, nonRecursive: nonRecursive });
            }
        }
        function stopWatchFailedLookupLocationOfResolution(resolution, filePath, getResolutionWithResolvedFileName) {
            ts.unorderedRemoveItem(ts.Debug.checkDefined(resolution.files), filePath);
            resolution.refCount--;
            if (resolution.refCount) {
                return;
            }
            var resolved = getResolutionWithResolvedFileName(resolution);
            if (resolved && resolved.resolvedFileName) {
                resolvedFileToResolution.remove(resolutionHost.toPath(resolved.resolvedFileName), resolution);
            }
            if (!ts.unorderedRemoveItem(resolutionsWithFailedLookups, resolution)) {
                // If not watching failed lookups, it wont be there in resolutionsWithFailedLookups
                return;
            }
            var failedLookupLocations = resolution.failedLookupLocations;
            var removeAtRoot = false;
            for (var _i = 0, failedLookupLocations_2 = failedLookupLocations; _i < failedLookupLocations_2.length; _i++) {
                var failedLookupLocation = failedLookupLocations_2[_i];
                var failedLookupLocationPath = resolutionHost.toPath(failedLookupLocation);
                var toWatch = getDirectoryToWatchFailedLookupLocation(failedLookupLocation, failedLookupLocationPath);
                if (toWatch) {
                    var dirPath = toWatch.dirPath;
                    var refCount = customFailedLookupPaths.get(failedLookupLocationPath);
                    if (refCount) {
                        if (refCount === 1) {
                            customFailedLookupPaths.delete(failedLookupLocationPath);
                        }
                        else {
                            ts.Debug.assert(refCount > 1);
                            customFailedLookupPaths.set(failedLookupLocationPath, refCount - 1);
                        }
                    }
                    if (dirPath === rootPath) {
                        removeAtRoot = true;
                    }
                    else {
                        removeDirectoryWatcher(dirPath);
                    }
                }
            }
            if (removeAtRoot) {
                removeDirectoryWatcher(rootPath);
            }
        }
        function removeDirectoryWatcher(dirPath) {
            var dirWatcher = directoryWatchesOfFailedLookups.get(dirPath);
            // Do not close the watcher yet since it might be needed by other failed lookup locations.
            dirWatcher.refCount--;
        }
        function createDirectoryWatcher(directory, dirPath, nonRecursive) {
            return resolutionHost.watchDirectoryOfFailedLookupLocation(directory, function (fileOrDirectory) {
                var fileOrDirectoryPath = resolutionHost.toPath(fileOrDirectory);
                if (cachedDirectoryStructureHost) {
                    // Since the file existence changed, update the sourceFiles cache
                    cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                }
                scheduleInvalidateResolutionOfFailedLookupLocation(fileOrDirectoryPath, dirPath === fileOrDirectoryPath);
            }, nonRecursive ? 0 /* WatchDirectoryFlags.None */ : 1 /* WatchDirectoryFlags.Recursive */);
        }
        function removeResolutionsOfFileFromCache(cache, filePath, getResolutionWithResolvedFileName) {
            // Deleted file, stop watching failed lookups for all the resolutions in the file
            var resolutions = cache.get(filePath);
            if (resolutions) {
                resolutions.forEach(function (resolution) { return stopWatchFailedLookupLocationOfResolution(resolution, filePath, getResolutionWithResolvedFileName); });
                cache.delete(filePath);
            }
        }
        function removeResolutionsFromProjectReferenceRedirects(filePath) {
            if (!ts.fileExtensionIs(filePath, ".json" /* Extension.Json */))
                return;
            var program = resolutionHost.getCurrentProgram();
            if (!program)
                return;
            // If this file is input file for the referenced project, get it
            var resolvedProjectReference = program.getResolvedProjectReferenceByPath(filePath);
            if (!resolvedProjectReference)
                return;
            // filePath is for the projectReference and the containing file is from this project reference, invalidate the resolution
            resolvedProjectReference.commandLine.fileNames.forEach(function (f) { return removeResolutionsOfFile(resolutionHost.toPath(f)); });
        }
        function removeResolutionsOfFile(filePath) {
            removeResolutionsOfFileFromCache(resolvedModuleNames, filePath, getResolvedModule);
            removeResolutionsOfFileFromCache(resolvedTypeReferenceDirectives, filePath, getResolvedTypeReferenceDirective);
        }
        function invalidateResolutions(resolutions, canInvalidate) {
            if (!resolutions)
                return false;
            var invalidated = false;
            for (var _i = 0, resolutions_1 = resolutions; _i < resolutions_1.length; _i++) {
                var resolution = resolutions_1[_i];
                if (resolution.isInvalidated || !canInvalidate(resolution))
                    continue;
                resolution.isInvalidated = invalidated = true;
                for (var _a = 0, _b = ts.Debug.checkDefined(resolution.files); _a < _b.length; _a++) {
                    var containingFilePath = _b[_a];
                    (filesWithInvalidatedResolutions || (filesWithInvalidatedResolutions = new ts.Set())).add(containingFilePath);
                    // When its a file with inferred types resolution, invalidate type reference directive resolution
                    hasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames || ts.endsWith(containingFilePath, ts.inferredTypesContainingFile);
                }
            }
            return invalidated;
        }
        function invalidateResolutionOfFile(filePath) {
            removeResolutionsOfFile(filePath);
            // Resolution is invalidated if the resulting file name is same as the deleted file path
            var prevHasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames;
            if (invalidateResolutions(resolvedFileToResolution.get(filePath), ts.returnTrue) &&
                hasChangedAutomaticTypeDirectiveNames &&
                !prevHasChangedAutomaticTypeDirectiveNames) {
                resolutionHost.onChangedAutomaticTypeDirectiveNames();
            }
        }
        function setFilesWithInvalidatedNonRelativeUnresolvedImports(filesMap) {
            ts.Debug.assert(filesWithInvalidatedNonRelativeUnresolvedImports === filesMap || filesWithInvalidatedNonRelativeUnresolvedImports === undefined);
            filesWithInvalidatedNonRelativeUnresolvedImports = filesMap;
        }
        function scheduleInvalidateResolutionOfFailedLookupLocation(fileOrDirectoryPath, isCreatingWatchedDirectory) {
            if (isCreatingWatchedDirectory) {
                // Watching directory is created
                // Invalidate any resolution has failed lookup in this directory
                (isInDirectoryChecks || (isInDirectoryChecks = [])).push(fileOrDirectoryPath);
            }
            else {
                // If something to do with folder/file starting with "." in node_modules folder, skip it
                var updatedPath = removeIgnoredPath(fileOrDirectoryPath);
                if (!updatedPath)
                    return false;
                fileOrDirectoryPath = updatedPath;
                // prevent saving an open file from over-eagerly triggering invalidation
                if (resolutionHost.fileIsOpen(fileOrDirectoryPath)) {
                    return false;
                }
                // Some file or directory in the watching directory is created
                // Return early if it does not have any of the watching extension or not the custom failed lookup path
                var dirOfFileOrDirectory = ts.getDirectoryPath(fileOrDirectoryPath);
                if (isNodeModulesAtTypesDirectory(fileOrDirectoryPath) || ts.isNodeModulesDirectory(fileOrDirectoryPath) ||
                    isNodeModulesAtTypesDirectory(dirOfFileOrDirectory) || ts.isNodeModulesDirectory(dirOfFileOrDirectory)) {
                    // Invalidate any resolution from this directory
                    (failedLookupChecks || (failedLookupChecks = [])).push(fileOrDirectoryPath);
                    (startsWithPathChecks || (startsWithPathChecks = new ts.Set())).add(fileOrDirectoryPath);
                }
                else {
                    if (!isPathWithDefaultFailedLookupExtension(fileOrDirectoryPath) && !customFailedLookupPaths.has(fileOrDirectoryPath)) {
                        return false;
                    }
                    // Ignore emits from the program
                    if (ts.isEmittedFileOfProgram(resolutionHost.getCurrentProgram(), fileOrDirectoryPath)) {
                        return false;
                    }
                    // Resolution need to be invalidated if failed lookup location is same as the file or directory getting created
                    (failedLookupChecks || (failedLookupChecks = [])).push(fileOrDirectoryPath);
                    // If the invalidated file is from a node_modules package, invalidate everything else
                    // in the package since we might not get notifications for other files in the package.
                    // This hardens our logic against unreliable file watchers.
                    var packagePath = ts.parseNodeModuleFromPath(fileOrDirectoryPath);
                    if (packagePath)
                        (startsWithPathChecks || (startsWithPathChecks = new ts.Set())).add(packagePath);
                }
            }
            resolutionHost.scheduleInvalidateResolutionsOfFailedLookupLocations();
        }
        function invalidateResolutionsOfFailedLookupLocations() {
            if (!failedLookupChecks && !startsWithPathChecks && !isInDirectoryChecks) {
                return false;
            }
            var invalidated = invalidateResolutions(resolutionsWithFailedLookups, canInvalidateFailedLookupResolution);
            failedLookupChecks = undefined;
            startsWithPathChecks = undefined;
            isInDirectoryChecks = undefined;
            return invalidated;
        }
        function canInvalidateFailedLookupResolution(resolution) {
            return resolution.failedLookupLocations.some(function (location) {
                var locationPath = resolutionHost.toPath(location);
                return ts.contains(failedLookupChecks, locationPath) ||
                    ts.firstDefinedIterator((startsWithPathChecks === null || startsWithPathChecks === void 0 ? void 0 : startsWithPathChecks.keys()) || ts.emptyIterator, function (fileOrDirectoryPath) { return ts.startsWith(locationPath, fileOrDirectoryPath) ? true : undefined; }) ||
                    (isInDirectoryChecks === null || isInDirectoryChecks === void 0 ? void 0 : isInDirectoryChecks.some(function (fileOrDirectoryPath) { return isInDirectoryPath(fileOrDirectoryPath, locationPath); }));
            });
        }
        function closeTypeRootsWatch() {
            ts.clearMap(typeRootsWatches, ts.closeFileWatcher);
        }
        function getDirectoryToWatchFailedLookupLocationFromTypeRoot(typeRoot, typeRootPath) {
            if (isInDirectoryPath(rootPath, typeRootPath)) {
                return rootPath;
            }
            var toWatch = getDirectoryToWatchFromFailedLookupLocationDirectory(typeRoot, typeRootPath);
            return toWatch && directoryWatchesOfFailedLookups.has(toWatch.dirPath) ? toWatch.dirPath : undefined;
        }
        function createTypeRootsWatch(typeRootPath, typeRoot) {
            // Create new watch and recursive info
            return resolutionHost.watchTypeRootsDirectory(typeRoot, function (fileOrDirectory) {
                var fileOrDirectoryPath = resolutionHost.toPath(fileOrDirectory);
                if (cachedDirectoryStructureHost) {
                    // Since the file existence changed, update the sourceFiles cache
                    cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                }
                // For now just recompile
                // We could potentially store more data here about whether it was/would be really be used or not
                // and with that determine to trigger compilation but for now this is enough
                hasChangedAutomaticTypeDirectiveNames = true;
                resolutionHost.onChangedAutomaticTypeDirectiveNames();
                // Since directory watchers invoked are flaky, the failed lookup location events might not be triggered
                // So handle to failed lookup locations here as well to ensure we are invalidating resolutions
                var dirPath = getDirectoryToWatchFailedLookupLocationFromTypeRoot(typeRoot, typeRootPath);
                if (dirPath) {
                    scheduleInvalidateResolutionOfFailedLookupLocation(fileOrDirectoryPath, dirPath === fileOrDirectoryPath);
                }
            }, 1 /* WatchDirectoryFlags.Recursive */);
        }
        /**
         * Watches the types that would get added as part of getAutomaticTypeDirectiveNames
         * To be called when compiler options change
         */
        function updateTypeRootsWatch() {
            var options = resolutionHost.getCompilationSettings();
            if (options.types) {
                // No need to do any watch since resolution cache is going to handle the failed lookups
                // for the types added by this
                closeTypeRootsWatch();
                return;
            }
            // we need to assume the directories exist to ensure that we can get all the type root directories that get included
            // But filter directories that are at root level to say directory doesnt exist, so that we arent watching them
            var typeRoots = ts.getEffectiveTypeRoots(options, { directoryExists: directoryExistsForTypeRootWatch, getCurrentDirectory: getCurrentDirectory });
            if (typeRoots) {
                ts.mutateMap(typeRootsWatches, ts.arrayToMap(typeRoots, function (tr) { return resolutionHost.toPath(tr); }), {
                    createNewValue: createTypeRootsWatch,
                    onDeleteValue: ts.closeFileWatcher
                });
            }
            else {
                closeTypeRootsWatch();
            }
        }
        /**
         * Use this function to return if directory exists to get type roots to watch
         * If we return directory exists then only the paths will be added to type roots
         * Hence return true for all directories except root directories which are filtered from watching
         */
        function directoryExistsForTypeRootWatch(nodeTypesDirectory) {
            var dir = ts.getDirectoryPath(ts.getDirectoryPath(nodeTypesDirectory));
            var dirPath = resolutionHost.toPath(dir);
            return dirPath === rootPath || canWatchDirectory(dirPath);
        }
    }
    ts.createResolutionCache = createResolutionCache;
    function resolutionIsSymlink(resolution) {
        var _a, _b;
        return !!(((_a = resolution.resolvedModule) === null || _a === void 0 ? void 0 : _a.originalPath) ||
            ((_b = resolution.resolvedTypeReferenceDirective) === null || _b === void 0 ? void 0 : _b.originalPath));
    }
})(ts || (ts = {}));
// Used by importFixes, getEditsForFileRename, and declaration emit to synthesize import module specifiers.
/* @internal */
var ts;
(function (ts) {
    var moduleSpecifiers;
    (function (moduleSpecifiers_1) {
        var RelativePreference;
        (function (RelativePreference) {
            RelativePreference[RelativePreference["Relative"] = 0] = "Relative";
            RelativePreference[RelativePreference["NonRelative"] = 1] = "NonRelative";
            RelativePreference[RelativePreference["Shortest"] = 2] = "Shortest";
            RelativePreference[RelativePreference["ExternalNonRelative"] = 3] = "ExternalNonRelative";
        })(RelativePreference || (RelativePreference = {}));
        // See UserPreferences#importPathEnding
        var Ending;
        (function (Ending) {
            Ending[Ending["Minimal"] = 0] = "Minimal";
            Ending[Ending["Index"] = 1] = "Index";
            Ending[Ending["JsExtension"] = 2] = "JsExtension";
        })(Ending || (Ending = {}));
        function getPreferences(host, _a, compilerOptions, importingSourceFile) {
            var importModuleSpecifierPreference = _a.importModuleSpecifierPreference, importModuleSpecifierEnding = _a.importModuleSpecifierEnding;
            return {
                relativePreference: importModuleSpecifierPreference === "relative" ? 0 /* RelativePreference.Relative */ :
                    importModuleSpecifierPreference === "non-relative" ? 1 /* RelativePreference.NonRelative */ :
                        importModuleSpecifierPreference === "project-relative" ? 3 /* RelativePreference.ExternalNonRelative */ :
                            2 /* RelativePreference.Shortest */,
                ending: getEnding(),
            };
            function getEnding() {
                switch (importModuleSpecifierEnding) {
                    case "minimal": return 0 /* Ending.Minimal */;
                    case "index": return 1 /* Ending.Index */;
                    case "js": return 2 /* Ending.JsExtension */;
                    default: return usesJsExtensionOnImports(importingSourceFile) || isFormatRequiringExtensions(compilerOptions, importingSourceFile.path, host) ? 2 /* Ending.JsExtension */
                        : ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeJs ? 1 /* Ending.Index */ : 0 /* Ending.Minimal */;
                }
            }
        }
        function getPreferencesForUpdate(compilerOptions, oldImportSpecifier, importingSourceFileName, host) {
            return {
                relativePreference: ts.isExternalModuleNameRelative(oldImportSpecifier) ? 0 /* RelativePreference.Relative */ : 1 /* RelativePreference.NonRelative */,
                ending: ts.hasJSFileExtension(oldImportSpecifier) || isFormatRequiringExtensions(compilerOptions, importingSourceFileName, host) ?
                    2 /* Ending.JsExtension */ :
                    ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeJs || ts.endsWith(oldImportSpecifier, "index") ? 1 /* Ending.Index */ : 0 /* Ending.Minimal */,
            };
        }
        function isFormatRequiringExtensions(compilerOptions, importingSourceFileName, host) {
            var _a;
            if (ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.Node16
                && ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeNext) {
                return false;
            }
            return ts.getImpliedNodeFormatForFile(importingSourceFileName, (_a = host.getPackageJsonInfoCache) === null || _a === void 0 ? void 0 : _a.call(host), getModuleResolutionHost(host), compilerOptions) !== ts.ModuleKind.CommonJS;
        }
        function getModuleResolutionHost(host) {
            var _a;
            return {
                fileExists: host.fileExists,
                readFile: ts.Debug.checkDefined(host.readFile),
                directoryExists: host.directoryExists,
                getCurrentDirectory: host.getCurrentDirectory,
                realpath: host.realpath,
                useCaseSensitiveFileNames: (_a = host.useCaseSensitiveFileNames) === null || _a === void 0 ? void 0 : _a.call(host),
            };
        }
        // `importingSourceFile` and `importingSourceFileName`? Why not just use `importingSourceFile.path`?
        // Because when this is called by the file renamer, `importingSourceFile` is the file being renamed,
        // while `importingSourceFileName` its *new* name. We need a source file just to get its
        // `impliedNodeFormat` and to detect certain preferences from existing import module specifiers.
        function updateModuleSpecifier(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, oldImportSpecifier, options) {
            if (options === void 0) { options = {}; }
            var res = getModuleSpecifierWorker(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, getPreferencesForUpdate(compilerOptions, oldImportSpecifier, importingSourceFileName, host), {}, options);
            if (res === oldImportSpecifier)
                return undefined;
            return res;
        }
        moduleSpecifiers_1.updateModuleSpecifier = updateModuleSpecifier;
        // `importingSourceFile` and `importingSourceFileName`? Why not just use `importingSourceFile.path`?
        // Because when this is called by the declaration emitter, `importingSourceFile` is the implementation
        // file, but `importingSourceFileName` and `toFileName` refer to declaration files (the former to the
        // one currently being produced; the latter to the one being imported). We need an implementation file
        // just to get its `impliedNodeFormat` and to detect certain preferences from existing import module
        // specifiers.
        function getModuleSpecifier(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, options) {
            if (options === void 0) { options = {}; }
            return getModuleSpecifierWorker(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, getPreferences(host, {}, compilerOptions, importingSourceFile), {}, options);
        }
        moduleSpecifiers_1.getModuleSpecifier = getModuleSpecifier;
        function getNodeModulesPackageName(compilerOptions, importingSourceFile, nodeModulesFileName, host, preferences, options) {
            if (options === void 0) { options = {}; }
            var info = getInfo(importingSourceFile.path, host);
            var modulePaths = getAllModulePaths(importingSourceFile.path, nodeModulesFileName, host, preferences, options);
            return ts.firstDefined(modulePaths, function (modulePath) { return tryGetModuleNameAsNodeModule(modulePath, info, importingSourceFile, host, compilerOptions, preferences, /*packageNameOnly*/ true, options.overrideImportMode); });
        }
        moduleSpecifiers_1.getNodeModulesPackageName = getNodeModulesPackageName;
        function getModuleSpecifierWorker(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, preferences, userPreferences, options) {
            if (options === void 0) { options = {}; }
            var info = getInfo(importingSourceFileName, host);
            var modulePaths = getAllModulePaths(importingSourceFileName, toFileName, host, userPreferences, options);
            return ts.firstDefined(modulePaths, function (modulePath) { return tryGetModuleNameAsNodeModule(modulePath, info, importingSourceFile, host, compilerOptions, userPreferences, /*packageNameOnly*/ undefined, options.overrideImportMode); }) ||
                getLocalModuleSpecifier(toFileName, info, compilerOptions, host, preferences);
        }
        function tryGetModuleSpecifiersFromCache(moduleSymbol, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            return tryGetModuleSpecifiersFromCacheWorker(moduleSymbol, importingSourceFile, host, userPreferences, options)[0];
        }
        moduleSpecifiers_1.tryGetModuleSpecifiersFromCache = tryGetModuleSpecifiersFromCache;
        function tryGetModuleSpecifiersFromCacheWorker(moduleSymbol, importingSourceFile, host, userPreferences, options) {
            var _a;
            if (options === void 0) { options = {}; }
            var moduleSourceFile = ts.getSourceFileOfModule(moduleSymbol);
            if (!moduleSourceFile) {
                return ts.emptyArray;
            }
            var cache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
            var cached = cache === null || cache === void 0 ? void 0 : cache.get(importingSourceFile.path, moduleSourceFile.path, userPreferences, options);
            return [cached === null || cached === void 0 ? void 0 : cached.moduleSpecifiers, moduleSourceFile, cached === null || cached === void 0 ? void 0 : cached.modulePaths, cache];
        }
        /** Returns an import for each symlink and for the realpath. */
        function getModuleSpecifiers(moduleSymbol, checker, compilerOptions, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            return getModuleSpecifiersWithCacheInfo(moduleSymbol, checker, compilerOptions, importingSourceFile, host, userPreferences, options).moduleSpecifiers;
        }
        moduleSpecifiers_1.getModuleSpecifiers = getModuleSpecifiers;
        function getModuleSpecifiersWithCacheInfo(moduleSymbol, checker, compilerOptions, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            var computedWithoutCache = false;
            var ambient = tryGetModuleNameFromAmbientModule(moduleSymbol, checker);
            if (ambient)
                return { moduleSpecifiers: [ambient], computedWithoutCache: computedWithoutCache };
            // eslint-disable-next-line prefer-const
            var _a = tryGetModuleSpecifiersFromCacheWorker(moduleSymbol, importingSourceFile, host, userPreferences, options), specifiers = _a[0], moduleSourceFile = _a[1], modulePaths = _a[2], cache = _a[3];
            if (specifiers)
                return { moduleSpecifiers: specifiers, computedWithoutCache: computedWithoutCache };
            if (!moduleSourceFile)
                return { moduleSpecifiers: ts.emptyArray, computedWithoutCache: computedWithoutCache };
            computedWithoutCache = true;
            modulePaths || (modulePaths = getAllModulePathsWorker(importingSourceFile.path, moduleSourceFile.originalFileName, host));
            var result = computeModuleSpecifiers(modulePaths, compilerOptions, importingSourceFile, host, userPreferences, options);
            cache === null || cache === void 0 ? void 0 : cache.set(importingSourceFile.path, moduleSourceFile.path, userPreferences, options, modulePaths, result);
            return { moduleSpecifiers: result, computedWithoutCache: computedWithoutCache };
        }
        moduleSpecifiers_1.getModuleSpecifiersWithCacheInfo = getModuleSpecifiersWithCacheInfo;
        function computeModuleSpecifiers(modulePaths, compilerOptions, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            var info = getInfo(importingSourceFile.path, host);
            var preferences = getPreferences(host, userPreferences, compilerOptions, importingSourceFile);
            var existingSpecifier = ts.forEach(modulePaths, function (modulePath) { return ts.forEach(host.getFileIncludeReasons().get(ts.toPath(modulePath.path, host.getCurrentDirectory(), info.getCanonicalFileName)), function (reason) {
                if (reason.kind !== ts.FileIncludeKind.Import || reason.file !== importingSourceFile.path)
                    return undefined;
                // If the candidate import mode doesn't match the mode we're generating for, don't consider it
                // TODO: maybe useful to keep around as an alternative option for certain contexts where the mode is overridable
                if (importingSourceFile.impliedNodeFormat && importingSourceFile.impliedNodeFormat !== ts.getModeForResolutionAtIndex(importingSourceFile, reason.index))
                    return undefined;
                var specifier = ts.getModuleNameStringLiteralAt(importingSourceFile, reason.index).text;
                // If the preference is for non relative and the module specifier is relative, ignore it
                return preferences.relativePreference !== 1 /* RelativePreference.NonRelative */ || !ts.pathIsRelative(specifier) ?
                    specifier :
                    undefined;
            }); });
            if (existingSpecifier) {
                var moduleSpecifiers_2 = [existingSpecifier];
                return moduleSpecifiers_2;
            }
            var importedFileIsInNodeModules = ts.some(modulePaths, function (p) { return p.isInNodeModules; });
            // Module specifier priority:
            //   1. "Bare package specifiers" (e.g. "@foo/bar") resulting from a path through node_modules to a package.json's "types" entry
            //   2. Specifiers generated using "paths" from tsconfig
            //   3. Non-relative specfiers resulting from a path through node_modules (e.g. "@foo/bar/path/to/file")
            //   4. Relative paths
            var nodeModulesSpecifiers;
            var pathsSpecifiers;
            var relativeSpecifiers;
            for (var _i = 0, modulePaths_1 = modulePaths; _i < modulePaths_1.length; _i++) {
                var modulePath = modulePaths_1[_i];
                var specifier = tryGetModuleNameAsNodeModule(modulePath, info, importingSourceFile, host, compilerOptions, userPreferences, /*packageNameOnly*/ undefined, options.overrideImportMode);
                nodeModulesSpecifiers = ts.append(nodeModulesSpecifiers, specifier);
                if (specifier && modulePath.isRedirect) {
                    // If we got a specifier for a redirect, it was a bare package specifier (e.g. "@foo/bar",
                    // not "@foo/bar/path/to/file"). No other specifier will be this good, so stop looking.
                    return nodeModulesSpecifiers;
                }
                if (!specifier && !modulePath.isRedirect) {
                    var local = getLocalModuleSpecifier(modulePath.path, info, compilerOptions, host, preferences);
                    if (ts.pathIsBareSpecifier(local)) {
                        pathsSpecifiers = ts.append(pathsSpecifiers, local);
                    }
                    else if (!importedFileIsInNodeModules || modulePath.isInNodeModules) {
                        // Why this extra conditional, not just an `else`? If some path to the file contained
                        // 'node_modules', but we can't create a non-relative specifier (e.g. "@foo/bar/path/to/file"),
                        // that means we had to go through a *sibling's* node_modules, not one we can access directly.
                        // If some path to the file was in node_modules but another was not, this likely indicates that
                        // we have a monorepo structure with symlinks. In this case, the non-node_modules path is
                        // probably the realpath, e.g. "../bar/path/to/file", but a relative path to another package
                        // in a monorepo is probably not portable. So, the module specifier we actually go with will be
                        // the relative path through node_modules, so that the declaration emitter can produce a
                        // portability error. (See declarationEmitReexportedSymlinkReference3)
                        relativeSpecifiers = ts.append(relativeSpecifiers, local);
                    }
                }
            }
            return (pathsSpecifiers === null || pathsSpecifiers === void 0 ? void 0 : pathsSpecifiers.length) ? pathsSpecifiers :
                (nodeModulesSpecifiers === null || nodeModulesSpecifiers === void 0 ? void 0 : nodeModulesSpecifiers.length) ? nodeModulesSpecifiers :
                    ts.Debug.checkDefined(relativeSpecifiers);
        }
        // importingSourceFileName is separate because getEditsForFileRename may need to specify an updated path
        function getInfo(importingSourceFileName, host) {
            var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames ? host.useCaseSensitiveFileNames() : true);
            var sourceDirectory = ts.getDirectoryPath(importingSourceFileName);
            return { getCanonicalFileName: getCanonicalFileName, importingSourceFileName: importingSourceFileName, sourceDirectory: sourceDirectory };
        }
        function getLocalModuleSpecifier(moduleFileName, info, compilerOptions, host, _a) {
            var ending = _a.ending, relativePreference = _a.relativePreference;
            var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths, rootDirs = compilerOptions.rootDirs;
            var sourceDirectory = info.sourceDirectory, getCanonicalFileName = info.getCanonicalFileName;
            var relativePath = rootDirs && tryGetModuleNameFromRootDirs(rootDirs, moduleFileName, sourceDirectory, getCanonicalFileName, ending, compilerOptions) ||
                removeExtensionAndIndexPostFix(ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(sourceDirectory, moduleFileName, getCanonicalFileName)), ending, compilerOptions);
            if (!baseUrl && !paths || relativePreference === 0 /* RelativePreference.Relative */) {
                return relativePath;
            }
            var baseDirectory = ts.getNormalizedAbsolutePath(ts.getPathsBasePath(compilerOptions, host) || baseUrl, host.getCurrentDirectory());
            var relativeToBaseUrl = getRelativePathIfInDirectory(moduleFileName, baseDirectory, getCanonicalFileName);
            if (!relativeToBaseUrl) {
                return relativePath;
            }
            var importRelativeToBaseUrl = removeExtensionAndIndexPostFix(relativeToBaseUrl, ending, compilerOptions);
            var fromPaths = paths && tryGetModuleNameFromPaths(ts.removeFileExtension(relativeToBaseUrl), importRelativeToBaseUrl, paths);
            var nonRelative = fromPaths === undefined && baseUrl !== undefined ? importRelativeToBaseUrl : fromPaths;
            if (!nonRelative) {
                return relativePath;
            }
            if (relativePreference === 1 /* RelativePreference.NonRelative */) {
                return nonRelative;
            }
            if (relativePreference === 3 /* RelativePreference.ExternalNonRelative */) {
                var projectDirectory = compilerOptions.configFilePath ?
                    ts.toPath(ts.getDirectoryPath(compilerOptions.configFilePath), host.getCurrentDirectory(), info.getCanonicalFileName) :
                    info.getCanonicalFileName(host.getCurrentDirectory());
                var modulePath = ts.toPath(moduleFileName, projectDirectory, getCanonicalFileName);
                var sourceIsInternal = ts.startsWith(sourceDirectory, projectDirectory);
                var targetIsInternal = ts.startsWith(modulePath, projectDirectory);
                if (sourceIsInternal && !targetIsInternal || !sourceIsInternal && targetIsInternal) {
                    // 1. The import path crosses the boundary of the tsconfig.json-containing directory.
                    //
                    //      src/
                    //        tsconfig.json
                    //        index.ts -------
                    //      lib/              | (path crosses tsconfig.json)
                    //        imported.ts <---
                    //
                    return nonRelative;
                }
                var nearestTargetPackageJson = getNearestAncestorDirectoryWithPackageJson(host, ts.getDirectoryPath(modulePath));
                var nearestSourcePackageJson = getNearestAncestorDirectoryWithPackageJson(host, sourceDirectory);
                if (nearestSourcePackageJson !== nearestTargetPackageJson) {
                    // 2. The importing and imported files are part of different packages.
                    //
                    //      packages/a/
                    //        package.json
                    //        index.ts --------
                    //      packages/b/        | (path crosses package.json)
                    //        package.json     |
                    //        component.ts <---
                    //
                    return nonRelative;
                }
                return relativePath;
            }
            if (relativePreference !== 2 /* RelativePreference.Shortest */)
                ts.Debug.assertNever(relativePreference);
            // Prefer a relative import over a baseUrl import if it has fewer components.
            return isPathRelativeToParent(nonRelative) || countPathComponents(relativePath) < countPathComponents(nonRelative) ? relativePath : nonRelative;
        }
        function countPathComponents(path) {
            var count = 0;
            for (var i = ts.startsWith(path, "./") ? 2 : 0; i < path.length; i++) {
                if (path.charCodeAt(i) === 47 /* CharacterCodes.slash */)
                    count++;
            }
            return count;
        }
        moduleSpecifiers_1.countPathComponents = countPathComponents;
        function usesJsExtensionOnImports(_a) {
            var imports = _a.imports;
            return ts.firstDefined(imports, function (_a) {
                var text = _a.text;
                return ts.pathIsRelative(text) ? ts.hasJSFileExtension(text) : undefined;
            }) || false;
        }
        function comparePathsByRedirectAndNumberOfDirectorySeparators(a, b) {
            return ts.compareBooleans(b.isRedirect, a.isRedirect) || ts.compareNumberOfDirectorySeparators(a.path, b.path);
        }
        function getNearestAncestorDirectoryWithPackageJson(host, fileName) {
            if (host.getNearestAncestorDirectoryWithPackageJson) {
                return host.getNearestAncestorDirectoryWithPackageJson(fileName);
            }
            return !!ts.forEachAncestorDirectory(fileName, function (directory) {
                return host.fileExists(ts.combinePaths(directory, "package.json")) ? true : undefined;
            });
        }
        function forEachFileNameOfModule(importingFileName, importedFileName, host, preferSymlinks, cb) {
            var _a;
            var getCanonicalFileName = ts.hostGetCanonicalFileName(host);
            var cwd = host.getCurrentDirectory();
            var referenceRedirect = host.isSourceOfProjectReferenceRedirect(importedFileName) ? host.getProjectReferenceRedirect(importedFileName) : undefined;
            var importedPath = ts.toPath(importedFileName, cwd, getCanonicalFileName);
            var redirects = host.redirectTargetsMap.get(importedPath) || ts.emptyArray;
            var importedFileNames = __spreadArray(__spreadArray(__spreadArray([], (referenceRedirect ? [referenceRedirect] : ts.emptyArray), true), [importedFileName], false), redirects, true);
            var targets = importedFileNames.map(function (f) { return ts.getNormalizedAbsolutePath(f, cwd); });
            var shouldFilterIgnoredPaths = !ts.every(targets, ts.containsIgnoredPath);
            if (!preferSymlinks) {
                // Symlinks inside ignored paths are already filtered out of the symlink cache,
                // so we only need to remove them from the realpath filenames.
                var result_15 = ts.forEach(targets, function (p) { return !(shouldFilterIgnoredPaths && ts.containsIgnoredPath(p)) && cb(p, referenceRedirect === p); });
                if (result_15)
                    return result_15;
            }
            var symlinkedDirectories = (_a = host.getSymlinkCache) === null || _a === void 0 ? void 0 : _a.call(host).getSymlinkedDirectoriesByRealpath();
            var fullImportedFileName = ts.getNormalizedAbsolutePath(importedFileName, cwd);
            var result = symlinkedDirectories && ts.forEachAncestorDirectory(ts.getDirectoryPath(fullImportedFileName), function (realPathDirectory) {
                var symlinkDirectories = symlinkedDirectories.get(ts.ensureTrailingDirectorySeparator(ts.toPath(realPathDirectory, cwd, getCanonicalFileName)));
                if (!symlinkDirectories)
                    return undefined; // Continue to ancestor directory
                // Don't want to a package to globally import from itself (importNameCodeFix_symlink_own_package.ts)
                if (ts.startsWithDirectory(importingFileName, realPathDirectory, getCanonicalFileName)) {
                    return false; // Stop search, each ancestor directory will also hit this condition
                }
                return ts.forEach(targets, function (target) {
                    if (!ts.startsWithDirectory(target, realPathDirectory, getCanonicalFileName)) {
                        return;
                    }
                    var relative = ts.getRelativePathFromDirectory(realPathDirectory, target, getCanonicalFileName);
                    for (var _i = 0, symlinkDirectories_1 = symlinkDirectories; _i < symlinkDirectories_1.length; _i++) {
                        var symlinkDirectory = symlinkDirectories_1[_i];
                        var option = ts.resolvePath(symlinkDirectory, relative);
                        var result_16 = cb(option, target === referenceRedirect);
                        shouldFilterIgnoredPaths = true; // We found a non-ignored path in symlinks, so we can reject ignored-path realpaths
                        if (result_16)
                            return result_16;
                    }
                });
            });
            return result || (preferSymlinks
                ? ts.forEach(targets, function (p) { return shouldFilterIgnoredPaths && ts.containsIgnoredPath(p) ? undefined : cb(p, p === referenceRedirect); })
                : undefined);
        }
        moduleSpecifiers_1.forEachFileNameOfModule = forEachFileNameOfModule;
        /**
         * Looks for existing imports that use symlinks to this module.
         * Symlinks will be returned first so they are preferred over the real path.
         */
        function getAllModulePaths(importingFilePath, importedFileName, host, preferences, options) {
            var _a;
            if (options === void 0) { options = {}; }
            var importedFilePath = ts.toPath(importedFileName, host.getCurrentDirectory(), ts.hostGetCanonicalFileName(host));
            var cache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
            if (cache) {
                var cached = cache.get(importingFilePath, importedFilePath, preferences, options);
                if (cached === null || cached === void 0 ? void 0 : cached.modulePaths)
                    return cached.modulePaths;
            }
            var modulePaths = getAllModulePathsWorker(importingFilePath, importedFileName, host);
            if (cache) {
                cache.setModulePaths(importingFilePath, importedFilePath, preferences, options, modulePaths);
            }
            return modulePaths;
        }
        function getAllModulePathsWorker(importingFileName, importedFileName, host) {
            var getCanonicalFileName = ts.hostGetCanonicalFileName(host);
            var allFileNames = new ts.Map();
            var importedFileFromNodeModules = false;
            forEachFileNameOfModule(importingFileName, importedFileName, host, 
            /*preferSymlinks*/ true, function (path, isRedirect) {
                var isInNodeModules = ts.pathContainsNodeModules(path);
                allFileNames.set(path, { path: getCanonicalFileName(path), isRedirect: isRedirect, isInNodeModules: isInNodeModules });
                importedFileFromNodeModules = importedFileFromNodeModules || isInNodeModules;
                // don't return value, so we collect everything
            });
            // Sort by paths closest to importing file Name directory
            var sortedPaths = [];
            var _loop_32 = function (directory) {
                var directoryStart = ts.ensureTrailingDirectorySeparator(directory);
                var pathsInDirectory;
                allFileNames.forEach(function (_a, fileName) {
                    var path = _a.path, isRedirect = _a.isRedirect, isInNodeModules = _a.isInNodeModules;
                    if (ts.startsWith(path, directoryStart)) {
                        (pathsInDirectory || (pathsInDirectory = [])).push({ path: fileName, isRedirect: isRedirect, isInNodeModules: isInNodeModules });
                        allFileNames.delete(fileName);
                    }
                });
                if (pathsInDirectory) {
                    if (pathsInDirectory.length > 1) {
                        pathsInDirectory.sort(comparePathsByRedirectAndNumberOfDirectorySeparators);
                    }
                    sortedPaths.push.apply(sortedPaths, pathsInDirectory);
                }
                var newDirectory = ts.getDirectoryPath(directory);
                if (newDirectory === directory)
                    return out_directory_1 = directory, "break";
                directory = newDirectory;
                out_directory_1 = directory;
            };
            var out_directory_1;
            for (var directory = ts.getDirectoryPath(importingFileName); allFileNames.size !== 0;) {
                var state_10 = _loop_32(directory);
                directory = out_directory_1;
                if (state_10 === "break")
                    break;
            }
            if (allFileNames.size) {
                var remainingPaths = ts.arrayFrom(allFileNames.values());
                if (remainingPaths.length > 1)
                    remainingPaths.sort(comparePathsByRedirectAndNumberOfDirectorySeparators);
                sortedPaths.push.apply(sortedPaths, remainingPaths);
            }
            return sortedPaths;
        }
        function tryGetModuleNameFromAmbientModule(moduleSymbol, checker) {
            var _a;
            var decl = (_a = moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return ts.isNonGlobalAmbientModule(d) && (!ts.isExternalModuleAugmentation(d) || !ts.isExternalModuleNameRelative(ts.getTextOfIdentifierOrLiteral(d.name))); });
            if (decl) {
                return decl.name.text;
            }
            // the module could be a namespace, which is export through "export=" from an ambient module.
            /**
             * declare module "m" {
             *     namespace ns {
             *         class c {}
             *     }
             *     export = ns;
             * }
             */
            // `import {c} from "m";` is valid, in which case, `moduleSymbol` is "ns", but the module name should be "m"
            var ambientModuleDeclareCandidates = ts.mapDefined(moduleSymbol.declarations, function (d) {
                var _a, _b, _c, _d;
                if (!ts.isModuleDeclaration(d))
                    return;
                var topNamespace = getTopNamespace(d);
                if (!(((_a = topNamespace === null || topNamespace === void 0 ? void 0 : topNamespace.parent) === null || _a === void 0 ? void 0 : _a.parent)
                    && ts.isModuleBlock(topNamespace.parent) && ts.isAmbientModule(topNamespace.parent.parent) && ts.isSourceFile(topNamespace.parent.parent.parent)))
                    return;
                var exportAssignment = (_d = (_c = (_b = topNamespace.parent.parent.symbol.exports) === null || _b === void 0 ? void 0 : _b.get("export=")) === null || _c === void 0 ? void 0 : _c.valueDeclaration) === null || _d === void 0 ? void 0 : _d.expression;
                if (!exportAssignment)
                    return;
                var exportSymbol = checker.getSymbolAtLocation(exportAssignment);
                if (!exportSymbol)
                    return;
                var originalExportSymbol = (exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.flags) & 2097152 /* SymbolFlags.Alias */ ? checker.getAliasedSymbol(exportSymbol) : exportSymbol;
                if (originalExportSymbol === d.symbol)
                    return topNamespace.parent.parent;
                function getTopNamespace(namespaceDeclaration) {
                    while (namespaceDeclaration.flags & 4 /* NodeFlags.NestedNamespace */) {
                        namespaceDeclaration = namespaceDeclaration.parent;
                    }
                    return namespaceDeclaration;
                }
            });
            var ambientModuleDeclare = ambientModuleDeclareCandidates[0];
            if (ambientModuleDeclare) {
                return ambientModuleDeclare.name.text;
            }
        }
        function tryGetModuleNameFromPaths(relativeToBaseUrlWithIndex, relativeToBaseUrl, paths) {
            for (var key in paths) {
                for (var _i = 0, _a = paths[key]; _i < _a.length; _i++) {
                    var patternText_1 = _a[_i];
                    var pattern = ts.removeFileExtension(ts.normalizePath(patternText_1));
                    var indexOfStar = pattern.indexOf("*");
                    if (indexOfStar !== -1) {
                        var prefix = pattern.substr(0, indexOfStar);
                        var suffix = pattern.substr(indexOfStar + 1);
                        if (relativeToBaseUrl.length >= prefix.length + suffix.length &&
                            ts.startsWith(relativeToBaseUrl, prefix) &&
                            ts.endsWith(relativeToBaseUrl, suffix) ||
                            !suffix && relativeToBaseUrl === ts.removeTrailingDirectorySeparator(prefix)) {
                            var matchedStar = relativeToBaseUrl.substr(prefix.length, relativeToBaseUrl.length - suffix.length - prefix.length);
                            return key.replace("*", matchedStar);
                        }
                    }
                    else if (pattern === relativeToBaseUrl || pattern === relativeToBaseUrlWithIndex) {
                        return key;
                    }
                }
            }
        }
        var MatchingMode;
        (function (MatchingMode) {
            MatchingMode[MatchingMode["Exact"] = 0] = "Exact";
            MatchingMode[MatchingMode["Directory"] = 1] = "Directory";
            MatchingMode[MatchingMode["Pattern"] = 2] = "Pattern";
        })(MatchingMode || (MatchingMode = {}));
        function tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, exports, conditions, mode) {
            if (mode === void 0) { mode = 0 /* MatchingMode.Exact */; }
            if (typeof exports === "string") {
                var pathOrPattern = ts.getNormalizedAbsolutePath(ts.combinePaths(packageDirectory, exports), /*currentDirectory*/ undefined);
                var extensionSwappedTarget = ts.hasTSFileExtension(targetFilePath) ? ts.removeFileExtension(targetFilePath) + tryGetJSExtensionForFile(targetFilePath, options) : undefined;
                switch (mode) {
                    case 0 /* MatchingMode.Exact */:
                        if (ts.comparePaths(targetFilePath, pathOrPattern) === 0 /* Comparison.EqualTo */ || (extensionSwappedTarget && ts.comparePaths(extensionSwappedTarget, pathOrPattern) === 0 /* Comparison.EqualTo */)) {
                            return { moduleFileToTry: packageName };
                        }
                        break;
                    case 1 /* MatchingMode.Directory */:
                        if (ts.containsPath(pathOrPattern, targetFilePath)) {
                            var fragment = ts.getRelativePathFromDirectory(pathOrPattern, targetFilePath, /*ignoreCase*/ false);
                            return { moduleFileToTry: ts.getNormalizedAbsolutePath(ts.combinePaths(ts.combinePaths(packageName, exports), fragment), /*currentDirectory*/ undefined) };
                        }
                        break;
                    case 2 /* MatchingMode.Pattern */:
                        var starPos = pathOrPattern.indexOf("*");
                        var leadingSlice = pathOrPattern.slice(0, starPos);
                        var trailingSlice = pathOrPattern.slice(starPos + 1);
                        if (ts.startsWith(targetFilePath, leadingSlice) && ts.endsWith(targetFilePath, trailingSlice)) {
                            var starReplacement = targetFilePath.slice(leadingSlice.length, targetFilePath.length - trailingSlice.length);
                            return { moduleFileToTry: packageName.replace("*", starReplacement) };
                        }
                        if (extensionSwappedTarget && ts.startsWith(extensionSwappedTarget, leadingSlice) && ts.endsWith(extensionSwappedTarget, trailingSlice)) {
                            var starReplacement = extensionSwappedTarget.slice(leadingSlice.length, extensionSwappedTarget.length - trailingSlice.length);
                            return { moduleFileToTry: packageName.replace("*", starReplacement) };
                        }
                        break;
                }
            }
            else if (Array.isArray(exports)) {
                return ts.forEach(exports, function (e) { return tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, e, conditions); });
            }
            else if (typeof exports === "object" && exports !== null) { // eslint-disable-line no-null/no-null
                if (ts.allKeysStartWithDot(exports)) {
                    // sub-mappings
                    // 3 cases:
                    // * directory mappings (legacyish, key ends with / (technically allows index/extension resolution under cjs mode))
                    // * pattern mappings (contains a *)
                    // * exact mappings (no *, does not end with /)
                    return ts.forEach(ts.getOwnKeys(exports), function (k) {
                        var subPackageName = ts.getNormalizedAbsolutePath(ts.combinePaths(packageName, k), /*currentDirectory*/ undefined);
                        var mode = ts.endsWith(k, "/") ? 1 /* MatchingMode.Directory */
                            : ts.stringContains(k, "*") ? 2 /* MatchingMode.Pattern */
                                : 0 /* MatchingMode.Exact */;
                        return tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, subPackageName, exports[k], conditions, mode);
                    });
                }
                else {
                    // conditional mapping
                    for (var _i = 0, _a = ts.getOwnKeys(exports); _i < _a.length; _i++) {
                        var key = _a[_i];
                        if (key === "default" || conditions.indexOf(key) >= 0 || ts.isApplicableVersionedTypesKey(conditions, key)) {
                            var subTarget = exports[key];
                            var result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
                            if (result) {
                                return result;
                            }
                        }
                    }
                }
            }
            return undefined;
        }
        function tryGetModuleNameFromRootDirs(rootDirs, moduleFileName, sourceDirectory, getCanonicalFileName, ending, compilerOptions) {
            var normalizedTargetPath = getPathRelativeToRootDirs(moduleFileName, rootDirs, getCanonicalFileName);
            if (normalizedTargetPath === undefined) {
                return undefined;
            }
            var normalizedSourcePath = getPathRelativeToRootDirs(sourceDirectory, rootDirs, getCanonicalFileName);
            var relativePath = normalizedSourcePath !== undefined ? ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(normalizedSourcePath, normalizedTargetPath, getCanonicalFileName)) : normalizedTargetPath;
            return ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs
                ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)
                : ts.removeFileExtension(relativePath);
        }
        function tryGetModuleNameAsNodeModule(_a, _b, importingSourceFile, host, options, userPreferences, packageNameOnly, overrideMode) {
            var path = _a.path, isRedirect = _a.isRedirect;
            var getCanonicalFileName = _b.getCanonicalFileName, sourceDirectory = _b.sourceDirectory;
            if (!host.fileExists || !host.readFile) {
                return undefined;
            }
            var parts = ts.getNodeModulePathParts(path);
            if (!parts) {
                return undefined;
            }
            // Simplify the full file path to something that can be resolved by Node.
            var moduleSpecifier = path;
            var isPackageRootPath = false;
            if (!packageNameOnly) {
                var preferences = getPreferences(host, userPreferences, options, importingSourceFile);
                var packageRootIndex = parts.packageRootIndex;
                var moduleFileName = void 0;
                while (true) {
                    // If the module could be imported by a directory name, use that directory's name
                    var _c = tryDirectoryWithPackageJson(packageRootIndex), moduleFileToTry = _c.moduleFileToTry, packageRootPath = _c.packageRootPath, blockedByExports = _c.blockedByExports, verbatimFromExports = _c.verbatimFromExports;
                    if (ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.Classic) {
                        if (blockedByExports) {
                            return undefined; // File is under this package.json, but is not publicly exported - there's no way to name it via `node_modules` resolution
                        }
                        if (verbatimFromExports) {
                            return moduleFileToTry;
                        }
                    }
                    if (packageRootPath) {
                        moduleSpecifier = packageRootPath;
                        isPackageRootPath = true;
                        break;
                    }
                    if (!moduleFileName)
                        moduleFileName = moduleFileToTry;
                    // try with next level of directory
                    packageRootIndex = path.indexOf(ts.directorySeparator, packageRootIndex + 1);
                    if (packageRootIndex === -1) {
                        moduleSpecifier = removeExtensionAndIndexPostFix(moduleFileName, preferences.ending, options, host);
                        break;
                    }
                }
            }
            if (isRedirect && !isPackageRootPath) {
                return undefined;
            }
            var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
            // Get a path that's relative to node_modules or the importing file's path
            // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
            var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
                return undefined;
            }
            // If the module was found in @types, get the actual Node package name
            var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
            var packageName = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
            // For classic resolution, only allow importing from node_modules/@types, not other node_modules
            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageName === nodeModulesDirectoryName ? undefined : packageName;
            function tryDirectoryWithPackageJson(packageRootIndex) {
                var _a, _b;
                var packageRootPath = path.substring(0, packageRootIndex);
                var packageJsonPath = ts.combinePaths(packageRootPath, "package.json");
                var moduleFileToTry = path;
                var cachedPackageJson = (_b = (_a = host.getPackageJsonInfoCache) === null || _a === void 0 ? void 0 : _a.call(host)) === null || _b === void 0 ? void 0 : _b.getPackageJsonInfo(packageJsonPath);
                if (typeof cachedPackageJson === "object" || cachedPackageJson === undefined && host.fileExists(packageJsonPath)) {
                    var packageJsonContent = (cachedPackageJson === null || cachedPackageJson === void 0 ? void 0 : cachedPackageJson.packageJsonContent) || JSON.parse(host.readFile(packageJsonPath));
                    if (ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Node16 || ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.NodeNext) {
                        // `conditions` *could* be made to go against `importingSourceFile.impliedNodeFormat` if something wanted to generate
                        // an ImportEqualsDeclaration in an ESM-implied file or an ImportCall in a CJS-implied file. But since this function is
                        // usually called to conjure an import out of thin air, we don't have an existing usage to call `getModeForUsageAtIndex`
                        // with, so for now we just stick with the mode of the file.
                        var conditions = ["node", overrideMode || importingSourceFile.impliedNodeFormat === ts.ModuleKind.ESNext ? "import" : "require", "types"];
                        var fromExports = packageJsonContent.exports && typeof packageJsonContent.name === "string"
                            ? tryGetModuleNameFromExports(options, path, packageRootPath, ts.getPackageNameFromTypesPackageName(packageJsonContent.name), packageJsonContent.exports, conditions)
                            : undefined;
                        if (fromExports) {
                            var withJsExtension = !ts.hasTSFileExtension(fromExports.moduleFileToTry)
                                ? fromExports
                                : { moduleFileToTry: ts.removeFileExtension(fromExports.moduleFileToTry) + tryGetJSExtensionForFile(fromExports.moduleFileToTry, options) };
                            return __assign(__assign({}, withJsExtension), { verbatimFromExports: true });
                        }
                        if (packageJsonContent.exports) {
                            return { moduleFileToTry: path, blockedByExports: true };
                        }
                    }
                    var versionPaths = packageJsonContent.typesVersions
                        ? ts.getPackageJsonTypesVersionsPaths(packageJsonContent.typesVersions)
                        : undefined;
                    if (versionPaths) {
                        var subModuleName = path.slice(packageRootPath.length + 1);
                        var fromPaths = tryGetModuleNameFromPaths(ts.removeFileExtension(subModuleName), removeExtensionAndIndexPostFix(subModuleName, 0 /* Ending.Minimal */, options), versionPaths.paths);
                        if (fromPaths !== undefined) {
                            moduleFileToTry = ts.combinePaths(packageRootPath, fromPaths);
                        }
                    }
                    // If the file is the main module, it can be imported by the package name
                    var mainFileRelative = packageJsonContent.typings || packageJsonContent.types || packageJsonContent.main || "index.js";
                    if (ts.isString(mainFileRelative)) {
                        var mainExportFile = ts.toPath(mainFileRelative, packageRootPath, getCanonicalFileName);
                        if (ts.removeFileExtension(mainExportFile) === ts.removeFileExtension(getCanonicalFileName(moduleFileToTry))) {
                            return { packageRootPath: packageRootPath, moduleFileToTry: moduleFileToTry };
                        }
                    }
                }
                else {
                    // No package.json exists; an index.js will still resolve as the package name
                    var fileName = getCanonicalFileName(moduleFileToTry.substring(parts.packageRootIndex + 1));
                    if (fileName === "index.d.ts" || fileName === "index.js" || fileName === "index.ts" || fileName === "index.tsx") {
                        return { moduleFileToTry: moduleFileToTry, packageRootPath: packageRootPath };
                    }
                }
                return { moduleFileToTry: moduleFileToTry };
            }
        }
        function tryGetAnyFileFromPath(host, path) {
            if (!host.fileExists)
                return;
            // We check all js, `node` and `json` extensions in addition to TS, since node module resolution would also choose those over the directory
            var extensions = ts.flatten(ts.getSupportedExtensions({ allowJs: true }, [{ extension: "node", isMixedContent: false }, { extension: "json", isMixedContent: false, scriptKind: 6 /* ScriptKind.JSON */ }]));
            for (var _i = 0, extensions_3 = extensions; _i < extensions_3.length; _i++) {
                var e = extensions_3[_i];
                var fullPath = path + e;
                if (host.fileExists(fullPath)) {
                    return fullPath;
                }
            }
        }
        function getPathRelativeToRootDirs(path, rootDirs, getCanonicalFileName) {
            return ts.firstDefined(rootDirs, function (rootDir) {
                var relativePath = getRelativePathIfInDirectory(path, rootDir, getCanonicalFileName);
                return relativePath !== undefined && isPathRelativeToParent(relativePath) ? undefined : relativePath;
            });
        }
        function removeExtensionAndIndexPostFix(fileName, ending, options, host) {
            if (ts.fileExtensionIsOneOf(fileName, [".json" /* Extension.Json */, ".mjs" /* Extension.Mjs */, ".cjs" /* Extension.Cjs */]))
                return fileName;
            var noExtension = ts.removeFileExtension(fileName);
            if (fileName === noExtension)
                return fileName;
            if (ts.fileExtensionIsOneOf(fileName, [".d.mts" /* Extension.Dmts */, ".mts" /* Extension.Mts */, ".d.cts" /* Extension.Dcts */, ".cts" /* Extension.Cts */]))
                return noExtension + getJSExtensionForFile(fileName, options);
            switch (ending) {
                case 0 /* Ending.Minimal */:
                    var withoutIndex = ts.removeSuffix(noExtension, "/index");
                    if (host && withoutIndex !== noExtension && tryGetAnyFileFromPath(host, withoutIndex)) {
                        // Can't remove index if there's a file by the same name as the directory.
                        // Probably more callers should pass `host` so we can determine this?
                        return noExtension;
                    }
                    return withoutIndex;
                case 1 /* Ending.Index */:
                    return noExtension;
                case 2 /* Ending.JsExtension */:
                    return noExtension + getJSExtensionForFile(fileName, options);
                default:
                    return ts.Debug.assertNever(ending);
            }
        }
        function getJSExtensionForFile(fileName, options) {
            var _a;
            return (_a = tryGetJSExtensionForFile(fileName, options)) !== null && _a !== void 0 ? _a : ts.Debug.fail("Extension ".concat(ts.extensionFromPath(fileName), " is unsupported:: FileName:: ").concat(fileName));
        }
        function tryGetJSExtensionForFile(fileName, options) {
            var ext = ts.tryGetExtensionFromPath(fileName);
            switch (ext) {
                case ".ts" /* Extension.Ts */:
                case ".d.ts" /* Extension.Dts */:
                    return ".js" /* Extension.Js */;
                case ".tsx" /* Extension.Tsx */:
                    return options.jsx === 1 /* JsxEmit.Preserve */ ? ".jsx" /* Extension.Jsx */ : ".js" /* Extension.Js */;
                case ".js" /* Extension.Js */:
                case ".jsx" /* Extension.Jsx */:
                case ".json" /* Extension.Json */:
                    return ext;
                case ".d.mts" /* Extension.Dmts */:
                case ".mts" /* Extension.Mts */:
                case ".mjs" /* Extension.Mjs */:
                    return ".mjs" /* Extension.Mjs */;
                case ".d.cts" /* Extension.Dcts */:
                case ".cts" /* Extension.Cts */:
                case ".cjs" /* Extension.Cjs */:
                    return ".cjs" /* Extension.Cjs */;
                default:
                    return undefined;
            }
        }
        moduleSpecifiers_1.tryGetJSExtensionForFile = tryGetJSExtensionForFile;
        function getRelativePathIfInDirectory(path, directoryPath, getCanonicalFileName) {
            var relativePath = ts.getRelativePathToDirectoryOrUrl(directoryPath, path, directoryPath, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);
            return ts.isRootedDiskPath(relativePath) ? undefined : relativePath;
        }
        function isPathRelativeToParent(path) {
            return ts.startsWith(path, "..");
        }
    })(moduleSpecifiers = ts.moduleSpecifiers || (ts.moduleSpecifiers = {}));
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var sysFormatDiagnosticsHost = ts.sys ? {
        getCurrentDirectory: function () { return ts.sys.getCurrentDirectory(); },
        getNewLine: function () { return ts.sys.newLine; },
        getCanonicalFileName: ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames)
    } : undefined;
    /**
     * Create a function that reports error by writing to the system and handles the formatting of the diagnostic
     */
    function createDiagnosticReporter(system, pretty) {
        var host = system === ts.sys && sysFormatDiagnosticsHost ? sysFormatDiagnosticsHost : {
            getCurrentDirectory: function () { return system.getCurrentDirectory(); },
            getNewLine: function () { return system.newLine; },
            getCanonicalFileName: ts.createGetCanonicalFileName(system.useCaseSensitiveFileNames),
        };
        if (!pretty) {
            return function (diagnostic) { return system.write(ts.formatDiagnostic(diagnostic, host)); };
        }
        var diagnostics = new Array(1);
        return function (diagnostic) {
            diagnostics[0] = diagnostic;
            system.write(ts.formatDiagnosticsWithColorAndContext(diagnostics, host) + host.getNewLine());
            diagnostics[0] = undefined; // TODO: GH#18217
        };
    }
    ts.createDiagnosticReporter = createDiagnosticReporter;
    /**
     * @returns Whether the screen was cleared.
     */
    function clearScreenIfNotWatchingForFileChanges(system, diagnostic, options) {
        if (system.clearScreen &&
            !options.preserveWatchOutput &&
            !options.extendedDiagnostics &&
            !options.diagnostics &&
            ts.contains(ts.screenStartingMessageCodes, diagnostic.code)) {
            system.clearScreen();
            return true;
        }
        return false;
    }
    ts.screenStartingMessageCodes = [
        ts.Diagnostics.Starting_compilation_in_watch_mode.code,
        ts.Diagnostics.File_change_detected_Starting_incremental_compilation.code,
    ];
    function getPlainDiagnosticFollowingNewLines(diagnostic, newLine) {
        return ts.contains(ts.screenStartingMessageCodes, diagnostic.code)
            ? newLine + newLine
            : newLine;
    }
    /**
     * Get locale specific time based on whether we are in test mode
     */
    function getLocaleTimeString(system) {
        return !system.now ?
            new Date().toLocaleTimeString() :
            system.now().toLocaleTimeString("en-US", { timeZone: "UTC" });
    }
    ts.getLocaleTimeString = getLocaleTimeString;
    /**
     * Create a function that reports watch status by writing to the system and handles the formatting of the diagnostic
     */
    function createWatchStatusReporter(system, pretty) {
        return pretty ?
            function (diagnostic, newLine, options) {
                clearScreenIfNotWatchingForFileChanges(system, diagnostic, options);
                var output = "[".concat(ts.formatColorAndReset(getLocaleTimeString(system), ts.ForegroundColorEscapeSequences.Grey), "] ");
                output += "".concat(ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine)).concat(newLine + newLine);
                system.write(output);
            } :
            function (diagnostic, newLine, options) {
                var output = "";
                if (!clearScreenIfNotWatchingForFileChanges(system, diagnostic, options)) {
                    output += newLine;
                }
                output += "".concat(getLocaleTimeString(system), " - ");
                output += "".concat(ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine)).concat(getPlainDiagnosticFollowingNewLines(diagnostic, newLine));
                system.write(output);
            };
    }
    ts.createWatchStatusReporter = createWatchStatusReporter;
    /** Parses config file using System interface */
    function parseConfigFileWithSystem(configFileName, optionsToExtend, extendedConfigCache, watchOptionsToExtend, system, reportDiagnostic) {
        var host = system;
        host.onUnRecoverableConfigFileDiagnostic = function (diagnostic) { return reportUnrecoverableDiagnostic(system, reportDiagnostic, diagnostic); };
        var result = ts.getParsedCommandLineOfConfigFile(configFileName, optionsToExtend, host, extendedConfigCache, watchOptionsToExtend);
        host.onUnRecoverableConfigFileDiagnostic = undefined; // TODO: GH#18217
        return result;
    }
    ts.parseConfigFileWithSystem = parseConfigFileWithSystem;
    function getErrorCountForSummary(diagnostics) {
        return ts.countWhere(diagnostics, function (diagnostic) { return diagnostic.category === ts.DiagnosticCategory.Error; });
    }
    ts.getErrorCountForSummary = getErrorCountForSummary;
    function getFilesInErrorForSummary(diagnostics) {
        var filesInError = ts.filter(diagnostics, function (diagnostic) { return diagnostic.category === ts.DiagnosticCategory.Error; })
            .map(function (errorDiagnostic) {
            if (errorDiagnostic.file === undefined)
                return;
            return "".concat(errorDiagnostic.file.fileName);
        });
        return filesInError.map(function (fileName) {
            var diagnosticForFileName = ts.find(diagnostics, function (diagnostic) {
                return diagnostic.file !== undefined && diagnostic.file.fileName === fileName;
            });
            if (diagnosticForFileName !== undefined) {
                var line = ts.getLineAndCharacterOfPosition(diagnosticForFileName.file, diagnosticForFileName.start).line;
                return {
                    fileName: fileName,
                    line: line + 1,
                };
            }
        });
    }
    ts.getFilesInErrorForSummary = getFilesInErrorForSummary;
    function getWatchErrorSummaryDiagnosticMessage(errorCount) {
        return errorCount === 1 ?
            ts.Diagnostics.Found_1_error_Watching_for_file_changes :
            ts.Diagnostics.Found_0_errors_Watching_for_file_changes;
    }
    ts.getWatchErrorSummaryDiagnosticMessage = getWatchErrorSummaryDiagnosticMessage;
    function prettyPathForFileError(error, cwd) {
        var line = ts.formatColorAndReset(":" + error.line, ts.ForegroundColorEscapeSequences.Grey);
        if (ts.pathIsAbsolute(error.fileName) && ts.pathIsAbsolute(cwd)) {
            return ts.getRelativePathFromDirectory(cwd, error.fileName, /* ignoreCase */ false) + line;
        }
        return error.fileName + line;
    }
    function getErrorSummaryText(errorCount, filesInError, newLine, host) {
        if (errorCount === 0)
            return "";
        var nonNilFiles = filesInError.filter(function (fileInError) { return fileInError !== undefined; });
        var distinctFileNamesWithLines = nonNilFiles.map(function (fileInError) { return "".concat(fileInError.fileName, ":").concat(fileInError.line); })
            .filter(function (value, index, self) { return self.indexOf(value) === index; });
        var firstFileReference = nonNilFiles[0] && prettyPathForFileError(nonNilFiles[0], host.getCurrentDirectory());
        var d = errorCount === 1 ?
            ts.createCompilerDiagnostic(filesInError[0] !== undefined ?
                ts.Diagnostics.Found_1_error_in_1 :
                ts.Diagnostics.Found_1_error, errorCount, firstFileReference) :
            ts.createCompilerDiagnostic(distinctFileNamesWithLines.length === 0 ?
                ts.Diagnostics.Found_0_errors :
                distinctFileNamesWithLines.length === 1 ?
                    ts.Diagnostics.Found_0_errors_in_the_same_file_starting_at_Colon_1 :
                    ts.Diagnostics.Found_0_errors_in_1_files, errorCount, distinctFileNamesWithLines.length === 1 ? firstFileReference : distinctFileNamesWithLines.length);
        var suffix = distinctFileNamesWithLines.length > 1 ? createTabularErrorsDisplay(nonNilFiles, host) : "";
        return "".concat(newLine).concat(ts.flattenDiagnosticMessageText(d.messageText, newLine)).concat(newLine).concat(newLine).concat(suffix);
    }
    ts.getErrorSummaryText = getErrorSummaryText;
    function createTabularErrorsDisplay(filesInError, host) {
        var distinctFiles = filesInError.filter(function (value, index, self) { return index === self.findIndex(function (file) { return (file === null || file === void 0 ? void 0 : file.fileName) === (value === null || value === void 0 ? void 0 : value.fileName); }); });
        if (distinctFiles.length === 0)
            return "";
        var numberLength = function (num) { return Math.log(num) * Math.LOG10E + 1; };
        var fileToErrorCount = distinctFiles.map(function (file) { return [file, ts.countWhere(filesInError, function (fileInError) { return fileInError.fileName === file.fileName; })]; });
        var maxErrors = fileToErrorCount.reduce(function (acc, value) { return Math.max(acc, value[1] || 0); }, 0);
        var headerRow = ts.Diagnostics.Errors_Files.message;
        var leftColumnHeadingLength = headerRow.split(" ")[0].length;
        var leftPaddingGoal = Math.max(leftColumnHeadingLength, numberLength(maxErrors));
        var headerPadding = Math.max(numberLength(maxErrors) - leftColumnHeadingLength, 0);
        var tabularData = "";
        tabularData += " ".repeat(headerPadding) + headerRow + "\n";
        fileToErrorCount.forEach(function (row) {
            var file = row[0], errorCount = row[1];
            var errorCountDigitsLength = Math.log(errorCount) * Math.LOG10E + 1 | 0;
            var leftPadding = errorCountDigitsLength < leftPaddingGoal ?
                " ".repeat(leftPaddingGoal - errorCountDigitsLength)
                : "";
            var fileRef = prettyPathForFileError(file, host.getCurrentDirectory());
            tabularData += "".concat(leftPadding).concat(errorCount, "  ").concat(fileRef, "\n");
        });
        return tabularData;
    }
    function isBuilderProgram(program) {
        return !!program.getState;
    }
    ts.isBuilderProgram = isBuilderProgram;
    function listFiles(program, write) {
        var options = program.getCompilerOptions();
        if (options.explainFiles) {
            explainFiles(isBuilderProgram(program) ? program.getProgram() : program, write);
        }
        else if (options.listFiles || options.listFilesOnly) {
            ts.forEach(program.getSourceFiles(), function (file) {
                write(file.fileName);
            });
        }
    }
    ts.listFiles = listFiles;
    function explainFiles(program, write) {
        var _a, _b;
        var reasons = program.getFileIncludeReasons();
        var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
        var relativeFileName = function (fileName) { return ts.convertToRelativePath(fileName, program.getCurrentDirectory(), getCanonicalFileName); };
        for (var _i = 0, _c = program.getSourceFiles(); _i < _c.length; _i++) {
            var file = _c[_i];
            write("".concat(toFileName(file, relativeFileName)));
            (_a = reasons.get(file.path)) === null || _a === void 0 ? void 0 : _a.forEach(function (reason) { return write("  ".concat(fileIncludeReasonToDiagnostics(program, reason, relativeFileName).messageText)); });
            (_b = explainIfFileIsRedirect(file, relativeFileName)) === null || _b === void 0 ? void 0 : _b.forEach(function (d) { return write("  ".concat(d.messageText)); });
        }
    }
    ts.explainFiles = explainFiles;
    function explainIfFileIsRedirect(file, fileNameConvertor) {
        var result;
        if (file.path !== file.resolvedPath) {
            (result || (result = [])).push(ts.chainDiagnosticMessages(
            /*details*/ undefined, ts.Diagnostics.File_is_output_of_project_reference_source_0, toFileName(file.originalFileName, fileNameConvertor)));
        }
        if (file.redirectInfo) {
            (result || (result = [])).push(ts.chainDiagnosticMessages(
            /*details*/ undefined, ts.Diagnostics.File_redirects_to_file_0, toFileName(file.redirectInfo.redirectTarget, fileNameConvertor)));
        }
        return result;
    }
    ts.explainIfFileIsRedirect = explainIfFileIsRedirect;
    function getMatchedFileSpec(program, fileName) {
        var _a;
        var configFile = program.getCompilerOptions().configFile;
        if (!((_a = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _a === void 0 ? void 0 : _a.validatedFilesSpec))
            return undefined;
        var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
        var filePath = getCanonicalFileName(fileName);
        var basePath = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFile.fileName, program.getCurrentDirectory()));
        return ts.find(configFile.configFileSpecs.validatedFilesSpec, function (fileSpec) { return getCanonicalFileName(ts.getNormalizedAbsolutePath(fileSpec, basePath)) === filePath; });
    }
    ts.getMatchedFileSpec = getMatchedFileSpec;
    function getMatchedIncludeSpec(program, fileName) {
        var _a, _b;
        var configFile = program.getCompilerOptions().configFile;
        if (!((_a = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _a === void 0 ? void 0 : _a.validatedIncludeSpecs))
            return undefined;
        var isJsonFile = ts.fileExtensionIs(fileName, ".json" /* Extension.Json */);
        var basePath = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFile.fileName, program.getCurrentDirectory()));
        var useCaseSensitiveFileNames = program.useCaseSensitiveFileNames();
        return ts.find((_b = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _b === void 0 ? void 0 : _b.validatedIncludeSpecs, function (includeSpec) {
            if (isJsonFile && !ts.endsWith(includeSpec, ".json" /* Extension.Json */))
                return false;
            var pattern = ts.getPatternFromSpec(includeSpec, basePath, "files");
            return !!pattern && ts.getRegexFromPattern("(".concat(pattern, ")$"), useCaseSensitiveFileNames).test(fileName);
        });
    }
    ts.getMatchedIncludeSpec = getMatchedIncludeSpec;
    function fileIncludeReasonToDiagnostics(program, reason, fileNameConvertor) {
        var _a, _b;
        var options = program.getCompilerOptions();
        if (ts.isReferencedFile(reason)) {
            var referenceLocation = ts.getReferencedFileLocation(function (path) { return program.getSourceFileByPath(path); }, reason);
            var referenceText = ts.isReferenceFileLocation(referenceLocation) ? referenceLocation.file.text.substring(referenceLocation.pos, referenceLocation.end) : "\"".concat(referenceLocation.text, "\"");
            var message = void 0;
            ts.Debug.assert(ts.isReferenceFileLocation(referenceLocation) || reason.kind === ts.FileIncludeKind.Import, "Only synthetic references are imports");
            switch (reason.kind) {
                case ts.FileIncludeKind.Import:
                    if (ts.isReferenceFileLocation(referenceLocation)) {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2 :
                            ts.Diagnostics.Imported_via_0_from_file_1;
                    }
                    else if (referenceLocation.text === ts.externalHelpersModuleNameText) {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions :
                            ts.Diagnostics.Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions;
                    }
                    else {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions :
                            ts.Diagnostics.Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions;
                    }
                    break;
                case ts.FileIncludeKind.ReferenceFile:
                    ts.Debug.assert(!referenceLocation.packageId);
                    message = ts.Diagnostics.Referenced_via_0_from_file_1;
                    break;
                case ts.FileIncludeKind.TypeReferenceDirective:
                    message = referenceLocation.packageId ?
                        ts.Diagnostics.Type_library_referenced_via_0_from_file_1_with_packageId_2 :
                        ts.Diagnostics.Type_library_referenced_via_0_from_file_1;
                    break;
                case ts.FileIncludeKind.LibReferenceDirective:
                    ts.Debug.assert(!referenceLocation.packageId);
                    message = ts.Diagnostics.Library_referenced_via_0_from_file_1;
                    break;
                default:
                    ts.Debug.assertNever(reason);
            }
            return ts.chainDiagnosticMessages(
            /*details*/ undefined, message, referenceText, toFileName(referenceLocation.file, fileNameConvertor), referenceLocation.packageId && ts.packageIdToString(referenceLocation.packageId));
        }
        switch (reason.kind) {
            case ts.FileIncludeKind.RootFile:
                if (!((_a = options.configFile) === null || _a === void 0 ? void 0 : _a.configFileSpecs))
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Root_file_specified_for_compilation);
                var fileName = ts.getNormalizedAbsolutePath(program.getRootFileNames()[reason.index], program.getCurrentDirectory());
                var matchedByFiles = getMatchedFileSpec(program, fileName);
                if (matchedByFiles)
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Part_of_files_list_in_tsconfig_json);
                var matchedByInclude = getMatchedIncludeSpec(program, fileName);
                return matchedByInclude ?
                    ts.chainDiagnosticMessages(
                    /*details*/ undefined, ts.Diagnostics.Matched_by_include_pattern_0_in_1, matchedByInclude, toFileName(options.configFile, fileNameConvertor)) :
                    // Could be additional files specified as roots
                    ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Root_file_specified_for_compilation);
            case ts.FileIncludeKind.SourceFromProjectReference:
            case ts.FileIncludeKind.OutputFromProjectReference:
                var isOutput = reason.kind === ts.FileIncludeKind.OutputFromProjectReference;
                var referencedResolvedRef = ts.Debug.checkDefined((_b = program.getResolvedProjectReferences()) === null || _b === void 0 ? void 0 : _b[reason.index]);
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, ts.outFile(options) ?
                    isOutput ?
                        ts.Diagnostics.Output_from_referenced_project_0_included_because_1_specified :
                        ts.Diagnostics.Source_from_referenced_project_0_included_because_1_specified :
                    isOutput ?
                        ts.Diagnostics.Output_from_referenced_project_0_included_because_module_is_specified_as_none :
                        ts.Diagnostics.Source_from_referenced_project_0_included_because_module_is_specified_as_none, toFileName(referencedResolvedRef.sourceFile.fileName, fileNameConvertor), options.outFile ? "--outFile" : "--out");
            case ts.FileIncludeKind.AutomaticTypeDirectiveFile:
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, options.types ?
                    reason.packageId ?
                        ts.Diagnostics.Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1 :
                        ts.Diagnostics.Entry_point_of_type_library_0_specified_in_compilerOptions :
                    reason.packageId ?
                        ts.Diagnostics.Entry_point_for_implicit_type_library_0_with_packageId_1 :
                        ts.Diagnostics.Entry_point_for_implicit_type_library_0, reason.typeReference, reason.packageId && ts.packageIdToString(reason.packageId));
            case ts.FileIncludeKind.LibFile:
                if (reason.index !== undefined)
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Library_0_specified_in_compilerOptions, options.lib[reason.index]);
                var target = ts.forEachEntry(ts.targetOptionDeclaration.type, function (value, key) { return value === ts.getEmitScriptTarget(options) ? key : undefined; });
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, target ?
                    ts.Diagnostics.Default_library_for_target_0 :
                    ts.Diagnostics.Default_library, target);
            default:
                ts.Debug.assertNever(reason);
        }
    }
    ts.fileIncludeReasonToDiagnostics = fileIncludeReasonToDiagnostics;
    function toFileName(file, fileNameConvertor) {
        var fileName = ts.isString(file) ? file : file.fileName;
        return fileNameConvertor ? fileNameConvertor(fileName) : fileName;
    }
    /**
     * Helper that emit files, report diagnostics and lists emitted and/or source files depending on compiler options
     */
    function emitFilesAndReportErrors(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        var isListFilesOnly = !!program.getCompilerOptions().listFilesOnly;
        // First get and report any syntactic errors.
        var allDiagnostics = program.getConfigFileParsingDiagnostics().slice();
        var configFileParsingDiagnosticsLength = allDiagnostics.length;
        ts.addRange(allDiagnostics, program.getSyntacticDiagnostics(/*sourceFile*/ undefined, cancellationToken));
        // If we didn't have any syntactic errors, then also try getting the global and
        // semantic errors.
        if (allDiagnostics.length === configFileParsingDiagnosticsLength) {
            ts.addRange(allDiagnostics, program.getOptionsDiagnostics(cancellationToken));
            if (!isListFilesOnly) {
                ts.addRange(allDiagnostics, program.getGlobalDiagnostics(cancellationToken));
                if (allDiagnostics.length === configFileParsingDiagnosticsLength) {
                    ts.addRange(allDiagnostics, program.getSemanticDiagnostics(/*sourceFile*/ undefined, cancellationToken));
                }
            }
        }
        // Emit and report any errors we ran into.
        var emitResult = isListFilesOnly
            ? { emitSkipped: true, diagnostics: ts.emptyArray }
            : program.emit(/*targetSourceFile*/ undefined, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
        var emittedFiles = emitResult.emittedFiles, emitDiagnostics = emitResult.diagnostics;
        ts.addRange(allDiagnostics, emitDiagnostics);
        var diagnostics = ts.sortAndDeduplicateDiagnostics(allDiagnostics);
        diagnostics.forEach(reportDiagnostic);
        if (write) {
            var currentDir_1 = program.getCurrentDirectory();
            ts.forEach(emittedFiles, function (file) {
                var filepath = ts.getNormalizedAbsolutePath(file, currentDir_1);
                write("TSFILE: ".concat(filepath));
            });
            listFiles(program, write);
        }
        if (reportSummary) {
            reportSummary(getErrorCountForSummary(diagnostics), getFilesInErrorForSummary(diagnostics));
        }
        return {
            emitResult: emitResult,
            diagnostics: diagnostics,
        };
    }
    ts.emitFilesAndReportErrors = emitFilesAndReportErrors;
    function emitFilesAndReportErrorsAndGetExitStatus(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        var _a = emitFilesAndReportErrors(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers), emitResult = _a.emitResult, diagnostics = _a.diagnostics;
        if (emitResult.emitSkipped && diagnostics.length > 0) {
            // If the emitter didn't emit anything, then pass that value along.
            return ts.ExitStatus.DiagnosticsPresent_OutputsSkipped;
        }
        else if (diagnostics.length > 0) {
            // The emitter emitted something, inform the caller if that happened in the presence
            // of diagnostics or not.
            return ts.ExitStatus.DiagnosticsPresent_OutputsGenerated;
        }
        return ts.ExitStatus.Success;
    }
    ts.emitFilesAndReportErrorsAndGetExitStatus = emitFilesAndReportErrorsAndGetExitStatus;
    ts.noopFileWatcher = { close: ts.noop };
    ts.returnNoopFileWatcher = function () { return ts.noopFileWatcher; };
    function createWatchHost(system, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var onWatchStatusChange = reportWatchStatus || createWatchStatusReporter(system);
        return {
            onWatchStatusChange: onWatchStatusChange,
            watchFile: ts.maybeBind(system, system.watchFile) || ts.returnNoopFileWatcher,
            watchDirectory: ts.maybeBind(system, system.watchDirectory) || ts.returnNoopFileWatcher,
            setTimeout: ts.maybeBind(system, system.setTimeout) || ts.noop,
            clearTimeout: ts.maybeBind(system, system.clearTimeout) || ts.noop
        };
    }
    ts.createWatchHost = createWatchHost;
    ts.WatchType = {
        ConfigFile: "Config file",
        ExtendedConfigFile: "Extended config file",
        SourceFile: "Source file",
        MissingFile: "Missing file",
        WildcardDirectory: "Wild card directory",
        FailedLookupLocations: "Failed Lookup Locations",
        TypeRoots: "Type roots",
        ConfigFileOfReferencedProject: "Config file of referened project",
        ExtendedConfigOfReferencedProject: "Extended config file of referenced project",
        WildcardDirectoryOfReferencedProject: "Wild card directory of referenced project",
        PackageJson: "package.json file",
    };
    function createWatchFactory(host, options) {
        var watchLogLevel = host.trace ? options.extendedDiagnostics ? ts.WatchLogLevel.Verbose : options.diagnostics ? ts.WatchLogLevel.TriggerOnly : ts.WatchLogLevel.None : ts.WatchLogLevel.None;
        var writeLog = watchLogLevel !== ts.WatchLogLevel.None ? (function (s) { return host.trace(s); }) : ts.noop;
        var result = ts.getWatchFactory(host, watchLogLevel, writeLog);
        result.writeLog = writeLog;
        return result;
    }
    ts.createWatchFactory = createWatchFactory;
    function createCompilerHostFromProgramHost(host, getCompilerOptions, directoryStructureHost) {
        if (directoryStructureHost === void 0) { directoryStructureHost = host; }
        var useCaseSensitiveFileNames = host.useCaseSensitiveFileNames();
        var hostGetNewLine = ts.memoize(function () { return host.getNewLine(); });
        return {
            getSourceFile: function (fileName, languageVersionOrOptions, onError) {
                var text;
                try {
                    ts.performance.mark("beforeIORead");
                    text = host.readFile(fileName, getCompilerOptions().charset);
                    ts.performance.mark("afterIORead");
                    ts.performance.measure("I/O Read", "beforeIORead", "afterIORead");
                }
                catch (e) {
                    if (onError) {
                        onError(e.message);
                    }
                    text = "";
                }
                return text !== undefined ? ts.createSourceFile(fileName, text, languageVersionOrOptions) : undefined;
            },
            getDefaultLibLocation: ts.maybeBind(host, host.getDefaultLibLocation),
            getDefaultLibFileName: function (options) { return host.getDefaultLibFileName(options); },
            writeFile: writeFile,
            getCurrentDirectory: ts.memoize(function () { return host.getCurrentDirectory(); }),
            useCaseSensitiveFileNames: function () { return useCaseSensitiveFileNames; },
            getCanonicalFileName: ts.createGetCanonicalFileName(useCaseSensitiveFileNames),
            getNewLine: function () { return ts.getNewLineCharacter(getCompilerOptions(), hostGetNewLine); },
            fileExists: function (f) { return host.fileExists(f); },
            readFile: function (f) { return host.readFile(f); },
            trace: ts.maybeBind(host, host.trace),
            directoryExists: ts.maybeBind(directoryStructureHost, directoryStructureHost.directoryExists),
            getDirectories: ts.maybeBind(directoryStructureHost, directoryStructureHost.getDirectories),
            realpath: ts.maybeBind(host, host.realpath),
            getEnvironmentVariable: ts.maybeBind(host, host.getEnvironmentVariable) || (function () { return ""; }),
            createHash: ts.maybeBind(host, host.createHash),
            readDirectory: ts.maybeBind(host, host.readDirectory),
            disableUseFileVersionAsSignature: host.disableUseFileVersionAsSignature,
            storeFilesChangingSignatureDuringEmit: host.storeFilesChangingSignatureDuringEmit,
        };
        function writeFile(fileName, text, writeByteOrderMark, onError) {
            try {
                ts.performance.mark("beforeIOWrite");
                // NOTE: If patchWriteFileEnsuringDirectory has been called,
                // the host.writeFile will do its own directory creation and
                // the ensureDirectoriesExist call will always be redundant.
                ts.writeFileEnsuringDirectories(fileName, text, writeByteOrderMark, function (path, data, writeByteOrderMark) { return host.writeFile(path, data, writeByteOrderMark); }, function (path) { return host.createDirectory(path); }, function (path) { return host.directoryExists(path); });
                ts.performance.mark("afterIOWrite");
                ts.performance.measure("I/O Write", "beforeIOWrite", "afterIOWrite");
            }
            catch (e) {
                if (onError) {
                    onError(e.message);
                }
            }
        }
    }
    ts.createCompilerHostFromProgramHost = createCompilerHostFromProgramHost;
    function setGetSourceFileAsHashVersioned(compilerHost, host) {
        var originalGetSourceFile = compilerHost.getSourceFile;
        var computeHash = ts.maybeBind(host, host.createHash) || ts.generateDjb2Hash;
        compilerHost.getSourceFile = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var result = originalGetSourceFile.call.apply(originalGetSourceFile, __spreadArray([compilerHost], args, false));
            if (result) {
                result.version = computeHash(result.text);
            }
            return result;
        };
    }
    ts.setGetSourceFileAsHashVersioned = setGetSourceFileAsHashVersioned;
    /**
     * Creates the watch compiler host that can be extended with config file or root file names and options host
     */
    function createProgramHost(system, createProgram) {
        var getDefaultLibLocation = ts.memoize(function () { return ts.getDirectoryPath(ts.normalizePath(system.getExecutingFilePath())); });
        return {
            useCaseSensitiveFileNames: function () { return system.useCaseSensitiveFileNames; },
            getNewLine: function () { return system.newLine; },
            getCurrentDirectory: ts.memoize(function () { return system.getCurrentDirectory(); }),
            getDefaultLibLocation: getDefaultLibLocation,
            getDefaultLibFileName: function (options) { return ts.combinePaths(getDefaultLibLocation(), ts.getDefaultLibFileName(options)); },
            fileExists: function (path) { return system.fileExists(path); },
            readFile: function (path, encoding) { return system.readFile(path, encoding); },
            directoryExists: function (path) { return system.directoryExists(path); },
            getDirectories: function (path) { return system.getDirectories(path); },
            readDirectory: function (path, extensions, exclude, include, depth) { return system.readDirectory(path, extensions, exclude, include, depth); },
            realpath: ts.maybeBind(system, system.realpath),
            getEnvironmentVariable: ts.maybeBind(system, system.getEnvironmentVariable),
            trace: function (s) { return system.write(s + system.newLine); },
            createDirectory: function (path) { return system.createDirectory(path); },
            writeFile: function (path, data, writeByteOrderMark) { return system.writeFile(path, data, writeByteOrderMark); },
            createHash: ts.maybeBind(system, system.createHash),
            createProgram: createProgram || ts.createEmitAndSemanticDiagnosticsBuilderProgram,
            disableUseFileVersionAsSignature: system.disableUseFileVersionAsSignature,
            storeFilesChangingSignatureDuringEmit: system.storeFilesChangingSignatureDuringEmit,
        };
    }
    ts.createProgramHost = createProgramHost;
    /**
     * Creates the watch compiler host that can be extended with config file or root file names and options host
     */
    function createWatchCompilerHost(system, createProgram, reportDiagnostic, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var write = function (s) { return system.write(s + system.newLine); };
        var result = createProgramHost(system, createProgram);
        ts.copyProperties(result, createWatchHost(system, reportWatchStatus));
        result.afterProgramCreate = function (builderProgram) {
            var compilerOptions = builderProgram.getCompilerOptions();
            var newLine = ts.getNewLineCharacter(compilerOptions, function () { return system.newLine; });
            emitFilesAndReportErrors(builderProgram, reportDiagnostic, write, function (errorCount) { return result.onWatchStatusChange(ts.createCompilerDiagnostic(getWatchErrorSummaryDiagnosticMessage(errorCount), errorCount), newLine, compilerOptions, errorCount); });
        };
        return result;
    }
    /**
     * Report error and exit
     */
    function reportUnrecoverableDiagnostic(system, reportDiagnostic, diagnostic) {
        reportDiagnostic(diagnostic);
        system.exit(ts.ExitStatus.DiagnosticsPresent_OutputsSkipped);
    }
    /**
     * Creates the watch compiler host from system for config file in watch mode
     */
    function createWatchCompilerHostOfConfigFile(_a) {
        var configFileName = _a.configFileName, optionsToExtend = _a.optionsToExtend, watchOptionsToExtend = _a.watchOptionsToExtend, extraFileExtensions = _a.extraFileExtensions, system = _a.system, createProgram = _a.createProgram, reportDiagnostic = _a.reportDiagnostic, reportWatchStatus = _a.reportWatchStatus;
        var diagnosticReporter = reportDiagnostic || createDiagnosticReporter(system);
        var host = createWatchCompilerHost(system, createProgram, diagnosticReporter, reportWatchStatus);
        host.onUnRecoverableConfigFileDiagnostic = function (diagnostic) { return reportUnrecoverableDiagnostic(system, diagnosticReporter, diagnostic); };
        host.configFileName = configFileName;
        host.optionsToExtend = optionsToExtend;
        host.watchOptionsToExtend = watchOptionsToExtend;
        host.extraFileExtensions = extraFileExtensions;
        return host;
    }
    ts.createWatchCompilerHostOfConfigFile = createWatchCompilerHostOfConfigFile;
    /**
     * Creates the watch compiler host from system for compiling root files and options in watch mode
     */
    function createWatchCompilerHostOfFilesAndCompilerOptions(_a) {
        var rootFiles = _a.rootFiles, options = _a.options, watchOptions = _a.watchOptions, projectReferences = _a.projectReferences, system = _a.system, createProgram = _a.createProgram, reportDiagnostic = _a.reportDiagnostic, reportWatchStatus = _a.reportWatchStatus;
        var host = createWatchCompilerHost(system, createProgram, reportDiagnostic || createDiagnosticReporter(system), reportWatchStatus);
        host.rootFiles = rootFiles;
        host.options = options;
        host.watchOptions = watchOptions;
        host.projectReferences = projectReferences;
        return host;
    }
    ts.createWatchCompilerHostOfFilesAndCompilerOptions = createWatchCompilerHostOfFilesAndCompilerOptions;
    function performIncrementalCompilation(input) {
        var system = input.system || ts.sys;
        var host = input.host || (input.host = ts.createIncrementalCompilerHost(input.options, system));
        var builderProgram = ts.createIncrementalProgram(input);
        var exitStatus = emitFilesAndReportErrorsAndGetExitStatus(builderProgram, input.reportDiagnostic || createDiagnosticReporter(system), function (s) { return host.trace && host.trace(s); }, input.reportErrorSummary || input.options.pretty ? function (errorCount, filesInError) { return system.write(getErrorSummaryText(errorCount, filesInError, system.newLine, host)); } : undefined);
        if (input.afterProgramEmitAndDiagnostics)
            input.afterProgramEmitAndDiagnostics(builderProgram);
        return exitStatus;
    }
    ts.performIncrementalCompilation = performIncrementalCompilation;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function readBuilderProgram(compilerOptions, host) {
        if (ts.outFile(compilerOptions))
            return undefined;
        var buildInfoPath = ts.getTsBuildInfoEmitOutputFilePath(compilerOptions);
        if (!buildInfoPath)
            return undefined;
        var content = host.readFile(buildInfoPath);
        if (!content)
            return undefined;
        var buildInfo = ts.getBuildInfo(content);
        if (buildInfo.version !== ts.version)
            return undefined;
        if (!buildInfo.program)
            return undefined;
        return ts.createBuildProgramUsingProgramBuildInfo(buildInfo.program, buildInfoPath, host);
    }
    ts.readBuilderProgram = readBuilderProgram;
    function createIncrementalCompilerHost(options, system) {
        if (system === void 0) { system = ts.sys; }
        var host = ts.createCompilerHostWorker(options, /*setParentNodes*/ undefined, system);
        host.createHash = ts.maybeBind(system, system.createHash);
        host.disableUseFileVersionAsSignature = system.disableUseFileVersionAsSignature;
        host.storeFilesChangingSignatureDuringEmit = system.storeFilesChangingSignatureDuringEmit;
        ts.setGetSourceFileAsHashVersioned(host, system);
        ts.changeCompilerHostLikeToUseCache(host, function (fileName) { return ts.toPath(fileName, host.getCurrentDirectory(), host.getCanonicalFileName); });
        return host;
    }
    ts.createIncrementalCompilerHost = createIncrementalCompilerHost;
    function createIncrementalProgram(_a) {
        var rootNames = _a.rootNames, options = _a.options, configFileParsingDiagnostics = _a.configFileParsingDiagnostics, projectReferences = _a.projectReferences, host = _a.host, createProgram = _a.createProgram;
        host = host || createIncrementalCompilerHost(options);
        createProgram = createProgram || ts.createEmitAndSemanticDiagnosticsBuilderProgram;
        var oldProgram = readBuilderProgram(options, host);
        return createProgram(rootNames, options, host, oldProgram, configFileParsingDiagnostics, projectReferences);
    }
    ts.createIncrementalProgram = createIncrementalProgram;
    function createWatchCompilerHost(rootFilesOrConfigFileName, options, system, createProgram, reportDiagnostic, reportWatchStatus, projectReferencesOrWatchOptionsToExtend, watchOptionsOrExtraFileExtensions) {
        if (ts.isArray(rootFilesOrConfigFileName)) {
            return ts.createWatchCompilerHostOfFilesAndCompilerOptions({
                rootFiles: rootFilesOrConfigFileName,
                options: options,
                watchOptions: watchOptionsOrExtraFileExtensions,
                projectReferences: projectReferencesOrWatchOptionsToExtend,
                system: system,
                createProgram: createProgram,
                reportDiagnostic: reportDiagnostic,
                reportWatchStatus: reportWatchStatus,
            });
        }
        else {
            return ts.createWatchCompilerHostOfConfigFile({
                configFileName: rootFilesOrConfigFileName,
                optionsToExtend: options,
                watchOptionsToExtend: projectReferencesOrWatchOptionsToExtend,
                extraFileExtensions: watchOptionsOrExtraFileExtensions,
                system: system,
                createProgram: createProgram,
                reportDiagnostic: reportDiagnostic,
                reportWatchStatus: reportWatchStatus,
            });
        }
    }
    ts.createWatchCompilerHost = createWatchCompilerHost;
    function createWatchProgram(host) {
        var builderProgram;
        var reloadLevel; // level to indicate if the program needs to be reloaded from config file/just filenames etc
        var missingFilesMap; // Map of file watchers for the missing files
        var packageJsonMap; // map of watchers for package json files used in module resolution
        var watchedWildcardDirectories; // map of watchers for the wild card directories in the config file
        var timerToUpdateProgram; // timer callback to recompile the program
        var timerToInvalidateFailedLookupResolutions; // timer callback to invalidate resolutions for changes in failed lookup locations
        var parsedConfigs; // Parsed commandline and watching cached for referenced projects
        var sharedExtendedConfigFileWatchers; // Map of file watchers for extended files, shared between different referenced projects
        var extendedConfigCache = host.extendedConfigCache; // Cache for extended config evaluation
        var changesAffectResolution = false; // Flag for indicating non-config changes affect module resolution
        var reportFileChangeDetectedOnCreateProgram = false; // True if synchronizeProgram should report "File change detected..." when a new program is created
        var sourceFilesCache = new ts.Map(); // Cache that stores the source file and version info
        var missingFilePathsRequestedForRelease; // These paths are held temporarily so that we can remove the entry from source file cache if the file is not tracked by missing files
        var hasChangedCompilerOptions = false; // True if the compiler options have changed between compilations
        var useCaseSensitiveFileNames = host.useCaseSensitiveFileNames();
        var currentDirectory = host.getCurrentDirectory();
        var configFileName = host.configFileName, _a = host.optionsToExtend, optionsToExtendForConfigFile = _a === void 0 ? {} : _a, watchOptionsToExtend = host.watchOptionsToExtend, extraFileExtensions = host.extraFileExtensions, createProgram = host.createProgram;
        var rootFileNames = host.rootFiles, compilerOptions = host.options, watchOptions = host.watchOptions, projectReferences = host.projectReferences;
        var wildcardDirectories;
        var configFileParsingDiagnostics;
        var canConfigFileJsonReportNoInputFiles = false;
        var hasChangedConfigFileParsingErrors = false;
        var cachedDirectoryStructureHost = configFileName === undefined ? undefined : ts.createCachedDirectoryStructureHost(host, currentDirectory, useCaseSensitiveFileNames);
        var directoryStructureHost = cachedDirectoryStructureHost || host;
        var parseConfigFileHost = ts.parseConfigHostFromCompilerHostLike(host, directoryStructureHost);
        // From tsc we want to get already parsed result and hence check for rootFileNames
        var newLine = updateNewLine();
        if (configFileName && host.configFileParsingResult) {
            setConfigFileParsingResult(host.configFileParsingResult);
            newLine = updateNewLine();
        }
        reportWatchDiagnostic(ts.Diagnostics.Starting_compilation_in_watch_mode);
        if (configFileName && !host.configFileParsingResult) {
            newLine = ts.getNewLineCharacter(optionsToExtendForConfigFile, function () { return host.getNewLine(); });
            ts.Debug.assert(!rootFileNames);
            parseConfigFile();
            newLine = updateNewLine();
        }
        var _b = ts.createWatchFactory(host, compilerOptions), watchFile = _b.watchFile, watchDirectory = _b.watchDirectory, writeLog = _b.writeLog;
        var getCanonicalFileName = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        writeLog("Current directory: ".concat(currentDirectory, " CaseSensitiveFileNames: ").concat(useCaseSensitiveFileNames));
        var configFileWatcher;
        if (configFileName) {
            configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
        }
        var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
        ts.setGetSourceFileAsHashVersioned(compilerHost, host);
        // Members for CompilerHost
        var getNewSourceFile = compilerHost.getSourceFile;
        compilerHost.getSourceFile = function (fileName) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return getVersionedSourceFileByPath.apply(void 0, __spreadArray([fileName, toPath(fileName)], args, false));
        };
        compilerHost.getSourceFileByPath = getVersionedSourceFileByPath;
        compilerHost.getNewLine = function () { return newLine; };
        compilerHost.fileExists = fileExists;
        compilerHost.onReleaseOldSourceFile = onReleaseOldSourceFile;
        compilerHost.onReleaseParsedCommandLine = onReleaseParsedCommandLine;
        // Members for ResolutionCacheHost
        compilerHost.toPath = toPath;
        compilerHost.getCompilationSettings = function () { return compilerOptions; };
        compilerHost.useSourceOfProjectReferenceRedirect = ts.maybeBind(host, host.useSourceOfProjectReferenceRedirect);
        compilerHost.watchDirectoryOfFailedLookupLocation = function (dir, cb, flags) { return watchDirectory(dir, cb, flags, watchOptions, ts.WatchType.FailedLookupLocations); };
        compilerHost.watchTypeRootsDirectory = function (dir, cb, flags) { return watchDirectory(dir, cb, flags, watchOptions, ts.WatchType.TypeRoots); };
        compilerHost.getCachedDirectoryStructureHost = function () { return cachedDirectoryStructureHost; };
        compilerHost.scheduleInvalidateResolutionsOfFailedLookupLocations = scheduleInvalidateResolutionsOfFailedLookupLocations;
        compilerHost.onInvalidatedResolution = scheduleProgramUpdate;
        compilerHost.onChangedAutomaticTypeDirectiveNames = scheduleProgramUpdate;
        compilerHost.fileIsOpen = ts.returnFalse;
        compilerHost.getCurrentProgram = getCurrentProgram;
        compilerHost.writeLog = writeLog;
        compilerHost.getParsedCommandLine = getParsedCommandLine;
        // Cache for the module resolution
        var resolutionCache = ts.createResolutionCache(compilerHost, configFileName ?
            ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFileName, currentDirectory)) :
            currentDirectory, 
        /*logChangesWhenResolvingModule*/ false);
        // Resolve module using host module resolution strategy if provided otherwise use resolution cache to resolve module names
        compilerHost.resolveModuleNames = host.resolveModuleNames ?
            (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return host.resolveModuleNames.apply(host, args);
            }) :
            (function (moduleNames, containingFile, reusedNames, redirectedReference, _options, sourceFile) { return resolutionCache.resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, sourceFile); });
        compilerHost.resolveTypeReferenceDirectives = host.resolveTypeReferenceDirectives ?
            (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return host.resolveTypeReferenceDirectives.apply(host, args);
            }) :
            (function (typeDirectiveNames, containingFile, redirectedReference, _options, containingFileMode) { return resolutionCache.resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, redirectedReference, containingFileMode); });
        var userProvidedResolution = !!host.resolveModuleNames || !!host.resolveTypeReferenceDirectives;
        builderProgram = readBuilderProgram(compilerOptions, compilerHost);
        synchronizeProgram();
        // Update the wild card directory watch
        watchConfigFileWildCardDirectories();
        // Update extended config file watch
        if (configFileName)
            updateExtendedConfigFilesWatches(toPath(configFileName), compilerOptions, watchOptions, ts.WatchType.ExtendedConfigFile);
        return configFileName ?
            { getCurrentProgram: getCurrentBuilderProgram, getProgram: updateProgram, close: close } :
            { getCurrentProgram: getCurrentBuilderProgram, getProgram: updateProgram, updateRootFileNames: updateRootFileNames, close: close };
        function close() {
            clearInvalidateResolutionsOfFailedLookupLocations();
            resolutionCache.clear();
            ts.clearMap(sourceFilesCache, function (value) {
                if (value && value.fileWatcher) {
                    value.fileWatcher.close();
                    value.fileWatcher = undefined;
                }
            });
            if (configFileWatcher) {
                configFileWatcher.close();
                configFileWatcher = undefined;
            }
            extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
            extendedConfigCache = undefined;
            if (sharedExtendedConfigFileWatchers) {
                ts.clearMap(sharedExtendedConfigFileWatchers, ts.closeFileWatcherOf);
                sharedExtendedConfigFileWatchers = undefined;
            }
            if (watchedWildcardDirectories) {
                ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf);
                watchedWildcardDirectories = undefined;
            }
            if (missingFilesMap) {
                ts.clearMap(missingFilesMap, ts.closeFileWatcher);
                missingFilesMap = undefined;
            }
            if (parsedConfigs) {
                ts.clearMap(parsedConfigs, function (config) {
                    var _a;
                    (_a = config.watcher) === null || _a === void 0 ? void 0 : _a.close();
                    config.watcher = undefined;
                    if (config.watchedDirectories)
                        ts.clearMap(config.watchedDirectories, ts.closeFileWatcherOf);
                    config.watchedDirectories = undefined;
                });
                parsedConfigs = undefined;
            }
            if (packageJsonMap) {
                ts.clearMap(packageJsonMap, ts.closeFileWatcher);
                packageJsonMap = undefined;
            }
        }
        function getCurrentBuilderProgram() {
            return builderProgram;
        }
        function getCurrentProgram() {
            return builderProgram && builderProgram.getProgramOrUndefined();
        }
        function synchronizeProgram() {
            writeLog("Synchronizing program");
            clearInvalidateResolutionsOfFailedLookupLocations();
            var program = getCurrentBuilderProgram();
            if (hasChangedCompilerOptions) {
                newLine = updateNewLine();
                if (program && (changesAffectResolution || ts.changesAffectModuleResolution(program.getCompilerOptions(), compilerOptions))) {
                    resolutionCache.clear();
                }
            }
            // All resolutions are invalid if user provided resolutions
            var hasInvalidatedResolution = resolutionCache.createHasInvalidatedResolution(userProvidedResolution || changesAffectResolution);
            if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, fileExists, hasInvalidatedResolution, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                if (hasChangedConfigFileParsingErrors) {
                    if (reportFileChangeDetectedOnCreateProgram) {
                        reportWatchDiagnostic(ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
                    }
                    builderProgram = createProgram(/*rootNames*/ undefined, /*options*/ undefined, compilerHost, builderProgram, configFileParsingDiagnostics, projectReferences);
                    hasChangedConfigFileParsingErrors = false;
                }
            }
            else {
                if (reportFileChangeDetectedOnCreateProgram) {
                    reportWatchDiagnostic(ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
                }
                createNewProgram(hasInvalidatedResolution);
            }
            changesAffectResolution = false; // reset for next sync
            reportFileChangeDetectedOnCreateProgram = false;
            if (host.afterProgramCreate && program !== builderProgram) {
                host.afterProgramCreate(builderProgram);
            }
            return builderProgram;
        }
        function createNewProgram(hasInvalidatedResolution) {
            // Compile the program
            writeLog("CreatingProgramWith::");
            writeLog("  roots: ".concat(JSON.stringify(rootFileNames)));
            writeLog("  options: ".concat(JSON.stringify(compilerOptions)));
            if (projectReferences)
                writeLog("  projectReferences: ".concat(JSON.stringify(projectReferences)));
            var needsUpdateInTypeRootWatch = hasChangedCompilerOptions || !getCurrentProgram();
            hasChangedCompilerOptions = false;
            hasChangedConfigFileParsingErrors = false;
            resolutionCache.startCachingPerDirectoryResolution();
            compilerHost.hasInvalidatedResolution = hasInvalidatedResolution;
            compilerHost.hasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames;
            builderProgram = createProgram(rootFileNames, compilerOptions, compilerHost, builderProgram, configFileParsingDiagnostics, projectReferences);
            // map package json cache entries to their realpaths so we don't try to watch across symlinks
            var packageCacheEntries = ts.map(resolutionCache.getModuleResolutionCache().getPackageJsonInfoCache().entries(), function (_a) {
                var path = _a[0], data = _a[1];
                return [compilerHost.realpath ? toPath(compilerHost.realpath(path)) : path, data];
            });
            resolutionCache.finishCachingPerDirectoryResolution();
            // Update watches
            ts.updateMissingFilePathsWatch(builderProgram.getProgram(), missingFilesMap || (missingFilesMap = new ts.Map()), watchMissingFilePath);
            ts.updatePackageJsonWatch(packageCacheEntries, packageJsonMap || (packageJsonMap = new ts.Map()), watchPackageJsonLookupPath);
            if (needsUpdateInTypeRootWatch) {
                resolutionCache.updateTypeRootsWatch();
            }
            if (missingFilePathsRequestedForRelease) {
                // These are the paths that program creater told us as not in use any more but were missing on the disk.
                // We didnt remove the entry for them from sourceFiles cache so that we dont have to do File IO,
                // if there is already watcher for it (for missing files)
                // At this point our watches were updated, hence now we know that these paths are not tracked and need to be removed
                // so that at later time we have correct result of their presence
                for (var _i = 0, missingFilePathsRequestedForRelease_1 = missingFilePathsRequestedForRelease; _i < missingFilePathsRequestedForRelease_1.length; _i++) {
                    var missingFilePath = missingFilePathsRequestedForRelease_1[_i];
                    if (!missingFilesMap.has(missingFilePath)) {
                        sourceFilesCache.delete(missingFilePath);
                    }
                }
                missingFilePathsRequestedForRelease = undefined;
            }
        }
        function updateRootFileNames(files) {
            ts.Debug.assert(!configFileName, "Cannot update root file names with config file watch mode");
            rootFileNames = files;
            scheduleProgramUpdate();
        }
        function updateNewLine() {
            return ts.getNewLineCharacter(compilerOptions || optionsToExtendForConfigFile, function () { return host.getNewLine(); });
        }
        function toPath(fileName) {
            return ts.toPath(fileName, currentDirectory, getCanonicalFileName);
        }
        function isFileMissingOnHost(hostSourceFile) {
            return typeof hostSourceFile === "boolean";
        }
        function isFilePresenceUnknownOnHost(hostSourceFile) {
            return typeof hostSourceFile.version === "boolean";
        }
        function fileExists(fileName) {
            var path = toPath(fileName);
            // If file is missing on host from cache, we can definitely say file doesnt exist
            // otherwise we need to ensure from the disk
            if (isFileMissingOnHost(sourceFilesCache.get(path))) {
                return false;
            }
            return directoryStructureHost.fileExists(fileName);
        }
        function getVersionedSourceFileByPath(fileName, path, languageVersionOrOptions, onError, shouldCreateNewSourceFile) {
            var hostSourceFile = sourceFilesCache.get(path);
            // No source file on the host
            if (isFileMissingOnHost(hostSourceFile)) {
                return undefined;
            }
            // Create new source file if requested or the versions dont match
            if (hostSourceFile === undefined || shouldCreateNewSourceFile || isFilePresenceUnknownOnHost(hostSourceFile)) {
                var sourceFile = getNewSourceFile(fileName, languageVersionOrOptions, onError);
                if (hostSourceFile) {
                    if (sourceFile) {
                        // Set the source file and create file watcher now that file was present on the disk
                        hostSourceFile.sourceFile = sourceFile;
                        hostSourceFile.version = sourceFile.version;
                        if (!hostSourceFile.fileWatcher) {
                            hostSourceFile.fileWatcher = watchFilePath(path, fileName, onSourceFileChange, ts.PollingInterval.Low, watchOptions, ts.WatchType.SourceFile);
                        }
                    }
                    else {
                        // There is no source file on host any more, close the watch, missing file paths will track it
                        if (hostSourceFile.fileWatcher) {
                            hostSourceFile.fileWatcher.close();
                        }
                        sourceFilesCache.set(path, false);
                    }
                }
                else {
                    if (sourceFile) {
                        var fileWatcher = watchFilePath(path, fileName, onSourceFileChange, ts.PollingInterval.Low, watchOptions, ts.WatchType.SourceFile);
                        sourceFilesCache.set(path, { sourceFile: sourceFile, version: sourceFile.version, fileWatcher: fileWatcher });
                    }
                    else {
                        sourceFilesCache.set(path, false);
                    }
                }
                if (sourceFile) {
                    sourceFile.impliedNodeFormat = ts.getImpliedNodeFormatForFile(path, resolutionCache.getModuleResolutionCache().getPackageJsonInfoCache(), compilerHost, compilerHost.getCompilationSettings());
                }
                return sourceFile;
            }
            return hostSourceFile.sourceFile;
        }
        function nextSourceFileVersion(path) {
            var hostSourceFile = sourceFilesCache.get(path);
            if (hostSourceFile !== undefined) {
                if (isFileMissingOnHost(hostSourceFile)) {
                    // The next version, lets set it as presence unknown file
                    sourceFilesCache.set(path, { version: false });
                }
                else {
                    hostSourceFile.version = false;
                }
            }
        }
        function getSourceVersion(path) {
            var hostSourceFile = sourceFilesCache.get(path);
            return !hostSourceFile || !hostSourceFile.version ? undefined : hostSourceFile.version;
        }
        function onReleaseOldSourceFile(oldSourceFile, _oldOptions, hasSourceFileByPath) {
            var hostSourceFileInfo = sourceFilesCache.get(oldSourceFile.resolvedPath);
            // If this is the source file thats in the cache and new program doesnt need it,
            // remove the cached entry.
            // Note we arent deleting entry if file became missing in new program or
            // there was version update and new source file was created.
            if (hostSourceFileInfo !== undefined) {
                // record the missing file paths so they can be removed later if watchers arent tracking them
                if (isFileMissingOnHost(hostSourceFileInfo)) {
                    (missingFilePathsRequestedForRelease || (missingFilePathsRequestedForRelease = [])).push(oldSourceFile.path);
                }
                else if (hostSourceFileInfo.sourceFile === oldSourceFile) {
                    if (hostSourceFileInfo.fileWatcher) {
                        hostSourceFileInfo.fileWatcher.close();
                    }
                    sourceFilesCache.delete(oldSourceFile.resolvedPath);
                    if (!hasSourceFileByPath) {
                        resolutionCache.removeResolutionsOfFile(oldSourceFile.path);
                    }
                }
            }
        }
        function reportWatchDiagnostic(message) {
            if (host.onWatchStatusChange) {
                host.onWatchStatusChange(ts.createCompilerDiagnostic(message), newLine, compilerOptions || optionsToExtendForConfigFile);
            }
        }
        function hasChangedAutomaticTypeDirectiveNames() {
            return resolutionCache.hasChangedAutomaticTypeDirectiveNames();
        }
        function clearInvalidateResolutionsOfFailedLookupLocations() {
            if (!timerToInvalidateFailedLookupResolutions)
                return false;
            host.clearTimeout(timerToInvalidateFailedLookupResolutions);
            timerToInvalidateFailedLookupResolutions = undefined;
            return true;
        }
        function scheduleInvalidateResolutionsOfFailedLookupLocations() {
            if (!host.setTimeout || !host.clearTimeout) {
                return resolutionCache.invalidateResolutionsOfFailedLookupLocations();
            }
            var pending = clearInvalidateResolutionsOfFailedLookupLocations();
            writeLog("Scheduling invalidateFailedLookup".concat(pending ? ", Cancelled earlier one" : ""));
            timerToInvalidateFailedLookupResolutions = host.setTimeout(invalidateResolutionsOfFailedLookup, 250);
        }
        function invalidateResolutionsOfFailedLookup() {
            timerToInvalidateFailedLookupResolutions = undefined;
            if (resolutionCache.invalidateResolutionsOfFailedLookupLocations()) {
                scheduleProgramUpdate();
            }
        }
        // Upon detecting a file change, wait for 250ms and then perform a recompilation. This gives batch
        // operations (such as saving all modified files in an editor) a chance to complete before we kick
        // off a new compilation.
        function scheduleProgramUpdate() {
            if (!host.setTimeout || !host.clearTimeout) {
                return;
            }
            if (timerToUpdateProgram) {
                host.clearTimeout(timerToUpdateProgram);
            }
            writeLog("Scheduling update");
            timerToUpdateProgram = host.setTimeout(updateProgramWithWatchStatus, 250);
        }
        function scheduleProgramReload() {
            ts.Debug.assert(!!configFileName);
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
            scheduleProgramUpdate();
        }
        function updateProgramWithWatchStatus() {
            timerToUpdateProgram = undefined;
            reportFileChangeDetectedOnCreateProgram = true;
            updateProgram();
        }
        function updateProgram() {
            switch (reloadLevel) {
                case ts.ConfigFileProgramReloadLevel.Partial:
                    ts.perfLogger.logStartUpdateProgram("PartialConfigReload");
                    reloadFileNamesFromConfigFile();
                    break;
                case ts.ConfigFileProgramReloadLevel.Full:
                    ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                    reloadConfigFile();
                    break;
                default:
                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                    synchronizeProgram();
                    break;
            }
            ts.perfLogger.logStopUpdateProgram("Done");
            return getCurrentBuilderProgram();
        }
        function reloadFileNamesFromConfigFile() {
            writeLog("Reloading new file names and options");
            reloadLevel = ts.ConfigFileProgramReloadLevel.None;
            rootFileNames = ts.getFileNamesFromConfigSpecs(compilerOptions.configFile.configFileSpecs, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), currentDirectory), compilerOptions, parseConfigFileHost, extraFileExtensions);
            if (ts.updateErrorForNoInputFiles(rootFileNames, ts.getNormalizedAbsolutePath(configFileName, currentDirectory), compilerOptions.configFile.configFileSpecs, configFileParsingDiagnostics, canConfigFileJsonReportNoInputFiles)) {
                hasChangedConfigFileParsingErrors = true;
            }
            // Update the program
            synchronizeProgram();
        }
        function reloadConfigFile() {
            writeLog("Reloading config file: ".concat(configFileName));
            reloadLevel = ts.ConfigFileProgramReloadLevel.None;
            if (cachedDirectoryStructureHost) {
                cachedDirectoryStructureHost.clearCache();
            }
            parseConfigFile();
            hasChangedCompilerOptions = true;
            synchronizeProgram();
            // Update the wild card directory watch
            watchConfigFileWildCardDirectories();
            // Update extended config file watch
            updateExtendedConfigFilesWatches(toPath(configFileName), compilerOptions, watchOptions, ts.WatchType.ExtendedConfigFile);
        }
        function parseConfigFile() {
            setConfigFileParsingResult(ts.getParsedCommandLineOfConfigFile(configFileName, optionsToExtendForConfigFile, parseConfigFileHost, extendedConfigCache || (extendedConfigCache = new ts.Map()), watchOptionsToExtend, extraFileExtensions)); // TODO: GH#18217
        }
        function setConfigFileParsingResult(configFileParseResult) {
            rootFileNames = configFileParseResult.fileNames;
            compilerOptions = configFileParseResult.options;
            watchOptions = configFileParseResult.watchOptions;
            projectReferences = configFileParseResult.projectReferences;
            wildcardDirectories = configFileParseResult.wildcardDirectories;
            configFileParsingDiagnostics = ts.getConfigFileParsingDiagnostics(configFileParseResult).slice();
            canConfigFileJsonReportNoInputFiles = ts.canJsonReportNoInputFiles(configFileParseResult.raw);
            hasChangedConfigFileParsingErrors = true;
        }
        function getParsedCommandLine(configFileName) {
            var configPath = toPath(configFileName);
            var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
            if (config) {
                if (!config.reloadLevel)
                    return config.parsedCommandLine;
                // With host implementing getParsedCommandLine we cant just update file names
                if (config.parsedCommandLine && config.reloadLevel === ts.ConfigFileProgramReloadLevel.Partial && !host.getParsedCommandLine) {
                    writeLog("Reloading new file names and options");
                    var fileNames = ts.getFileNamesFromConfigSpecs(config.parsedCommandLine.options.configFile.configFileSpecs, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), currentDirectory), compilerOptions, parseConfigFileHost);
                    config.parsedCommandLine = __assign(__assign({}, config.parsedCommandLine), { fileNames: fileNames });
                    config.reloadLevel = undefined;
                    return config.parsedCommandLine;
                }
            }
            writeLog("Loading config file: ".concat(configFileName));
            var parsedCommandLine = host.getParsedCommandLine ?
                host.getParsedCommandLine(configFileName) :
                getParsedCommandLineFromConfigFileHost(configFileName);
            if (config) {
                config.parsedCommandLine = parsedCommandLine;
                config.reloadLevel = undefined;
            }
            else {
                (parsedConfigs || (parsedConfigs = new ts.Map())).set(configPath, config = { parsedCommandLine: parsedCommandLine });
            }
            watchReferencedProject(configFileName, configPath, config);
            return parsedCommandLine;
        }
        function getParsedCommandLineFromConfigFileHost(configFileName) {
            // Ignore the file absent errors
            var onUnRecoverableConfigFileDiagnostic = parseConfigFileHost.onUnRecoverableConfigFileDiagnostic;
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = ts.noop;
            var parsedCommandLine = ts.getParsedCommandLineOfConfigFile(configFileName, 
            /*optionsToExtend*/ undefined, parseConfigFileHost, extendedConfigCache || (extendedConfigCache = new ts.Map()), watchOptionsToExtend);
            parseConfigFileHost.onUnRecoverableConfigFile